[{"sourceFileName":"org.jgrapht.experimental.PartiteRandomGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.generate.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices in the first partition","javadocBlockTagName":"numVertices1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices in the first partition'}]}', name=Optional[numVertices1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices in the second partition","javadocBlockTagName":"numVertices2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices in the second partition'}]}', name=Optional[numVertices2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of edges to be generated","javadocBlockTagName":"numEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of edges to be generated'}]}', name=Optional[numEdges]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.PartiteRandomGraphGenerator.PartiteRandomGraphGenerator(int, int, int)","variableDeclarationExprs":[{"variableType":"int[]","variableName":"numVertices","variableDeclarationExprId":1,"variableDeclarationExpr":"final int[] numVertices = { numVertices1, numVertices2 }","variableDeclarationExprRange":"(line 84,col 9)-(line 87,col 9)","variableTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","variableRange":"(line 84,col 22)-(line 87,col 9)"}],"constructorRange":"(line 71,col 5)-(line 90,col 5)","constructorJavadocComment":"\n     * Construct a new PartiteRandomGraphGenerator for a bipartite graph.\n     *\n     * @param numVertices1 number of vertices in the first partition\n     * @param numVertices2 number of vertices in the second partition\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public PartiteRandomGraphGenerator(int numVertices1, int numVertices2, int numEdges)","constructorBody":"{\n    if ((numVertices1 < 0) || (numVertices2 < 0)) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    if ((numEdges < 0) || (numEdges > (numVertices1 * numVertices2))) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    final int[] numVertices = { numVertices1, numVertices2 };\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}","constructorName":"PartiteRandomGraphGenerator","constructorQualifiedName":"org.jgrapht.experimental.PartiteRandomGraphGenerator.PartiteRandomGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numVertices1","parameterName":"numVertices1"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numVertices2","parameterName":"numVertices2"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numEdges","parameterName":"numEdges"}],"literalExprs":[{"literalExprRange":"(line 76,col 29)-(line 76,col 29)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 51)-(line 76,col 51)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 48)-(line 77,col 69)","literalExprId":3,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 80,col 25)-(line 80,col 25)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 81,col 48)-(line 81,col 72)","literalExprId":5,"literalExpr":"\"illegal number of edges\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public PartiteRandomGraphGenerator(\n        int numVertices1,\n        int numVertices2,\n        int numEdges)\n    {\n        if ((numVertices1 < 0) || (numVertices2 < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0) || (numEdges > (numVertices1 * numVertices2))) {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        final int [] numVertices = {\n            numVertices1,\n            numVertices2\n        };\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new PartiteRandomGraphGenerator for a bipartite graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices in the first partition'}]}', name=Optional[numVertices1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices in the second partition'}]}', name=Optional[numVertices2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of edges to be generated'}]}', name=Optional[numEdges]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices in the k partitions","javadocBlockTagName":"numVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices in the k partitions'}]}', name=Optional[numVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of edges to be generated between any two\npartitions","javadocBlockTagName":"numEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of edges to be generated between any two\npartitions'}]}', name=Optional[numEdges]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.PartiteRandomGraphGenerator.PartiteRandomGraphGenerator(int[], int)","variableDeclarationExprs":[{"variableType":"int","variableName":"i","variableDeclarationExprId":1,"variableDeclarationExpr":"int i = 0","variableDeclarationExprRange":"(line 107,col 14)-(line 107,col 22)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 107,col 18)-(line 107,col 22)"},{"variableType":"int","variableName":"j","variableDeclarationExprId":2,"variableDeclarationExpr":"int j = 0","variableDeclarationExprRange":"(line 112,col 18)-(line 112,col 26)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 112,col 22)-(line 112,col 26)"}],"constructorRange":"(line 101,col 5)-(line 122,col 5)","constructorJavadocComment":"\n     * Construct a new PartiteRandomGraphGenerator for a k-partite graph.\n     *\n     * @param numVertices number of vertices in the k partitions\n     * @param numEdges number of edges to be generated between any two\n     * partitions\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public PartiteRandomGraphGenerator(int[] numVertices, int numEdges)","constructorBody":"{\n    if (numEdges < 0) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    for (int i = 0; i < numVertices.length; i++) {\n        if (numVertices[i] < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n        for (int j = 0; j < i; j++) {\n            if (numEdges > (numVertices[i] * numVertices[j])) {\n                throw new IllegalArgumentException(\"illegal number of edges\");\n            }\n        }\n    }\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}","constructorName":"PartiteRandomGraphGenerator","constructorQualifiedName":"org.jgrapht.experimental.PartiteRandomGraphGenerator.PartiteRandomGraphGenerator","constructorParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] numVertices","parameterName":"numVertices"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numEdges","parameterName":"numEdges"}],"literalExprs":[{"literalExprRange":"(line 103,col 24)-(line 103,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 104,col 48)-(line 104,col 72)","literalExprId":2,"literalExpr":"\"illegal number of edges\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 107,col 22)-(line 107,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 34)-(line 108,col 34)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 109,col 52)-(line 109,col 73)","literalExprId":5,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 112,col 26)-(line 112,col 26)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 115,col 25)-(line 115,col 49)","literalExprId":7,"literalExpr":"\"illegal number of edges\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public PartiteRandomGraphGenerator(int [] numVertices, int numEdges)\n    {\n        if (numEdges < 0) {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        for (int i = 0; i < numVertices.length; i++) {\n            if (numVertices[i] < 0) {\n                throw new IllegalArgumentException(\"must be non-negative\");\n            }\n\n            for (int j = 0; j < i; j++) {\n                if (numEdges > (numVertices[i] * numVertices[j])) {\n                    throw new IllegalArgumentException(\n                        \"illegal number of edges\");\n                }\n            }\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new PartiteRandomGraphGenerator for a k-partite graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices in the k partitions'}]}', name=Optional[numVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of edges to be generated between any two\npartitions'}]}', name=Optional[numEdges]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertexFactory","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexFactory]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"some array of vertices","javadocBlockTagName":"resultMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='some array of vertices'}]}', name=Optional[resultMap]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphGenerator#generateGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphGenerator#generateGraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, Object[]> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object[][] vertices = new Object[numVertices.length][];\n    for (int i = 0; i < numVertices.length; i++) {\n        vertices[i] = RandomGraphHelper.addVertices(target, vertexFactory, numVertices[i]);\n        if (resultMap != null) {\n            resultMap.put(Integer.toString(i), vertices[i]);\n        }\n        for (int j = 0; j < i; j++) {\n            RandomGraphHelper.addEdges(target, Arrays.asList(vertices[i]), Arrays.asList(vertices[j]), numEdges);\n        }\n    }\n}","methodRange":"(line 133,col 5)-(line 159,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, Object[]> resultMap)\n    {\n        Object [][] vertices = new Object[numVertices.length][];\n\n        for (int i = 0; i < numVertices.length; i++) {\n            vertices[i] =\n                RandomGraphHelper.addVertices(\n                    target,\n                    vertexFactory,\n                    numVertices[i]);\n\n            if (resultMap != null) {\n                resultMap.put(Integer.toString(i), vertices[i]);\n            }\n\n            for (int j = 0; j < i; j++) {\n                RandomGraphHelper.addEdges(\n                    target,\n                    Arrays.asList(vertices[i]),\n                    Arrays.asList(vertices[j]),\n                    numEdges);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * TODO hb 30-nov-05: document me\n     *\n     * @param target\n     * @param vertexFactory\n     * @param resultMap some array of vertices\n     *\n     * @see GraphGenerator#generateGraph\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, Object[]>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, java.lang.Object[]>","parameter":"Map<String, Object[]> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.experimental.PartiteRandomGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='TODO hb 30-nov-05: document me'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexFactory]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='some array of vertices'}]}', name=Optional[resultMap]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphGenerator#generateGraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 140,col 22)-(line 140,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 30)-(line 147,col 33)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 151,col 26)-(line 151,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.PartiteRandomGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, java.lang.Object[]>)"}],"classJavadoc":"\/**\n * PartiteRandomGraphGenerator generates a <a\n * href=\"http:\/\/mathworld.wolfram.com\/RandomGraph.html\">partite uniform random\n * graph<\/a> of any size. A partite uniform random graph contains edges chosen\n * independently uniformly at random from the set of possible edges between\n * partition classes.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n *\/\n","className":"PartiteRandomGraphGenerator","fields":[{"fieldRange":"(line 59,col 5)-(line 59,col 37)","fieldName":"numVertices","fieldJavadocComment":"","fieldTokenRange":"private final int [] numVertices;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[]"},{"fieldRange":"(line 60,col 5)-(line 60,col 31)","fieldName":"numEdges","fieldJavadocComment":"","fieldTokenRange":"private final int numEdges;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":1,"packageName":"org.jgrapht.experimental"},{"sourceFileName":"org.jgrapht.experimental.RandomGraphHelper","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.experimental.RandomGraphHelper.RandomGraphHelper()","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * .\n     ","constructorDeclaration":"private RandomGraphHelper()","constructorBody":"{\n}","constructorName":"RandomGraphHelper","constructorQualifiedName":"org.jgrapht.experimental.RandomGraphHelper.RandomGraphHelper","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"private RandomGraphHelper()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"org.jgrapht.generate.GraphGenerator#generateGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='org.jgrapht.generate.GraphGenerator#generateGraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public static void addEdges(Graph target, List sourceVertices, List destVertices, int numEdges)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int sourceSize = sourceVertices.size();\n    int destSize = destVertices.size();\n    for (int i = 0; i < numEdges; ++i) {\n        while (target.addEdge(sourceVertices.get(randSingleton.nextInt(sourceSize)), destVertices.get(randSingleton.nextInt(destSize))) == null) {\n            ;\n        }\n    }\n}","methodRange":"(line 68,col 5)-(line 89,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    public static void addEdges(\n        Graph target,\n        List sourceVertices,\n        List destVertices,\n        int numEdges)\n    {\n        int sourceSize = sourceVertices.size();\n        int destSize = destVertices.size();\n\n        for (int i = 0; i < numEdges; ++i) {\n            while (\n                target.addEdge(\n                    sourceVertices.get(randSingleton.nextInt(\n                            sourceSize)),\n                    destVertices.get(randSingleton.nextInt(destSize)))\n                == null)\n            {\n                ;\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see org.jgrapht.generate.GraphGenerator#generateGraph\n     ","methodParameters":[{"parameterType":"Graph","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph","parameter":"Graph target","parameterName":"target"},{"parameterType":"List","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.List","parameter":"List sourceVertices","parameterName":"sourceVertices"},{"parameterType":"List","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.List","parameter":"List destVertices","parameterName":"destVertices"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numEdges","parameterName":"numEdges"}],"methodName":"addEdges","methodQualifiedSignature":"org.jgrapht.experimental.RandomGraphHelper.addEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='org.jgrapht.generate.GraphGenerator#generateGraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 68,col 23)-(line 68,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 22)-(line 78,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 84,col 20)-(line 84,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.RandomGraphHelper.addEdges(org.jgrapht.Graph, java.util.List, java.util.List, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertexFactory","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexFactory]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"numVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[numVertices]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"vertices","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vertices'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Object[] addVertices(Graph target, VertexFactory vertexFactory, int numVertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object[] vertices = new Object[numVertices];\n    for (int i = 0; i < numVertices; ++i) {\n        vertices[i] = vertexFactory.createVertex();\n        target.addVertex(vertices[i]);\n    }\n    return vertices;\n}","methodRange":"(line 100,col 5)-(line 114,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    public static Object [] addVertices(\n        Graph target,\n        VertexFactory vertexFactory,\n        int numVertices)\n    {\n        Object [] vertices = new Object[numVertices];\n\n        for (int i = 0; i < numVertices; ++i) {\n            vertices[i] = vertexFactory.createVertex();\n            target.addVertex(vertices[i]);\n        }\n\n        return vertices;\n    }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n     * .\n     *\n     * @param target\n     * @param vertexFactory\n     * @param numVertices\n     *\n     * @return vertices\n     ","methodParameters":[{"parameterType":"Graph","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph","parameter":"Graph target","parameterName":"target"},{"parameterType":"VertexFactory","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory","parameter":"VertexFactory vertexFactory","parameterName":"vertexFactory"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numVertices","parameterName":"numVertices"}],"methodName":"addVertices","methodQualifiedSignature":"org.jgrapht.experimental.RandomGraphHelper.addVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexFactory]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[numVertices]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vertices'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object[]","methodType":"Object[]","literalExprs":[{"literalExprRange":"(line 100,col 23)-(line 100,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 108,col 22)-(line 108,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.RandomGraphHelper.addVertices(org.jgrapht.Graph, org.jgrapht.VertexFactory, int)"}],"classJavadoc":"\/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http:\/\/mathworld.wolfram.com\/RandomGraph.html\">uniform random graph<\/a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n *\/\n","className":"RandomGraphHelper","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 61)","fieldName":"randSingleton","fieldJavadocComment":"","fieldTokenRange":"private static final Random randSingleton = new Random();","fieldTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new Random()]","fieldType":"Random","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Random"}]}],"sourceFileId":2,"packageName":"org.jgrapht.experimental"},{"sourceFileName":"org.jgrapht.experimental.GraphReader","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.generate.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.experimental.GraphReader.GraphReader(java.io.Reader, boolean, double)","variableDeclarationExprs":[],"constructorRange":"(line 67,col 5)-(line 77,col 5)","constructorJavadocComment":"\n     * Construct a new GraphReader.\n     ","constructorDeclaration":"private GraphReader(Reader input, boolean isWeighted, double defaultWeight) throws IOException","constructorBody":"{\n    if (input instanceof BufferedReader) {\n        _in = (BufferedReader) input;\n    } else {\n        _in = new BufferedReader(input);\n    }\n    _isWeighted = isWeighted;\n    _defaultWeight = defaultWeight;\n}","constructorName":"GraphReader","constructorQualifiedName":"org.jgrapht.experimental.GraphReader.GraphReader","constructorParameters":[{"parameterType":"Reader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Reader","parameter":"Reader input","parameterName":"input"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean isWeighted","parameterName":"isWeighted"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double defaultWeight","parameterName":"defaultWeight"}],"literalExprs":[],"constructorTokenRange":"private GraphReader(Reader input, boolean isWeighted, double defaultWeight)\n        throws IOException\n    {\n        if (input instanceof BufferedReader) {\n            _in = (BufferedReader) input;\n        } else {\n            _in = new BufferedReader(input);\n        }\n        _isWeighted = isWeighted;\n        _defaultWeight = defaultWeight;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new GraphReader.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.experimental.GraphReader.GraphReader(java.io.Reader)","variableDeclarationExprs":[],"constructorRange":"(line 82,col 5)-(line 86,col 5)","constructorJavadocComment":"\n     * Construct a new GraphReader.\n     ","constructorDeclaration":"public GraphReader(Reader input) throws IOException","constructorBody":"{\n    this(input, false, 1);\n}","constructorName":"GraphReader","constructorQualifiedName":"org.jgrapht.experimental.GraphReader.GraphReader","constructorParameters":[{"parameterType":"Reader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Reader","parameter":"Reader input","parameterName":"input"}],"literalExprs":[{"literalExprRange":"(line 85,col 21)-(line 85,col 25)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 85,col 28)-(line 85,col 28)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public GraphReader(Reader input)\n        throws IOException\n    {\n        this(input, false, 1);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new GraphReader.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.experimental.GraphReader.GraphReader(java.io.Reader, double)","variableDeclarationExprs":[],"constructorRange":"(line 91,col 5)-(line 95,col 5)","constructorJavadocComment":"\n     * Construct a new GraphReader.\n     ","constructorDeclaration":"public GraphReader(Reader input, double defaultWeight) throws IOException","constructorBody":"{\n    this(input, true, defaultWeight);\n}","constructorName":"GraphReader","constructorQualifiedName":"org.jgrapht.experimental.GraphReader.GraphReader","constructorParameters":[{"parameterType":"Reader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Reader","parameter":"Reader input","parameterName":"input"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double defaultWeight","parameterName":"defaultWeight"}],"literalExprs":[{"literalExprRange":"(line 94,col 21)-(line 94,col 24)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public GraphReader(Reader input, double defaultWeight)\n        throws IOException\n    {\n        this(input, true, defaultWeight);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new GraphReader.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"private String[] split(final String src)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (src == null) {\n        return null;\n    }\n    return src.split(\"\\\\s+\");\n}","methodRange":"(line 99,col 5)-(line 105,col 5)","methodTokenRange":"private String [] split(final String src)\n    {\n        if (src == null) {\n            return null;\n        }\n        return src.split(\"\\\\s+\");\n    }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"final String src","parameterName":"src"}],"methodName":"split","methodQualifiedSignature":"org.jgrapht.experimental.GraphReader.split","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 101,col 20)-(line 101,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 102,col 20)-(line 102,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 104,col 26)-(line 104,col 31)","literalExprId":3,"literalExpr":"\"\\\\s+\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphReader.split(java.lang.String)"},{"methodDeclaration":"private String[] skipComments()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    String[] cols = null;\n    try {\n        cols = split(_in.readLine());\n        while ((cols != null) && ((cols.length == 0) || cols[0].equals(\"c\") || cols[0].startsWith(\"%\"))) {\n            cols = split(_in.readLine());\n        }\n    } catch (IOException e) {\n    }\n    return cols;\n}","methodRange":"(line 107,col 5)-(line 123,col 5)","methodTokenRange":"private String [] skipComments()\n    {\n        String [] cols = null;\n        try {\n            cols = split(_in.readLine());\n            while (\n                (cols != null)\n                && ((cols.length == 0)\n                    || cols[0].equals(\"c\")\n                    || cols[0].startsWith(\"%\")))\n            {\n                cols = split(_in.readLine());\n            }\n        } catch (IOException e) {\n        }\n        return cols;\n    }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"skipComments","methodQualifiedSignature":"org.jgrapht.experimental.GraphReader.skipComments","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 109,col 26)-(line 109,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 113,col 26)-(line 113,col 29)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 114,col 37)-(line 114,col 37)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 115,col 29)-(line 115,col 29)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 115,col 39)-(line 115,col 41)","literalExprId":5,"literalExpr":"\"c\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 116,col 29)-(line 116,col 29)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 116,col 43)-(line 116,col 45)","literalExprId":7,"literalExpr":"\"%\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphReader.skipComments()"},{"methodDeclaration":"private int readNodeCount()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    final String[] cols = skipComments();\n    if (cols[0].equals(\"p\")) {\n        return Integer.parseInt(cols[1]);\n    }\n    return -1;\n}","methodRange":"(line 125,col 5)-(line 132,col 5)","methodTokenRange":"private int readNodeCount()\n    {\n        final String [] cols = skipComments();\n        if (cols[0].equals(\"p\")) {\n            return Integer.parseInt(cols[1]);\n        }\n        return -1;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"readNodeCount","methodQualifiedSignature":"org.jgrapht.experimental.GraphReader.readNodeCount","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 128,col 18)-(line 128,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 128,col 28)-(line 128,col 30)","literalExprId":2,"literalExpr":"\"p\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 129,col 42)-(line 129,col 42)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 131,col 17)-(line 131,col 17)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphReader.readNodeCount()"},{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    final int size = readNodeCount();\n    if (resultMap == null) {\n        resultMap = new HashMap<String, V>();\n    }\n    for (int i = 0; i < size; i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n        resultMap.put(Integer.toString(i + 1), newVertex);\n    }\n    String[] cols = skipComments();\n    while (cols != null) {\n        if (cols[0].equals(\"e\")) {\n            E edge = target.addEdge(resultMap.get(cols[1]), resultMap.get(cols[2]));\n            if (_isWeighted && (edge != null)) {\n                double weight = _defaultWeight;\n                if (cols.length > 3) {\n                    weight = Double.parseDouble(cols[3]);\n                }\n                ((WeightedGraph<V, E>) target).setEdgeWeight(edge, weight);\n            }\n        }\n        cols = skipComments();\n    }\n}","methodRange":"(line 137,col 5)-(line 169,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        final int size = readNodeCount();\n        if (resultMap == null) {\n            resultMap = new HashMap<String, V>();\n        }\n\n        for (int i = 0; i < size; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            resultMap.put(Integer.toString(i + 1), newVertex);\n        }\n        String [] cols = skipComments();\n        while (cols != null) {\n            if (cols[0].equals(\"e\")) {\n                E edge =\n                    target.addEdge(\n                        resultMap.get(cols[1]),\n                        resultMap.get(cols[2]));\n                if (_isWeighted && (edge != null)) {\n                    double weight = _defaultWeight;\n                    if (cols.length > 3) {\n                        weight = Double.parseDouble(cols[3]);\n                    }\n                    ((WeightedGraph<V, E>) target).setEdgeWeight(edge, weight);\n                }\n            }\n            cols = skipComments();\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.experimental.GraphReader.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 143,col 26)-(line 143,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 147,col 22)-(line 147,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 150,col 48)-(line 150,col 48)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 24)-(line 153,col 27)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 154,col 22)-(line 154,col 22)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 154,col 32)-(line 154,col 34)","literalExprId":6,"literalExpr":"\"e\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 157,col 44)-(line 157,col 44)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 158,col 44)-(line 158,col 44)","literalExprId":8,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 45)-(line 159,col 48)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 161,col 39)-(line 161,col 39)","literalExprId":10,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 162,col 58)-(line 162,col 58)","literalExprId":11,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphReader.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"","className":"GraphReader","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 37)","fieldName":"_in","fieldJavadocComment":"","fieldTokenRange":"private final BufferedReader _in;","fieldTypeResolved":"ReferenceType{java.io.BufferedReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"BufferedReader","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.io.BufferedReader"},{"fieldRange":"(line 59,col 5)-(line 59,col 38)","fieldName":"_isWeighted","fieldJavadocComment":"","fieldTokenRange":"private final boolean _isWeighted;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 60,col 5)-(line 60,col 40)","fieldName":"_defaultWeight","fieldJavadocComment":"","fieldTokenRange":"private final double _defaultWeight;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":3,"packageName":"org.jgrapht.experimental"},{"sourceFileName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"DirectedAcyclicGraph","constructorQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.DirectedAcyclicGraph","constructorQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.DirectedAcyclicGraph(java.lang.Class<? extends E>)","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> arg0","parameterName":"arg0"}],"literalExprs":[],"constructorTokenRange":"public DirectedAcyclicGraph(Class<? extends E> arg0)\n    {\n        super(arg0);\n        initialize();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 97,col 5)-(line 101,col 5)","constructorJavadocComment":"","constructorDeclaration":"public DirectedAcyclicGraph(Class<? extends E> arg0)","constructorBody":"{\n    super(arg0);\n    initialize();\n}","constructorJavadoc":""},{"constructorName":"DirectedAcyclicGraph","constructorQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.DirectedAcyclicGraph","constructorQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.DirectedAcyclicGraph(org.jgrapht.EdgeFactory<V, E>)","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public DirectedAcyclicGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n        initialize();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 103,col 5)-(line 107,col 5)","constructorJavadocComment":"","constructorDeclaration":"public DirectedAcyclicGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n    initialize();\n}","constructorJavadoc":""},{"constructorName":"DirectedAcyclicGraph","constructorQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.DirectedAcyclicGraph","constructorQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.DirectedAcyclicGraph(java.lang.Class<? extends E>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedFactory, org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory<V>)","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> arg0","parameterName":"arg0"},{"parameterType":"VisitedFactory","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedFactory, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedFactory","parameter":"VisitedFactory visitedFactory","parameterName":"visitedFactory"},{"parameterType":"TopoOrderMappingFactory<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory<V>","parameter":"TopoOrderMappingFactory<V> topoOrderFactory","parameterName":"topoOrderFactory"}],"literalExprs":[{"literalExprRange":"(line 115,col 31)-(line 115,col 34)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 118,col 33)-(line 118,col 36)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"DirectedAcyclicGraph(\n        Class<? extends E> arg0,\n        VisitedFactory visitedFactory,\n        TopoOrderMappingFactory<V> topoOrderFactory)\n    {\n        super(arg0);\n        if (visitedFactory != null) {\n            this.visitedFactory = visitedFactory;\n        }\n        if (topoOrderFactory != null) {\n            this.topoOrderFactory = topoOrderFactory;\n        }\n        initialize();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 109,col 5)-(line 122,col 5)","constructorJavadocComment":"","constructorDeclaration":" DirectedAcyclicGraph(Class<? extends E> arg0, VisitedFactory visitedFactory, TopoOrderMappingFactory<V> topoOrderFactory)","constructorBody":"{\n    super(arg0);\n    if (visitedFactory != null) {\n        this.visitedFactory = visitedFactory;\n    }\n    if (topoOrderFactory != null) {\n        this.topoOrderFactory = topoOrderFactory;\n    }\n    initialize();\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 539,col 5)-(line 583,col 5)","classOrInterfaceTokenRange":"public interface TopoOrderMapping<V>\n        extends Serializable\n    {\n        \/**\n         * add a vertex at the given topological index.\n         *\n         * @param index\n         * @param vertex\n         *\/\n        public void putVertex(Integer index, V vertex);\n\n        \/**\n         * get the vertex at the given topological index.\n         *\n         * @param index\n         *\n         * @return vertex\n         *\/\n        public V getVertex(Integer index);\n\n        \/**\n         * get the topological index of the given vertex.\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex is at, or null if the vertex isn't\n         * in the topological ordering\n         *\/\n        public Integer getTopologicalIndex(V vertex);\n\n        \/**\n         * remove the given vertex from the topological ordering\n         *\n         * @param vertex\n         *\n         * @return the index that the vertex was at, or null if the vertex\n         * wasn't in the topological ordering\n         *\/\n        public Integer removeVertex(V vertex);\n\n        \/**\n         * remove all vertices from the topological ordering\n         *\/\n        public void removeAllVertices();\n    }","classOrInterfaceJavadocComment":"\n     * For performance tuning, an interface for storing the topological ordering\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='For performance tuning, an interface for storing the topological ordering'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 585,col 5)-(line 588,col 5)","classOrInterfaceTokenRange":"public interface TopoOrderMappingFactory<V>\n    {\n        public TopoOrderMapping<V> getTopoOrderMapping();\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 595,col 5)-(line 624,col 5)","classOrInterfaceTokenRange":"public interface Visited\n    {\n        \/**\n         * mark the given topological index as visited\n         *\n         * @param index the topological index\n         *\/\n        public void setVisited(int index);\n\n        \/**\n         * has the given topological index been visited?\n         *\n         * @param index the topological index\n         *\/\n        public boolean getVisited(int index);\n\n        \/**\n         * Clear the visited state of the given topological index\n         *\n         * @param index\n         *\n         * @throws UnsupportedOperationException if the implementation doesn't\n         * support (or doesn't need) clearance. For example, if the factory\n         * vends a new instance every time, it is a waste of cycles to clear the\n         * state after the search of the Affected Region is done, so an\n         * UnsupportedOperationException *should* be thrown.\n         *\/\n        public void clearVisited(int index)\n            throws UnsupportedOperationException;\n    }","classOrInterfaceJavadocComment":"\n     * this interface allows specification of a strategy for marking vertices as\n     * visited (based on their topological index, so the vertex type isn't part\n     * of the interface).\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='this interface allows specification of a strategy for marking vertices as\nvisited (based on their topological index, so the vertex type isn't part\nof the interface).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 631,col 5)-(line 635,col 5)","classOrInterfaceTokenRange":"public interface VisitedFactory\n        extends Serializable\n    {\n        public Visited getInstance(Region affectedRegion);\n    }","classOrInterfaceJavadocComment":"\n     * interface for a factory that vends Visited implementations\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='interface for a factory that vends Visited implementations'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 645,col 5)-(line 665,col 5)","classOrInterfaceTokenRange":"private static class TopoComparator<V>\n        implements Comparator<V>,\n            Serializable\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private TopoOrderMapping<V> topoOrderMap;\n\n        public TopoComparator(TopoOrderMapping<V> topoOrderMap)\n        {\n            this.topoOrderMap = topoOrderMap;\n        }\n\n        @Override public int compare(V o1, V o2)\n        {\n            return topoOrderMap.getTopologicalIndex(o1).compareTo(\n                topoOrderMap.getTopologicalIndex(o2));\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Note, this is a lazy and incomplete implementation, with assumptions that\n     * inputs are in the given topoIndexMap\n     *\n     * @param <V>\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Note, this is a lazy and incomplete implementation, with assumptions that\ninputs are in the given topoIndexMap'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<V>]}, JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 672,col 5)-(line 719,col 5)","classOrInterfaceTokenRange":"private class TopoVertexBiMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private final Map<Integer, V> topoToVertex = new HashMap<Integer, V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            topoToVertex.put(index, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(index);\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.get(vertex);\n            return topoIndex;\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.remove(topoIndex);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * a dual HashMap implementation\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='a dual HashMap implementation'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 727,col 5)-(line 798,col 5)","classOrInterfaceTokenRange":"public class TopoVertexMap\n        implements TopoOrderMapping<V>,\n            TopoOrderMappingFactory<V>\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private final List<V> topoToVertex = new ArrayList<V>();\n        private final Map<V, Integer> vertexToTopo = new HashMap<V, Integer>();\n\n        @Override public void putVertex(Integer index, V vertex)\n        {\n            int translatedIndex = translateIndex(index);\n\n            \/\/ grow topoToVertex as needed to accommodate elements\n            while ((translatedIndex + 1) > topoToVertex.size()) {\n                topoToVertex.add(null);\n            }\n\n            topoToVertex.set(translatedIndex, vertex);\n            vertexToTopo.put(vertex, index);\n        }\n\n        @Override public V getVertex(Integer index)\n        {\n            return topoToVertex.get(translateIndex(index));\n        }\n\n        @Override public Integer getTopologicalIndex(V vertex)\n        {\n            return vertexToTopo.get(vertex);\n        }\n\n        @Override public Integer removeVertex(V vertex)\n        {\n            Integer topoIndex = vertexToTopo.remove(vertex);\n            if (topoIndex != null) {\n                topoToVertex.set(translateIndex(topoIndex), null);\n            }\n            return topoIndex;\n        }\n\n        @Override public void removeAllVertices()\n        {\n            vertexToTopo.clear();\n            topoToVertex.clear();\n        }\n\n        @Override public TopoOrderMapping<V> getTopoOrderMapping()\n        {\n            return this;\n        }\n\n        \/**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         *\/\n        private final int translateIndex(int index)\n        {\n            if (index >= 0) {\n                return 2 * index;\n            }\n            return -1 * ((index * 2) - 1);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * For performance and flexibility uses an ArrayList for topological index\n     * to vertex mapping, and a HashMap for vertex to topological index mapping.\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='For performance and flexibility uses an ArrayList for topological index\nto vertex mapping, and a HashMap for vertex to topological index mapping.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 806,col 5)-(line 835,col 5)","classOrInterfaceTokenRange":"public static class Region\n        implements Serializable\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        public final int start;\n        public final int finish;\n\n        public Region(int start, int finish)\n        {\n            if (start > finish) {\n                throw new IllegalArgumentException(\n                    \"(start > finish): invariant broken\");\n            }\n            this.start = start;\n            this.finish = finish;\n        }\n\n        public int getSize()\n        {\n            return (finish - start) + 1;\n        }\n\n        public boolean isIn(int index)\n        {\n            return (index >= start) && (index <= finish);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Region is an *inclusive* range of indices. Esthetically displeasing, but\n     * convenient for our purposes.\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Region is an *inclusive* range of indices. Esthetically displeasing, but\nconvenient for our purposes.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 843,col 5)-(line 892,col 5)","classOrInterfaceTokenRange":"public static class VisitedBitSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private final BitSet visited = new BitSet();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), true);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.get(translateIndex(index));\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.clear(translateIndex(index));\n        }\n\n        \/**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         *\/\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * This implementation is close to the performance of VisitedArrayListImpl,\n     * with 1\/8 the memory usage.\n     *\n     * @author perfecthash\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation is close to the performance of VisitedArrayListImpl,\nwith 1\/8 the memory usage.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='perfecthash'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 903,col 5)-(line 964,col 5)","classOrInterfaceTokenRange":"public static class VisitedArrayListImpl\n        implements Visited,\n            VisitedFactory\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private final List<Boolean> visited = new ArrayList<Boolean>();\n\n        private Region affectedRegion;\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            \/\/ Make sure visited is big enough\n            int minSize = (affectedRegion.finish - affectedRegion.start) + 1;\n            \/* plus one because the region range is inclusive of both indices *\/\n\n            while (visited.size() < minSize) {\n                visited.add(Boolean.FALSE);\n            }\n\n            this.affectedRegion = affectedRegion;\n\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.set(translateIndex(index), Boolean.TRUE);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            Boolean result = null;\n\n            result = visited.get(translateIndex(index));\n\n            return result;\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            visited.set(translateIndex(index), Boolean.FALSE);\n        }\n\n        \/**\n         * We translate the topological index to an ArrayList index. We have to\n         * do this because topological indices can be negative, and we want to\n         * do it because we can make better use of space by only needing an\n         * ArrayList of size |AR|.\n         *\n         * @param unscaledIndex\n         *\n         * @return the ArrayList index\n         *\/\n        private int translateIndex(int index)\n        {\n            return index - affectedRegion.start;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * This implementation seems to offer the best performance in most cases. It\n     * grows the internal ArrayList as needed to be as large as |AR|, so it will\n     * be more memory intensive than the HashSet implementation, and unlike the\n     * Array implementation, it will hold on to that memory (it expands, but\n     * never contracts).\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation seems to offer the best performance in most cases. It\ngrows the internal ArrayList as needed to be as large as |AR|, so it will\nbe more memory intensive than the HashSet implementation, and unlike the\nArray implementation, it will hold on to that memory (it expands, but\nnever contracts).'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 974,col 5)-(line 1005,col 5)","classOrInterfaceTokenRange":"public static class VisitedHashSetImpl\n        implements Visited,\n            VisitedFactory\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private final Set<Integer> visited = new HashSet<Integer>();\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            visited.clear();\n            return this;\n        }\n\n        @Override public void setVisited(int index)\n        {\n            visited.add(index);\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            return visited.contains(index);\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }","classOrInterfaceJavadocComment":"\n     * This implementation doesn't seem to perform as well, though I can imagine\n     * circumstances where it should shine (lots and lots of vertices). It also\n     * should have the lowest memory footprint as it only uses storage for\n     * indices that have been visited.\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation doesn't seem to perform as well, though I can imagine\ncircumstances where it should shine (lots and lots of vertices). It also\nshould have the lowest memory footprint as it only uses storage for\nindices that have been visited.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 1014,col 5)-(line 1081,col 5)","classOrInterfaceTokenRange":"public static class VisitedArrayImpl\n        implements Visited,\n            VisitedFactory\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = 1L;\n\n        private final boolean [] visited;\n\n        private final Region region;\n\n        \/**\n         * Constructs empty factory instance\n         *\/\n        public VisitedArrayImpl()\n        {\n            this(null);\n        }\n\n        public VisitedArrayImpl(Region region)\n        {\n            if (region == null) { \/\/ make empty instance\n                this.visited = null;\n                this.region = null;\n            } else { \/\/ fill in the needed pieces\n                this.region = region;\n\n                \/\/ initialized to all false by default\n                visited = new boolean[region.getSize()];\n            }\n        }\n\n        @Override public Visited getInstance(Region affectedRegion)\n        {\n            return new VisitedArrayImpl(affectedRegion);\n        }\n\n        @Override public void setVisited(int index)\n        {\n            try {\n                visited[index - region.start] = true;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                \/*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                *\/\n                throw e;\n            }\n        }\n\n        @Override public boolean getVisited(int index)\n        {\n            try {\n                return visited[index - region.start];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                \/*\n                log.error(\"Visited set operation out of region boundaries\", e);\n                *\/\n                throw e;\n            }\n        }\n\n        @Override public void clearVisited(int index)\n            throws UnsupportedOperationException\n        {\n            throw new UnsupportedOperationException();\n        }\n    }","classOrInterfaceJavadocComment":"\n     * This implementation, somewhat to my surprise, is slower than the\n     * ArrayList version, probably due to its reallocation of the underlying\n     * array for every topology reorder that is required.\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation, somewhat to my surprise, is slower than the\nArrayList version, probably due to its reallocation of the underlying\narray for every topology reorder that is required.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 1088,col 5)-(line 1092,col 5)","classOrInterfaceTokenRange":"public static class CycleFoundException\n        extends Exception\n    {\n        private static final long serialVersionUID = 5583471522212552754L;\n    }","classOrInterfaceJavadocComment":"\n     * Exception used in dfsF when a cycle is found\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Exception used in dfsF when a cycle is found'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 1099,col 5)-(line 1168,col 5)","classOrInterfaceTokenRange":"private class TopoIterator\n        implements Iterator<V>\n    {\n        private int currentTopoIndex;\n        private final long updateCountAtCreation;\n        private Integer nextIndex = null;\n\n        public TopoIterator()\n        {\n            updateCountAtCreation = topologyUpdateCount;\n            currentTopoIndex = minTopoIndex - 1;\n        }\n\n        @Override public boolean hasNext()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            nextIndex = getNextIndex();\n            return nextIndex != null;\n        }\n\n        @Override public V next()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            if (nextIndex == null) {\n                \/\/ find nextIndex\n                nextIndex = getNextIndex();\n            }\n            if (nextIndex == null) {\n                throw new NoSuchElementException();\n            }\n            currentTopoIndex = nextIndex;\n            nextIndex = null;\n            return topoOrderMap.getVertex(currentTopoIndex); \/\/topoToVertex.get(currentTopoIndex);\n        }\n\n        @Override public void remove()\n        {\n            if (updateCountAtCreation != topologyUpdateCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            V vertexToRemove = null;\n            if (null\n                != (vertexToRemove =\n                        topoOrderMap.getVertex(\n                            currentTopoIndex)))\n            {\n                topoOrderMap.removeVertex(vertexToRemove);\n            } else {\n                \/\/ should only happen if next() hasn't been called\n                throw new IllegalStateException();\n            }\n        }\n\n        private Integer getNextIndex()\n        {\n            for (int i = currentTopoIndex + 1; i <= maxTopoIndex; i++) {\n                if (null != topoOrderMap.getVertex(i)) {\n                    return i;\n                }\n            }\n            return null;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * iterator which follows topological order\n     *\n     * @author gilesp\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='iterator which follows topological order'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='gilesp'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[],"methodDeclaration":"private void initialize()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    topoOrderMap = topoOrderFactory.getTopoOrderMapping();\n    topoComparator = new TopoComparator<V>(topoOrderMap);\n}","methodRange":"(line 128,col 5)-(line 132,col 5)","methodTokenRange":"private void initialize()\n    {\n        topoOrderMap = topoOrderFactory.getTopoOrderMapping();\n        topoComparator = new TopoComparator<V>(topoOrderMap);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * set the topoOrderMap based on the current factory, and create the\n     * comparator;\n     ","methodParameters":[],"methodName":"initialize","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.initialize","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='set the topoOrderMap based on the current factory, and create the\ncomparator;'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.initialize()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"an iterator that will traverse the graph in topological order","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an iterator that will traverse the graph in topological order'}]}', name=Optional.empty}"}],"methodDeclaration":"public Iterator<V> iterator()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new TopoIterator();\n}","methodRange":"(line 142,col 5)-(line 145,col 5)","methodTokenRange":"public Iterator<V> iterator()\n    {\n        return new TopoIterator();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * iterator will traverse the vertices in topological order, meaning that\n     * for a directed graph G = (V,E), if there exists a path from vertex va to\n     * vertex vb then va is guaranteed to come before vertex vb in the iteration\n     * order.\n     *\n     * @return an iterator that will traverse the graph in topological order\n     ","methodParameters":[],"methodName":"iterator","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.iterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='iterator will traverse the vertices in topological order, meaning that\nfor a directed graph G = (V,E), if there exists a path from vertex va to\nvertex vb then va is guaranteed to come before vertex vb in the iteration\norder.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an iterator that will traverse the graph in topological order'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<V>","methodType":"Iterator<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.iterator()"},{"javadocBlockTags":[],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean added = super.addVertex(v);\n    if (added) {\n        ++maxTopoIndex;\n        topoOrderMap.putVertex(maxTopoIndex, v);\n        ++topologyUpdateCount;\n    }\n    return added;\n}","methodRange":"(line 151,col 5)-(line 164,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            \/\/ add to the top\n            ++maxTopoIndex;\n            topoOrderMap.putVertex(maxTopoIndex, v);\n\n            ++topologyUpdateCount;\n        }\n\n        return added;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * adds the vertex if it wasn't already in the graph, and puts it at the top\n     * of the internal topological vertex ordering\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='adds the vertex if it wasn't already in the graph, and puts it at the top\nof the internal topological vertex ordering'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"addToTop","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[addToTop]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"whether new vertex was added","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether new vertex was added'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v, boolean addToTop)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean added = super.addVertex(v);\n    if (added) {\n        int insertIndex;\n        if (addToTop) {\n            insertIndex = ++maxTopoIndex;\n        } else {\n            insertIndex = --minTopoIndex;\n        }\n        topoOrderMap.putVertex(insertIndex, v);\n        ++topologyUpdateCount;\n    }\n    return added;\n}","methodRange":"(line 177,col 5)-(line 195,col 5)","methodTokenRange":"public boolean addVertex(V v, boolean addToTop)\n    {\n        boolean added = super.addVertex(v);\n\n        if (added) {\n            int insertIndex;\n\n            \/\/ add to the top\n            if (addToTop) {\n                insertIndex = ++maxTopoIndex;\n            } else {\n                insertIndex = --minTopoIndex;\n            }\n            topoOrderMap.putVertex(insertIndex, v);\n\n            ++topologyUpdateCount;\n        }\n        return added;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * adds the vertex if it wasn't already in the graph, and puts it either at\n     * the top or the bottom of the topological ordering, depending on the value\n     * of addToTop. This may provide useful optimizations for merging\n     * DirectedAcyclicGraphs that become connected.\n     *\n     * @param v\n     * @param addToTop\n     *\n     * @return whether new vertex was added\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean addToTop","parameterName":"addToTop"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='adds the vertex if it wasn't already in the graph, and puts it either at\nthe top or the bottom of the topological ordering, depending on the value\nof addToTop. This may provide useful optimizations for merging\nDirectedAcyclicGraphs that become connected.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[addToTop]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether new vertex was added'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addVertex(V, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"null if the edge is already in the graph, else the created edge\nis returned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null if the edge is already in the graph, else the created edge\nis returned'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If either fromVertex or toVertex is not\na member of the graph","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If either fromVertex or toVertex is not\na member of the graph'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the edge would induce a cycle in the graph","javadocBlockTagName":"CycleFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the edge would induce a cycle in the graph'}]}', name=Optional[CycleFoundException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addDagEdge(V fromVertex, V toVertex) throws CycleFoundException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    updateDag(fromVertex, toVertex);\n    return super.addEdge(fromVertex, toVertex);\n}","methodRange":"(line 215,col 5)-(line 221,col 5)","methodTokenRange":"public E addDagEdge(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * <\/ul>\n     *\n     * @return null if the edge is already in the graph, else the created edge\n     * is returned\n     *\n     * @throws IllegalArgumentException If either fromVertex or toVertex is not\n     * a member of the graph\n     * @throws CycleFoundException if the edge would induce a cycle in the graph\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V fromVertex","parameterName":"fromVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V toVertex","parameterName":"toVertex"}],"methodName":"addDagEdge","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addDagEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Adds the given edge and updates the internal topological order for\nconsistency IFF\n\n<UL>\n<li>there is not already an edge (fromVertex, toVertex) in the graph\n<li>the edge does not induce a cycle in the graph\n<\/ul>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null if the edge is already in the graph, else the created edge\nis returned'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If either fromVertex or toVertex is not\na member of the graph'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the edge would induce a cycle in the graph'}]}', name=Optional[CycleFoundException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addDagEdge(V, V)"},{"javadocBlockTags":[],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E result = null;\n    try {\n        result = addDagEdge(sourceVertex, targetVertex);\n    } catch (CycleFoundException e) {\n        throw new IllegalArgumentException(e);\n    }\n    return result;\n}","methodRange":"(line 228,col 5)-(line 237,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E result = null;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * identical to {@link #addDagEdge(Object, Object)}, except an unchecked\n     * {@link IllegalArgumentException} is thrown if a cycle would have been\n     * induced by this edge\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='identical to '}, JavadocInlineTag{tagName='link', type=LINK, content=' #addDagEdge(Object, Object)'}, JavadocSnippet{text=', except an unchecked\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' IllegalArgumentException'}, JavadocSnippet{text=' is thrown if a cycle would have been\ninduced by this edge'}]}, blockTags=[]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 230,col 20)-(line 230,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the edge was added to the graph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the edge was added to the graph'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if adding an edge (fromVertex, toVertex) to\nthe graph would induce a cycle.","javadocBlockTagName":"CycleFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if adding an edge (fromVertex, toVertex) to\nthe graph would induce a cycle.'}]}', name=Optional[CycleFoundException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addDagEdge(V fromVertex, V toVertex, E e) throws CycleFoundException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (e == null) {\n        throw new NullPointerException();\n    } else if (containsEdge(e)) {\n        return false;\n    }\n    updateDag(fromVertex, toVertex);\n    return super.addEdge(fromVertex, toVertex, e);\n}","methodRange":"(line 256,col 5)-(line 268,col 5)","methodTokenRange":"public boolean addDagEdge(V fromVertex, V toVertex, E e)\n        throws CycleFoundException\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        updateDag(fromVertex, toVertex);\n\n        return super.addEdge(fromVertex, toVertex, e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * <p>Adds the given edge and updates the internal topological order for\n     * consistency IFF\n     *\n     * <UL>\n     * <li>the given edge is not already a member of the graph\n     * <li>there is not already an edge (fromVertex, toVertex) in the graph\n     * <li>the edge does not induce a cycle in the graph\n     * <\/ul>\n     *\n     * @return true if the edge was added to the graph\n     *\n     * @throws CycleFoundException if adding an edge (fromVertex, toVertex) to\n     * the graph would induce a cycle.\n     *\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V fromVertex","parameterName":"fromVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V toVertex","parameterName":"toVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addDagEdge","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addDagEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Adds the given edge and updates the internal topological order for\nconsistency IFF\n\n<UL>\n<li>the given edge is not already a member of the graph\n<li>there is not already an edge (fromVertex, toVertex) in the graph\n<li>the edge does not induce a cycle in the graph\n<\/ul>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the edge was added to the graph'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if adding an edge (fromVertex, toVertex) to\nthe graph would induce a cycle.'}]}', name=Optional[CycleFoundException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 259,col 18)-(line 259,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 262,col 20)-(line 262,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addDagEdge(V, V, E)"},{"methodDeclaration":"private void updateDag(V fromVertex, V toVertex) throws CycleFoundException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Integer lb = topoOrderMap.getTopologicalIndex(toVertex);\n    Integer ub = topoOrderMap.getTopologicalIndex(fromVertex);\n    if ((lb == null) || (ub == null)) {\n        throw new IllegalArgumentException(\"vertices must be in the graph already!\");\n    }\n    if (lb < ub) {\n        Set<V> df = new HashSet<V>();\n        Set<V> db = new HashSet<V>();\n        Region affectedRegion = new Region(lb, ub);\n        Visited visited = visitedFactory.getInstance(affectedRegion);\n        dfsF(toVertex, df, visited, affectedRegion);\n        dfsB(fromVertex, db, visited, affectedRegion);\n        reorder(df, db, visited);\n        ++topologyUpdateCount;\n    }\n}","methodRange":"(line 270,col 5)-(line 297,col 5)","methodTokenRange":"private void updateDag(V fromVertex, V toVertex)\n        throws CycleFoundException\n    {\n        Integer lb = topoOrderMap.getTopologicalIndex(toVertex);\n        Integer ub = topoOrderMap.getTopologicalIndex(fromVertex);\n\n        if ((lb == null) || (ub == null)) {\n            throw new IllegalArgumentException(\n                \"vertices must be in the graph already!\");\n        }\n\n        if (lb < ub) {\n            Set<V> df = new HashSet<V>();\n            Set<V> db = new HashSet<V>();\n\n            \/\/ Discovery\n            Region affectedRegion = new Region(lb, ub);\n            Visited visited = visitedFactory.getInstance(affectedRegion);\n\n            \/\/ throws CycleFoundException if there is a cycle\n            dfsF(toVertex, df, visited, affectedRegion);\n\n            dfsB(fromVertex, db, visited, affectedRegion);\n            reorder(df, db, visited);\n            ++topologyUpdateCount; \/\/ if we do a reorder, than the topology has\n                                   \/\/ been updated\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V fromVertex","parameterName":"fromVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V toVertex","parameterName":"toVertex"}],"methodName":"updateDag","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.updateDag","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 276,col 20)-(line 276,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 276,col 36)-(line 276,col 39)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 278,col 17)-(line 278,col 56)","literalExprId":3,"literalExpr":"\"vertices must be in the graph already!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.updateDag(V, V)"},{"javadocBlockTags":[],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean result;\n    try {\n        result = addDagEdge(sourceVertex, targetVertex, edge);\n    } catch (CycleFoundException e) {\n        throw new IllegalArgumentException(e);\n    }\n    return result;\n}","methodRange":"(line 304,col 5)-(line 313,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E edge)\n    {\n        boolean result;\n        try {\n            result = addDagEdge(sourceVertex, targetVertex, edge);\n        } catch (CycleFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n        return result;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * identical to {@link #addDagEdge(Object, Object, Object)}, except an\n     * unchecked {@link IllegalArgumentException} is thrown if a cycle would\n     * have been induced by this edge\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='identical to '}, JavadocInlineTag{tagName='link', type=LINK, content=' #addDagEdge(Object, Object, Object)'}, JavadocSnippet{text=', except an\nunchecked '}, JavadocInlineTag{tagName='link', type=LINK, content=' IllegalArgumentException'}, JavadocSnippet{text=' is thrown if a cycle would\nhave been induced by this edge'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.addEdge(V, V, E)"},{"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean removed = super.removeVertex(v);\n    if (removed) {\n        Integer topoIndex = topoOrderMap.removeVertex(v);\n        if (topoIndex == minTopoIndex) {\n            while ((minTopoIndex < 0) && (null == topoOrderMap.getVertex(minTopoIndex))) {\n                ++minTopoIndex;\n            }\n        }\n        if (topoIndex == maxTopoIndex) {\n            while ((maxTopoIndex > 0) && (null == topoOrderMap.getVertex(maxTopoIndex))) {\n                --maxTopoIndex;\n            }\n        }\n        ++topologyUpdateCount;\n    }\n    return removed;\n}","methodRange":"(line 318,col 5)-(line 349,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        boolean removed = super.removeVertex(v);\n\n        if (removed) {\n            Integer topoIndex = topoOrderMap.removeVertex(v);\n\n            \/\/ contract minTopoIndex as we are able\n            if (topoIndex == minTopoIndex) {\n                while (\n                    (minTopoIndex < 0)\n                    && (null == topoOrderMap.getVertex(minTopoIndex)))\n                {\n                    ++minTopoIndex;\n                }\n            }\n\n            \/\/ contract maxTopoIndex as we are able\n            if (topoIndex == maxTopoIndex) {\n                while (\n                    (maxTopoIndex > 0)\n                    && (null == topoOrderMap.getVertex(maxTopoIndex)))\n                {\n                    --maxTopoIndex;\n                }\n            }\n\n            ++topologyUpdateCount;\n        }\n\n        return removed;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" for certain operations over time","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.removeVertex","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 328,col 37)-(line 328,col 37)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 329,col 25)-(line 329,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 338,col 37)-(line 338,col 37)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 339,col 25)-(line 339,col 28)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.removeVertex(V)"},{"methodDeclaration":"public boolean removeAllVertices(Collection<? extends V> arg0)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean removed = super.removeAllVertices(arg0);\n    topoOrderMap.removeAllVertices();\n    maxTopoIndex = 0;\n    minTopoIndex = 0;\n    ++topologyUpdateCount;\n    return removed;\n}","methodRange":"(line 351,col 5)-(line 363,col 5)","methodTokenRange":"@Override public boolean removeAllVertices(Collection<? extends V> arg0)\n    {\n        boolean removed = super.removeAllVertices(arg0);\n\n        topoOrderMap.removeAllVertices();\n\n        maxTopoIndex = 0;\n        minTopoIndex = 0;\n\n        ++topologyUpdateCount;\n\n        return removed;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> arg0","parameterName":"arg0"}],"methodName":"removeAllVertices","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.removeAllVertices","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 357,col 24)-(line 357,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 358,col 24)-(line 358,col 24)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.removeAllVertices(java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex being visited","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex being visited'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the set we are populating with forward connected vertices in\nthe Affected Region","javadocBlockTagName":"df","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the set we are populating with forward connected vertices in\nthe Affected Region'}]}', name=Optional[df]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a simple data structure that lets us know if we already\nvisited a node with a given topo index","javadocBlockTagName":"visited","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a simple data structure that lets us know if we already\nvisited a node with a given topo index'}]}', name=Optional[visited]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"for quick lookups, a map from vertex to topo index in\nthe AR","javadocBlockTagName":"topoIndexMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='for quick lookups, a map from vertex to topo index in\nthe AR'}]}', name=Optional[topoIndexMap]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the topo index of the original fromVertex -- used for cycle\ndetection","javadocBlockTagName":"ub","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the topo index of the original fromVertex -- used for cycle\ndetection'}]}', name=Optional[ub]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if a cycle is discovered","javadocBlockTagName":"CycleFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a cycle is discovered'}]}', name=Optional[CycleFoundException]}"}],"methodDeclaration":"private void dfsF(V vertex, Set<V> df, Visited visited, Region affectedRegion) throws CycleFoundException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n    visited.setVisited(topoIndex);\n    df.add(vertex);\n    for (E outEdge : outgoingEdgesOf(vertex)) {\n        V nextVertex = getEdgeTarget(outEdge);\n        Integer nextVertexTopoIndex = topoOrderMap.getTopologicalIndex(nextVertex);\n        if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n            try {\n                for (V visitedVertex : df) {\n                    visited.clearVisited(topoOrderMap.getTopologicalIndex(visitedVertex));\n                }\n            } catch (UnsupportedOperationException e) {\n            }\n            throw new CycleFoundException();\n        }\n        if (affectedRegion.isIn(nextVertexTopoIndex) && !visited.getVisited(nextVertexTopoIndex)) {\n            dfsF(nextVertex, df, visited, affectedRegion);\n        }\n    }\n}","methodRange":"(line 381,col 5)-(line 424,col 5)","methodTokenRange":"private void dfsF(\n        V vertex,\n        Set<V> df,\n        Visited visited,\n        Region affectedRegion)\n        throws CycleFoundException\n    {\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n        \/\/ Assumption: vertex is in the AR and so it will be in visited\n        visited.setVisited(topoIndex);\n\n        df.add(vertex);\n\n        for (E outEdge : outgoingEdgesOf(vertex)) {\n            V nextVertex = getEdgeTarget(outEdge);\n            Integer nextVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(nextVertex);\n\n            if (nextVertexTopoIndex.intValue() == affectedRegion.finish) {\n                \/\/ reset visited\n                try {\n                    for (V visitedVertex : df) {\n                        visited.clearVisited(\n                            topoOrderMap.getTopologicalIndex(visitedVertex));\n                    }\n                } catch (UnsupportedOperationException e) {\n                    \/\/ okay, fine, some implementations (ones that automatically\n                    \/\/ clear themselves out) don't work this way\n                }\n                throw new CycleFoundException();\n            }\n\n            \/\/ note, order of checks is important as we need to make sure the\n            \/\/ vertex is in the affected region before we check its visited\n            \/\/ status (otherwise we will be causing an\n            \/\/ ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(nextVertexTopoIndex)\n                && !visited.getVisited(nextVertexTopoIndex))\n            {\n                dfsF(nextVertex, df, visited, affectedRegion); \/\/ recurse\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Depth first search forward, building up the set (df) of forward-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param df the set we are populating with forward connected vertices in\n     * the Affected Region\n     * @param visited a simple data structure that lets us know if we already\n     * visited a node with a given topo index\n     * @param topoIndexMap for quick lookups, a map from vertex to topo index in\n     * the AR\n     * @param ub the topo index of the original fromVertex -- used for cycle\n     * detection\n     *\n     * @throws CycleFoundException if a cycle is discovered\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> df","parameterName":"df"},{"parameterType":"Visited","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited","parameter":"Visited visited","parameterName":"visited"},{"parameterType":"Region","parameterId":4,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region","parameter":"Region affectedRegion","parameterName":"affectedRegion"}],"methodName":"dfsF","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.dfsF","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Depth first search forward, building up the set (df) of forward-connected\nvertices in the Affected Region'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex being visited'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the set we are populating with forward connected vertices in\nthe Affected Region'}]}', name=Optional[df]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a simple data structure that lets us know if we already\nvisited a node with a given topo index'}]}', name=Optional[visited]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='for quick lookups, a map from vertex to topo index in\nthe AR'}]}', name=Optional[topoIndexMap]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the topo index of the original fromVertex -- used for cycle\ndetection'}]}', name=Optional[ub]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a cycle is discovered'}]}', name=Optional[CycleFoundException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.dfsF(V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex being visited","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex being visited'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the set we are populating with back-connected vertices in the\nAR","javadocBlockTagName":"db","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the set we are populating with back-connected vertices in the\nAR'}]}', name=Optional[db]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"visited","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[visited]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"topoIndexMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[topoIndexMap]}"}],"methodDeclaration":"private void dfsB(V vertex, Set<V> db, Visited visited, Region affectedRegion)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n    visited.setVisited(topoIndex);\n    db.add(vertex);\n    for (E inEdge : incomingEdgesOf(vertex)) {\n        V previousVertex = getEdgeSource(inEdge);\n        Integer previousVertexTopoIndex = topoOrderMap.getTopologicalIndex(previousVertex);\n        if (affectedRegion.isIn(previousVertexTopoIndex) && !visited.getVisited(previousVertexTopoIndex)) {\n            dfsB(previousVertex, db, visited, affectedRegion);\n        }\n    }\n}","methodRange":"(line 436,col 5)-(line 467,col 5)","methodTokenRange":"private void dfsB(\n        V vertex,\n        Set<V> db,\n        Visited visited,\n        Region affectedRegion)\n    {\n        \/\/ Assumption: vertex is in the AR and so we will get a topoIndex from\n        \/\/ the map\n        int topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        visited.setVisited(topoIndex);\n\n        db.add(vertex);\n\n        for (E inEdge : incomingEdgesOf(vertex)) {\n            V previousVertex = getEdgeSource(inEdge);\n            Integer previousVertexTopoIndex =\n                topoOrderMap.getTopologicalIndex(previousVertex);\n\n            \/\/ note, order of checks is important as we need to make sure the\n            \/\/ vertex is in the affected region before we check its visited\n            \/\/ status (otherwise we will be causing an\n            \/\/ ArrayIndexOutOfBoundsException).\n            if (affectedRegion.isIn(previousVertexTopoIndex)\n                && !visited.getVisited(previousVertexTopoIndex))\n            {\n                \/\/ if prevousVertexTopoIndex != null, the vertex is in the\n                \/\/ Affected Region according to our topoIndexMap\n\n                dfsB(previousVertex, db, visited, affectedRegion);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Depth first search backward, building up the set (db) of back-connected\n     * vertices in the Affected Region\n     *\n     * @param vertex the vertex being visited\n     * @param db the set we are populating with back-connected vertices in the\n     * AR\n     * @param visited\n     * @param topoIndexMap\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> db","parameterName":"db"},{"parameterType":"Visited","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited","parameter":"Visited visited","parameterName":"visited"},{"parameterType":"Region","parameterId":4,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region","parameter":"Region affectedRegion","parameterName":"affectedRegion"}],"methodName":"dfsB","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.dfsB","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Depth first search backward, building up the set (db) of back-connected\nvertices in the Affected Region'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex being visited'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the set we are populating with back-connected vertices in the\nAR'}]}', name=Optional[db]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[visited]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[topoIndexMap]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.dfsB(V, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Region)"},{"methodDeclaration":"private void reorder(Set<V> df, Set<V> db, Visited visited)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<V> topoDf = new ArrayList<V>(df);\n    List<V> topoDb = new ArrayList<V>(db);\n    Collections.sort(topoDf, topoComparator);\n    Collections.sort(topoDb, topoComparator);\n    SortedSet<Integer> availableTopoIndices = new TreeSet<Integer>();\n    V[] bigL = (V[]) new Object[df.size() + db.size()];\n    int lIndex = 0;\n    boolean clearVisited = true;\n    for (V vertex : topoDb) {\n        Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        availableTopoIndices.add(topoIndex);\n        bigL[lIndex++] = vertex;\n        if (clearVisited) {\n            try {\n                visited.clearVisited(topoIndex);\n            } catch (UnsupportedOperationException e) {\n                clearVisited = false;\n            }\n        }\n    }\n    for (V vertex : topoDf) {\n        Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n        availableTopoIndices.add(topoIndex);\n        bigL[lIndex++] = vertex;\n        if (clearVisited) {\n            try {\n                visited.clearVisited(topoIndex);\n            } catch (UnsupportedOperationException e) {\n                clearVisited = false;\n            }\n        }\n    }\n    lIndex = 0;\n    for (Integer topoIndex : availableTopoIndices) {\n        V vertex = bigL[lIndex++];\n        topoOrderMap.putVertex(topoIndex, vertex);\n    }\n}","methodRange":"(line 469,col 5)-(line 532,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    private void reorder(Set<V> df, Set<V> db, Visited visited)\n    {\n        List<V> topoDf = new ArrayList<V>(df);\n        List<V> topoDb = new ArrayList<V>(db);\n\n        Collections.sort(topoDf, topoComparator);\n        Collections.sort(topoDb, topoComparator);\n\n        \/\/ merge these suckers together in topo order\n\n        SortedSet<Integer> availableTopoIndices = new TreeSet<Integer>();\n\n        \/\/ we have to cast to the generic type, can't do \"new V[size]\" in java\n        \/\/ 5;\n        V [] bigL = (V []) new Object[df.size() + db.size()];\n        int lIndex = 0; \/\/ this index is used for the sole purpose of pushing\n                        \/\/ into\n\n        \/\/ the correct index of bigL\n\n        \/\/ assume (for now) that we are resetting visited\n        boolean clearVisited = true;\n\n        for (V vertex : topoDb) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            \/\/ add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { \/\/ reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        for (V vertex : topoDf) {\n            Integer topoIndex = topoOrderMap.getTopologicalIndex(vertex);\n\n            \/\/ add the available indices to the set\n            availableTopoIndices.add(topoIndex);\n            bigL[lIndex++] = vertex;\n\n            if (clearVisited) { \/\/ reset visited status if supported\n                try {\n                    visited.clearVisited(topoIndex);\n                } catch (UnsupportedOperationException e) {\n                    clearVisited = false;\n                }\n            }\n        }\n\n        lIndex = 0; \/\/ reusing lIndex\n        for (Integer topoIndex : availableTopoIndices) {\n            \/\/ assign the indexes to the elements of bigL in order\n            V vertex = bigL[lIndex++]; \/\/ note the post-increment\n            topoOrderMap.putVertex(topoIndex, vertex);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> df","parameterName":"df"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> db","parameterName":"db"},{"parameterType":"Visited","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited","parameter":"Visited visited","parameterName":"visited"}],"methodName":"reorder","methodQualifiedSignature":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.reorder","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 469,col 23)-(line 469,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 485,col 22)-(line 485,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 32)-(line 491,col 35)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 505,col 36)-(line 505,col 40)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 521,col 36)-(line 521,col 40)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 526,col 18)-(line 526,col 18)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.reorder(java.util.Set<V>, java.util.Set<V>, org.jgrapht.experimental.dag.DirectedAcyclicGraph.Visited)"}],"classJavadoc":"\/**\n * <p>DirectedAcyclicGraph implements a DAG that can be modified (vertices &amp;\n * edges added and removed), is guaranteed to remain acyclic, and provides fast\n * topological order iteration.<\/p>\n *\n * <p>This is done using a dynamic topological sort which is based on the\n * algorithm PK described in \"D. Pearce &amp; P. Kelly, 2007: A Dynamic\n * Topological Sort Algorithm for Directed Acyclic Graphs\", (see <a\n * href=\"http:\/\/www.mcs.vuw.ac.nz\/~djp\/files\/PK-JEA07.pdf\">Paper<\/a> or <a\n * href=\"http:\/\/doi.acm.org\/10.1145\/1187436.1210590\">ACM link<\/a> for details).\n * <\/p>\n *\n * <p>The implementation differs from the algorithm specified in the above paper\n * in some ways, perhaps most notably in that the topological ordering is stored\n * by default using two HashMaps, which will have some effects on runtime, but\n * also allows for vertex addition and removal, and other operations which are\n * helpful for manipulating or combining DAGs. This storage mechanism is\n * pluggable for subclassers.<\/p>\n *\n * <p>This class makes no claims to thread safety, and concurrent usage from\n * multiple threads will produce undefined results.<\/p>\n *\n * @author Peter Giles, gilesp@u.washington.edu\n *\/\n","className":"DirectedAcyclicGraph","fields":[{"fieldRange":"(line 75,col 5)-(line 75,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 4522128427004938150L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 75,col 50)-(line 75,col 69)","literalExprId":1,"literalExpr":"4522128427004938150L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[4522128427004938150L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 77,col 5)-(line 77,col 45)","fieldName":"topoComparator","fieldJavadocComment":"","fieldTokenRange":"private TopoComparator<V> topoComparator;","fieldTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoComparator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoComparator.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"TopoComparator<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoComparator<V>"},{"fieldRange":"(line 79,col 5)-(line 79,col 45)","fieldName":"topoOrderMap","fieldJavadocComment":"","fieldTokenRange":"private TopoOrderMapping<V> topoOrderMap;","fieldTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMapping, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMapping.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"TopoOrderMapping<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMapping<V>"},{"fieldRange":"(line 81,col 5)-(line 81,col 33)","fieldName":"maxTopoIndex","fieldJavadocComment":"","fieldTokenRange":"private int maxTopoIndex = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 81,col 32)-(line 81,col 32)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 82,col 5)-(line 82,col 33)","fieldName":"minTopoIndex","fieldJavadocComment":"","fieldTokenRange":"private int minTopoIndex = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 82,col 32)-(line 82,col 32)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 85,col 5)-(line 85,col 41)","fieldName":"topologyUpdateCount","fieldJavadocComment":" this update count is used to keep internal topological iterators honest","fieldTokenRange":"private long topologyUpdateCount = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 85,col 40)-(line 85,col 40)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 90,col 5)-(line 90,col 68)","fieldName":"visitedFactory","fieldJavadocComment":"\n     * Pluggable VisitedFactory implementation\n     ","fieldTokenRange":"private VisitedFactory visitedFactory = new VisitedBitSetImpl();","fieldTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedFactory, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new VisitedBitSetImpl()]","fieldType":"VisitedFactory","fieldJavadoc":"Pluggable VisitedFactory implementation\n","fieldTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.VisitedFactory"},{"fieldRange":"(line 95,col 5)-(line 95,col 80)","fieldName":"topoOrderFactory","fieldJavadocComment":"\n     * Pluggable TopoOrderMappingFactory implementation\n     ","fieldTokenRange":"private TopoOrderMappingFactory<V> topoOrderFactory = new TopoVertexBiMap();","fieldTypeResolved":"ReferenceType{org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new TopoVertexBiMap()]","fieldType":"TopoOrderMappingFactory<V>","fieldJavadoc":"Pluggable TopoOrderMappingFactory implementation\n","fieldTypeResolvedDescribed":"org.jgrapht.experimental.dag.DirectedAcyclicGraph.TopoOrderMappingFactory<V>"}]}],"sourceFileId":4,"packageName":"org.jgrapht.experimental.dag"},{"sourceFileName":"org.jgrapht.experimental.GraphSquare","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.event.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph of which a square is to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph of which a square is to be created.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"createLoops","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[createLoops]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.GraphSquare.GraphSquare(org.jgrapht.Graph<V, E>, boolean)","variableDeclarationExprs":[{"variableType":"E","variableName":"edge","variableDeclarationExprId":1,"variableDeclarationExpr":"E edge = e.getEdge()","variableDeclarationExprRange":"(line 76,col 25)-(line 76,col 44)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 76,col 27)-(line 76,col 44)"}],"constructorRange":"(line 64,col 5)-(line 107,col 5)","constructorJavadocComment":"\n     * Constructor for GraphSquare.\n     *\n     * @param g the graph of which a square is to be created.\n     * @param createLoops\n     ","constructorDeclaration":"public GraphSquare(final Graph<V, E> g, final boolean createLoops)","constructorBody":"{\n    super(g.getEdgeFactory(), false, createLoops);\n    Graphs.addAllVertices(this, g.vertexSet());\n    addSquareEdges(g, createLoops);\n    if (g instanceof ListenableGraph) {\n        ((ListenableGraph<V, E>) g).addGraphListener(new GraphListener<V, E>() {\n\n            @Override\n            public void edgeAdded(GraphEdgeChangeEvent<V, E> e) {\n                E edge = e.getEdge();\n                addEdgesStartingAt(g, g.getEdgeSource(edge), g.getEdgeTarget(edge), createLoops);\n                addEdgesStartingAt(g, g.getEdgeTarget(edge), g.getEdgeSource(edge), createLoops);\n            }\n\n            @Override\n            public void edgeRemoved(GraphEdgeChangeEvent<V, E> e) {\n                GraphSquare.super.removeAllEdges(edgeSet());\n                addSquareEdges(g, createLoops);\n            }\n\n            @Override\n            public void vertexAdded(GraphVertexChangeEvent<V> e) {\n            }\n\n            @Override\n            public void vertexRemoved(GraphVertexChangeEvent<V> e) {\n            }\n        });\n    }\n}","constructorName":"GraphSquare","constructorQualifiedName":"org.jgrapht.experimental.GraphSquare.GraphSquare","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"final boolean createLoops","parameterName":"createLoops"}],"literalExprs":[{"literalExprRange":"(line 66,col 35)-(line 66,col 39)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public GraphSquare(final Graph<V, E> g, final boolean createLoops)\n    {\n        super(g.getEdgeFactory(), false, createLoops);\n        Graphs.addAllVertices(this, g.vertexSet());\n        addSquareEdges(g, createLoops);\n\n        if (g instanceof ListenableGraph) {\n            ((ListenableGraph<V, E>) g).addGraphListener(\n                new GraphListener<V, E>() {\n                    @Override public void edgeAdded(\n                        GraphEdgeChangeEvent<V, E> e)\n                    {\n                        E edge = e.getEdge();\n                        addEdgesStartingAt(\n                            g,\n                            g.getEdgeSource(edge),\n                            g.getEdgeTarget(edge),\n                            createLoops);\n                        addEdgesStartingAt(\n                            g,\n                            g.getEdgeTarget(edge),\n                            g.getEdgeSource(edge),\n                            createLoops);\n                    }\n\n                    @Override public void edgeRemoved(\n                        GraphEdgeChangeEvent<V, E> e)\n                    { \/\/ this is not a very performant implementation\n                        GraphSquare.super.removeAllEdges(edgeSet());\n                        addSquareEdges(g, createLoops);\n                    }\n\n                    @Override public void vertexAdded(\n                        GraphVertexChangeEvent<V> e)\n                    {\n                    }\n\n                    @Override public void vertexRemoved(\n                        GraphVertexChangeEvent<V> e)\n                    {\n                    }\n                });\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for GraphSquare.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph of which a square is to be created.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[createLoops]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 112,col 5)-(line 115,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 120,col 5)-(line 123,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 128,col 5)-(line 131,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllEdges(Collection<? extends E> edges)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 136,col 5)-(line 139,col 5)","methodTokenRange":"@Override public boolean removeAllEdges(Collection<? extends E> edges)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edges","parameterName":"edges"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.removeAllEdges(java.util.Collection<? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> removeAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 144,col 5)-(line 147,col 5)","methodTokenRange":"@Override public Set<E> removeAllEdges(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.removeAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllVertices(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllVertices(Collection<? extends V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 152,col 5)-(line 155,col 5)","methodTokenRange":"@Override public boolean removeAllVertices(Collection<? extends V> vertices)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllVertices(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertices","parameterName":"vertices"}],"methodName":"removeAllVertices","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.removeAllVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.removeAllVertices(java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 160,col 5)-(line 163,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 168,col 5)-(line 171,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 176,col 5)-(line 179,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.removeVertex(V)"},{"methodDeclaration":"private void addEdgesStartingAt(final Graph<V, E> g, final V v, final V u, boolean createLoops)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!g.containsEdge(v, u)) {\n        return;\n    }\n    final List<V> adjVertices = Graphs.neighborListOf(g, u);\n    for (int i = 0; i < adjVertices.size(); i++) {\n        final V w = adjVertices.get(i);\n        if (g.containsEdge(u, w) && ((v != w) || createLoops)) {\n            super.addEdge(v, w);\n        }\n    }\n}","methodRange":"(line 181,col 5)-(line 200,col 5)","methodTokenRange":"private void addEdgesStartingAt(\n        final Graph<V, E> g,\n        final V v,\n        final V u,\n        boolean createLoops)\n    {\n        if (!g.containsEdge(v, u)) {\n            return;\n        }\n\n        final List<V> adjVertices = Graphs.neighborListOf(g, u);\n\n        for (int i = 0; i < adjVertices.size(); i++) {\n            final V w = adjVertices.get(i);\n\n            if (g.containsEdge(u, w) && ((v != w) || createLoops)) {\n                super.addEdge(v, w);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"final V v","parameterName":"v"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"final V u","parameterName":"u"},{"parameterType":"boolean","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean createLoops","parameterName":"createLoops"}],"methodName":"addEdgesStartingAt","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.addEdgesStartingAt","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 193,col 22)-(line 193,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.addEdgesStartingAt(org.jgrapht.Graph<V, E>, V, V, boolean)"},{"methodDeclaration":"private void addSquareEdges(Graph<V, E> g, boolean createLoops)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V v : g.vertexSet()) {\n        List<V> adjVertices = Graphs.neighborListOf(g, v);\n        for (int i = 0; i < adjVertices.size(); i++) {\n            addEdgesStartingAt(g, v, adjVertices.get(i), createLoops);\n        }\n    }\n}","methodRange":"(line 202,col 5)-(line 211,col 5)","methodTokenRange":"private void addSquareEdges(Graph<V, E> g, boolean createLoops)\n    {\n        for (V v : g.vertexSet()) {\n            List<V> adjVertices = Graphs.neighborListOf(g, v);\n\n            for (int i = 0; i < adjVertices.size(); i++) {\n                addEdgesStartingAt(g, v, adjVertices.get(i), createLoops);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean createLoops","parameterName":"createLoops"}],"methodName":"addSquareEdges","methodQualifiedSignature":"org.jgrapht.experimental.GraphSquare.addSquareEdges","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 207,col 26)-(line 207,col 26)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphSquare.addSquareEdges(org.jgrapht.Graph<V, E>, boolean)"}],"classJavadoc":"\/**\n * DOCUMENT ME!\n *\n * @author Michael Behrisch\n * @since Sep 14, 2004\n *\/\n","className":"GraphSquare","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 71)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -2642034600395594304L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 55,col 51)-(line 55,col 70)","literalExprId":1,"literalExpr":"2642034600395594304L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-2642034600395594304L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 56,col 5)-(line 56,col 76)","fieldName":"UNMODIFIABLE","fieldJavadocComment":"","fieldTokenRange":"private static final String UNMODIFIABLE = \"this graph is unmodifiable\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 48)-(line 56,col 75)","literalExprId":1,"literalExpr":"\"this graph is unmodifiable\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"this graph is unmodifiable\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":5,"packageName":"org.jgrapht.experimental"},{"sourceFileName":"org.jgrapht.experimental.UniformRandomGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.generate.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"numVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[numVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of edges to be generated","javadocBlockTagName":"numEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of edges to be generated'}]}', name=Optional[numEdges]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.UniformRandomGraphGenerator.UniformRandomGraphGenerator(int, int)","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 83,col 5)","constructorJavadocComment":"\n     * Construct a new UniformRandomGraphGenerator.\n     *\n     * @param numVertices number of vertices to be generated\n     * @param numEdges number of edges to be generated\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public UniformRandomGraphGenerator(int numVertices, int numEdges)","constructorBody":"{\n    if (numVertices < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    if ((numEdges < 0) || (numEdges > (numVertices * (numVertices - 1) \/ 2))) {\n        throw new IllegalArgumentException(\"illegal number of edges\");\n    }\n    this.numVertices = numVertices;\n    this.numEdges = numEdges;\n}","constructorName":"UniformRandomGraphGenerator","constructorQualifiedName":"org.jgrapht.experimental.UniformRandomGraphGenerator.UniformRandomGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numVertices","parameterName":"numVertices"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numEdges","parameterName":"numEdges"}],"literalExprs":[{"literalExprRange":"(line 71,col 27)-(line 71,col 27)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 72,col 48)-(line 72,col 69)","literalExprId":2,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 75,col 25)-(line 75,col 25)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 58)-(line 76,col 58)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 63)-(line 76,col 63)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 48)-(line 78,col 72)","literalExprId":6,"literalExpr":"\"illegal number of edges\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public UniformRandomGraphGenerator(int numVertices, int numEdges)\n    {\n        if (numVertices < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        if ((numEdges < 0)\n            || (numEdges > (numVertices * (numVertices - 1) \/ 2)))\n        {\n            throw new IllegalArgumentException(\"illegal number of edges\");\n        }\n\n        this.numVertices = numVertices;\n        this.numEdges = numEdges;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new UniformRandomGraphGenerator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[numVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of edges to be generated'}]}', name=Optional[numEdges]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphGenerator#generateGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphGenerator#generateGraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public void generateGraph(Graph target, VertexFactory vertexFactory, Map resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object[] vertices = RandomGraphHelper.addVertices(target, vertexFactory, numVertices);\n    RandomGraphHelper.addEdges(target, Arrays.asList(vertices), Arrays.asList(vertices), numEdges);\n}","methodRange":"(line 88,col 5)-(line 103,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph target,\n        VertexFactory vertexFactory,\n        Map resultMap)\n    {\n        Object [] vertices =\n            RandomGraphHelper.addVertices(\n                target,\n                vertexFactory,\n                numVertices);\n        RandomGraphHelper.addEdges(\n            target,\n            Arrays.asList(vertices),\n            Arrays.asList(vertices),\n            numEdges);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphGenerator#generateGraph\n     ","methodParameters":[{"parameterType":"Graph","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph","parameter":"Graph target","parameterName":"target"},{"parameterType":"VertexFactory","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory","parameter":"VertexFactory vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Map","parameter":"Map resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.experimental.UniformRandomGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphGenerator#generateGraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.UniformRandomGraphGenerator.generateGraph(org.jgrapht.Graph, org.jgrapht.VertexFactory, java.util.Map)"}],"classJavadoc":"\/**\n * UniformRandomGraphGenerator generates a <a\n * href=\"http:\/\/mathworld.wolfram.com\/RandomGraph.html\">uniform random graph<\/a>\n * of any size. A uniform random graph contains edges chosen independently\n * uniformly at random from the set of all possible edges.\n *\n * @author Michael Behrisch\n * @since Sep 13, 2004\n *\/\n","className":"UniformRandomGraphGenerator","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 31)","fieldName":"numEdges","fieldJavadocComment":"","fieldTokenRange":"private final int numEdges;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 59,col 5)-(line 59,col 34)","fieldName":"numVertices","fieldJavadocComment":"","fieldTokenRange":"private final int numVertices;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":6,"packageName":"org.jgrapht.experimental"},{"sourceFileName":"org.jgrapht.experimental.GraphTests","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"GraphTests","constructorQualifiedName":"org.jgrapht.experimental.GraphTests.GraphTests","constructorQualifiedSignature":"org.jgrapht.experimental.GraphTests.GraphTests()","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"private GraphTests()\n    {\n    }","variableDeclarationExprs":[],"constructorRange":"(line 22,col 5)-(line 24,col 5)","constructorJavadocComment":"","constructorDeclaration":"private GraphTests()","constructorBody":"{\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static boolean isEmpty(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return g.edgeSet().isEmpty();\n}","methodRange":"(line 26,col 5)-(line 29,col 5)","methodTokenRange":"public static <V, E> boolean isEmpty(Graph<V, E> g)\n    {\n        return g.edgeSet().isEmpty();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"isEmpty","methodQualifiedSignature":"org.jgrapht.experimental.GraphTests.isEmpty","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.GraphTests.isEmpty(org.jgrapht.Graph<V, E>)"},{"methodDeclaration":"public static boolean isComplete(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int n = g.vertexSet().size();\n    return g.edgeSet().size() == (n * (n - 1) \/ 2);\n}","methodRange":"(line 31,col 5)-(line 36,col 5)","methodTokenRange":"public static <V, E> boolean isComplete(Graph<V, E> g)\n    {\n        int n = g.vertexSet().size();\n        return g.edgeSet().size()\n            == (n * (n - 1) \/ 2);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"isComplete","methodQualifiedSignature":"org.jgrapht.experimental.GraphTests.isComplete","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 35,col 26)-(line 35,col 26)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 35,col 31)-(line 35,col 31)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphTests.isComplete(org.jgrapht.Graph<V, E>)"},{"methodDeclaration":"public static boolean isConnected(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int numVertices = g.vertexSet().size();\n    int numEdges = g.edgeSet().size();\n    if (numEdges < (numVertices - 1)) {\n        return false;\n    }\n    if ((numVertices < 2) || (numEdges > ((numVertices - 1) * (numVertices - 2) \/ 2))) {\n        return true;\n    }\n    Set<V> known = new HashSet<V>();\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = g.vertexSet().iterator().next();\n    queue.add(v);\n    known.add(v);\n    while (!queue.isEmpty()) {\n        v = queue.removeFirst();\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            v = it.next();\n            if (!known.contains(v)) {\n                known.add(v);\n                queue.add(v);\n            }\n        }\n    }\n    return known.size() == numVertices;\n}","methodRange":"(line 38,col 5)-(line 73,col 5)","methodTokenRange":"public static <V, E> boolean isConnected(Graph<V, E> g)\n    {\n        int numVertices = g.vertexSet().size();\n        int numEdges = g.edgeSet().size();\n\n        if (numEdges < (numVertices - 1)) {\n            return false;\n        }\n        if ((numVertices < 2)\n            || (numEdges > ((numVertices - 1) * (numVertices - 2) \/ 2)))\n        {\n            return true;\n        }\n\n        Set<V> known = new HashSet<V>();\n        LinkedList<V> queue = new LinkedList<V>();\n        V v = g.vertexSet().iterator().next();\n\n        queue.add(v); \/\/ start with node 1\n        known.add(v);\n\n        while (!queue.isEmpty()) {\n            v = queue.removeFirst();\n            for (\n                Iterator<V> it = Graphs.neighborListOf(g, v).iterator();\n                it.hasNext();)\n            {\n                v = it.next();\n                if (!known.contains(v)) {\n                    known.add(v);\n                    queue.add(v);\n                }\n            }\n        }\n        return known.size() == numVertices;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"isConnected","methodQualifiedSignature":"org.jgrapht.experimental.GraphTests.isConnected","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 43,col 39)-(line 43,col 39)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 44,col 20)-(line 44,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 46,col 28)-(line 46,col 28)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 47,col 44)-(line 47,col 44)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 47,col 64)-(line 47,col 64)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 47,col 69)-(line 47,col 69)","literalExprId":6,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 49,col 20)-(line 49,col 23)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphTests.isConnected(org.jgrapht.Graph<V, E>)"},{"methodDeclaration":"public static boolean isTree(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return isConnected(g) && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n}","methodRange":"(line 75,col 5)-(line 79,col 5)","methodTokenRange":"public static <V, E> boolean isTree(Graph<V, E> g)\n    {\n        return isConnected(g)\n            && (g.edgeSet().size() == (g.vertexSet().size() - 1));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"isTree","methodQualifiedSignature":"org.jgrapht.experimental.GraphTests.isTree","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 78,col 63)-(line 78,col 63)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphTests.isTree(org.jgrapht.Graph<V, E>)"},{"methodDeclaration":"public static boolean isBipartite(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if ((4 * g.edgeSet().size()) > (g.vertexSet().size() * g.vertexSet().size())) {\n        return false;\n    }\n    if (isEmpty(g)) {\n        return true;\n    }\n    Set<V> unknown = new HashSet<V>(g.vertexSet());\n    LinkedList<V> queue = new LinkedList<V>();\n    V v = unknown.iterator().next();\n    Set<V> odd = new HashSet<V>();\n    queue.add(v);\n    while (!unknown.isEmpty()) {\n        if (queue.isEmpty()) {\n            queue.add(unknown.iterator().next());\n        }\n        v = queue.removeFirst();\n        unknown.remove(v);\n        for (Iterator<V> it = Graphs.neighborListOf(g, v).iterator(); it.hasNext(); ) {\n            V n = it.next();\n            if (unknown.contains(n)) {\n                queue.add(n);\n                if (!odd.contains(v)) {\n                    odd.add(n);\n                }\n            } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}","methodRange":"(line 81,col 5)-(line 123,col 5)","methodTokenRange":"public static <V, E> boolean isBipartite(Graph<V, E> g)\n    {\n        if ((4 * g.edgeSet().size())\n            > (g.vertexSet().size() * g.vertexSet().size()))\n        {\n            return false;\n        }\n        if (isEmpty(g)) {\n            return true;\n        }\n\n        Set<V> unknown = new HashSet<V>(g.vertexSet());\n        LinkedList<V> queue = new LinkedList<V>();\n        V v = unknown.iterator().next();\n        Set<V> odd = new HashSet<V>();\n\n        queue.add(v);\n\n        while (!unknown.isEmpty()) {\n            if (queue.isEmpty()) {\n                queue.add(unknown.iterator().next());\n            }\n\n            v = queue.removeFirst();\n            unknown.remove(v);\n\n            for (\n                Iterator<V> it = Graphs.neighborListOf(g, v).iterator();\n                it.hasNext();)\n            {\n                V n = it.next();\n                if (unknown.contains(n)) {\n                    queue.add(n);\n                    if (!odd.contains(v)) {\n                        odd.add(n);\n                    }\n                } else if (!(odd.contains(v) ^ odd.contains(n))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"isBipartite","methodQualifiedSignature":"org.jgrapht.experimental.GraphTests.isBipartite","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 83,col 14)-(line 83,col 14)","literalExprId":1,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 86,col 20)-(line 86,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 89,col 20)-(line 89,col 23)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 118,col 28)-(line 118,col 32)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 122,col 16)-(line 122,col 19)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.GraphTests.isBipartite(org.jgrapht.Graph<V, E>)"}],"classJavadoc":"","className":"GraphTests","fields":[]}],"sourceFileId":7,"packageName":"org.jgrapht.experimental"},{"sourceFileName":"org.jgrapht.experimental.alg.ApproximationAlgorithm","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":" ResultType getUpperBound(Map<V, Object> optionalData)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 20,col 5)-(line 20,col 58)","methodTokenRange":"ResultType getUpperBound(Map<V, Object> optionalData);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(ResultType, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"Map<V, Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Object>","parameter":"Map<V, Object> optionalData","parameterName":"optionalData"}],"methodName":"getUpperBound","methodQualifiedSignature":"org.jgrapht.experimental.alg.ApproximationAlgorithm.getUpperBound","methodJavadoc":"","methodReturnTypeDescribed":"ResultType","methodType":"ResultType","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.alg.ApproximationAlgorithm.getUpperBound(java.util.Map<V, java.lang.Object>)"},{"methodDeclaration":" ResultType getLowerBound(Map<V, Object> optionalData)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 22,col 5)-(line 22,col 58)","methodTokenRange":"ResultType getLowerBound(Map<V, Object> optionalData);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(ResultType, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"Map<V, Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Object>","parameter":"Map<V, Object> optionalData","parameterName":"optionalData"}],"methodName":"getLowerBound","methodQualifiedSignature":"org.jgrapht.experimental.alg.ApproximationAlgorithm.getLowerBound","methodJavadoc":"","methodReturnTypeDescribed":"ResultType","methodType":"ResultType","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.alg.ApproximationAlgorithm.getLowerBound(java.util.Map<V, java.lang.Object>)"},{"methodDeclaration":" boolean isExact()","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 24,col 5)-(line 24,col 22)","methodTokenRange":"boolean isExact();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"isExact","methodQualifiedSignature":"org.jgrapht.experimental.alg.ApproximationAlgorithm.isExact","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.alg.ApproximationAlgorithm.isExact()"}],"classJavadoc":"","className":"ApproximationAlgorithm","fields":[]}],"sourceFileId":8,"packageName":"org.jgrapht.experimental.alg"},{"sourceFileName":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.experimental.alg.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring.BrownBacktrackColoring(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 39,col 5)-(line 42,col 5)","constructorJavadocComment":"\n     * @param g\n     ","constructorDeclaration":"public BrownBacktrackColoring(final Graph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"BrownBacktrackColoring","constructorQualifiedName":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring.BrownBacktrackColoring","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public BrownBacktrackColoring(final Graph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":" void recursiveColor(int pos)","methodAccessSpecifier":"NONE","methodBody":"{\n    _colorCount[pos] = _colorCount[pos - 1];\n    _allowedColors[pos].set(0, _colorCount[pos] + 1);\n    for (int i = 0; i < _neighbors[pos].length; i++) {\n        final int nb = _neighbors[pos][i];\n        if (_color[nb] > 0) {\n            _allowedColors[pos].clear(_color[nb]);\n        }\n    }\n    for (int i = 1; (i <= _colorCount[pos]) && (_colorCount[pos] < _chi); i++) {\n        if (_allowedColors[pos].get(i)) {\n            _color[pos] = i;\n            if (pos < (_neighbors.length - 1)) {\n                recursiveColor(pos + 1);\n            } else {\n                _chi = _colorCount[pos];\n            }\n        }\n    }\n    if ((_colorCount[pos] + 1) < _chi) {\n        _colorCount[pos]++;\n        _color[pos] = _colorCount[pos];\n        if (pos < (_neighbors.length - 1)) {\n            recursiveColor(pos + 1);\n        } else {\n            _chi = _colorCount[pos];\n        }\n    }\n    _color[pos] = 0;\n}","methodRange":"(line 44,col 5)-(line 79,col 5)","methodTokenRange":"void recursiveColor(int pos)\n    {\n        _colorCount[pos] = _colorCount[pos - 1];\n        _allowedColors[pos].set(0, _colorCount[pos] + 1);\n        for (int i = 0; i < _neighbors[pos].length; i++) {\n            final int nb = _neighbors[pos][i];\n            if (_color[nb] > 0) {\n                _allowedColors[pos].clear(_color[nb]);\n            }\n        }\n        for (\n            int i = 1;\n            (i <= _colorCount[pos])\n            && (_colorCount[pos] < _chi);\n            i++)\n        {\n            if (_allowedColors[pos].get(i)) {\n                _color[pos] = i;\n                if (pos < (_neighbors.length - 1)) {\n                    recursiveColor(pos + 1);\n                } else {\n                    _chi = _colorCount[pos];\n                }\n            }\n        }\n        if ((_colorCount[pos] + 1) < _chi) {\n            _colorCount[pos]++;\n            _color[pos] = _colorCount[pos];\n            if (pos < (_neighbors.length - 1)) {\n                recursiveColor(pos + 1);\n            } else {\n                _chi = _colorCount[pos];\n            }\n        }\n        _color[pos] = 0;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int pos","parameterName":"pos"}],"methodName":"recursiveColor","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring.recursiveColor","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 46,col 46)-(line 46,col 46)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 47,col 33)-(line 47,col 33)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 47,col 55)-(line 47,col 55)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 48,col 22)-(line 48,col 22)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 50,col 30)-(line 50,col 30)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 55,col 21)-(line 55,col 21)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 62,col 48)-(line 62,col 48)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 63,col 42)-(line 63,col 42)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 69,col 33)-(line 69,col 33)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 72,col 44)-(line 72,col 44)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 73,col 38)-(line 73,col 38)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 23)-(line 78,col 23)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring.recursiveColor(int)"},{"methodDeclaration":"public Integer getResult(Map<V, Object> additionalData)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    _chi = _neighbors.length;\n    _color = new int[_neighbors.length];\n    _color[0] = 1;\n    _colorCount = new int[_neighbors.length];\n    _colorCount[0] = 1;\n    _allowedColors = new BitSet[_neighbors.length];\n    for (int i = 0; i < _neighbors.length; i++) {\n        _allowedColors[i] = new BitSet(1);\n    }\n    recursiveColor(1);\n    if (additionalData != null) {\n        for (int i = 0; i < _vertices.size(); i++) {\n            additionalData.put(_vertices.get(i), _color[i]);\n        }\n    }\n    return _chi;\n}","methodRange":"(line 84,col 5)-(line 102,col 5)","methodTokenRange":"@Override public Integer getResult(Map<V, Object> additionalData)\n    {\n        _chi = _neighbors.length;\n        _color = new int[_neighbors.length];\n        _color[0] = 1;\n        _colorCount = new int[_neighbors.length];\n        _colorCount[0] = 1;\n        _allowedColors = new BitSet[_neighbors.length];\n        for (int i = 0; i < _neighbors.length; i++) {\n            _allowedColors[i] = new BitSet(1);\n        }\n        recursiveColor(1);\n        if (additionalData != null) {\n            for (int i = 0; i < _vertices.size(); i++) {\n                additionalData.put(_vertices.get(i), _color[i]);\n            }\n        }\n        return _chi;\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" (non-Javadoc)\n     * @see org.jgrapht.experimental.alg.ExactAlgorithm#getResult()\n     ","methodParameters":[{"parameterType":"Map<V, Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Object>","parameter":"Map<V, Object> additionalData","parameterName":"additionalData"}],"methodName":"getResult","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring.getResult","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 88,col 16)-(line 88,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 88,col 21)-(line 88,col 21)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 90,col 21)-(line 90,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 90,col 26)-(line 90,col 26)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 22)-(line 92,col 22)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 93,col 44)-(line 93,col 44)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 95,col 24)-(line 95,col 24)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 96,col 31)-(line 96,col 34)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 97,col 26)-(line 97,col 26)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.BrownBacktrackColoring.getResult(java.util.Map<V, java.lang.Object>)"}],"classJavadoc":"\/**\n * @author micha\n *\/\n","className":"BrownBacktrackColoring","fields":[{"fieldRange":"(line 31,col 5)-(line 31,col 26)","fieldName":"_color","fieldJavadocComment":"","fieldTokenRange":"private int [] _color;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[]"},{"fieldRange":"(line 32,col 5)-(line 32,col 31)","fieldName":"_colorCount","fieldJavadocComment":"","fieldTokenRange":"private int [] _colorCount;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[]"},{"fieldRange":"(line 33,col 5)-(line 33,col 37)","fieldName":"_allowedColors","fieldJavadocComment":"","fieldTokenRange":"private BitSet [] _allowedColors;","fieldTypeResolved":"ResolvedArrayType{ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"BitSet[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.BitSet[]"},{"fieldRange":"(line 34,col 5)-(line 34,col 21)","fieldName":"_chi","fieldJavadocComment":"","fieldTokenRange":"private int _chi;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":9,"packageName":"org.jgrapht.experimental.alg.color"},{"sourceFileName":"org.jgrapht.experimental.alg.color.GreedyColoring","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.experimental.alg.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.GreedyColoring(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 35,col 5)-(line 38,col 5)","constructorJavadocComment":"\n     * @param g\n     ","constructorDeclaration":"public GreedyColoring(final Graph<V, E> g)","constructorBody":"{\n    this(g, BEST_ORDER);\n}","constructorName":"GreedyColoring","constructorQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.GreedyColoring","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public GreedyColoring(final Graph<V, E> g)\n    {\n        this(g, BEST_ORDER);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.GreedyColoring(org.jgrapht.Graph<V, E>, int)","variableDeclarationExprs":[],"constructorRange":"(line 43,col 5)-(line 47,col 5)","constructorJavadocComment":"\n     * @param g\n     ","constructorDeclaration":"public GreedyColoring(final Graph<V, E> g, final int method)","constructorBody":"{\n    super(g);\n    _order = method;\n}","constructorName":"GreedyColoring","constructorQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.GreedyColoring","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"final int method","parameterName":"method"}],"literalExprs":[],"constructorTokenRange":"public GreedyColoring(final Graph<V, E> g, final int method)\n    {\n        super(g);\n        _order = method;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":" int color(int[] order)","methodAccessSpecifier":"NONE","methodBody":"{\n    final int[] color = new int[_neighbors.length];\n    int maxColor = 1;\n    BitSet usedColors = new BitSet(_neighbors.length);\n    for (int i = 0; i < _neighbors.length; i++) {\n        final int v = (order == null) ? i : order[i];\n        usedColors.clear();\n        for (int j = 0; j < _neighbors[v].length; j++) {\n            final int nb = _neighbors[v][j];\n            if (color[nb] > 0) {\n                usedColors.set(color[nb]);\n            }\n        }\n        color[v] = usedColors.nextClearBit(1);\n        if (color[v] > maxColor) {\n            maxColor = color[v];\n        }\n    }\n    return maxColor;\n}","methodRange":"(line 49,col 5)-(line 70,col 5)","methodTokenRange":"int color(int [] order)\n    {\n        final int [] color = new int[_neighbors.length];\n        int maxColor = 1;\n        BitSet usedColors = new BitSet(_neighbors.length);\n\n        for (int i = 0; i < _neighbors.length; i++) {\n            final int v = (order == null) ? i : order[i];\n            usedColors.clear();\n            for (int j = 0; j < _neighbors[v].length; j++) {\n                final int nb = _neighbors[v][j];\n                if (color[nb] > 0) {\n                    usedColors.set(color[nb]);\n                }\n            }\n            color[v] = usedColors.nextClearBit(1);\n            if (color[v] > maxColor) {\n                maxColor = color[v];\n            }\n        }\n        return maxColor;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] order","parameterName":"order"}],"methodName":"color","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.color","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 52,col 24)-(line 52,col 24)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 55,col 22)-(line 55,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 56,col 37)-(line 56,col 40)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 58,col 26)-(line 58,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 60,col 33)-(line 60,col 33)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 64,col 48)-(line 64,col 48)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.color(int[])"},{"methodDeclaration":" int[] smallestDegreeLastOrder()","methodAccessSpecifier":"NONE","methodBody":"{\n    final int[] order = new int[_neighbors.length];\n    final int[] degree = new int[_neighbors.length];\n    final List<List<Integer>> buckets = new ArrayList<List<Integer>>(_neighbors.length);\n    int index = _neighbors.length - 1;\n    for (int i = 0; i < _neighbors.length; i++) {\n        buckets.add(new ArrayList<Integer>());\n        degree[i] = _neighbors[i].length;\n    }\n    for (int i = 0; i < _neighbors.length; i++) {\n        buckets.get(degree[i]).add(i);\n    }\n    for (int i = 0; i < _neighbors.length; i++) {\n        while (buckets.get(i).size() > 0) {\n            final int s = buckets.get(i).size() - 1;\n            final int vertex = (Integer) buckets.get(i).get(s);\n            buckets.get(i).remove(s);\n            degree[vertex] = -1;\n            order[index--] = vertex;\n            for (int j = 0; j < _neighbors[vertex].length; j++) {\n                final int nb = _neighbors[vertex][j];\n                if (degree[nb] >= 0) {\n                    buckets.get(degree[nb]).remove(new Integer(nb));\n                    degree[nb]--;\n                    buckets.get(degree[nb]).add(nb);\n                    if (degree[nb] < i) {\n                        i = degree[nb];\n                    }\n                }\n            }\n        }\n    }\n    return order;\n}","methodRange":"(line 72,col 5)-(line 108,col 5)","methodTokenRange":"int [] smallestDegreeLastOrder()\n    {\n        final int [] order = new int[_neighbors.length];\n        final int [] degree = new int[_neighbors.length];\n        final List<List<Integer>> buckets =\n            new ArrayList<List<Integer>>(_neighbors.length);\n        int index = _neighbors.length - 1;\n\n        for (int i = 0; i < _neighbors.length; i++) {\n            buckets.add(new ArrayList<Integer>());\n            degree[i] = _neighbors[i].length;\n        }\n        for (int i = 0; i < _neighbors.length; i++) {\n            buckets.get(degree[i]).add(i);\n        }\n        for (int i = 0; i < _neighbors.length; i++) {\n            while (buckets.get(i).size() > 0) {\n                final int s = buckets.get(i).size() - 1;\n                final int vertex = (Integer) buckets.get(i).get(s);\n                buckets.get(i).remove(s);\n                degree[vertex] = -1;\n                order[index--] = vertex;\n                for (int j = 0; j < _neighbors[vertex].length; j++) {\n                    final int nb = _neighbors[vertex][j];\n                    if (degree[nb] >= 0) {\n                        buckets.get(degree[nb]).remove(new Integer(nb));\n                        degree[nb]--;\n                        buckets.get(degree[nb]).add(nb);\n                        if (degree[nb] < i) {\n                            i = degree[nb];\n                        }\n                    }\n                }\n            }\n        }\n        return order;\n    }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"","methodParameters":[],"methodName":"smallestDegreeLastOrder","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.smallestDegreeLastOrder","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 78,col 41)-(line 78,col 41)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 80,col 22)-(line 80,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 84,col 22)-(line 84,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 87,col 22)-(line 87,col 22)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 88,col 44)-(line 88,col 44)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 89,col 55)-(line 89,col 55)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 35)-(line 92,col 35)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 94,col 30)-(line 94,col 30)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 96,col 39)-(line 96,col 39)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.smallestDegreeLastOrder()"},{"methodDeclaration":" int[] largestSaturationFirstOrder()","methodAccessSpecifier":"NONE","methodBody":"{\n    final int[] satur = new int[_neighbors.length];\n    final int[] buckets = new int[_neighbors.length];\n    final int[] cumBucketSize = new int[_neighbors.length];\n    final int[] bucketIndex = new int[_neighbors.length];\n    int index = 0;\n    int maxSat = 0;\n    for (int i = 0; i < _neighbors.length; i++) {\n        buckets[i] = i;\n        bucketIndex[i] = i;\n    }\n    cumBucketSize[0] = _neighbors.length;\n    while (index < _neighbors.length) {\n        while ((maxSat > 0) && (cumBucketSize[maxSat] == cumBucketSize[maxSat - 1])) {\n            cumBucketSize[maxSat--] = 0;\n        }\n        final int v = buckets[cumBucketSize[maxSat] - 1];\n        cumBucketSize[maxSat]--;\n        satur[v] = -1;\n        index++;\n        for (int j = 0; j < _neighbors[v].length; j++) {\n            final int nb = (int) _neighbors[v][j];\n            final int bi = bucketIndex[nb];\n            if (satur[nb] >= 0) {\n                if (bi != (cumBucketSize[satur[nb]] - 1)) {\n                    buckets[bi] = buckets[cumBucketSize[satur[nb]] - 1];\n                    buckets[cumBucketSize[satur[nb]] - 1] = nb;\n                    bucketIndex[nb] = cumBucketSize[satur[nb]] - 1;\n                    bucketIndex[buckets[bi]] = bi;\n                }\n                cumBucketSize[satur[nb]]--;\n                satur[nb]++;\n                if (cumBucketSize[satur[nb]] == 0) {\n                    cumBucketSize[satur[nb]] = cumBucketSize[satur[nb] - 1] + 1;\n                }\n                if (satur[nb] > maxSat) {\n                    maxSat = satur[nb];\n                }\n            }\n        }\n    }\n    Collections.reverse(Arrays.asList(buckets));\n    return buckets;\n}","methodRange":"(line 110,col 5)-(line 159,col 5)","methodTokenRange":"int [] largestSaturationFirstOrder()\n    {\n        final int [] satur = new int[_neighbors.length];\n        final int [] buckets = new int[_neighbors.length];\n        final int [] cumBucketSize = new int[_neighbors.length];\n        final int [] bucketIndex = new int[_neighbors.length];\n        int index = 0;\n        int maxSat = 0;\n\n        for (int i = 0; i < _neighbors.length; i++) {\n            buckets[i] = i;\n            bucketIndex[i] = i;\n        }\n        cumBucketSize[0] = _neighbors.length;\n        while (index < _neighbors.length) {\n            while (\n                (maxSat > 0)\n                && (cumBucketSize[maxSat] == cumBucketSize[maxSat - 1]))\n            {\n                cumBucketSize[maxSat--] = 0;\n            }\n            final int v = buckets[cumBucketSize[maxSat] - 1];\n            cumBucketSize[maxSat]--;\n            satur[v] = -1;\n            index++;\n            for (int j = 0; j < _neighbors[v].length; j++) {\n                final int nb = (int) _neighbors[v][j];\n                final int bi = bucketIndex[nb];\n                if (satur[nb] >= 0) {\n                    if (bi != (cumBucketSize[satur[nb]] - 1)) {\n                        buckets[bi] = buckets[cumBucketSize[satur[nb]] - 1];\n                        buckets[cumBucketSize[satur[nb]] - 1] = nb;\n                        bucketIndex[nb] = cumBucketSize[satur[nb]] - 1;\n                        bucketIndex[buckets[bi]] = bi;\n                    }\n                    cumBucketSize[satur[nb]]--;\n                    satur[nb]++;\n                    if (cumBucketSize[satur[nb]] == 0) {\n                        cumBucketSize[satur[nb]] =\n                            cumBucketSize[satur[nb] - 1] + 1;\n                    }\n                    if (satur[nb] > maxSat) {\n                        maxSat = satur[nb];\n                    }\n                }\n            }\n        }\n        Collections.reverse(Arrays.asList(buckets));\n        return buckets;\n    }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"","methodParameters":[],"methodName":"largestSaturationFirstOrder","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.largestSaturationFirstOrder","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 116,col 21)-(line 116,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 117,col 22)-(line 117,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 119,col 22)-(line 119,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 23)-(line 123,col 23)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 126,col 27)-(line 126,col 27)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 127,col 69)-(line 127,col 69)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 129,col 43)-(line 129,col 43)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 131,col 59)-(line 131,col 59)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 133,col 25)-(line 133,col 25)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 135,col 26)-(line 135,col 26)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 138,col 34)-(line 138,col 34)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 139,col 59)-(line 139,col 59)","literalExprId":12,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 140,col 74)-(line 140,col 74)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 141,col 60)-(line 141,col 60)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 142,col 70)-(line 142,col 70)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 53)-(line 147,col 53)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 149,col 55)-(line 149,col 55)","literalExprId":17,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 149,col 60)-(line 149,col 60)","literalExprId":18,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.largestSaturationFirstOrder()"},{"methodDeclaration":"public Integer getLowerBound(Map<V, Object> optionalData)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return 0;\n}","methodRange":"(line 161,col 5)-(line 164,col 5)","methodTokenRange":"@Override public Integer getLowerBound(Map<V, Object> optionalData)\n    {\n        return 0;\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Map<V, Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Object>","parameter":"Map<V, Object> optionalData","parameterName":"optionalData"}],"methodName":"getLowerBound","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.getLowerBound","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 163,col 16)-(line 163,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.getLowerBound(java.util.Map<V, java.lang.Object>)"},{"methodDeclaration":"public Integer getUpperBound(Map<V, Object> optionalData)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    switch(_order) {\n        case BEST_ORDER:\n            return Math.min(Math.min(color(null), color(smallestDegreeLastOrder())), color(largestSaturationFirstOrder()));\n        case NATURAL_ORDER:\n            return color(null);\n        case SMALLEST_DEGREE_LAST_ORDER:\n            return color(smallestDegreeLastOrder());\n        case LARGEST_SATURATION_FIRST_ORDER:\n            return color(largestSaturationFirstOrder());\n    }\n    return _neighbors.length;\n}","methodRange":"(line 166,col 5)-(line 181,col 5)","methodTokenRange":"@Override public Integer getUpperBound(Map<V, Object> optionalData)\n    {\n        switch (_order) {\n        case BEST_ORDER:\n            return Math.min(\n                Math.min(color(null), color(smallestDegreeLastOrder())),\n                color(largestSaturationFirstOrder()));\n        case NATURAL_ORDER:\n            return color(null);\n        case SMALLEST_DEGREE_LAST_ORDER:\n            return color(smallestDegreeLastOrder());\n        case LARGEST_SATURATION_FIRST_ORDER:\n            return color(largestSaturationFirstOrder());\n        }\n        return _neighbors.length;\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Map<V, Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Object>","parameter":"Map<V, Object> optionalData","parameterName":"optionalData"}],"methodName":"getUpperBound","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.getUpperBound","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 171,col 32)-(line 171,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 174,col 26)-(line 174,col 29)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.getUpperBound(java.util.Map<V, java.lang.Object>)"},{"methodDeclaration":"public boolean isExact()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return false;\n}","methodRange":"(line 183,col 5)-(line 186,col 5)","methodTokenRange":"@Override public boolean isExact()\n    {\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"isExact","methodQualifiedSignature":"org.jgrapht.experimental.alg.color.GreedyColoring.isExact","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 185,col 16)-(line 185,col 20)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.experimental.alg.color.GreedyColoring.isExact()"}],"classJavadoc":"","className":"GreedyColoring","fields":[{"fieldRange":"(line 25,col 5)-(line 25,col 43)","fieldName":"BEST_ORDER","fieldJavadocComment":"","fieldTokenRange":"public static final int BEST_ORDER = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 25,col 42)-(line 25,col 42)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 26,col 5)-(line 26,col 46)","fieldName":"NATURAL_ORDER","fieldJavadocComment":"","fieldTokenRange":"public static final int NATURAL_ORDER = 1;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 26,col 45)-(line 26,col 45)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[1]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 27,col 5)-(line 27,col 59)","fieldName":"SMALLEST_DEGREE_LAST_ORDER","fieldJavadocComment":"","fieldTokenRange":"public static final int SMALLEST_DEGREE_LAST_ORDER = 2;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 27,col 58)-(line 27,col 58)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[2]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 28,col 5)-(line 28,col 63)","fieldName":"LARGEST_SATURATION_FIRST_ORDER","fieldJavadocComment":"","fieldTokenRange":"public static final int LARGEST_SATURATION_FIRST_ORDER = 3;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 28,col 62)-(line 28,col 62)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[3]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 30,col 5)-(line 30,col 36)","fieldName":"_order","fieldJavadocComment":"","fieldTokenRange":"private int _order = BEST_ORDER;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[BEST_ORDER]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":10,"packageName":"org.jgrapht.experimental.alg.color"},{"sourceFileName":"org.jgrapht.experimental.alg.IntArrayGraphAlgorithm","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.experimental.alg.IntArrayGraphAlgorithm.IntArrayGraphAlgorithm(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[{"variableType":"int","variableName":"numVertices","variableDeclarationExprId":1,"variableDeclarationExpr":"final int numVertices = g.vertexSet().size()","variableDeclarationExprRange":"(line 37,col 9)-(line 37,col 52)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 37,col 19)-(line 37,col 52)"},{"variableType":"V","variableName":"vertex","variableDeclarationExprId":2,"variableDeclarationExpr":"V vertex","variableDeclarationExprRange":"(line 41,col 14)-(line 41,col 21)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 41,col 16)-(line 41,col 21)"},{"variableType":"int","variableName":"i","variableDeclarationExprId":3,"variableDeclarationExpr":"int i = 0","variableDeclarationExprRange":"(line 46,col 14)-(line 46,col 22)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 46,col 18)-(line 46,col 22)"},{"variableType":"int","variableName":"nbIndex","variableDeclarationExprId":4,"variableDeclarationExpr":"int nbIndex = 0","variableDeclarationExprRange":"(line 47,col 13)-(line 47,col 27)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 47,col 17)-(line 47,col 27)"},{"variableType":"V","variableName":"vertex","variableDeclarationExprId":5,"variableDeclarationExpr":"final V vertex = _vertices.get(i)","variableDeclarationExprRange":"(line 48,col 13)-(line 48,col 45)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 48,col 21)-(line 48,col 45)"},{"variableType":"E","variableName":"e","variableDeclarationExprId":6,"variableDeclarationExpr":"E e","variableDeclarationExprRange":"(line 49,col 18)-(line 49,col 20)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 49,col 20)-(line 49,col 20)"}],"constructorRange":"(line 35,col 5)-(line 54,col 5)","constructorJavadocComment":"\n     * @param g\n     ","constructorDeclaration":"public IntArrayGraphAlgorithm(final Graph<V, E> g)","constructorBody":"{\n    final int numVertices = g.vertexSet().size();\n    _vertices = new ArrayList<V>(numVertices);\n    _neighbors = new int[numVertices][];\n    _vertexToPos = new HashMap<V, Integer>(numVertices);\n    for (V vertex : g.vertexSet()) {\n        _neighbors[_vertices.size()] = new int[g.edgesOf(vertex).size()];\n        _vertexToPos.put(vertex, _vertices.size());\n        _vertices.add(vertex);\n    }\n    for (int i = 0; i < numVertices; i++) {\n        int nbIndex = 0;\n        final V vertex = _vertices.get(i);\n        for (E e : g.edgesOf(vertex)) {\n            _neighbors[i][nbIndex++] = _vertexToPos.get(Graphs.getOppositeVertex(g, e, vertex));\n        }\n    }\n}","constructorName":"IntArrayGraphAlgorithm","constructorQualifiedName":"org.jgrapht.experimental.alg.IntArrayGraphAlgorithm.IntArrayGraphAlgorithm","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 46,col 22)-(line 46,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 47,col 27)-(line 47,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public IntArrayGraphAlgorithm(final Graph<V, E> g)\n    {\n        final int numVertices = g.vertexSet().size();\n        _vertices = new ArrayList<V>(numVertices);\n        _neighbors = new int[numVertices][];\n        _vertexToPos = new HashMap<V, Integer>(numVertices);\n        for (V vertex : g.vertexSet()) {\n            _neighbors[_vertices.size()] = new int[g.edgesOf(vertex).size()];\n            _vertexToPos.put(vertex, _vertices.size());\n            _vertices.add(vertex);\n        }\n        for (int i = 0; i < numVertices; i++) {\n            int nbIndex = 0;\n            final V vertex = _vertices.get(i);\n            for (E e : g.edgesOf(vertex)) {\n                _neighbors[i][nbIndex++] =\n                    _vertexToPos.get(Graphs.getOppositeVertex(g, e, vertex));\n            }\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * @author micha\n *\/\n","className":"IntArrayGraphAlgorithm","fields":[{"fieldRange":"(line 28,col 5)-(line 28,col 38)","fieldName":"_vertices","fieldJavadocComment":"","fieldTokenRange":"protected final List<V> _vertices;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"},{"fieldRange":"(line 29,col 5)-(line 29,col 40)","fieldName":"_neighbors","fieldJavadocComment":"","fieldTokenRange":"protected final int [][] _neighbors;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[][]"},{"fieldRange":"(line 30,col 5)-(line 30,col 49)","fieldName":"_vertexToPos","fieldJavadocComment":"","fieldTokenRange":"protected final Map<V, Integer> _vertexToPos;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"}]}],"sourceFileId":11,"packageName":"org.jgrapht.experimental.alg"},{"sourceFileName":"org.jgrapht.experimental.alg.ExactAlgorithm","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":" ResultType getResult(Map<V, Object> optionalData)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 20,col 5)-(line 20,col 54)","methodTokenRange":"ResultType getResult(Map<V, Object> optionalData);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(ResultType, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"Map<V, Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Object>","parameter":"Map<V, Object> optionalData","parameterName":"optionalData"}],"methodName":"getResult","methodQualifiedSignature":"org.jgrapht.experimental.alg.ExactAlgorithm.getResult","methodJavadoc":"","methodReturnTypeDescribed":"ResultType","methodType":"ResultType","literalExprs":[],"methodQualifiedName":"org.jgrapht.experimental.alg.ExactAlgorithm.getResult(java.util.Map<V, java.lang.Object>)"}],"classJavadoc":"","className":"ExactAlgorithm","fields":[]}],"sourceFileId":12,"packageName":"org.jgrapht.experimental.alg"},{"sourceFileName":"org.jgrapht.ListenableGraph","imports":[{"importId":1,"import":"import org.jgrapht.event.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the listener to be added.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be added.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void addGraphListener(GraphListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 60,col 5)-(line 60,col 56)","methodTokenRange":"public void addGraphListener(GraphListener<V, E> l);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds the specified graph listener to this graph, if not already present.\n     *\n     * @param l the listener to be added.\n     ","methodParameters":[{"parameterType":"GraphListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphListener<V, E>","parameter":"GraphListener<V, E> l","parameterName":"l"}],"methodName":"addGraphListener","methodQualifiedSignature":"org.jgrapht.ListenableGraph.addGraphListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified graph listener to this graph, if not already present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be added.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.ListenableGraph.addGraphListener(org.jgrapht.event.GraphListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the listener to be added.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be added.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void addVertexSetListener(VertexSetListener<V> l)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 68,col 5)-(line 68,col 61)","methodTokenRange":"public void addVertexSetListener(VertexSetListener<V> l);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds the specified vertex set listener to this graph, if not already\n     * present.\n     *\n     * @param l the listener to be added.\n     ","methodParameters":[{"parameterType":"VertexSetListener<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexSetListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexSetListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexSetListener<V>","parameter":"VertexSetListener<V> l","parameterName":"l"}],"methodName":"addVertexSetListener","methodQualifiedSignature":"org.jgrapht.ListenableGraph.addVertexSetListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified vertex set listener to this graph, if not already\npresent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be added.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.ListenableGraph.addVertexSetListener(org.jgrapht.event.VertexSetListener<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the listener to be removed.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be removed.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void removeGraphListener(GraphListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 75,col 5)-(line 75,col 59)","methodTokenRange":"public void removeGraphListener(GraphListener<V, E> l);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes the specified graph listener from this graph, if present.\n     *\n     * @param l the listener to be removed.\n     ","methodParameters":[{"parameterType":"GraphListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphListener<V, E>","parameter":"GraphListener<V, E> l","parameterName":"l"}],"methodName":"removeGraphListener","methodQualifiedSignature":"org.jgrapht.ListenableGraph.removeGraphListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the specified graph listener from this graph, if present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be removed.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.ListenableGraph.removeGraphListener(org.jgrapht.event.GraphListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the listener to be removed.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be removed.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void removeVertexSetListener(VertexSetListener<V> l)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 82,col 5)-(line 82,col 64)","methodTokenRange":"public void removeVertexSetListener(VertexSetListener<V> l);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes the specified vertex set listener from this graph, if present.\n     *\n     * @param l the listener to be removed.\n     ","methodParameters":[{"parameterType":"VertexSetListener<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexSetListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexSetListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexSetListener<V>","parameter":"VertexSetListener<V> l","parameterName":"l"}],"methodName":"removeVertexSetListener","methodQualifiedSignature":"org.jgrapht.ListenableGraph.removeVertexSetListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the specified vertex set listener from this graph, if present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the listener to be removed.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.ListenableGraph.removeVertexSetListener(org.jgrapht.event.VertexSetListener<V>)"}],"classJavadoc":"\/**\n * A graph that supports listeners on structural change events.\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n *\/\n","className":"ListenableGraph","fields":[]}],"sourceFileId":13,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.util.ModifiableInteger","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"DEPRECATED","javadocBlockTagContent":"not really deprecated, just marked so to avoid mistaken use.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='not really deprecated, just marked so to avoid mistaken use.'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"org.jgrapht.util.ModifiableInteger.ModifiableInteger()","variableDeclarationExprs":[],"constructorRange":"(line 83,col 5)-(line 85,col 5)","constructorJavadocComment":"\n     * <b>!!! DON'T USE - Use the {@link #ModifiableInteger(int)} constructor\n     * instead !!!<\/b>\n     *\n     * <p>This constructor is for the use of java.beans.XMLDecoder\n     * deserialization. The constructor is marked as 'deprecated' to indicate to\n     * the programmer against using it by mistake.<\/p>\n     *\n     * @deprecated not really deprecated, just marked so to avoid mistaken use.\n     ","constructorDeclaration":"public ModifiableInteger()","constructorBody":"{\n}","constructorName":"ModifiableInteger","constructorQualifiedName":"org.jgrapht.util.ModifiableInteger.ModifiableInteger","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"@Deprecated public ModifiableInteger()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<b>!!! DON'T USE - Use the '}, JavadocInlineTag{tagName='link', type=LINK, content=' #ModifiableInteger(int)'}, JavadocSnippet{text=' constructor\ninstead !!!<\/b>\n\n<p>This constructor is for the use of java.beans.XMLDecoder\ndeserialization. The constructor is marked as 'deprecated' to indicate to\nthe programmer against using it by mistake.<\/p>'}]}, blockTags=[JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='not really deprecated, just marked so to avoid mistaken use.'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to be represented by the <code>\nModifiableInteger<\/code> object.","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to be represented by the <code>\nModifiableInteger<\/code> object.'}]}', name=Optional[value]}"}],"constructorQualifiedSignature":"org.jgrapht.util.ModifiableInteger.ModifiableInteger(int)","variableDeclarationExprs":[],"constructorRange":"(line 94,col 5)-(line 97,col 5)","constructorJavadocComment":"\n     * Constructs a newly allocated <code>ModifiableInteger<\/code> object that\n     * represents the specified <code>int<\/code> value.\n     *\n     * @param value the value to be represented by the <code>\n     * ModifiableInteger<\/code> object.\n     ","constructorDeclaration":"public ModifiableInteger(int value)","constructorBody":"{\n    this.value = value;\n}","constructorName":"ModifiableInteger","constructorQualifiedName":"org.jgrapht.util.ModifiableInteger.ModifiableInteger","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int value","parameterName":"value"}],"literalExprs":[],"constructorTokenRange":"public ModifiableInteger(int value)\n    {\n        this.value = value;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a newly allocated <code>ModifiableInteger<\/code> object that\nrepresents the specified <code>int<\/code> value.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to be represented by the <code>\nModifiableInteger<\/code> object.'}]}', name=Optional[value]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the new value to set.","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new value to set.'}]}', name=Optional[value]}"}],"methodDeclaration":"public void setValue(int value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.value = value;\n}","methodRange":"(line 104,col 5)-(line 107,col 5)","methodTokenRange":"public void setValue(int value)\n    {\n        this.value = value;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Sets a new value for this modifiable integer.\n     *\n     * @param value the new value to set.\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int value","parameterName":"value"}],"methodName":"setValue","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.setValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets a new value for this modifiable integer.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new value to set.'}]}', name=Optional[value]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.setValue(int)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the value.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.value;\n}","methodRange":"(line 116,col 5)-(line 119,col 5)","methodTokenRange":"public int getValue()\n    {\n        return this.value;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the value of this object, similarly to {@link #intValue()}. This\n     * getter is NOT redundant. It is used for serialization by\n     * java.beans.XMLEncoder.\n     *\n     * @return the value.\n     ","methodParameters":[],"methodName":"getValue","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.getValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the value of this object, similarly to '}, JavadocInlineTag{tagName='link', type=LINK, content=' #intValue()'}, JavadocSnippet{text='. This\ngetter is NOT redundant. It is used for serialization by\njava.beans.XMLEncoder.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.getValue()"},{"javadocBlockTags":[],"methodDeclaration":"public void increment()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.value++;\n}","methodRange":"(line 124,col 5)-(line 127,col 5)","methodTokenRange":"public void increment()\n    {\n        this.value++;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds one to the value of this modifiable integer.\n     ","methodParameters":[],"methodName":"increment","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.increment","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds one to the value of this modifiable integer.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.increment()"},{"javadocBlockTags":[],"methodDeclaration":"public void decrement()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.value--;\n}","methodRange":"(line 132,col 5)-(line 135,col 5)","methodTokenRange":"public void decrement()\n    {\n        this.value--;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Subtracts one from the value of this modifiable integer.\n     ","methodParameters":[],"methodName":"decrement","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.decrement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Subtracts one from the value of this modifiable integer.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.decrement()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the <code>ModifiableInteger<\/code> to be compared.","javadocBlockTagName":"anotherInteger","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the <code>ModifiableInteger<\/code> to be compared.'}]}', name=Optional[anotherInteger]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the value <code>0<\/code> if this <code>ModifiableInteger<\/code>\nis equal to the argument <code>ModifiableInteger<\/code>; a value less\nthan <code>0<\/code> if this <code>ModifiableInteger<\/code> is numerically\nless than the argument <code>ModifiableInteger<\/code>; and a value\ngreater than <code>0<\/code> if this <code>ModifiableInteger<\/code> is\nnumerically greater than the argument <code>ModifiableInteger<\/code>\n(signed comparison).","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value <code>0<\/code> if this <code>ModifiableInteger<\/code>\nis equal to the argument <code>ModifiableInteger<\/code>; a value less\nthan <code>0<\/code> if this <code>ModifiableInteger<\/code> is numerically\nless than the argument <code>ModifiableInteger<\/code>; and a value\ngreater than <code>0<\/code> if this <code>ModifiableInteger<\/code> is\nnumerically greater than the argument <code>ModifiableInteger<\/code>\n(signed comparison).'}]}', name=Optional.empty}"}],"methodDeclaration":"public int compareTo(ModifiableInteger anotherInteger)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int thisVal = this.value;\n    int anotherVal = anotherInteger.value;\n    return (thisVal < anotherVal) ? -1 : ((thisVal == anotherVal) ? 0 : 1);\n}","methodRange":"(line 150,col 5)-(line 156,col 5)","methodTokenRange":"@Override public int compareTo(ModifiableInteger anotherInteger)\n    {\n        int thisVal = this.value;\n        int anotherVal = anotherInteger.value;\n\n        return (thisVal < anotherVal) ? -1 : ((thisVal == anotherVal) ? 0 : 1);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Compares two <code>ModifiableInteger<\/code> objects numerically.\n     *\n     * @param anotherInteger the <code>ModifiableInteger<\/code> to be compared.\n     *\n     * @return the value <code>0<\/code> if this <code>ModifiableInteger<\/code>\n     * is equal to the argument <code>ModifiableInteger<\/code>; a value less\n     * than <code>0<\/code> if this <code>ModifiableInteger<\/code> is numerically\n     * less than the argument <code>ModifiableInteger<\/code>; and a value\n     * greater than <code>0<\/code> if this <code>ModifiableInteger<\/code> is\n     * numerically greater than the argument <code>ModifiableInteger<\/code>\n     * (signed comparison).\n     ","methodParameters":[{"parameterType":"ModifiableInteger","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.ModifiableInteger, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.ModifiableInteger","parameter":"ModifiableInteger anotherInteger","parameterName":"anotherInteger"}],"methodName":"compareTo","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.compareTo","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compares two <code>ModifiableInteger<\/code> objects numerically.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the <code>ModifiableInteger<\/code> to be compared.'}]}', name=Optional[anotherInteger]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value <code>0<\/code> if this <code>ModifiableInteger<\/code>\nis equal to the argument <code>ModifiableInteger<\/code>; a value less\nthan <code>0<\/code> if this <code>ModifiableInteger<\/code> is numerically\nless than the argument <code>ModifiableInteger<\/code>; and a value\ngreater than <code>0<\/code> if this <code>ModifiableInteger<\/code> is\nnumerically greater than the argument <code>ModifiableInteger<\/code>\n(signed comparison).'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 155,col 42)-(line 155,col 42)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 155,col 73)-(line 155,col 73)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 155,col 77)-(line 155,col 77)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.compareTo(org.jgrapht.util.ModifiableInteger)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Number#doubleValue()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#doubleValue()'}]}', name=Optional.empty}"}],"methodDeclaration":"public double doubleValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.value;\n}","methodRange":"(line 161,col 5)-(line 164,col 5)","methodTokenRange":"@Override public double doubleValue()\n    {\n        return this.value;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @see Number#doubleValue()\n     ","methodParameters":[],"methodName":"doubleValue","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.doubleValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#doubleValue()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.doubleValue()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the object to compare with.","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to compare with.'}]}', name=Optional[o]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the objects are the same; <code>false<\/code>\notherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the objects are the same; <code>false<\/code>\notherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean equals(Object o)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (o instanceof ModifiableInteger) {\n        return this.value == ((ModifiableInteger) o).value;\n    }\n    return false;\n}","methodRange":"(line 177,col 5)-(line 184,col 5)","methodTokenRange":"@Override public boolean equals(Object o)\n    {\n        if (o instanceof ModifiableInteger) {\n            return this.value == ((ModifiableInteger) o).value;\n        }\n\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Compares this object to the specified object. The result is <code>\n     * true<\/code> if and only if the argument is not <code>null<\/code> and is\n     * an <code>ModifiableInteger<\/code> object that contains the same <code>\n     * int<\/code> value as this object.\n     *\n     * @param o the object to compare with.\n     *\n     * @return <code>true<\/code> if the objects are the same; <code>false<\/code>\n     * otherwise.\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"equals","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.equals","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compares this object to the specified object. The result is <code>\ntrue<\/code> if and only if the argument is not <code>null<\/code> and is\nan <code>ModifiableInteger<\/code> object that contains the same <code>\nint<\/code> value as this object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to compare with.'}]}', name=Optional[o]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the objects are the same; <code>false<\/code>\notherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 183,col 16)-(line 183,col 20)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.equals(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Number#floatValue()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#floatValue()'}]}', name=Optional.empty}"}],"methodDeclaration":"public float floatValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.value;\n}","methodRange":"(line 189,col 5)-(line 192,col 5)","methodTokenRange":"@Override public float floatValue()\n    {\n        return this.value;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='float'}","methodJavadocComment":"\n     * @see Number#floatValue()\n     ","methodParameters":[],"methodName":"floatValue","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.floatValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#floatValue()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"float","methodType":"float","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.floatValue()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash code value for this object, equal to the primitive <code>\nint<\/code> value represented by this <code>ModifiableInteger<\/code>\nobject.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash code value for this object, equal to the primitive <code>\nint<\/code> value represented by this <code>ModifiableInteger<\/code>\nobject.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.value;\n}","methodRange":"(line 201,col 5)-(line 204,col 5)","methodTokenRange":"@Override public int hashCode()\n    {\n        return this.value;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns a hash code for this <code>ModifiableInteger<\/code>.\n     *\n     * @return a hash code value for this object, equal to the primitive <code>\n     * int<\/code> value represented by this <code>ModifiableInteger<\/code>\n     * object.\n     ","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.hashCode","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a hash code for this <code>ModifiableInteger<\/code>.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash code value for this object, equal to the primitive <code>\nint<\/code> value represented by this <code>ModifiableInteger<\/code>\nobject.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.hashCode()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Number#intValue()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#intValue()'}]}', name=Optional.empty}"}],"methodDeclaration":"public int intValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.value;\n}","methodRange":"(line 209,col 5)-(line 212,col 5)","methodTokenRange":"@Override public int intValue()\n    {\n        return this.value;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see Number#intValue()\n     ","methodParameters":[],"methodName":"intValue","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.intValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#intValue()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.intValue()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Number#longValue()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#longValue()'}]}', name=Optional.empty}"}],"methodDeclaration":"public long longValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.value;\n}","methodRange":"(line 217,col 5)-(line 220,col 5)","methodTokenRange":"@Override public long longValue()\n    {\n        return this.value;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n     * @see Number#longValue()\n     ","methodParameters":[],"methodName":"longValue","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.longValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Number#longValue()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.longValue()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"an <code>Integer<\/code> representation of the value of this\nobject.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an <code>Integer<\/code> representation of the value of this\nobject.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Integer toInteger()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return Integer.valueOf(this.value);\n}","methodRange":"(line 229,col 5)-(line 232,col 5)","methodTokenRange":"public Integer toInteger()\n    {\n        return Integer.valueOf(this.value);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Returns an <code>Integer<\/code> object representing this <code>\n     * ModifiableInteger<\/code>'s value.\n     *\n     * @return an <code>Integer<\/code> representation of the value of this\n     * object.\n     ","methodParameters":[],"methodName":"toInteger","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.toInteger","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an <code>Integer<\/code> object representing this <code>\nModifiableInteger<\/code>'s value.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an <code>Integer<\/code> representation of the value of this\nobject.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.toInteger()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the value of this object in\nbase&nbsp;10.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the value of this object in\nbase&nbsp;10.'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return String.valueOf(this.value);\n}","methodRange":"(line 244,col 5)-(line 247,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return String.valueOf(this.value);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Returns a <code>String<\/code> object representing this <code>\n     * ModifiableInteger<\/code>'s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if the\n     * integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return a string representation of the value of this object in\n     * base&nbsp;10.\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.util.ModifiableInteger.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a <code>String<\/code> object representing this <code>\nModifiableInteger<\/code>'s value. The value is converted to signed\ndecimal representation and returned as a string, exactly as if the\ninteger value were given as an argument to the '}, JavadocInlineTag{tagName='link', type=LINK, content='\njava.lang.Integer#toString(int)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the value of this object in\nbase&nbsp;10.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ModifiableInteger.toString()"}],"classJavadoc":"\/**\n * The <code>ModifiableInteger<\/code> class wraps a value of the primitive type\n * <code>int<\/code> in an object, similarly to {@link java.lang.Integer}. An\n * object of type <code>ModifiableInteger<\/code> contains a single field whose\n * type is <code>int<\/code>.\n *\n * <p>Unlike <code>java.lang.Integer<\/code>, the int value which the\n * ModifiableInteger represents can be modified. It becomes useful when used\n * together with the collection framework. For example, if you want to have a\n * {@link java.util.List} of counters. You could use <code>Integer<\/code> but\n * that would have became wasteful and inefficient if you frequently had to\n * update the counters.<\/p>\n *\n * <p>WARNING: Because instances of this class are mutable, great care must be\n * exercised if used as keys of a {@link java.util.Map} or as values in a {@link\n * java.util.Set} in a manner that affects equals comparisons while the\n * instances are keys in the map (or values in the set). For more see\n * documentation of <code>Map<\/code> and <code>Set<\/code>.<\/p>\n *\n * @author Barak Naveh\n * @since May 27, 2004\n *\/\n","className":"ModifiableInteger","fields":[{"fieldRange":"(line 66,col 5)-(line 66,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3618698612851422261L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 66,col 50)-(line 66,col 69)","literalExprId":1,"literalExpr":"3618698612851422261L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3618698612851422261L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 71,col 5)-(line 71,col 21)","fieldName":"value","fieldJavadocComment":"\n     * The int value represented by this <code>ModifiableInteger<\/code>.\n     ","fieldTokenRange":"public int value;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The int value represented by this <code>ModifiableInteger<\/code>.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":14,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.FibonacciHeapNode","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"data for this node","javadocBlockTagName":"data","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='data for this node'}]}', name=Optional[data]}"}],"constructorQualifiedSignature":"org.jgrapht.util.FibonacciHeapNode.FibonacciHeapNode(T)","variableDeclarationExprs":[],"constructorRange":"(line 107,col 5)-(line 112,col 5)","constructorJavadocComment":"\n     * Default constructor. Initializes the right and left pointers, making this\n     * a circular doubly-linked list.\n     *\n     * @param data data for this node\n     ","constructorDeclaration":"public FibonacciHeapNode(T data)","constructorBody":"{\n    right = this;\n    left = this;\n    this.data = data;\n}","constructorName":"FibonacciHeapNode","constructorQualifiedName":"org.jgrapht.util.FibonacciHeapNode.FibonacciHeapNode","constructorParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T data","parameterName":"data"}],"literalExprs":[],"constructorTokenRange":"public FibonacciHeapNode(T data)\n    {\n        right = this;\n        left = this;\n        this.data = data;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Default constructor. Initializes the right and left pointers, making this\na circular doubly-linked list.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='data for this node'}]}', name=Optional[data]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the key","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the key'}]}', name=Optional.empty}"}],"methodDeclaration":"public final double getKey()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return key;\n}","methodRange":"(line 119,col 5)-(line 122,col 5)","methodTokenRange":"public final double getKey()\n    {\n        return key;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Obtain the key for this node.\n     *\n     * @return the key\n     ","methodParameters":[],"methodName":"getKey","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeapNode.getKey","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Obtain the key for this node.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the key'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.FibonacciHeapNode.getKey()"},{"javadocBlockTags":[],"methodDeclaration":"public final T getData()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return data;\n}","methodRange":"(line 127,col 5)-(line 130,col 5)","methodTokenRange":"public final T getData()\n    {\n        return data;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","methodJavadocComment":"\n     * Obtain the data for this node.\n     ","methodParameters":[],"methodName":"getData","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeapNode.getData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Obtain the data for this node.'}]}, blockTags=[]}","methodReturnTypeDescribed":"T","methodType":"T","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.FibonacciHeapNode.getData()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"string representing this object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='string representing this object'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return Double.toString(key);\n}","methodRange":"(line 137,col 5)-(line 140,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return Double.toString(key);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Return the string representation of this object.\n     *\n     * @return string representing this object\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeapNode.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the string representation of this object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='string representing this object'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.FibonacciHeapNode.toString()"}],"classJavadoc":"\/**\n * Implements a node of the Fibonacci heap. It holds the information necessary\n * for maintaining the structure of the heap. It also holds the reference to the\n * key value (which is used to determine the heap structure).\n *\n * @author Nathan Fiedler\n *\/\n","className":"FibonacciHeapNode","fields":[{"fieldRange":"(line 63,col 5)-(line 63,col 11)","fieldName":"data","fieldJavadocComment":"\n     * Node data.\n     ","fieldTokenRange":"T data;","fieldTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"T","fieldJavadoc":"Node data.\n","fieldTypeResolvedDescribed":"T"},{"fieldRange":"(line 68,col 5)-(line 68,col 31)","fieldName":"child","fieldJavadocComment":"\n     * first child node\n     ","fieldTokenRange":"FibonacciHeapNode<T> child;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"FibonacciHeapNode<T>","fieldJavadoc":"first child node\n","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>"},{"fieldRange":"(line 73,col 5)-(line 73,col 30)","fieldName":"left","fieldJavadocComment":"\n     * left sibling node\n     ","fieldTokenRange":"FibonacciHeapNode<T> left;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"FibonacciHeapNode<T>","fieldJavadoc":"left sibling node\n","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>"},{"fieldRange":"(line 78,col 5)-(line 78,col 32)","fieldName":"parent","fieldJavadocComment":"\n     * parent node\n     ","fieldTokenRange":"FibonacciHeapNode<T> parent;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"FibonacciHeapNode<T>","fieldJavadoc":"parent node\n","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>"},{"fieldRange":"(line 83,col 5)-(line 83,col 31)","fieldName":"right","fieldJavadocComment":"\n     * right sibling node\n     ","fieldTokenRange":"FibonacciHeapNode<T> right;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"FibonacciHeapNode<T>","fieldJavadoc":"right sibling node\n","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>"},{"fieldRange":"(line 89,col 5)-(line 89,col 17)","fieldName":"mark","fieldJavadocComment":"\n     * true if this node has had a child removed since this node was added to\n     * its parent\n     ","fieldTokenRange":"boolean mark;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"true if this node has had a child removed since this node was added to\nits parent\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 94,col 5)-(line 94,col 15)","fieldName":"key","fieldJavadocComment":"\n     * key value for this node\n     ","fieldTokenRange":"double key;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"key value for this node\n","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 99,col 5)-(line 99,col 15)","fieldName":"degree","fieldJavadocComment":"\n     * number of children of this node (does not count grandchildren)\n     ","fieldTokenRange":"int degree;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"number of children of this node (does not count grandchildren)\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":15,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.WeightCombiner","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first weight","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first weight'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second weight","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second weight'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"result of the operator","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='result of the operator'}]}', name=Optional.empty}"}],"methodDeclaration":" double combine(double a, double b)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 117,col 5)-(line 117,col 39)","methodTokenRange":"double combine(double a, double b);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Combines two weights.\n     *\n     * @param a first weight\n     * @param b second weight\n     *\n     * @return result of the operator\n     ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double a","parameterName":"a"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double b","parameterName":"b"}],"methodName":"combine","methodQualifiedSignature":"org.jgrapht.util.WeightCombiner.combine","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Combines two weights.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first weight'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second weight'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='result of the operator'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.WeightCombiner.combine(double, double)"}],"classJavadoc":"\/**\n * Binary operator for edge weights. There are some prewritten operators.\n *\/\n","className":"WeightCombiner","fields":[{"fieldRange":"(line 46,col 5)-(line 52,col 10)","fieldName":"SUM","fieldJavadocComment":"\n     * Sum of weights.\n     ","fieldTokenRange":"public WeightCombiner SUM =\n        new WeightCombiner() {\n            @Override public double combine(double a, double b)\n            {\n                return a + b;\n            }\n        };","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new WeightCombiner() {\n\n    @Override\n    public double combine(double a, double b) {\n        return a + b;\n    }\n}]","fieldType":"WeightCombiner","fieldJavadoc":"Sum of weights.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"},{"fieldRange":"(line 57,col 5)-(line 63,col 10)","fieldName":"MULT","fieldJavadocComment":"\n     * Multiplication of weights.\n     ","fieldTokenRange":"public WeightCombiner MULT =\n        new WeightCombiner() {\n            @Override public double combine(double a, double b)\n            {\n                return a * b;\n            }\n        };","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new WeightCombiner() {\n\n    @Override\n    public double combine(double a, double b) {\n        return a * b;\n    }\n}]","fieldType":"WeightCombiner","fieldJavadoc":"Multiplication of weights.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"},{"fieldRange":"(line 68,col 5)-(line 74,col 10)","fieldName":"MIN","fieldJavadocComment":"\n     * Minimum weight.\n     ","fieldTokenRange":"public WeightCombiner MIN =\n        new WeightCombiner() {\n            @Override public double combine(double a, double b)\n            {\n                return Math.min(a, b);\n            }\n        };","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new WeightCombiner() {\n\n    @Override\n    public double combine(double a, double b) {\n        return Math.min(a, b);\n    }\n}]","fieldType":"WeightCombiner","fieldJavadoc":"Minimum weight.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"},{"fieldRange":"(line 79,col 5)-(line 85,col 10)","fieldName":"MAX","fieldJavadocComment":"\n     * Maximum weight.\n     ","fieldTokenRange":"public WeightCombiner MAX =\n        new WeightCombiner() {\n            @Override public double combine(double a, double b)\n            {\n                return Math.max(a, b);\n            }\n        };","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new WeightCombiner() {\n\n    @Override\n    public double combine(double a, double b) {\n        return Math.max(a, b);\n    }\n}]","fieldType":"WeightCombiner","fieldJavadoc":"Maximum weight.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"},{"fieldRange":"(line 90,col 5)-(line 96,col 10)","fieldName":"FIRST","fieldJavadocComment":"\n     * First weight.\n     ","fieldTokenRange":"public WeightCombiner FIRST =\n        new WeightCombiner() {\n            @Override public double combine(double a, double b)\n            {\n                return a;\n            }\n        };","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new WeightCombiner() {\n\n    @Override\n    public double combine(double a, double b) {\n        return a;\n    }\n}]","fieldType":"WeightCombiner","fieldJavadoc":"First weight.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"},{"fieldRange":"(line 101,col 5)-(line 107,col 10)","fieldName":"SECOND","fieldJavadocComment":"\n     * Second weight.\n     ","fieldTokenRange":"public WeightCombiner SECOND =\n        new WeightCombiner() {\n            @Override public double combine(double a, double b)\n            {\n                return b;\n            }\n        };","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new WeightCombiner() {\n\n    @Override\n    public double combine(double a, double b) {\n        return b;\n    }\n}]","fieldType":"WeightCombiner","fieldJavadoc":"Second weight.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"}]}],"sourceFileId":16,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.FibonacciHeap","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.util.FibonacciHeap.FibonacciHeap()","variableDeclarationExprs":[],"constructorRange":"(line 94,col 5)-(line 96,col 5)","constructorJavadocComment":"\n     * Constructs a FibonacciHeap object that contains no elements.\n     ","constructorDeclaration":"public FibonacciHeap()","constructorBody":"{\n}","constructorName":"FibonacciHeap","constructorQualifiedName":"org.jgrapht.util.FibonacciHeap.FibonacciHeap","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public FibonacciHeap()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a FibonacciHeap object that contains no elements.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the heap is empty, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the heap is empty, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isEmpty()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return minNode == null;\n}","methodRange":"(line 106,col 5)-(line 109,col 5)","methodTokenRange":"public boolean isEmpty()\n    {\n        return minNode == null;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Tests if the Fibonacci heap is empty or not. Returns true if the heap is\n     * empty, false otherwise.\n     *\n     * <p>Running time: O(1) actual<\/p>\n     *\n     * @return true if the heap is empty, false otherwise\n     ","methodParameters":[],"methodName":"isEmpty","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.isEmpty","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests if the Fibonacci heap is empty or not. Returns true if the heap is\nempty, false otherwise.\n\n<p>Running time: O(1) actual<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the heap is empty, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 108,col 27)-(line 108,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.isEmpty()"},{"javadocBlockTags":[],"methodDeclaration":"public void clear()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    minNode = null;\n    nNodes = 0;\n}","methodRange":"(line 116,col 5)-(line 120,col 5)","methodTokenRange":"public void clear()\n    {\n        minNode = null;\n        nNodes = 0;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes all elements from this heap.\n     ","methodParameters":[],"methodName":"clear","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.clear","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all elements from this heap.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 118,col 19)-(line 118,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 119,col 18)-(line 119,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.clear()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"node to decrease the key of","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to decrease the key of'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"new key value for node x","javadocBlockTagName":"k","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new key value for node x'}]}', name=Optional[k]}"},{"javadocBlockType":"EXCEPTION","javadocBlockTagContent":"Thrown if k is larger than x.key\nvalue.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=EXCEPTION, content='JavadocDescription{elements=[JavadocSnippet{text='Thrown if k is larger than x.key\nvalue.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":"public void decreaseKey(FibonacciHeapNode<T> x, double k)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (k > x.key) {\n        throw new IllegalArgumentException(\"decreaseKey() got larger key value. Current key: \" + x.key + \" new key: \" + k);\n    }\n    x.key = k;\n    FibonacciHeapNode<T> y = x.parent;\n    if ((y != null) && (x.key < y.key)) {\n        cut(x, y);\n        cascadingCut(y);\n    }\n    if (x.key < minNode.key) {\n        minNode = x;\n    }\n}","methodRange":"(line 136,col 5)-(line 156,col 5)","methodTokenRange":"public void decreaseKey(FibonacciHeapNode<T> x, double k)\n    {\n        if (k > x.key) {\n            throw new IllegalArgumentException(\n                \"decreaseKey() got larger key value. Current key: \" + x.key\n                + \" new key: \" + k);\n        }\n\n        x.key = k;\n\n        FibonacciHeapNode<T> y = x.parent;\n\n        if ((y != null) && (x.key < y.key)) {\n            cut(x, y);\n            cascadingCut(y);\n        }\n\n        if (x.key < minNode.key) {\n            minNode = x;\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Decreases the key value for a heap node, given the new value to take on.\n     * The structure of the heap may be changed and will not be consolidated.\n     *\n     * <p>Running time: O(1) amortized<\/p>\n     *\n     * @param x node to decrease the key of\n     * @param k new key value for node x\n     *\n     * @exception IllegalArgumentException Thrown if k is larger than x.key\n     * value.\n     ","methodParameters":[{"parameterType":"FibonacciHeapNode<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> x","parameterName":"x"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double k","parameterName":"k"}],"methodName":"decreaseKey","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.decreaseKey","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Decreases the key value for a heap node, given the new value to take on.\nThe structure of the heap may be changed and will not be consolidated.\n\n<p>Running time: O(1) amortized<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to decrease the key of'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new key value for node x'}]}', name=Optional[k]}, JavadocBlockTag{type=EXCEPTION, content='JavadocDescription{elements=[JavadocSnippet{text='Thrown if k is larger than x.key\nvalue.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 140,col 17)-(line 140,col 67)","literalExprId":1,"literalExpr":"\"decreaseKey() got larger key value. Current key: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 141,col 19)-(line 141,col 30)","literalExprId":2,"literalExpr":"\" new key: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 148,col 19)-(line 148,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.decreaseKey(org.jgrapht.util.FibonacciHeapNode<T>, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"node to remove from heap","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to remove from heap'}]}', name=Optional[x]}"}],"methodDeclaration":"public void delete(FibonacciHeapNode<T> x)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    decreaseKey(x, Double.NEGATIVE_INFINITY);\n    removeMin();\n}","methodRange":"(line 170,col 5)-(line 177,col 5)","methodTokenRange":"public void delete(FibonacciHeapNode<T> x)\n    {\n        \/\/ make x as small as possible\n        decreaseKey(x, Double.NEGATIVE_INFINITY);\n\n        \/\/ remove the smallest, which decreases n also\n        removeMin();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Deletes a node from the heap given the reference to the node. The trees\n     * in the heap will be consolidated, if necessary. This operation may fail\n     * to remove the correct element if there are nodes with key value\n     * -Infinity.\n     *\n     * <p>Running time: O(log n) amortized<\/p>\n     *\n     * @param x node to remove from heap\n     ","methodParameters":[{"parameterType":"FibonacciHeapNode<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> x","parameterName":"x"}],"methodName":"delete","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.delete","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes a node from the heap given the reference to the node. The trees\nin the heap will be consolidated, if necessary. This operation may fail\nto remove the correct element if there are nodes with key value\n-Infinity.\n\n<p>Running time: O(log n) amortized<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to remove from heap'}]}', name=Optional[x]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.delete(org.jgrapht.util.FibonacciHeapNode<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"new node to insert into heap","javadocBlockTagName":"node","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new node to insert into heap'}]}', name=Optional[node]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"key value associated with data object","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='key value associated with data object'}]}', name=Optional[key]}"}],"methodDeclaration":"public void insert(FibonacciHeapNode<T> node, double key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    node.key = key;\n    if (minNode != null) {\n        node.left = minNode;\n        node.right = minNode.right;\n        minNode.right = node;\n        node.right.left = node;\n        if (key < minNode.key) {\n            minNode = node;\n        }\n    } else {\n        minNode = node;\n    }\n    nNodes++;\n}","methodRange":"(line 191,col 5)-(line 210,col 5)","methodTokenRange":"public void insert(FibonacciHeapNode<T> node, double key)\n    {\n        node.key = key;\n\n        \/\/ concatenate node into min list\n        if (minNode != null) {\n            node.left = minNode;\n            node.right = minNode.right;\n            minNode.right = node;\n            node.right.left = node;\n\n            if (key < minNode.key) {\n                minNode = node;\n            }\n        } else {\n            minNode = node;\n        }\n\n        nNodes++;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Inserts a new data element into the heap. No heap consolidation is\n     * performed at this time, the new node is simply inserted into the root\n     * list of this heap.\n     *\n     * <p>Running time: O(1) actual<\/p>\n     *\n     * @param node new node to insert into heap\n     * @param key key value associated with data object\n     ","methodParameters":[{"parameterType":"FibonacciHeapNode<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> node","parameterName":"node"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double key","parameterName":"key"}],"methodName":"insert","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.insert","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Inserts a new data element into the heap. No heap consolidation is\nperformed at this time, the new node is simply inserted into the root\nlist of this heap.\n\n<p>Running time: O(1) actual<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new node to insert into heap'}]}', name=Optional[node]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='key value associated with data object'}]}', name=Optional[key]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 196,col 24)-(line 196,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.insert(org.jgrapht.util.FibonacciHeapNode<T>, double)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"heap node with the smallest key","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='heap node with the smallest key'}]}', name=Optional.empty}"}],"methodDeclaration":"public FibonacciHeapNode<T> min()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return minNode;\n}","methodRange":"(line 222,col 5)-(line 225,col 5)","methodTokenRange":"public FibonacciHeapNode<T> min()\n    {\n        return minNode;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the smallest element in the heap. This smallest element is the\n     * one with the minimum key value.\n     *\n     * <p>Running time: O(1) actual<\/p>\n     *\n     * @return heap node with the smallest key\n     ","methodParameters":[],"methodName":"min","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the smallest element in the heap. This smallest element is the\none with the minimum key value.\n\n<p>Running time: O(1) actual<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='heap node with the smallest key'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"FibonacciHeapNode<T>","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.min()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"node with the smallest key","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='node with the smallest key'}]}', name=Optional.empty}"}],"methodDeclaration":"public FibonacciHeapNode<T> removeMin()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FibonacciHeapNode<T> z = minNode;\n    if (z != null) {\n        int numKids = z.degree;\n        FibonacciHeapNode<T> x = z.child;\n        FibonacciHeapNode<T> tempRight;\n        while (numKids > 0) {\n            tempRight = x.right;\n            x.left.right = x.right;\n            x.right.left = x.left;\n            x.left = minNode;\n            x.right = minNode.right;\n            minNode.right = x;\n            x.right.left = x;\n            x.parent = null;\n            x = tempRight;\n            numKids--;\n        }\n        z.left.right = z.right;\n        z.right.left = z.left;\n        if (z == z.right) {\n            minNode = null;\n        } else {\n            minNode = z.right;\n            consolidate();\n        }\n        nNodes--;\n    }\n    return z;\n}","methodRange":"(line 237,col 5)-(line 282,col 5)","methodTokenRange":"public FibonacciHeapNode<T> removeMin()\n    {\n        FibonacciHeapNode<T> z = minNode;\n\n        if (z != null) {\n            int numKids = z.degree;\n            FibonacciHeapNode<T> x = z.child;\n            FibonacciHeapNode<T> tempRight;\n\n            \/\/ for each child of z do...\n            while (numKids > 0) {\n                tempRight = x.right;\n\n                \/\/ remove x from child list\n                x.left.right = x.right;\n                x.right.left = x.left;\n\n                \/\/ add x to root list of heap\n                x.left = minNode;\n                x.right = minNode.right;\n                minNode.right = x;\n                x.right.left = x;\n\n                \/\/ set parent[x] to null\n                x.parent = null;\n                x = tempRight;\n                numKids--;\n            }\n\n            \/\/ remove z from root list of heap\n            z.left.right = z.right;\n            z.right.left = z.left;\n\n            if (z == z.right) {\n                minNode = null;\n            } else {\n                minNode = z.right;\n                consolidate();\n            }\n\n            \/\/ decrement size of heap\n            nNodes--;\n        }\n\n        return z;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Removes the smallest element from the heap. This will cause the trees in\n     * the heap to be consolidated, if necessary.\n     *\n     * <p>Running time: O(log n) amortized<\/p>\n     *\n     * @return node with the smallest key\n     ","methodParameters":[],"methodName":"removeMin","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.removeMin","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the smallest element from the heap. This will cause the trees in\nthe heap to be consolidated, if necessary.\n\n<p>Running time: O(log n) amortized<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='node with the smallest key'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"FibonacciHeapNode<T>","literalExprs":[{"literalExprRange":"(line 241,col 18)-(line 241,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 247,col 30)-(line 247,col 30)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 261,col 28)-(line 261,col 31)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 271,col 27)-(line 271,col 30)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.removeMin()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of elements in the heap","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of elements in the heap'}]}', name=Optional.empty}"}],"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return nNodes;\n}","methodRange":"(line 294,col 5)-(line 297,col 5)","methodTokenRange":"public int size()\n    {\n        return nNodes;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the size of the heap which is measured in the number of elements\n     * contained in the heap.\n     *\n     * <p>Running time: O(1) actual<\/p>\n     *\n     * @return number of elements in the heap\n     ","methodParameters":[],"methodName":"size","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.size","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the size of the heap which is measured in the number of elements\ncontained in the heap.\n\n<p>Running time: O(1) actual<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of elements in the heap'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.size()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first heap","javadocBlockTagName":"h1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first heap'}]}', name=Optional[h1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second heap","javadocBlockTagName":"h2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second heap'}]}', name=Optional[h2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"new heap containing h1 and h2","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new heap containing h1 and h2'}]}', name=Optional.empty}"}],"methodDeclaration":"public static FibonacciHeap<T> union(FibonacciHeap<T> h1, FibonacciHeap<T> h2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FibonacciHeap<T> h = new FibonacciHeap<T>();\n    if ((h1 != null) && (h2 != null)) {\n        h.minNode = h1.minNode;\n        if (h.minNode != null) {\n            if (h2.minNode != null) {\n                h.minNode.right.left = h2.minNode.left;\n                h2.minNode.left.right = h.minNode.right;\n                h.minNode.right = h2.minNode;\n                h2.minNode.left = h.minNode;\n                if (h2.minNode.key < h1.minNode.key) {\n                    h.minNode = h2.minNode;\n                }\n            }\n        } else {\n            h.minNode = h2.minNode;\n        }\n        h.nNodes = h1.nNodes + h2.nNodes;\n    }\n    return h;\n}","methodRange":"(line 312,col 5)-(line 340,col 5)","methodTokenRange":"public static <T> FibonacciHeap<T> union(\n        FibonacciHeap<T> h1,\n        FibonacciHeap<T> h2)\n    {\n        FibonacciHeap<T> h = new FibonacciHeap<T>();\n\n        if ((h1 != null) && (h2 != null)) {\n            h.minNode = h1.minNode;\n\n            if (h.minNode != null) {\n                if (h2.minNode != null) {\n                    h.minNode.right.left = h2.minNode.left;\n                    h2.minNode.left.right = h.minNode.right;\n                    h.minNode.right = h2.minNode;\n                    h2.minNode.left = h.minNode;\n\n                    if (h2.minNode.key < h1.minNode.key) {\n                        h.minNode = h2.minNode;\n                    }\n                }\n            } else {\n                h.minNode = h2.minNode;\n            }\n\n            h.nNodes = h1.nNodes + h2.nNodes;\n        }\n\n        return h;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeap, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeap.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n     * Joins two Fibonacci heaps into a new one. No heap consolidation is\n     * performed at this time. The two root lists are simply joined together.\n     *\n     * <p>Running time: O(1) actual<\/p>\n     *\n     * @param h1 first heap\n     * @param h2 second heap\n     *\n     * @return new heap containing h1 and h2\n     ","methodParameters":[{"parameterType":"FibonacciHeap<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeap, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeap.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeap<T>","parameter":"FibonacciHeap<T> h1","parameterName":"h1"},{"parameterType":"FibonacciHeap<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeap, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeap.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeap<T>","parameter":"FibonacciHeap<T> h2","parameterName":"h2"}],"methodName":"union","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.union","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Joins two Fibonacci heaps into a new one. No heap consolidation is\nperformed at this time. The two root lists are simply joined together.\n\n<p>Running time: O(1) actual<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first heap'}]}', name=Optional[h1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second heap'}]}', name=Optional[h2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new heap containing h1 and h2'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.util.FibonacciHeap<T>","methodType":"FibonacciHeap<T>","literalExprs":[{"literalExprRange":"(line 318,col 20)-(line 318,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 318,col 36)-(line 318,col 39)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 321,col 30)-(line 321,col 33)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 322,col 35)-(line 322,col 38)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.union(org.jgrapht.util.FibonacciHeap<T>, org.jgrapht.util.FibonacciHeap<T>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"String of this.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='String of this.'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (minNode == null) {\n        return \"FibonacciHeap=[]\";\n    }\n    Stack<FibonacciHeapNode<T>> stack = new Stack<FibonacciHeapNode<T>>();\n    stack.push(minNode);\n    StringBuffer buf = new StringBuffer(512);\n    buf.append(\"FibonacciHeap=[\");\n    while (!stack.empty()) {\n        FibonacciHeapNode<T> curr = stack.pop();\n        buf.append(curr);\n        buf.append(\", \");\n        if (curr.child != null) {\n            stack.push(curr.child);\n        }\n        FibonacciHeapNode<T> start = curr;\n        curr = curr.right;\n        while (curr != start) {\n            buf.append(curr);\n            buf.append(\", \");\n            if (curr.child != null) {\n                stack.push(curr.child);\n            }\n            curr = curr.right;\n        }\n    }\n    buf.append(']');\n    return buf.toString();\n}","methodRange":"(line 349,col 5)-(line 390,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        if (minNode == null) {\n            return \"FibonacciHeap=[]\";\n        }\n\n        \/\/ create a new stack and put root on it\n        Stack<FibonacciHeapNode<T>> stack = new Stack<FibonacciHeapNode<T>>();\n        stack.push(minNode);\n\n        StringBuffer buf = new StringBuffer(512);\n        buf.append(\"FibonacciHeap=[\");\n\n        \/\/ do a simple breadth-first traversal on the tree\n        while (!stack.empty()) {\n            FibonacciHeapNode<T> curr = stack.pop();\n            buf.append(curr);\n            buf.append(\", \");\n\n            if (curr.child != null) {\n                stack.push(curr.child);\n            }\n\n            FibonacciHeapNode<T> start = curr;\n            curr = curr.right;\n\n            while (curr != start) {\n                buf.append(curr);\n                buf.append(\", \");\n\n                if (curr.child != null) {\n                    stack.push(curr.child);\n                }\n\n                curr = curr.right;\n            }\n        }\n\n        buf.append(']');\n\n        return buf.toString();\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Creates a String representation of this Fibonacci heap.\n     *\n     * @return String of this.\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a String representation of this Fibonacci heap.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='String of this.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 351,col 24)-(line 351,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 352,col 20)-(line 352,col 37)","literalExprId":2,"literalExpr":"\"FibonacciHeap=[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 359,col 45)-(line 359,col 47)","literalExprId":3,"literalExpr":"512","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 360,col 20)-(line 360,col 36)","literalExprId":4,"literalExpr":"\"FibonacciHeap=[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 366,col 24)-(line 366,col 27)","literalExprId":5,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 368,col 31)-(line 368,col 34)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 377,col 28)-(line 377,col 31)","literalExprId":7,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 379,col 35)-(line 379,col 38)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 387,col 20)-(line 387,col 22)","literalExprId":9,"literalExpr":"']'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.toString()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"node to perform cascading cut on","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to perform cascading cut on'}]}', name=Optional[y]}"}],"methodDeclaration":"protected void cascadingCut(FibonacciHeapNode<T> y)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    FibonacciHeapNode<T> z = y.parent;\n    if (z != null) {\n        if (!y.mark) {\n            y.mark = true;\n        } else {\n            cut(y, z);\n            cascadingCut(z);\n        }\n    }\n}","methodRange":"(line 402,col 5)-(line 419,col 5)","methodTokenRange":"protected void cascadingCut(FibonacciHeapNode<T> y)\n    {\n        FibonacciHeapNode<T> z = y.parent;\n\n        \/\/ if there's a parent...\n        if (z != null) {\n            \/\/ if y is unmarked, set it marked\n            if (!y.mark) {\n                y.mark = true;\n            } else {\n                \/\/ it's marked, cut it from parent\n                cut(y, z);\n\n                \/\/ cut its parent as well\n                cascadingCut(z);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Performs a cascading cut operation. This cuts y from its parent and then\n     * does the same for its parent, and so on up the tree.\n     *\n     * <p>Running time: O(log n); O(1) excluding the recursion<\/p>\n     *\n     * @param y node to perform cascading cut on\n     ","methodParameters":[{"parameterType":"FibonacciHeapNode<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> y","parameterName":"y"}],"methodName":"cascadingCut","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.cascadingCut","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Performs a cascading cut operation. This cuts y from its parent and then\ndoes the same for its parent, and so on up the tree.\n\n<p>Running time: O(log n); O(1) excluding the recursion<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to perform cascading cut on'}]}', name=Optional[y]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 407,col 18)-(line 407,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 410,col 26)-(line 410,col 29)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.cascadingCut(org.jgrapht.util.FibonacciHeapNode<T>)"},{"methodDeclaration":"protected void consolidate()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    int arraySize = ((int) Math.floor(Math.log(nNodes) * oneOverLogPhi)) + 1;\n    List<FibonacciHeapNode<T>> array = new ArrayList<FibonacciHeapNode<T>>(arraySize);\n    for (int i = 0; i < arraySize; i++) {\n        array.add(null);\n    }\n    int numRoots = 0;\n    FibonacciHeapNode<T> x = minNode;\n    if (x != null) {\n        numRoots++;\n        x = x.right;\n        while (x != minNode) {\n            numRoots++;\n            x = x.right;\n        }\n    }\n    while (numRoots > 0) {\n        int d = x.degree;\n        FibonacciHeapNode<T> next = x.right;\n        for (; ; ) {\n            FibonacciHeapNode<T> y = array.get(d);\n            if (y == null) {\n                break;\n            }\n            if (x.key > y.key) {\n                FibonacciHeapNode<T> temp = y;\n                y = x;\n                x = temp;\n            }\n            link(y, x);\n            array.set(d, null);\n            d++;\n        }\n        array.set(d, x);\n        x = next;\n        numRoots--;\n    }\n    minNode = null;\n    for (int i = 0; i < arraySize; i++) {\n        FibonacciHeapNode<T> y = array.get(i);\n        if (y == null) {\n            continue;\n        }\n        if (minNode != null) {\n            y.left.right = y.right;\n            y.right.left = y.left;\n            y.left = minNode;\n            y.right = minNode.right;\n            minNode.right = y;\n            y.right.left = y;\n            if (y.key < minNode.key) {\n                minNode = y;\n            }\n        } else {\n            minNode = y;\n        }\n    }\n}","methodRange":"(line 423,col 5)-(line 519,col 5)","methodTokenRange":"protected void consolidate()\n    {\n        int arraySize =\n            ((int) Math.floor(Math.log(nNodes) * oneOverLogPhi)) + 1;\n\n        List<FibonacciHeapNode<T>> array =\n            new ArrayList<FibonacciHeapNode<T>>(arraySize);\n\n        \/\/ Initialize degree array\n        for (int i = 0; i < arraySize; i++) {\n            array.add(null);\n        }\n\n        \/\/ Find the number of root nodes.\n        int numRoots = 0;\n        FibonacciHeapNode<T> x = minNode;\n\n        if (x != null) {\n            numRoots++;\n            x = x.right;\n\n            while (x != minNode) {\n                numRoots++;\n                x = x.right;\n            }\n        }\n\n        \/\/ For each node in root list do...\n        while (numRoots > 0) {\n            \/\/ Access this node's degree..\n            int d = x.degree;\n            FibonacciHeapNode<T> next = x.right;\n\n            \/\/ ..and see if there's another of the same degree.\n            for (;;) {\n                FibonacciHeapNode<T> y = array.get(d);\n                if (y == null) {\n                    \/\/ Nope.\n                    break;\n                }\n\n                \/\/ There is, make one of the nodes a child of the other.\n                \/\/ Do this based on the key value.\n                if (x.key > y.key) {\n                    FibonacciHeapNode<T> temp = y;\n                    y = x;\n                    x = temp;\n                }\n\n                \/\/ FibonacciHeapNode<T> y disappears from root list.\n                link(y, x);\n\n                \/\/ We've handled this degree, go to next one.\n                array.set(d, null);\n                d++;\n            }\n\n            \/\/ Save this node for later when we might encounter another\n            \/\/ of the same degree.\n            array.set(d, x);\n\n            \/\/ Move forward through list.\n            x = next;\n            numRoots--;\n        }\n\n        \/\/ Set min to null (effectively losing the root list) and\n        \/\/ reconstruct the root list from the array entries in array[].\n        minNode = null;\n\n        for (int i = 0; i < arraySize; i++) {\n            FibonacciHeapNode<T> y = array.get(i);\n            if (y == null) {\n                continue;\n            }\n\n            \/\/ We've got a live one, add it to root list.\n            if (minNode != null) {\n                \/\/ First remove node from root list.\n                y.left.right = y.right;\n                y.right.left = y.left;\n\n                \/\/ Now add to root list, again.\n                y.left = minNode;\n                y.right = minNode.right;\n                minNode.right = y;\n                y.right.left = y;\n\n                \/\/ Check if this is a new min.\n                if (y.key < minNode.key) {\n                    minNode = y;\n                }\n            } else {\n                minNode = y;\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"consolidate","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.consolidate","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 426,col 68)-(line 426,col 68)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 22)-(line 432,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 23)-(line 433,col 26)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 437,col 24)-(line 437,col 24)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 440,col 18)-(line 440,col 21)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 451,col 27)-(line 451,col 27)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 459,col 26)-(line 459,col 29)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 476,col 30)-(line 476,col 33)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 491,col 19)-(line 491,col 22)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 493,col 22)-(line 493,col 22)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 495,col 22)-(line 495,col 25)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 500,col 28)-(line 500,col 31)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.consolidate()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"child of y to be removed from y's child list","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='child of y to be removed from y's child list'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"parent of x about to lose a child","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='parent of x about to lose a child'}]}', name=Optional[y]}"}],"methodDeclaration":"protected void cut(FibonacciHeapNode<T> x, FibonacciHeapNode<T> y)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    x.left.right = x.right;\n    x.right.left = x.left;\n    y.degree--;\n    if (y.child == x) {\n        y.child = x.right;\n    }\n    if (y.degree == 0) {\n        y.child = null;\n    }\n    x.left = minNode;\n    x.right = minNode.right;\n    minNode.right = x;\n    x.right.left = x;\n    x.parent = null;\n    x.mark = false;\n}","methodRange":"(line 532,col 5)-(line 559,col 5)","methodTokenRange":"protected void cut(FibonacciHeapNode<T> x, FibonacciHeapNode<T> y)\n    {\n        \/\/ remove x from childlist of y and decrement degree[y]\n        x.left.right = x.right;\n        x.right.left = x.left;\n        y.degree--;\n\n        \/\/ reset y.child if necessary\n        if (y.child == x) {\n            y.child = x.right;\n        }\n\n        if (y.degree == 0) {\n            y.child = null;\n        }\n\n        \/\/ add x to root list of heap\n        x.left = minNode;\n        x.right = minNode.right;\n        minNode.right = x;\n        x.right.left = x;\n\n        \/\/ set parent[x] to nil\n        x.parent = null;\n\n        \/\/ set mark[x] to false\n        x.mark = false;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * The reverse of the link operation: removes x from the child list of y.\n     * This method assumes that min is non-null.\n     *\n     * <p>Running time: O(1)<\/p>\n     *\n     * @param x child of y to be removed from y's child list\n     * @param y parent of x about to lose a child\n     ","methodParameters":[{"parameterType":"FibonacciHeapNode<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> x","parameterName":"x"},{"parameterType":"FibonacciHeapNode<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> y","parameterName":"y"}],"methodName":"cut","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.cut","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The reverse of the link operation: removes x from the child list of y.\nThis method assumes that min is non-null.\n\n<p>Running time: O(1)<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='child of y to be removed from y's child list'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='parent of x about to lose a child'}]}', name=Optional[y]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 544,col 25)-(line 544,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 545,col 23)-(line 545,col 26)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 555,col 20)-(line 555,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 558,col 18)-(line 558,col 22)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.cut(org.jgrapht.util.FibonacciHeapNode<T>, org.jgrapht.util.FibonacciHeapNode<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"node to become child","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to become child'}]}', name=Optional[y]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"node to become parent","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to become parent'}]}', name=Optional[x]}"}],"methodDeclaration":"protected void link(FibonacciHeapNode<T> y, FibonacciHeapNode<T> x)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    y.left.right = y.right;\n    y.right.left = y.left;\n    y.parent = x;\n    if (x.child == null) {\n        x.child = y;\n        y.right = y;\n        y.left = y;\n    } else {\n        y.left = x.child;\n        y.right = x.child.right;\n        x.child.right = y;\n        y.right.left = y;\n    }\n    x.degree++;\n    y.mark = false;\n}","methodRange":"(line 571,col 5)-(line 596,col 5)","methodTokenRange":"protected void link(FibonacciHeapNode<T> y, FibonacciHeapNode<T> x)\n    {\n        \/\/ remove y from root list of heap\n        y.left.right = y.right;\n        y.right.left = y.left;\n\n        \/\/ make y a child of x\n        y.parent = x;\n\n        if (x.child == null) {\n            x.child = y;\n            y.right = y;\n            y.left = y;\n        } else {\n            y.left = x.child;\n            y.right = x.child.right;\n            x.child.right = y;\n            y.right.left = y;\n        }\n\n        \/\/ increase degree[x]\n        x.degree++;\n\n        \/\/ set mark[y] false\n        y.mark = false;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Make node y a child of node x.\n     *\n     * <p>Running time: O(1) actual<\/p>\n     *\n     * @param y node to become child\n     * @param x node to become parent\n     ","methodParameters":[{"parameterType":"FibonacciHeapNode<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> y","parameterName":"y"},{"parameterType":"FibonacciHeapNode<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>","parameter":"FibonacciHeapNode<T> x","parameterName":"x"}],"methodName":"link","methodQualifiedSignature":"org.jgrapht.util.FibonacciHeap.link","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Make node y a child of node x.\n\n<p>Running time: O(1) actual<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to become child'}]}', name=Optional[y]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node to become parent'}]}', name=Optional[x]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 580,col 24)-(line 580,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 595,col 18)-(line 595,col 22)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.FibonacciHeap.link(org.jgrapht.util.FibonacciHeapNode<T>, org.jgrapht.util.FibonacciHeapNode<T>)"}],"classJavadoc":"\/**\n * This class implements a Fibonacci heap data structure. Much of the code in\n * this class is based on the algorithms in the \"Introduction to Algorithms\"by\n * Cormen, Leiserson, and Rivest in Chapter 21. The amortized running time of\n * most of these methods is O(1), making it a very fast data structure. Several\n * have an actual running time of O(1). removeMin() and delete() have O(log n)\n * amortized running times because they do the heap consolidation. If you\n * attempt to store nodes in this heap with key values of -Infinity\n * (Double.NEGATIVE_INFINITY) the <code>delete()<\/code> operation may fail to\n * remove the correct element.\n *\n * <p><b>Note that this implementation is not synchronized.<\/b> If multiple\n * threads access a set concurrently, and at least one of the threads modifies\n * the set, it <i>must<\/i> be synchronized externally. This is typically\n * accomplished by synchronizing on some object that naturally encapsulates the\n * set.<\/p>\n *\n * <p>This class was originally developed by Nathan Fiedler for the GraphMaker\n * project. It was imported to JGraphT with permission, courtesy of Nathan\n * Fiedler.<\/p>\n *\n * @author Nathan Fiedler\n *\/\n","className":"FibonacciHeap","fields":[{"fieldRange":"(line 78,col 5)-(line 79,col 53)","fieldName":"oneOverLogPhi","fieldJavadocComment":"","fieldTokenRange":"private static final double oneOverLogPhi =\n        1.0 \/ Math.log((1.0 + Math.sqrt(5.0)) \/ 2.0);","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 79,col 9)-(line 79,col 11)","literalExprId":1,"literalExpr":"1.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 79,col 25)-(line 79,col 27)","literalExprId":2,"literalExpr":"1.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 79,col 41)-(line 79,col 43)","literalExprId":3,"literalExpr":"5.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 79,col 49)-(line 79,col 51)","literalExprId":4,"literalExpr":"2.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[1.0 \/ Math.log((1.0 + Math.sqrt(5.0)) \/ 2.0)]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 84,col 5)-(line 84,col 41)","fieldName":"minNode","fieldJavadocComment":"\n     * Points to the minimum node in the heap.\n     ","fieldTokenRange":"private FibonacciHeapNode<T> minNode;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"FibonacciHeapNode<T>","fieldJavadoc":"Points to the minimum node in the heap.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<T>"},{"fieldRange":"(line 89,col 5)-(line 89,col 23)","fieldName":"nNodes","fieldJavadocComment":"\n     * Number of nodes in the heap.\n     ","fieldTokenRange":"private int nNodes;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of nodes in the heap.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":17,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.TypeUtil","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"object to be cast","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object to be cast'}]}', name=Optional[o]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"conveys the target type information; the actual value is\nunused and can be null since this is all just stupid compiler tricks","javadocBlockTagName":"typeDecl","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='conveys the target type information; the actual value is\nunused and can be null since this is all just stupid compiler tricks'}]}', name=Optional[typeDecl]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the result of the cast","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the result of the cast'}]}', name=Optional.empty}"}],"methodDeclaration":"public static T uncheckedCast(Object o, TypeUtil<T> typeDecl)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (T) o;\n}","methodRange":"(line 55,col 5)-(line 59,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    public static <T> T uncheckedCast(Object o, TypeUtil<T> typeDecl)\n    {\n        return (T) o;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","methodJavadocComment":"\n     * Casts an object to a type.\n     *\n     * @param o object to be cast\n     * @param typeDecl conveys the target type information; the actual value is\n     * unused and can be null since this is all just stupid compiler tricks\n     *\n     * @return the result of the cast\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"},{"parameterType":"TypeUtil<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.TypeUtil, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.TypeUtil.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.TypeUtil<T>","parameter":"TypeUtil<T> typeDecl","parameterName":"typeDecl"}],"methodName":"uncheckedCast","methodQualifiedSignature":"org.jgrapht.util.TypeUtil.uncheckedCast","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Casts an object to a type.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object to be cast'}]}', name=Optional[o]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='conveys the target type information; the actual value is\nunused and can be null since this is all just stupid compiler tricks'}]}', name=Optional[typeDecl]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the result of the cast'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T","methodType":"T","literalExprs":[{"literalExprRange":"(line 55,col 23)-(line 55,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.TypeUtil.uncheckedCast(java.lang.Object, org.jgrapht.util.TypeUtil<T>)"}],"classJavadoc":"\/**\n * TypeUtil isolates type-unsafety so that code which uses it for legitimate\n * reasons can stay warning-free.\n *\n * @author John V. Sichi\n *\/\n","className":"TypeUtil","fields":[]}],"sourceFileId":18,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.ArrayUnenforcedSet","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"ArrayUnenforcedSet","constructorQualifiedName":"org.jgrapht.util.ArrayUnenforcedSet.ArrayUnenforcedSet","constructorQualifiedSignature":"org.jgrapht.util.ArrayUnenforcedSet.ArrayUnenforcedSet()","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public ArrayUnenforcedSet()\n    {\n        super();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 58,col 5)-(line 61,col 5)","constructorJavadocComment":"","constructorDeclaration":"public ArrayUnenforcedSet()","constructorBody":"{\n    super();\n}","constructorJavadoc":""},{"constructorName":"ArrayUnenforcedSet","constructorQualifiedName":"org.jgrapht.util.ArrayUnenforcedSet.ArrayUnenforcedSet","constructorQualifiedSignature":"org.jgrapht.util.ArrayUnenforcedSet.ArrayUnenforcedSet(java.util.Collection<? extends E>)","constructorParameters":[{"parameterType":"Collection<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> c","parameterName":"c"}],"literalExprs":[],"constructorTokenRange":"public ArrayUnenforcedSet(Collection<? extends E> c)\n    {\n        super(c);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 66,col 5)","constructorJavadocComment":"","constructorDeclaration":"public ArrayUnenforcedSet(Collection<? extends E> c)","constructorBody":"{\n    super(c);\n}","constructorJavadoc":""},{"constructorName":"ArrayUnenforcedSet","constructorQualifiedName":"org.jgrapht.util.ArrayUnenforcedSet.ArrayUnenforcedSet","constructorQualifiedSignature":"org.jgrapht.util.ArrayUnenforcedSet.ArrayUnenforcedSet(int)","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int n","parameterName":"n"}],"literalExprs":[],"constructorTokenRange":"public ArrayUnenforcedSet(int n)\n    {\n        super(n);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 68,col 5)-(line 71,col 5)","constructorJavadocComment":"","constructorDeclaration":"public ArrayUnenforcedSet(int n)","constructorBody":"{\n    super(n);\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 86,col 5)-(line 98,col 5)","classOrInterfaceTokenRange":"private class SetForEquality\n        extends AbstractSet<E>\n    {\n        @Override public Iterator<E> iterator()\n        {\n            return ArrayUnenforcedSet.this.iterator();\n        }\n\n        @Override public int size()\n        {\n            return ArrayUnenforcedSet.this.size();\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Multiple inheritance helper.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Multiple inheritance helper.'}]}, blockTags=[]}]"}],"methods":[{"methodDeclaration":"public boolean equals(Object o)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new SetForEquality().equals(o);\n}","methodRange":"(line 73,col 5)-(line 76,col 5)","methodTokenRange":"@Override public boolean equals(Object o)\n    {\n        return new SetForEquality().equals(o);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"equals","methodQualifiedSignature":"org.jgrapht.util.ArrayUnenforcedSet.equals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ArrayUnenforcedSet.equals(java.lang.Object)"},{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new SetForEquality().hashCode();\n}","methodRange":"(line 78,col 5)-(line 81,col 5)","methodTokenRange":"@Override public int hashCode()\n    {\n        return new SetForEquality().hashCode();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"org.jgrapht.util.ArrayUnenforcedSet.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.ArrayUnenforcedSet.hashCode()"}],"classJavadoc":"\/**\n * Helper for efficiently representing small sets whose elements are known to be\n * unique by construction, implying we don't need to enforce the uniqueness\n * property in the data structure itself. Use with caution.\n *\n * <p>Note that for equals\/hashCode, the class implements the Set behavior\n * (unordered), not the list behavior (ordered); the fact that it subclasses\n * ArrayList should be considered an implementation detail.\n *\n * @author John V. Sichi\n *\/\n","className":"ArrayUnenforcedSet","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 71)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -7413250161201811238L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 51)-(line 56,col 70)","literalExprId":1,"literalExpr":"7413250161201811238L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-7413250161201811238L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":19,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.VertexPair","imports":[],"typeDeclarations":[{"constructors":[{"constructorName":"VertexPair","constructorQualifiedName":"org.jgrapht.util.VertexPair.VertexPair","constructorQualifiedSignature":"org.jgrapht.util.VertexPair.VertexPair(V, V)","constructorParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V n1","parameterName":"n1"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V n2","parameterName":"n2"}],"literalExprs":[],"constructorTokenRange":"public VertexPair(V n1, V n2)\n    {\n        this.n1 = n1;\n        this.n2 = n2;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 49,col 5)-(line 53,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VertexPair(V n1, V n2)","constructorBody":"{\n    this.n1 = n1;\n    this.n2 = n2;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public V getFirst()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return n1;\n}","methodRange":"(line 55,col 5)-(line 58,col 5)","methodTokenRange":"public V getFirst()\n    {\n        return n1;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[],"methodName":"getFirst","methodQualifiedSignature":"org.jgrapht.util.VertexPair.getFirst","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.VertexPair.getFirst()"},{"methodDeclaration":"public V getSecond()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return n2;\n}","methodRange":"(line 60,col 5)-(line 63,col 5)","methodTokenRange":"public V getSecond()\n    {\n        return n2;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[],"methodName":"getSecond","methodQualifiedSignature":"org.jgrapht.util.VertexPair.getSecond","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.VertexPair.getSecond()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The vertex in question","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The vertex in question'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if contains, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if contains, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return v.equals(n1) || v.equals(n2);\n}","methodRange":"(line 72,col 5)-(line 75,col 5)","methodTokenRange":"public boolean hasVertex(V v)\n    {\n        return v.equals(n1) || v.equals(n2);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Assess if this pair contains the vertex.\n     *\n     * @param v The vertex in question\n     *\n     * @return true if contains, false otherwise\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"hasVertex","methodQualifiedSignature":"org.jgrapht.util.VertexPair.hasVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Assess if this pair contains the vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The vertex in question'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if contains, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.VertexPair.hasVertex(V)"},{"methodDeclaration":"public V getOther(V one)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (one.equals(n1)) {\n        return n2;\n    } else if (one.equals(n2)) {\n        return n1;\n    } else {\n        return null;\n    }\n}","methodRange":"(line 77,col 5)-(line 86,col 5)","methodTokenRange":"public V getOther(V one)\n    {\n        if (one.equals(n1)) {\n            return n2;\n        } else if (one.equals(n2)) {\n            return n1;\n        } else {\n            return null;\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V one","parameterName":"one"}],"methodName":"getOther","methodQualifiedSignature":"org.jgrapht.util.VertexPair.getOther","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 84,col 20)-(line 84,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.VertexPair.getOther(V)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return n1 + \",\" + n2;\n}","methodRange":"(line 88,col 5)-(line 91,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return n1 + \",\" + n2;\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.util.VertexPair.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 90,col 21)-(line 90,col 23)","literalExprId":1,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.VertexPair.toString()"},{"methodDeclaration":"public boolean equals(Object o)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (this == o) {\n        return true;\n    }\n    if ((o == null) || (getClass() != o.getClass())) {\n        return false;\n    }\n    @SuppressWarnings(\"unchecked\")\n    VertexPair<V> that = (VertexPair<V>) o;\n    if ((n1 != null) ? (!n1.equals(that.n1)) : (that.n1 != null)) {\n        return false;\n    }\n    if ((n2 != null) ? (!n2.equals(that.n2)) : (that.n2 != null)) {\n        return false;\n    }\n    return true;\n}","methodRange":"(line 93,col 5)-(line 113,col 5)","methodTokenRange":"@Override public boolean equals(Object o)\n    {\n        if (this == o) {\n            return true;\n        }\n        if ((o == null) || (getClass() != o.getClass())) {\n            return false;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        VertexPair<V> that = (VertexPair<V>) o;\n\n        if ((n1 != null) ? (!n1.equals(that.n1)) : (that.n1 != null)) {\n            return false;\n        }\n        if ((n2 != null) ? (!n2.equals(that.n2)) : (that.n2 != null)) {\n            return false;\n        }\n\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"equals","methodQualifiedSignature":"org.jgrapht.util.VertexPair.equals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 96,col 20)-(line 96,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 98,col 19)-(line 98,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 99,col 20)-(line 99,col 24)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 102,col 27)-(line 102,col 37)","literalExprId":4,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 105,col 20)-(line 105,col 23)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 105,col 64)-(line 105,col 67)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 106,col 20)-(line 106,col 24)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 108,col 20)-(line 108,col 23)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 108,col 64)-(line 108,col 67)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 109,col 20)-(line 109,col 24)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 112,col 16)-(line 112,col 19)","literalExprId":11,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.VertexPair.equals(java.lang.Object)"},{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int result = (n1 != null) ? n1.hashCode() : 0;\n    result = (31 * result) + ((n2 != null) ? n2.hashCode() : 0);\n    return result;\n}","methodRange":"(line 115,col 5)-(line 120,col 5)","methodTokenRange":"@Override public int hashCode()\n    {\n        int result = (n1 != null) ? n1.hashCode() : 0;\n        result = (31 * result) + ((n2 != null) ? n2.hashCode() : 0);\n        return result;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"org.jgrapht.util.VertexPair.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 117,col 29)-(line 117,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 117,col 53)-(line 117,col 53)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 118,col 19)-(line 118,col 20)","literalExprId":3,"literalExpr":"31","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 118,col 42)-(line 118,col 45)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 118,col 66)-(line 118,col 66)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.VertexPair.hashCode()"}],"classJavadoc":"\/**\n * Representation of a pair of vertices; to be replaced by Pair&lt;V,V&gt; if\n * Sun ever gets around to adding Pair to java.util.\n *\n * @author Soren (soren@tanesha.net)\n *\/\n","className":"VertexPair","fields":[{"fieldRange":"(line 46,col 5)-(line 46,col 17)","fieldName":"n1","fieldJavadocComment":"","fieldTokenRange":"private V n1;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 47,col 5)-(line 47,col 17)","fieldName":"n2","fieldJavadocComment":"","fieldTokenRange":"private V n2;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":20,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.MathUtil","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public static long factorial(int N)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long multi = 1;\n    for (int i = 1; i <= N; i++) {\n        multi = multi * i;\n    }\n    return multi;\n}","methodRange":"(line 49,col 5)-(line 56,col 5)","methodTokenRange":"public static long factorial(int N)\n    {\n        long multi = 1;\n        for (int i = 1; i <= N; i++) {\n            multi = multi * i;\n        }\n        return multi;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int N","parameterName":"N"}],"methodName":"factorial","methodQualifiedSignature":"org.jgrapht.util.MathUtil.factorial","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 51,col 22)-(line 51,col 22)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 52,col 22)-(line 52,col 22)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.MathUtil.factorial(int)"}],"classJavadoc":"\/**\n * Math Utilities. Currently contains the following:\n *\n * <ol>\n * <li>factorial(int N) - caclulate the factorial of N (aka N!)<\/li>\n * <\/ol>\n *\n * @author Assaf\n * @since May 30, 2005\n *\/\n","className":"MathUtil","fields":[]}],"sourceFileId":21,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.util.PrefetchIterator","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"PrefetchIterator","constructorQualifiedName":"org.jgrapht.util.PrefetchIterator.PrefetchIterator","constructorQualifiedSignature":"org.jgrapht.util.PrefetchIterator.PrefetchIterator(org.jgrapht.util.PrefetchIterator.NextElementFunctor<E>)","constructorParameters":[{"parameterType":"NextElementFunctor<E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.PrefetchIterator.NextElementFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.PrefetchIterator.NextElementFunctor.EE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.PrefetchIterator.NextElementFunctor<E>","parameter":"NextElementFunctor<E> aEnum","parameterName":"aEnum"}],"literalExprs":[],"constructorTokenRange":"public PrefetchIterator(NextElementFunctor<E> aEnum)\n    {\n        innerEnum = aEnum;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 98,col 5)-(line 101,col 5)","constructorJavadocComment":"","constructorDeclaration":"public PrefetchIterator(NextElementFunctor<E> aEnum)","constructorBody":"{\n    innerEnum = aEnum;\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 201,col 5)-(line 209,col 5)","classOrInterfaceTokenRange":"public interface NextElementFunctor<EE>\n    {\n        \/**\n         * You must implement that NoSuchElementException is thrown on\n         * nextElement() if it is out of bound.\n         *\/\n        public EE nextElement()\n            throws NoSuchElementException;\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[],"methodDeclaration":"private E getNextElementFromInnerFunctor()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    innerFunctorUsageCounter++;\n    E result = this.innerEnum.nextElement();\n    flagIsEnumerationStartedEmpty = false;\n    return result;\n}","methodRange":"(line 107,col 5)-(line 116,col 5)","methodTokenRange":"private E getNextElementFromInnerFunctor()\n    {\n        innerFunctorUsageCounter++;\n        E result = this.innerEnum.nextElement();\n\n        \/\/ if we got here , an exception was not thrown, so at least\n        \/\/ one time a good value returned\n        flagIsEnumerationStartedEmpty = false;\n        return result;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Serves as one contact place to the functor; all must use it and not\n     * directly the NextElementFunctor.\n     ","methodParameters":[],"methodName":"getNextElementFromInnerFunctor","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.getNextElementFromInnerFunctor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Serves as one contact place to the functor; all must use it and not\ndirectly the NextElementFunctor.'}]}, blockTags=[]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 114,col 41)-(line 114,col 45)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.getNextElementFromInnerFunctor()"},{"javadocBlockTags":[],"methodDeclaration":"public E nextElement()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E result = null;\n    if (this.isGetNextLastResultUpToDate) {\n        result = this.getNextLastResult;\n    } else {\n        result = getNextElementFromInnerFunctor();\n    }\n    this.isGetNextLastResultUpToDate = false;\n    return result;\n}","methodRange":"(line 123,col 5)-(line 134,col 5)","methodTokenRange":"@Override public E nextElement()\n    {\n        E result = null;\n        if (this.isGetNextLastResultUpToDate) {\n            result = this.getNextLastResult;\n        } else {\n            result = getNextElementFromInnerFunctor();\n        }\n\n        this.isGetNextLastResultUpToDate = false;\n        return result;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * 1. Retrieves the saved value or calculates it if it does not exist 2.\n     * Changes isGetNextLastResultUpToDate to false. (Because it does not save\n     * the NEXT element now; it saves the current one!)\n     ","methodParameters":[],"methodName":"nextElement","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.nextElement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='1. Retrieves the saved value or calculates it if it does not exist 2.\nChanges isGetNextLastResultUpToDate to false. (Because it does not save\nthe NEXT element now; it saves the current one!)'}]}, blockTags=[]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 125,col 20)-(line 125,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 132,col 44)-(line 132,col 48)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.nextElement()"},{"javadocBlockTags":[],"methodDeclaration":"public boolean hasMoreElements()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (endOfEnumerationReached) {\n        return false;\n    }\n    if (isGetNextLastResultUpToDate) {\n        return true;\n    } else {\n        try {\n            this.getNextLastResult = getNextElementFromInnerFunctor();\n            this.isGetNextLastResultUpToDate = true;\n            return true;\n        } catch (NoSuchElementException noSuchE) {\n            endOfEnumerationReached = true;\n            return false;\n        }\n    }\n}","methodRange":"(line 140,col 5)-(line 158,col 5)","methodTokenRange":"@Override public boolean hasMoreElements()\n    {\n        if (endOfEnumerationReached) {\n            return false;\n        }\n\n        if (isGetNextLastResultUpToDate) {\n            return true;\n        } else {\n            try {\n                this.getNextLastResult = getNextElementFromInnerFunctor();\n                this.isGetNextLastResultUpToDate = true;\n                return true;\n            } catch (NoSuchElementException noSuchE) {\n                endOfEnumerationReached = true;\n                return false;\n            }\n        } \/\/ else\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * If (isGetNextLastResultUpToDate==true) returns true else 1. calculates\n     * getNext() and saves it 2. sets isGetNextLastResultUpToDate to true.\n     ","methodParameters":[],"methodName":"hasMoreElements","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.hasMoreElements","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='If (isGetNextLastResultUpToDate==true) returns true else 1. calculates\ngetNext() and saves it 2. sets isGetNextLastResultUpToDate to true.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 143,col 20)-(line 143,col 24)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 147,col 20)-(line 147,col 23)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 151,col 52)-(line 151,col 55)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 152,col 24)-(line 152,col 27)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 154,col 43)-(line 154,col 46)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 155,col 24)-(line 155,col 28)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.hasMoreElements()"},{"javadocBlockTags":[],"methodDeclaration":"public boolean isEnumerationStartedEmpty()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (this.innerFunctorUsageCounter == 0) {\n        if (hasMoreElements()) {\n            return false;\n        } else {\n            return true;\n        }\n    } else {\n        return flagIsEnumerationStartedEmpty;\n    }\n}","methodRange":"(line 166,col 5)-(line 180,col 5)","methodTokenRange":"public boolean isEnumerationStartedEmpty()\n    {\n        if (this.innerFunctorUsageCounter == 0) {\n            if (hasMoreElements()) {\n                return false;\n            } else {\n                return true;\n            }\n        } else \/\/ it is not the first time , so use the saved value\n               \/\/ which was initilaizeed during a call to\n               \/\/ getNextElementFromInnerFunctor\n        {\n            return flagIsEnumerationStartedEmpty;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Tests whether the enumeration started as an empty one. It does not matter\n     * if it hasMoreElements() now, only at initialization time. Efficiency: if\n     * nextElements(), hasMoreElements() were never used, it activates the\n     * hasMoreElements() once. Else it is immediately(O(1))\n     ","methodParameters":[],"methodName":"isEnumerationStartedEmpty","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.isEnumerationStartedEmpty","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests whether the enumeration started as an empty one. It does not matter\nif it hasMoreElements() now, only at initialization time. Efficiency: if\nnextElements(), hasMoreElements() were never used, it activates the\nhasMoreElements() once. Else it is immediately(O(1))'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 168,col 46)-(line 168,col 46)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 170,col 24)-(line 170,col 28)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 172,col 24)-(line 172,col 27)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.isEnumerationStartedEmpty()"},{"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.hasMoreElements();\n}","methodRange":"(line 182,col 5)-(line 185,col 5)","methodTokenRange":"@Override public boolean hasNext()\n    {\n        return this.hasMoreElements();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.hasNext","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.hasNext()"},{"methodDeclaration":"public E next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.nextElement();\n}","methodRange":"(line 187,col 5)-(line 190,col 5)","methodTokenRange":"@Override public E next()\n    {\n        return this.nextElement();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[],"methodName":"next","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.next","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.next()"},{"javadocBlockTags":[],"methodDeclaration":"public void remove() throws UnsupportedOperationException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException();\n}","methodRange":"(line 195,col 5)-(line 199,col 5)","methodTokenRange":"@Override public void remove()\n        throws UnsupportedOperationException\n    {\n        throw new UnsupportedOperationException();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Always throws UnsupportedOperationException.\n     ","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"org.jgrapht.util.PrefetchIterator.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Always throws UnsupportedOperationException.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.util.PrefetchIterator.remove()"}],"classJavadoc":"\/**\n * Utility class to help implement an iterator\/enumerator in which the hasNext()\n * method needs to calculate the next elements ahead of time.\n *\n * <p>Many classes which implement an iterator face a common problem: if there\n * is no easy way to calculate hasNext() other than to call getNext(), then they\n * save the result for fetching in the next call to getNext(). This utility\n * helps in doing just that.\n *\n * <p><b>Usage:<\/b> The new iterator class will hold this class as a member\n * variable and forward the hasNext() and next() to it. When creating an\n * instance of this class, you supply it with a functor that is doing the real\n * job of calculating the next element.\n *\n * <pre><code>\n *    \/\/This class supllies enumeration of integer till 100.\n *    public class IteratorExample implements Enumeration{\n *    private int counter=0;\n *    private PrefetchIterator nextSupplier;\n *\n *        IteratorExample()\n *        {\n *            nextSupplier = new PrefetchIterator(new PrefetchIterator.NextElementFunctor(){\n *\n *                public Object nextElement() throws NoSuchElementException {\n *                    counter++;\n *                    if (counter &lt;= 100)\n *                        throw new NoSuchElementException();\n *                    else\n *                        return new Integer(counter);\n *                }\n *\n *            });\n *        }\n *        \/\/forwarding to nextSupplier and return its returned value\n *        public boolean hasMoreElements() {\n *            return this.nextSupplier.hasMoreElements();\n *        }\n *    \/\/  forwarding to nextSupplier and return its returned value\n *        public Object nextElement() {\n *            return this.nextSupplier.nextElement();\n *        }\n *  }<\/code>\n * <\/pre>\n *\n * @author Assaf_Lehr\n *\/\n","className":"PrefetchIterator","fields":[{"fieldRange":"(line 91,col 5)-(line 91,col 44)","fieldName":"innerEnum","fieldJavadocComment":"","fieldTokenRange":"private NextElementFunctor<E> innerEnum;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.PrefetchIterator.NextElementFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.PrefetchIterator.NextElementFunctor.EE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"NextElementFunctor<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.PrefetchIterator.NextElementFunctor<E>"},{"fieldRange":"(line 92,col 5)-(line 92,col 32)","fieldName":"getNextLastResult","fieldJavadocComment":"","fieldTokenRange":"private E getNextLastResult;","fieldTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"E","fieldJavadoc":"","fieldTypeResolvedDescribed":"E"},{"fieldRange":"(line 93,col 5)-(line 93,col 56)","fieldName":"isGetNextLastResultUpToDate","fieldJavadocComment":"","fieldTokenRange":"private boolean isGetNextLastResultUpToDate = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 93,col 51)-(line 93,col 55)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 94,col 5)-(line 94,col 52)","fieldName":"endOfEnumerationReached","fieldJavadocComment":"","fieldTokenRange":"private boolean endOfEnumerationReached = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 94,col 47)-(line 94,col 51)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 95,col 5)-(line 95,col 57)","fieldName":"flagIsEnumerationStartedEmpty","fieldJavadocComment":"","fieldTokenRange":"private boolean flagIsEnumerationStartedEmpty = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 95,col 53)-(line 95,col 56)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 96,col 5)-(line 96,col 45)","fieldName":"innerFunctorUsageCounter","fieldJavadocComment":"","fieldTokenRange":"private int innerFunctorUsageCounter = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 96,col 44)-(line 96,col 44)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":22,"packageName":"org.jgrapht.util"},{"sourceFileName":"org.jgrapht.VertexFactory","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the new vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V createVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 55,col 5)-(line 55,col 28)","methodTokenRange":"public V createVertex();","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Creates a new vertex.\n     *\n     * @return the new vertex\n     ","methodParameters":[],"methodName":"createVertex","methodQualifiedSignature":"org.jgrapht.VertexFactory.createVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new vertex.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.VertexFactory.createVertex()"}],"classJavadoc":"\/**\n * A vertex factory used by graph algorithms for creating new vertices.\n * Normally, vertices are constructed by user code and added to a graph\n * explicitly, but algorithms which generate new vertices require a factory.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n *\/\n","className":"VertexFactory","fields":[]}],"sourceFileId":23,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.Graph","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of all edges connecting source vertex to target vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges connecting source vertex to target vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 95,col 5)-(line 95,col 62)","methodTokenRange":"public Set<E> getAllEdges(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of all edges connecting source vertex to target vertex if\n     * such vertices exist in this graph. If any of the vertices does not exist\n     * or is <code>null<\/code>, returns <code>null<\/code>. If both vertices\n     * exist but no edges found, returns an empty set.\n     *\n     * <p>In undirected graphs, some of the returned edges may have their source\n     * and target vertices in the opposite order. In simple graphs the returned\n     * set is either singleton set or empty set.<\/p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return a set of all edges connecting source vertex to target vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.Graph.getAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of all edges connecting source vertex to target vertex if\nsuch vertices exist in this graph. If any of the vertices does not exist\nor is <code>null<\/code>, returns <code>null<\/code>. If both vertices\nexist but no edges found, returns an empty set.\n\n<p>In undirected graphs, some of the returned edges may have their source\nand target vertices in the opposite order. In simple graphs the returned\nset is either singleton set or empty set.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges connecting source vertex to target vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.getAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an edge connecting source vertex to target vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an edge connecting source vertex to target vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 111,col 5)-(line 111,col 53)","methodTokenRange":"public E getEdge(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Returns an edge connecting source vertex to target vertex if such\n     * vertices and such edge exist in this graph. Otherwise returns <code>\n     * null<\/code>. If any of the specified vertices is <code>null<\/code>\n     * returns <code>null<\/code>\n     *\n     * <p>In undirected graphs, the returned edge may have its source and target\n     * vertices in the opposite order.<\/p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return an edge connecting source vertex to target vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.Graph.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an edge connecting source vertex to target vertex if such\nvertices and such edge exist in this graph. Otherwise returns <code>\nnull<\/code>. If any of the specified vertices is <code>null<\/code>\nreturns <code>null<\/code>\n\n<p>In undirected graphs, the returned edge may have its source and target\nvertices in the opposite order.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an edge connecting source vertex to target vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.getEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the edge factory using which this graph creates new edges.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory using which this graph creates new edges.'}]}', name=Optional.empty}"}],"methodDeclaration":"public EdgeFactory<V, E> getEdgeFactory()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 120,col 5)-(line 120,col 46)","methodTokenRange":"public EdgeFactory<V, E> getEdgeFactory();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the edge factory using which this graph creates new edges. The\n     * edge factory is defined when the graph is constructed and must not be\n     * modified.\n     *\n     * @return the edge factory using which this graph creates new edges.\n     ","methodParameters":[],"methodName":"getEdgeFactory","methodQualifiedSignature":"org.jgrapht.Graph.getEdgeFactory","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the edge factory using which this graph creates new edges. The\nedge factory is defined when the graph is constructed and must not be\nmodified.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory using which this graph creates new edges.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"EdgeFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.getEdgeFactory()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if source or target vertices are not\nfound in the graph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if source or target vertices are not\nfound in the graph.'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if any of the specified vertices is <code>\nnull<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if any of the specified vertices is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#getEdgeFactory()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#getEdgeFactory()'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 155,col 5)-(line 155,col 53)","methodTokenRange":"public E addEdge(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Creates a new edge in this graph, going from the source vertex to the\n     * target vertex, and returns the created edge. Some graphs do not allow\n     * edge-multiplicity. In such cases, if the graph already contains an edge\n     * from the specified source to the specified target, than this method does\n     * not change the graph and returns <code>null<\/code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.<\/p>\n     *\n     * <p>This method creates the new edge <code>e<\/code> using this graph's\n     * <code>EdgeFactory<\/code>. For the new edge to be added <code>e<\/code>\n     * must <i>not<\/i> be equal to any other edge the graph (even if the graph\n     * allows edge-multiplicity). More formally, the graph must not contain any\n     * edge <code>e2<\/code> such that <code>e2.equals(e)<\/code>. If such <code>\n     * e2<\/code> is found then the newly created edge <code>e<\/code> is\n     * abandoned, the method leaves this graph unchanged returns <code>\n     * null<\/code>.<\/p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null<\/code>.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null<\/code>.\n     *\n     * @see #getEdgeFactory()\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.Graph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new edge in this graph, going from the source vertex to the\ntarget vertex, and returns the created edge. Some graphs do not allow\nedge-multiplicity. In such cases, if the graph already contains an edge\nfrom the specified source to the specified target, than this method does\nnot change the graph and returns <code>null<\/code>.\n\n<p>The source and target vertices must already be contained in this\ngraph. If they are not found in graph IllegalArgumentException is\nthrown.<\/p>\n\n<p>This method creates the new edge <code>e<\/code> using this graph's\n<code>EdgeFactory<\/code>. For the new edge to be added <code>e<\/code>\nmust <i>not<\/i> be equal to any other edge the graph (even if the graph\nallows edge-multiplicity). More formally, the graph must not contain any\nedge <code>e2<\/code> such that <code>e2.equals(e)<\/code>. If such <code>\ne2<\/code> is found then the newly created edge <code>e<\/code> is\nabandoned, the method leaves this graph unchanged returns <code>\nnull<\/code>.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if source or target vertices are not\nfound in the graph.'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if any of the specified vertices is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#getEdgeFactory()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge to be added to this graph.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge to be added to this graph.'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph did not already contain the specified\nedge.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph did not already contain the specified\nedge.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if source or target vertices are not\nfound in the graph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if source or target vertices are not\nfound in the graph.'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified edge is not assignment\ncompatible with the class of edges produced by the edge factory of this\ngraph.","javadocBlockTagName":"ClassCastException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified edge is not assignment\ncompatible with the class of edges produced by the edge factory of this\ngraph.'}]}', name=Optional[ClassCastException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if any of the specified vertices is <code>\nnull<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if any of the specified vertices is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#addEdge(Object, Object)'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#getEdgeFactory()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#getEdgeFactory()'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 191,col 5)-(line 191,col 64)","methodTokenRange":"public boolean addEdge(V sourceVertex, V targetVertex, E e);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds the specified edge to this graph, going from the source vertex to\n     * the target vertex. More formally, adds the specified edge, <code>\n     * e<\/code>, to this graph if this graph contains no edge <code>e2<\/code>\n     * such that <code>e2.equals(e)<\/code>. If this graph already contains such\n     * an edge, the call leaves this graph unchanged and returns <tt>false<\/tt>.\n     * Some graphs do not allow edge-multiplicity. In such cases, if the graph\n     * already contains an edge from the specified source to the specified\n     * target, than this method does not change the graph and returns <code>\n     * false<\/code>. If the edge was added to the graph, returns <code>\n     * true<\/code>.\n     *\n     * <p>The source and target vertices must already be contained in this\n     * graph. If they are not found in graph IllegalArgumentException is\n     * thrown.<\/p>\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param e edge to be added to this graph.\n     *\n     * @return <tt>true<\/tt> if this graph did not already contain the specified\n     * edge.\n     *\n     * @throws IllegalArgumentException if source or target vertices are not\n     * found in the graph.\n     * @throws ClassCastException if the specified edge is not assignment\n     * compatible with the class of edges produced by the edge factory of this\n     * graph.\n     * @throws NullPointerException if any of the specified vertices is <code>\n     * null<\/code>.\n     *\n     * @see #addEdge(Object, Object)\n     * @see #getEdgeFactory()\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.Graph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified edge to this graph, going from the source vertex to\nthe target vertex. More formally, adds the specified edge, <code>\ne<\/code>, to this graph if this graph contains no edge <code>e2<\/code>\nsuch that <code>e2.equals(e)<\/code>. If this graph already contains such\nan edge, the call leaves this graph unchanged and returns <tt>false<\/tt>.\nSome graphs do not allow edge-multiplicity. In such cases, if the graph\nalready contains an edge from the specified source to the specified\ntarget, than this method does not change the graph and returns <code>\nfalse<\/code>. If the edge was added to the graph, returns <code>\ntrue<\/code>.\n\n<p>The source and target vertices must already be contained in this\ngraph. If they are not found in graph IllegalArgumentException is\nthrown.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge to be added to this graph.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph did not already contain the specified\nedge.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if source or target vertices are not\nfound in the graph.'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified edge is not assignment\ncompatible with the class of edges produced by the edge factory of this\ngraph.'}]}', name=Optional[ClassCastException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if any of the specified vertices is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#addEdge(Object, Object)'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#getEdgeFactory()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex to be added to this graph.","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex to be added to this graph.'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph did not already contain the specified\nvertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph did not already contain the specified\nvertex.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified vertex is <code>\nnull<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified vertex is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 210,col 5)-(line 210,col 34)","methodTokenRange":"public boolean addVertex(V v);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds the specified vertex to this graph if not already present. More\n     * formally, adds the specified vertex, <code>v<\/code>, to this graph if\n     * this graph contains no vertex <code>u<\/code> such that <code>\n     * u.equals(v)<\/code>. If this graph already contains such vertex, the call\n     * leaves this graph unchanged and returns <tt>false<\/tt>. In combination\n     * with the restriction on constructors, this ensures that graphs never\n     * contain duplicate vertices.\n     *\n     * @param v vertex to be added to this graph.\n     *\n     * @return <tt>true<\/tt> if this graph did not already contain the specified\n     * vertex.\n     *\n     * @throws NullPointerException if the specified vertex is <code>\n     * null<\/code>.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.Graph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified vertex to this graph if not already present. More\nformally, adds the specified vertex, <code>v<\/code>, to this graph if\nthis graph contains no vertex <code>u<\/code> such that <code>\nu.equals(v)<\/code>. If this graph already contains such vertex, the call\nleaves this graph unchanged and returns <tt>false<\/tt>. In combination\nwith the restriction on constructors, this ensures that graphs never\ncontain duplicate vertices.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex to be added to this graph.'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph did not already contain the specified\nvertex.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified vertex is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph contains the specified edge.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph contains the specified edge.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 224,col 5)-(line 224,col 64)","methodTokenRange":"public boolean containsEdge(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <tt>true<\/tt> if and only if this graph contains an edge going\n     * from the source vertex to the target vertex. In undirected graphs the\n     * same result is obtained when source and target are inverted. If any of\n     * the specified vertices does not exist in the graph, or if is <code>\n     * null<\/code>, returns <code>false<\/code>.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return <tt>true<\/tt> if this graph contains the specified edge.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.Graph.containsEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <tt>true<\/tt> if and only if this graph contains an edge going\nfrom the source vertex to the target vertex. In undirected graphs the\nsame result is obtained when source and target are inverted. If any of\nthe specified vertices does not exist in the graph, or if is <code>\nnull<\/code>, returns <code>false<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph contains the specified edge.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.containsEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge whose presence in this graph is to be tested.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge whose presence in this graph is to be tested.'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph contains the specified edge.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph contains the specified edge.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 236,col 5)-(line 236,col 37)","methodTokenRange":"public boolean containsEdge(E e);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <tt>true<\/tt> if this graph contains the specified edge. More\n     * formally, returns <tt>true<\/tt> if and only if this graph contains an\n     * edge <code>e2<\/code> such that <code>e.equals(e2)<\/code>. If the\n     * specified edge is <code>null<\/code> returns <code>false<\/code>.\n     *\n     * @param e edge whose presence in this graph is to be tested.\n     *\n     * @return <tt>true<\/tt> if this graph contains the specified edge.\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.Graph.containsEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <tt>true<\/tt> if this graph contains the specified edge. More\nformally, returns <tt>true<\/tt> if and only if this graph contains an\nedge <code>e2<\/code> such that <code>e.equals(e2)<\/code>. If the\nspecified edge is <code>null<\/code> returns <code>false<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge whose presence in this graph is to be tested.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph contains the specified edge.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.containsEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex whose presence in this graph is to be tested.","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose presence in this graph is to be tested.'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph contains the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph contains the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 248,col 5)-(line 248,col 39)","methodTokenRange":"public boolean containsVertex(V v);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <tt>true<\/tt> if this graph contains the specified vertex. More\n     * formally, returns <tt>true<\/tt> if and only if this graph contains a\n     * vertex <code>u<\/code> such that <code>u.equals(v)<\/code>. If the\n     * specified vertex is <code>null<\/code> returns <code>false<\/code>.\n     *\n     * @param v vertex whose presence in this graph is to be tested.\n     *\n     * @return <tt>true<\/tt> if this graph contains the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"containsVertex","methodQualifiedSignature":"org.jgrapht.Graph.containsVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <tt>true<\/tt> if this graph contains the specified vertex. More\nformally, returns <tt>true<\/tt> if and only if this graph contains a\nvertex <code>u<\/code> such that <code>u.equals(v)<\/code>. If the\nspecified vertex is <code>null<\/code> returns <code>false<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose presence in this graph is to be tested.'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph contains the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.containsVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of the edges contained in this graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of the edges contained in this graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 263,col 5)-(line 263,col 28)","methodTokenRange":"public Set<E> edgeSet();","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of the edges contained in this graph. The set is backed by\n     * the graph, so changes to the graph are reflected in the set. If the graph\n     * is modified while an iteration over the set is in progress, the results\n     * of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.<\/p>\n     *\n     * @return a set of the edges contained in this graph.\n     ","methodParameters":[],"methodName":"edgeSet","methodQualifiedSignature":"org.jgrapht.Graph.edgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of the edges contained in this graph. The set is backed by\nthe graph, so changes to the graph are reflected in the set. If the graph\nis modified while an iteration over the set is in progress, the results\nof the iteration are undefined.\n\n<p>The graph implementation may maintain a particular set ordering (e.g.\nvia '}, JavadocInlineTag{tagName='link', type=LINK, content=' java.util.LinkedHashSet'}, JavadocSnippet{text=') for deterministic iteration, but\nthis is not required. It is the responsibility of callers who rely on\nthis behavior to only use graph implementations which support it.<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of the edges contained in this graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.edgeSet()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex for which a set of touching edges is to be\nreturned.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which a set of touching edges is to be\nreturned.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of all edges touching the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges touching the specified vertex.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if vertex is not found in the graph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if vertex is not found in the graph.'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if vertex is <code>null<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if vertex is <code>null<\/code>.'}]}', name=Optional[NullPointerException]}"}],"methodDeclaration":"public Set<E> edgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 277,col 5)-(line 277,col 36)","methodTokenRange":"public Set<E> edgesOf(V vertex);","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of all edges touching the specified vertex. If no edges are\n     * touching the specified vertex returns an empty set.\n     *\n     * @param vertex the vertex for which a set of touching edges is to be\n     * returned.\n     *\n     * @return a set of all edges touching the specified vertex.\n     *\n     * @throws IllegalArgumentException if vertex is not found in the graph.\n     * @throws NullPointerException if vertex is <code>null<\/code>.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOf","methodQualifiedSignature":"org.jgrapht.Graph.edgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of all edges touching the specified vertex. If no edges are\ntouching the specified vertex returns an empty set.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which a set of touching edges is to be\nreturned.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges touching the specified vertex.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if vertex is not found in the graph.'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if vertex is <code>null<\/code>.'}]}', name=Optional[NullPointerException]}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.edgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to be removed from this graph.","javadocBlockTagName":"edges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to be removed from this graph.'}]}', name=Optional[edges]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph changed as a result of the call","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified edge collection is <tt>\nnull<\/tt>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified edge collection is <tt>\nnull<\/tt>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#removeEdge(Object)'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#containsEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#containsEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllEdges(Collection<? extends E> edges)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 295,col 5)-(line 295,col 65)","methodTokenRange":"public boolean removeAllEdges(Collection<? extends E> edges);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge collection. After this call returns, this graph will\n     * contain no edges in common with the specified edges. This method will\n     * invoke the {@link #removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true<\/tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified edge collection is <tt>\n     * null<\/tt>.\n     *\n     * @see #removeEdge(Object)\n     * @see #containsEdge(Object)\n     ","methodParameters":[{"parameterType":"Collection<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edges","parameterName":"edges"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.Graph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all the edges in this graph that are also contained in the\nspecified edge collection. After this call returns, this graph will\ncontain no edges in common with the specified edges. This method will\ninvoke the '}, JavadocInlineTag{tagName='link', type=LINK, content=' #removeEdge(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to be removed from this graph.'}]}', name=Optional[edges]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified edge collection is <tt>\nnull<\/tt>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#removeEdge(Object)'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#containsEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.removeAllEdges(java.util.Collection<? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the removed edges, or <code>null<\/code> if either vertex is not\npart of graph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the removed edges, or <code>null<\/code> if either vertex is not\npart of graph'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> removeAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 311,col 5)-(line 311,col 65)","methodTokenRange":"public Set<E> removeAllEdges(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Removes all the edges going from the specified source vertex to the\n     * specified target vertex, and returns a set of all removed edges. Returns\n     * <code>null<\/code> if any of the specified vertices does not exist in the\n     * graph. If both vertices exist but no edge is found, returns an empty set.\n     * This method will either invoke the {@link #removeEdge(Object)} method, or\n     * the {@link #removeEdge(Object, Object)} method.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return the removed edges, or <code>null<\/code> if either vertex is not\n     * part of graph\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.Graph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all the edges going from the specified source vertex to the\nspecified target vertex, and returns a set of all removed edges. Returns\n<code>null<\/code> if any of the specified vertices does not exist in the\ngraph. If both vertices exist but no edge is found, returns an empty set.\nThis method will either invoke the '}, JavadocInlineTag{tagName='link', type=LINK, content=' #removeEdge(Object)'}, JavadocSnippet{text=' method, or\nthe '}, JavadocInlineTag{tagName='link', type=LINK, content=' #removeEdge(Object, Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the removed edges, or <code>null<\/code> if either vertex is not\npart of graph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.removeAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to be removed from this graph.","javadocBlockTagName":"vertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to be removed from this graph.'}]}', name=Optional[vertices]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph changed as a result of the call","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified vertex collection is <tt>\nnull<\/tt>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified vertex collection is <tt>\nnull<\/tt>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#removeVertex(Object)'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#containsVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#containsVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllVertices(Collection<? extends V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 329,col 5)-(line 329,col 71)","methodTokenRange":"public boolean removeAllVertices(Collection<? extends V> vertices);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Removes all the vertices in this graph that are also contained in the\n     * specified vertex collection. After this call returns, this graph will\n     * contain no vertices in common with the specified vertices. This method\n     * will invoke the {@link #removeVertex(Object)} method.\n     *\n     * @param vertices vertices to be removed from this graph.\n     *\n     * @return <tt>true<\/tt> if this graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertex collection is <tt>\n     * null<\/tt>.\n     *\n     * @see #removeVertex(Object)\n     * @see #containsVertex(Object)\n     ","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertices","parameterName":"vertices"}],"methodName":"removeAllVertices","methodQualifiedSignature":"org.jgrapht.Graph.removeAllVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all the vertices in this graph that are also contained in the\nspecified vertex collection. After this call returns, this graph will\ncontain no vertices in common with the specified vertices. This method\nwill invoke the '}, JavadocInlineTag{tagName='link', type=LINK, content=' #removeVertex(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to be removed from this graph.'}]}', name=Optional[vertices]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified vertex collection is <tt>\nnull<\/tt>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#removeVertex(Object)'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#containsVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.removeAllVertices(java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The removed edge, or <code>null<\/code> if no edge removed.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The removed edge, or <code>null<\/code> if no edge removed.'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 341,col 5)-(line 341,col 56)","methodTokenRange":"public E removeEdge(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Removes an edge going from source vertex to target vertex, if such\n     * vertices and such edge exist in this graph. Returns the edge if removed\n     * or <code>null<\/code> otherwise.\n     *\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The removed edge, or <code>null<\/code> if no edge removed.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.Graph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes an edge going from source vertex to target vertex, if such\nvertices and such edge exist in this graph. Returns the edge if removed\nor <code>null<\/code> otherwise.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The removed edge, or <code>null<\/code> if no edge removed.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge to be removed from this graph, if present.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge to be removed from this graph, if present.'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if and only if the graph contained the\nspecified edge.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if the graph contained the\nspecified edge.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 358,col 5)-(line 358,col 35)","methodTokenRange":"public boolean removeEdge(E e);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Removes the specified edge from the graph. Removes the specified edge\n     * from this graph if it is present. More formally, removes an edge <code>\n     * e2<\/code> such that <code>e2.equals(e)<\/code>, if the graph contains such\n     * edge. Returns <tt>true<\/tt> if the graph contained the specified edge.\n     * (The graph will not contain the specified edge once the call returns).\n     *\n     * <p>If the specified edge is <code>null<\/code> returns <code>\n     * false<\/code>.<\/p>\n     *\n     * @param e edge to be removed from this graph, if present.\n     *\n     * @return <code>true<\/code> if and only if the graph contained the\n     * specified edge.\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.Graph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the specified edge from the graph. Removes the specified edge\nfrom this graph if it is present. More formally, removes an edge <code>\ne2<\/code> such that <code>e2.equals(e)<\/code>, if the graph contains such\nedge. Returns <tt>true<\/tt> if the graph contained the specified edge.\n(The graph will not contain the specified edge once the call returns).\n\n<p>If the specified edge is <code>null<\/code> returns <code>\nfalse<\/code>.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge to be removed from this graph, if present.'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if the graph contained the\nspecified edge.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex to be removed from this graph, if present.","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex to be removed from this graph, if present.'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the graph contained the specified vertex;\n<code>false<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the graph contained the specified vertex;\n<code>false<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 377,col 5)-(line 377,col 37)","methodTokenRange":"public boolean removeVertex(V v);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Removes the specified vertex from this graph including all its touching\n     * edges if present. More formally, if the graph contains a vertex <code>\n     * u<\/code> such that <code>u.equals(v)<\/code>, the call removes all edges\n     * that touch <code>u<\/code> and then removes <code>u<\/code> itself. If no\n     * such <code>u<\/code> is found, the call leaves the graph unchanged.\n     * Returns <tt>true<\/tt> if the graph contained the specified vertex. (The\n     * graph will not contain the specified vertex once the call returns).\n     *\n     * <p>If the specified vertex is <code>null<\/code> returns <code>\n     * false<\/code>.<\/p>\n     *\n     * @param v vertex to be removed from this graph, if present.\n     *\n     * @return <code>true<\/code> if the graph contained the specified vertex;\n     * <code>false<\/code> otherwise.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.Graph.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the specified vertex from this graph including all its touching\nedges if present. More formally, if the graph contains a vertex <code>\nu<\/code> such that <code>u.equals(v)<\/code>, the call removes all edges\nthat touch <code>u<\/code> and then removes <code>u<\/code> itself. If no\nsuch <code>u<\/code> is found, the call leaves the graph unchanged.\nReturns <tt>true<\/tt> if the graph contained the specified vertex. (The\ngraph will not contain the specified vertex once the call returns).\n\n<p>If the specified vertex is <code>null<\/code> returns <code>\nfalse<\/code>.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex to be removed from this graph, if present.'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the graph contained the specified vertex;\n<code>false<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.removeVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set view of the vertices contained in this graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set view of the vertices contained in this graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> vertexSet()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 392,col 5)-(line 392,col 30)","methodTokenRange":"public Set<V> vertexSet();","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of the vertices contained in this graph. The set is backed\n     * by the graph, so changes to the graph are reflected in the set. If the\n     * graph is modified while an iteration over the set is in progress, the\n     * results of the iteration are undefined.\n     *\n     * <p>The graph implementation may maintain a particular set ordering (e.g.\n     * via {@link java.util.LinkedHashSet}) for deterministic iteration, but\n     * this is not required. It is the responsibility of callers who rely on\n     * this behavior to only use graph implementations which support it.<\/p>\n     *\n     * @return a set view of the vertices contained in this graph.\n     ","methodParameters":[],"methodName":"vertexSet","methodQualifiedSignature":"org.jgrapht.Graph.vertexSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of the vertices contained in this graph. The set is backed\nby the graph, so changes to the graph are reflected in the set. If the\ngraph is modified while an iteration over the set is in progress, the\nresults of the iteration are undefined.\n\n<p>The graph implementation may maintain a particular set ordering (e.g.\nvia '}, JavadocInlineTag{tagName='link', type=LINK, content=' java.util.LinkedHashSet'}, JavadocSnippet{text=') for deterministic iteration, but\nthis is not required. It is the responsibility of callers who rely on\nthis behavior to only use graph implementations which support it.<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set view of the vertices contained in this graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.vertexSet()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge of interest","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge of interest'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"source vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeSource(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 403,col 5)-(line 403,col 32)","methodTokenRange":"public V getEdgeSource(E e);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the source vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return source vertex\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.Graph.getEdgeSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the source vertex of an edge. For an undirected graph, source and\ntarget are distinguishable designations (but without any mathematical\nmeaning).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge of interest'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.getEdgeSource(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge of interest","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge of interest'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"target vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeTarget(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 414,col 5)-(line 414,col 32)","methodTokenRange":"public V getEdgeTarget(E e);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the target vertex of an edge. For an undirected graph, source and\n     * target are distinguishable designations (but without any mathematical\n     * meaning).\n     *\n     * @param e edge of interest\n     *\n     * @return target vertex\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.Graph.getEdgeTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the target vertex of an edge. For an undirected graph, source and\ntarget are distinguishable designations (but without any mathematical\nmeaning).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge of interest'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.getEdgeTarget(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge of interest","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge of interest'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"edge weight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='edge weight'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"WeightedGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 427,col 5)-(line 427,col 37)","methodTokenRange":"public double getEdgeWeight(E e);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n     * (as defined by {@link WeightedGraph#DEFAULT_EDGE_WEIGHT}), allowing\n     * weighted-graph algorithms to apply to them where meaningful.\n     *\n     * @param e edge of interest\n     *\n     * @return edge weight\n     *\n     * @see WeightedGraph\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.Graph.getEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the weight assigned to a given edge. Unweighted graphs return 1.0\n(as defined by '}, JavadocInlineTag{tagName='link', type=LINK, content=' WeightedGraph#DEFAULT_EDGE_WEIGHT'}, JavadocSnippet{text='), allowing\nweighted-graph algorithms to apply to them where meaningful.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge of interest'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='edge weight'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graph.getEdgeWeight(E)"}],"classJavadoc":"\/**\n * The root interface in the graph hierarchy. A mathematical graph-theory graph\n * object <tt>G(V,E)<\/tt> contains a set <tt>V<\/tt> of vertices and a set <tt>\n * E<\/tt> of edges. Each edge e=(v1,v2) in E connects vertex v1 to vertex v2.\n * for more information about graphs and their related definitions see <a\n * href=\"http:\/\/mathworld.wolfram.com\/Graph.html\">\n * http:\/\/mathworld.wolfram.com\/Graph.html<\/a>.\n *\n * <p>This library generally follows the terminology found at: <a\n * href=\"http:\/\/mathworld.wolfram.com\/topics\/GraphTheory.html\">\n * http:\/\/mathworld.wolfram.com\/topics\/GraphTheory.html<\/a>. Implementation of\n * this interface can provide simple-graphs, multigraphs, pseudographs etc. The\n * package <code>org.jgrapht.graph<\/code> provides a gallery of abstract and\n * concrete graph implementations.<\/p>\n *\n * <p>This library works best when vertices represent arbitrary objects and\n * edges represent the relationships between them. Vertex and edge instances may\n * be shared by more than one graph.<\/p>\n *\n * <p>Through generics, a graph can be typed to specific classes for vertices\n * <code>V<\/code> and edges <code>E&lt;T&gt;<\/code>. Such a graph can contain\n * vertices of type <code>V<\/code> and all sub-types and Edges of type <code>\n * E<\/code> and all sub-types.<\/p>\n *\n * <p>For guidelines on vertex and edge classes, see <a\n * href=\"https:\/\/github.com\/jgrapht\/jgrapht\/wiki\/EqualsAndHashCode\">this wiki\n * page<\/a>.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n *\/\n","className":"Graph","fields":[]}],"sourceFileId":24,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.GraphPath","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the containing graph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the containing graph'}]}', name=Optional.empty}"}],"methodDeclaration":"public Graph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 59,col 5)-(line 59,col 34)","methodTokenRange":"public Graph<V, E> getGraph();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph over which this path is defined. The path may also be\n     * valid with respect to other graphs.\n     *\n     * @return the containing graph\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.GraphPath.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph over which this path is defined. The path may also be\nvalid with respect to other graphs.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the containing graph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"Graph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphPath.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the start vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the start vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getStartVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 66,col 5)-(line 66,col 30)","methodTokenRange":"public V getStartVertex();","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the start vertex in the path.\n     *\n     * @return the start vertex\n     ","methodParameters":[],"methodName":"getStartVertex","methodQualifiedSignature":"org.jgrapht.GraphPath.getStartVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the start vertex in the path.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the start vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphPath.getStartVertex()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the end vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the end vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEndVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 73,col 5)-(line 73,col 28)","methodTokenRange":"public V getEndVertex();","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the end vertex in the path.\n     *\n     * @return the end vertex\n     ","methodParameters":[],"methodName":"getEndVertex","methodQualifiedSignature":"org.jgrapht.GraphPath.getEndVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the end vertex in the path.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the end vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphPath.getEndVertex()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of edges traversed by the path","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of edges traversed by the path'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<E> getEdgeList()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 88,col 5)-(line 88,col 33)","methodTokenRange":"public List<E> getEdgeList();","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the edges making up the path. The first edge in this path is\n     * incident to the start vertex. The last edge is incident to the end\n     * vertex. The vertices along the path can be obtained by traversing from\n     * the start vertex, finding its opposite across the first edge, and then\n     * doing the same successively across subsequent edges; {@link\n     * Graphs#getPathVertexList} provides a convenience method for this.\n     *\n     * <p>Whether or not the returned edge list is modifiable depends on the\n     * path implementation.\n     *\n     * @return list of edges traversed by the path\n     ","methodParameters":[],"methodName":"getEdgeList","methodQualifiedSignature":"org.jgrapht.GraphPath.getEdgeList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the edges making up the path. The first edge in this path is\nincident to the start vertex. The last edge is incident to the end\nvertex. The vertices along the path can be obtained by traversing from\nthe start vertex, finding its opposite across the first edge, and then\ndoing the same successively across subsequent edges; '}, JavadocInlineTag{tagName='link', type=LINK, content='\nGraphs#getPathVertexList'}, JavadocSnippet{text=' provides a convenience method for this.\n\n<p>Whether or not the returned edge list is modifiable depends on the\npath implementation.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of edges traversed by the path'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphPath.getEdgeList()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the weight of the path","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the weight of the path'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 97,col 5)-(line 97,col 30)","methodTokenRange":"public double getWeight();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns the weight assigned to the path. Typically, this will be the sum\n     * of the weights of the edge list entries (as defined by the containing\n     * graph), but some path implementations may use other definitions.\n     *\n     * @return the weight of the path\n     ","methodParameters":[],"methodName":"getWeight","methodQualifiedSignature":"org.jgrapht.GraphPath.getWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the weight assigned to the path. Typically, this will be the sum\nof the weights of the edge list entries (as defined by the containing\ngraph), but some path implementations may use other definitions.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the weight of the path'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphPath.getWeight()"}],"classJavadoc":"\/**\n * A GraphPath represents a <a href=\"http:\/\/mathworld.wolfram.com\/Path.html\">\n * path<\/a> in a {@link Graph}. Note that a path is defined primarily in terms\n * of edges (rather than vertices) so that multiple edges between the same pair\n * of vertices can be discriminated.\n *\n * @author John Sichi\n * @since Jan 1, 2008\n *\/\n","className":"GraphPath","fields":[]}],"sourceFileId":25,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.graph.UndirectedGraphUnion","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"UndirectedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.util.WeightCombiner)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"UndirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g2","parameterName":"g2"},{"parameterType":"WeightCombiner","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner","parameter":"WeightCombiner operator","parameterName":"operator"}],"literalExprs":[],"constructorTokenRange":"UndirectedGraphUnion(\n        UndirectedGraph<V, E> g1,\n        UndirectedGraph<V, E> g2,\n        WeightCombiner operator)\n    {\n        super(g1, g2, operator);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 50,col 5)-(line 56,col 5)","constructorJavadocComment":"","constructorDeclaration":" UndirectedGraphUnion(UndirectedGraph<V, E> g1, UndirectedGraph<V, E> g2, WeightCombiner operator)","constructorBody":"{\n    super(g1, g2, operator);\n}","constructorJavadoc":""},{"constructorName":"UndirectedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.UndirectedGraph<V, E>)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"UndirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g2","parameterName":"g2"}],"literalExprs":[],"constructorTokenRange":"UndirectedGraphUnion(UndirectedGraph<V, E> g1, UndirectedGraph<V, E> g2)\n    {\n        super(g1, g2);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 58,col 5)-(line 61,col 5)","constructorJavadocComment":"","constructorDeclaration":" UndirectedGraphUnion(UndirectedGraph<V, E> g1, UndirectedGraph<V, E> g2)","constructorBody":"{\n    super(g1, g2);\n}","constructorJavadoc":""},{"constructorName":"UndirectedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.graph.UndirectedGraphUnion<V, E>, org.jgrapht.util.WeightCombiner)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"UndirectedGraphUnion<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.UndirectedGraphUnion, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.UndirectedGraphUnion.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.UndirectedGraphUnion.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.UndirectedGraphUnion<V, E>","parameter":"UndirectedGraphUnion<V, E> g2","parameterName":"g2"},{"parameterType":"WeightCombiner","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner","parameter":"WeightCombiner operator","parameterName":"operator"}],"literalExprs":[],"constructorTokenRange":"@Deprecated\n    UndirectedGraphUnion(\n        UndirectedGraph<V, E> g1,\n        UndirectedGraphUnion<V, E> g2,\n        WeightCombiner operator)\n    {\n        super(g1, g2, operator);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 70,col 5)","constructorJavadocComment":"","constructorDeclaration":" UndirectedGraphUnion(UndirectedGraph<V, E> g1, UndirectedGraphUnion<V, E> g2, WeightCombiner operator)","constructorBody":"{\n    super(g1, g2, operator);\n}","constructorJavadoc":""},{"constructorName":"UndirectedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.UndirectedGraphUnion.UndirectedGraphUnion(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.graph.UndirectedGraphUnion<V, E>)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"UndirectedGraphUnion<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.UndirectedGraphUnion, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.UndirectedGraphUnion.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.UndirectedGraphUnion.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.UndirectedGraphUnion<V, E>","parameter":"UndirectedGraphUnion<V, E> g2","parameterName":"g2"}],"literalExprs":[],"constructorTokenRange":"@Deprecated\n    UndirectedGraphUnion(\n        UndirectedGraph<V, E> g1,\n        UndirectedGraphUnion<V, E> g2)\n    {\n        super(g1, g2);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 78,col 5)","constructorJavadocComment":"","constructorDeclaration":" UndirectedGraphUnion(UndirectedGraph<V, E> g1, UndirectedGraphUnion<V, E> g2)","constructorBody":"{\n    super(g1, g2);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = edgesOf(vertex);\n    return res.size();\n}","methodRange":"(line 80,col 5)-(line 84,col 5)","methodTokenRange":"@Override public int degreeOf(V vertex)\n    {\n        Set<E> res = edgesOf(vertex);\n        return res.size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.graph.UndirectedGraphUnion.degreeOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UndirectedGraphUnion.degreeOf(V)"}],"classJavadoc":"","className":"UndirectedGraphUnion","fields":[{"fieldRange":"(line 48,col 5)-(line 48,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -740199233080172450L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 48,col 51)-(line 48,col 69)","literalExprId":1,"literalExpr":"740199233080172450L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-740199233080172450L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":26,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.SimpleGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleGraph.SimpleGraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 66,col 5)","constructorJavadocComment":"\n     * Creates a new simple graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public SimpleGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, false, false);\n}","constructorName":"SimpleGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleGraph.SimpleGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 65,col 19)-(line 65,col 23)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 65,col 26)-(line 65,col 30)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public SimpleGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, false, false);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple graph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleGraph.SimpleGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a new simple graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public SimpleGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"SimpleGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleGraph.SimpleGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public SimpleGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(edgeClass));\n}","methodRange":"(line 78,col 5)-(line 83,col 5)","methodTokenRange":"public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends SimpleGraph<V, E>, ?> builder(Class<? extends E> edgeClass)\n    {\n        return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(\n            new SimpleGraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleGraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(new SimpleGraph<V, E>(ef));\n}","methodRange":"(line 85,col 5)-(line 90,col 5)","methodTokenRange":"public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends SimpleGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedGraphBuilder<V, E, SimpleGraph<V, E>>(\n            new SimpleGraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedGraphBuilderBase<V, E, ? extends SimpleGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleGraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A simple graph. A simple graph is an undirected graph for which at most one\n * edge connects any two vertices, and loops are not permitted. If you're unsure\n * about simple graphs, see: <a\n * href=\"http:\/\/mathworld.wolfram.com\/SimpleGraph.html\">\n * http:\/\/mathworld.wolfram.com\/SimpleGraph.html<\/a>.\n *\/\n","className":"SimpleGraph","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3545796589454112304L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 50)-(line 56,col 69)","literalExprId":1,"literalExpr":"3545796589454112304L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3545796589454112304L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":27,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.MixedGraphUnion","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"MixedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.MixedGraphUnion.MixedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.MixedGraphUnion.MixedGraphUnion(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.DirectedGraph<V, E>, org.jgrapht.util.WeightCombiner)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"DirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g2","parameterName":"g2"},{"parameterType":"WeightCombiner","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner","parameter":"WeightCombiner operator","parameterName":"operator"}],"literalExprs":[],"constructorTokenRange":"public MixedGraphUnion(\n        UndirectedGraph<V, E> g1,\n        DirectedGraph<V, E> g2,\n        WeightCombiner operator)\n    {\n        super(g1, g2, operator);\n        this.undirectedGraph = g1;\n        this.directedGraph = g2;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 69,col 5)","constructorJavadocComment":"","constructorDeclaration":"public MixedGraphUnion(UndirectedGraph<V, E> g1, DirectedGraph<V, E> g2, WeightCombiner operator)","constructorBody":"{\n    super(g1, g2, operator);\n    this.undirectedGraph = g1;\n    this.directedGraph = g2;\n}","constructorJavadoc":""},{"constructorName":"MixedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.MixedGraphUnion.MixedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.MixedGraphUnion.MixedGraphUnion(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.DirectedGraph<V, E>)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"DirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g2","parameterName":"g2"}],"literalExprs":[],"constructorTokenRange":"public MixedGraphUnion(UndirectedGraph<V, E> g1, DirectedGraph<V, E> g2)\n    {\n        super(g1, g2);\n        this.undirectedGraph = g1;\n        this.directedGraph = g2;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 71,col 5)-(line 76,col 5)","constructorJavadocComment":"","constructorDeclaration":"public MixedGraphUnion(UndirectedGraph<V, E> g1, DirectedGraph<V, E> g2)","constructorBody":"{\n    super(g1, g2);\n    this.undirectedGraph = g1;\n    this.directedGraph = g2;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = incomingEdgesOf(vertex);\n    return res.size();\n}","methodRange":"(line 78,col 5)-(line 82,col 5)","methodTokenRange":"@Override public int inDegreeOf(V vertex)\n    {\n        Set<E> res = incomingEdgesOf(vertex);\n        return res.size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.MixedGraphUnion.inDegreeOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MixedGraphUnion.inDegreeOf(V)"},{"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new LinkedHashSet<E>();\n    if (directedGraph.containsVertex(vertex)) {\n        res.addAll(directedGraph.incomingEdgesOf(vertex));\n    }\n    if (undirectedGraph.containsVertex(vertex)) {\n        res.addAll(undirectedGraph.edgesOf(vertex));\n    }\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 84,col 5)-(line 94,col 5)","methodTokenRange":"@Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        if (directedGraph.containsVertex(vertex)) {\n            res.addAll(directedGraph.incomingEdgesOf(vertex));\n        }\n        if (undirectedGraph.containsVertex(vertex)) {\n            res.addAll(undirectedGraph.edgesOf(vertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.MixedGraphUnion.incomingEdgesOf","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MixedGraphUnion.incomingEdgesOf(V)"},{"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = outgoingEdgesOf(vertex);\n    return res.size();\n}","methodRange":"(line 96,col 5)-(line 100,col 5)","methodTokenRange":"@Override public int outDegreeOf(V vertex)\n    {\n        Set<E> res = outgoingEdgesOf(vertex);\n        return res.size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.MixedGraphUnion.outDegreeOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MixedGraphUnion.outDegreeOf(V)"},{"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new LinkedHashSet<E>();\n    if (directedGraph.containsVertex(vertex)) {\n        res.addAll(directedGraph.outgoingEdgesOf(vertex));\n    }\n    if (undirectedGraph.containsVertex(vertex)) {\n        res.addAll(undirectedGraph.edgesOf(vertex));\n    }\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 102,col 5)-(line 112,col 5)","methodTokenRange":"@Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        if (directedGraph.containsVertex(vertex)) {\n            res.addAll(directedGraph.outgoingEdgesOf(vertex));\n        }\n        if (undirectedGraph.containsVertex(vertex)) {\n            res.addAll(undirectedGraph.edgesOf(vertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.MixedGraphUnion.outgoingEdgesOf","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MixedGraphUnion.outgoingEdgesOf(V)"}],"classJavadoc":"","className":"MixedGraphUnion","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 56)","fieldName":"undirectedGraph","fieldJavadocComment":"","fieldTokenRange":"private final UndirectedGraph<V, E> undirectedGraph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 59,col 5)-(line 59,col 52)","fieldName":"directedGraph","fieldJavadocComment":"","fieldTokenRange":"private final DirectedGraph<V, E> directedGraph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"}]}],"sourceFileId":28,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DefaultGraphMapping","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g1ToG2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g1ToG2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g2ToG1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g2ToG1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g2]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultGraphMapping.DefaultGraphMapping(java.util.Map<V, V>, java.util.Map<V, V>, org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 80,col 5)","constructorJavadocComment":"\n     * The maps themselves are used. There is no defensive-copy. Assumption: The\n     * key and value in the mappings are of valid graph objects. It is not\n     * checked.\n     *\n     * @param g1ToG2\n     * @param g2ToG1\n     * @param g1\n     * @param g2\n     ","constructorDeclaration":"public DefaultGraphMapping(Map<V, V> g1ToG2, Map<V, V> g2ToG1, Graph<V, E> g1, Graph<V, E> g2)","constructorBody":"{\n    this.graph1 = g1;\n    this.graph2 = g2;\n    this.graphMappingForward = g1ToG2;\n    this.graphMappingReverse = g2ToG1;\n}","constructorName":"DefaultGraphMapping","constructorQualifiedName":"org.jgrapht.graph.DefaultGraphMapping.DefaultGraphMapping","constructorParameters":[{"parameterType":"Map<V, V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, V>","parameter":"Map<V, V> g1ToG2","parameterName":"g1ToG2"},{"parameterType":"Map<V, V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, V>","parameter":"Map<V, V> g2ToG1","parameterName":"g2ToG1"},{"parameterType":"Graph<V, E>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g1","parameterName":"g1"},{"parameterType":"Graph<V, E>","parameterId":4,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g2","parameterName":"g2"}],"literalExprs":[],"constructorTokenRange":"public DefaultGraphMapping(\n        Map<V, V> g1ToG2,\n        Map<V, V> g2ToG1,\n        Graph<V, E> g1,\n        Graph<V, E> g2)\n    {\n        this.graph1 = g1;\n        this.graph2 = g2;\n        this.graphMappingForward = g1ToG2;\n        this.graphMappingReverse = g2ToG1;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The maps themselves are used. There is no defensive-copy. Assumption: The\nkey and value in the mappings are of valid graph objects. It is not\nchecked.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g1ToG2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g2ToG1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g2]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public E getEdgeCorrespondence(E currEdge, boolean forward)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Graph<V, E> sourceGraph, targetGraph;\n    if (forward) {\n        sourceGraph = this.graph1;\n        targetGraph = this.graph2;\n    } else {\n        sourceGraph = this.graph2;\n        targetGraph = this.graph1;\n    }\n    V mappedSourceVertex = getVertexCorrespondence(sourceGraph.getEdgeSource(currEdge), forward);\n    V mappedTargetVertex = getVertexCorrespondence(sourceGraph.getEdgeTarget(currEdge), forward);\n    if ((mappedSourceVertex == null) || (mappedTargetVertex == null)) {\n        return null;\n    } else {\n        return targetGraph.getEdge(mappedSourceVertex, mappedTargetVertex);\n    }\n}","methodRange":"(line 82,col 5)-(line 109,col 5)","methodTokenRange":"@Override public E getEdgeCorrespondence(E currEdge, boolean forward)\n    {\n        Graph<V, E> sourceGraph, targetGraph;\n\n        if (forward) {\n            sourceGraph = this.graph1;\n            targetGraph = this.graph2;\n        } else {\n            sourceGraph = this.graph2;\n            targetGraph = this.graph1;\n        }\n\n        V mappedSourceVertex =\n            getVertexCorrespondence(\n                sourceGraph.getEdgeSource(currEdge),\n                forward);\n        V mappedTargetVertex =\n            getVertexCorrespondence(\n                sourceGraph.getEdgeTarget(currEdge),\n                forward);\n        if ((mappedSourceVertex == null) || (mappedTargetVertex == null)) {\n            return null;\n        } else {\n            return targetGraph.getEdge(\n                mappedSourceVertex,\n                mappedTargetVertex);\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E currEdge","parameterName":"currEdge"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean forward","parameterName":"forward"}],"methodName":"getEdgeCorrespondence","methodQualifiedSignature":"org.jgrapht.graph.DefaultGraphMapping.getEdgeCorrespondence","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 102,col 36)-(line 102,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 102,col 68)-(line 102,col 71)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 103,col 20)-(line 103,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DefaultGraphMapping.getEdgeCorrespondence(E, boolean)"},{"methodDeclaration":"public V getVertexCorrespondence(V keyVertex, boolean forward)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Map<V, V> graphMapping;\n    if (forward) {\n        graphMapping = graphMappingForward;\n    } else {\n        graphMapping = graphMappingReverse;\n    }\n    return graphMapping.get(keyVertex);\n}","methodRange":"(line 111,col 5)-(line 123,col 5)","methodTokenRange":"@Override public V getVertexCorrespondence(\n        V keyVertex,\n        boolean forward)\n    {\n        Map<V, V> graphMapping;\n        if (forward) {\n            graphMapping = graphMappingForward;\n        } else {\n            graphMapping = graphMappingReverse;\n        }\n\n        return graphMapping.get(keyVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V keyVertex","parameterName":"keyVertex"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean forward","parameterName":"forward"}],"methodName":"getVertexCorrespondence","methodQualifiedSignature":"org.jgrapht.graph.DefaultGraphMapping.getVertexCorrespondence","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultGraphMapping.getVertexCorrespondence(V, boolean)"}],"classJavadoc":"\/**\n * Implementation of the GraphMapping interface. The performance of <code>\n * getVertex\/EdgeCorrespondence<\/code> is based on the performance of the\n * concrete Map class which is passed in the constructor. For example, using\n * hashmaps will provide O(1) performence.\n *\n * @author Assaf\n * @since Jul 30, 2005\n *\/\n","className":"DefaultGraphMapping","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 42)","fieldName":"graphMappingForward","fieldJavadocComment":"","fieldTokenRange":"private Map<V, V> graphMappingForward;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, V>"},{"fieldRange":"(line 55,col 5)-(line 55,col 42)","fieldName":"graphMappingReverse","fieldJavadocComment":"","fieldTokenRange":"private Map<V, V> graphMappingReverse;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, V>"},{"fieldRange":"(line 57,col 5)-(line 57,col 31)","fieldName":"graph1","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph1;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 58,col 5)-(line 58,col 31)","fieldName":"graph2","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph2;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"}]}],"sourceFileId":29,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.WeightedPseudograph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.WeightedPseudograph.WeightedPseudograph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 66,col 5)","constructorJavadocComment":"\n     * Creates a new weighted pseudograph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public WeightedPseudograph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"WeightedPseudograph","constructorQualifiedName":"org.jgrapht.graph.WeightedPseudograph.WeightedPseudograph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public WeightedPseudograph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new weighted pseudograph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.WeightedPseudograph.WeightedPseudograph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a new weighted pseudograph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public WeightedPseudograph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"WeightedPseudograph","constructorQualifiedName":"org.jgrapht.graph.WeightedPseudograph.WeightedPseudograph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public WeightedPseudograph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new weighted pseudograph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(edgeClass));\n}","methodRange":"(line 78,col 5)-(line 85,col 5)","methodTokenRange":"public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedPseudograph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedPseudograph<V, E>>(\n                new WeightedPseudograph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.WeightedPseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.WeightedPseudograph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedPseudograph<V, E>>(new WeightedPseudograph<V, E>(ef));\n}","methodRange":"(line 87,col 5)-(line 93,col 5)","methodTokenRange":"public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedPseudograph<V, E>>(\n                new WeightedPseudograph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.WeightedPseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedPseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.WeightedPseudograph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A weighted pseudograph. A weighted pseudograph is a non-simple undirected\n * graph in which both graph loops and multiple edges are permitted. The edges\n * of a weighted pseudograph have weights. If you're unsure about pseudographs,\n * see: <a href=\"http:\/\/mathworld.wolfram.com\/Pseudograph.html\">\n * http:\/\/mathworld.wolfram.com\/Pseudograph.html<\/a>.\n *\/\n","className":"WeightedPseudograph","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3257290244524356152L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 50)-(line 56,col 69)","literalExprId":1,"literalExpr":"3257290244524356152L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3257290244524356152L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":30,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.UndirectedMaskSubgraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"UndirectedMaskSubgraph","constructorQualifiedName":"org.jgrapht.graph.UndirectedMaskSubgraph.UndirectedMaskSubgraph","constructorQualifiedSignature":"org.jgrapht.graph.UndirectedMaskSubgraph.UndirectedMaskSubgraph(org.jgrapht.UndirectedGraph<V, E>, org.jgrapht.graph.MaskFunctor<V, E>)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> base","parameterName":"base"},{"parameterType":"MaskFunctor<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>","parameter":"MaskFunctor<V, E> mask","parameterName":"mask"}],"literalExprs":[],"constructorTokenRange":"public UndirectedMaskSubgraph(\n        UndirectedGraph<V, E> base,\n        MaskFunctor<V, E> mask)\n    {\n        super(base, mask);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 51,col 5)-(line 56,col 5)","constructorJavadocComment":"","constructorDeclaration":"public UndirectedMaskSubgraph(UndirectedGraph<V, E> base, MaskFunctor<V, E> mask)","constructorBody":"{\n    super(base, mask);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * An undirected graph that is a {@link MaskSubgraph} on another graph.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"UndirectedMaskSubgraph","fields":[]}],"sourceFileId":31,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.MaskEdgeSet","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"},{"importId":4,"import":"import org.jgrapht.util.PrefetchIterator.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"MaskEdgeSet","constructorQualifiedName":"org.jgrapht.graph.MaskEdgeSet.MaskEdgeSet","constructorQualifiedSignature":"org.jgrapht.graph.MaskEdgeSet.MaskEdgeSet(org.jgrapht.Graph<V, E>, java.util.Set<E>, org.jgrapht.graph.MaskFunctor<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"Set<E>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSet","parameterName":"edgeSet"},{"parameterType":"MaskFunctor<V, E>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>","parameter":"MaskFunctor<V, E> mask","parameterName":"mask"}],"literalExprs":[{"literalExprRange":"(line 72,col 22)-(line 72,col 22)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public MaskEdgeSet(\n        Graph<V, E> graph,\n        Set<E> edgeSet,\n        MaskFunctor<V, E> mask)\n    {\n        this.graph = graph;\n        this.edgeSet = edgeSet;\n        this.mask = mask;\n        this.size = -1;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 73,col 5)","constructorJavadocComment":"","constructorDeclaration":"public MaskEdgeSet(Graph<V, E> graph, Set<E> edgeSet, MaskFunctor<V, E> mask)","constructorBody":"{\n    this.graph = graph;\n    this.edgeSet = edgeSet;\n    this.mask = mask;\n    this.size = -1;\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 107,col 5)-(line 135,col 5)","classOrInterfaceTokenRange":"private class MaskEdgeSetNextElementFunctor\n        implements NextElementFunctor<E>\n    {\n        private Iterator<E> iter;\n\n        public MaskEdgeSetNextElementFunctor()\n        {\n            this.iter = MaskEdgeSet.this.edgeSet.iterator();\n        }\n\n        @Override public E nextElement()\n            throws NoSuchElementException\n        {\n            E edge = this.iter.next();\n            while (isMasked(edge)) {\n                edge = this.iter.next();\n            }\n            return edge;\n        }\n\n        private boolean isMasked(E edge)\n        {\n            return MaskEdgeSet.this.mask.isEdgeMasked(edge)\n                || MaskEdgeSet.this.mask.isVertexMasked(\n                    MaskEdgeSet.this.graph.getEdgeSource(edge))\n                || MaskEdgeSet.this.mask.isVertexMasked(\n                    MaskEdgeSet.this.graph.getEdgeTarget(edge));\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Collection#contains(java.lang.Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Collection#contains(java.lang.Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean contains(Object o)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.edgeSet.contains(o) && !this.mask.isEdgeMasked(TypeUtil.uncheckedCast(o, edgeTypeDecl));\n}","methodRange":"(line 78,col 5)-(line 82,col 5)","methodTokenRange":"@Override public boolean contains(Object o)\n    {\n        return this.edgeSet.contains(o)\n            && !this.mask.isEdgeMasked(TypeUtil.uncheckedCast(o, edgeTypeDecl));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see java.util.Collection#contains(java.lang.Object)\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"contains","methodQualifiedSignature":"org.jgrapht.graph.MaskEdgeSet.contains","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Collection#contains(java.lang.Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskEdgeSet.contains(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Set#iterator()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#iterator()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Iterator<E> iterator()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new PrefetchIterator<E>(new MaskEdgeSetNextElementFunctor());\n}","methodRange":"(line 87,col 5)-(line 90,col 5)","methodTokenRange":"@Override public Iterator<E> iterator()\n    {\n        return new PrefetchIterator<E>(new MaskEdgeSetNextElementFunctor());\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see java.util.Set#iterator()\n     ","methodParameters":[],"methodName":"iterator","methodQualifiedSignature":"org.jgrapht.graph.MaskEdgeSet.iterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#iterator()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<E>","methodType":"Iterator<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskEdgeSet.iterator()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Set#size()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#size()'}]}', name=Optional.empty}"}],"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (this.size == -1) {\n        this.size = 0;\n        for (Iterator<E> iter = iterator(); iter.hasNext(); ) {\n            iter.next();\n            this.size++;\n        }\n    }\n    return this.size;\n}","methodRange":"(line 95,col 5)-(line 105,col 5)","methodTokenRange":"@Override public int size()\n    {\n        if (this.size == -1) {\n            this.size = 0;\n            for (Iterator<E> iter = iterator(); iter.hasNext();) {\n                iter.next();\n                this.size++;\n            }\n        }\n        return this.size;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see java.util.Set#size()\n     ","methodParameters":[],"methodName":"size","methodQualifiedSignature":"org.jgrapht.graph.MaskEdgeSet.size","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#size()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 97,col 27)-(line 97,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 98,col 25)-(line 98,col 25)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.MaskEdgeSet.size()"}],"classJavadoc":"\/**\n * Helper for {@link MaskSubgraph}.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"MaskEdgeSet","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 27)","fieldName":"edgeSet","fieldJavadocComment":"","fieldTokenRange":"private Set<E> edgeSet;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 56,col 5)-(line 56,col 30)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 58,col 5)-(line 58,col 35)","fieldName":"mask","fieldJavadocComment":"","fieldTokenRange":"private MaskFunctor<V, E> mask;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"MaskFunctor<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>"},{"fieldRange":"(line 60,col 5)-(line 60,col 54)","fieldName":"edgeTypeDecl","fieldJavadocComment":"","fieldTokenRange":"private transient TypeUtil<E> edgeTypeDecl = null;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.TypeUtil, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.TypeUtil.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 60,col 50)-(line 60,col 53)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"TypeUtil<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.TypeUtil<E>"},{"fieldRange":"(line 62,col 5)-(line 62,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":32,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.Pseudograph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.Pseudograph.Pseudograph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 62,col 5)-(line 65,col 5)","constructorJavadocComment":"\n     * Creates a new pseudograph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public Pseudograph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"Pseudograph","constructorQualifiedName":"org.jgrapht.graph.Pseudograph.Pseudograph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public Pseudograph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new pseudograph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.Pseudograph.Pseudograph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * Creates a new pseudograph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public Pseudograph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, true, true);\n}","constructorName":"Pseudograph","constructorQualifiedName":"org.jgrapht.graph.Pseudograph.Pseudograph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 74,col 19)-(line 74,col 22)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 74,col 25)-(line 74,col 28)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public Pseudograph(EdgeFactory<V, E> ef)\n    {\n        super(ef, true, true);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new pseudograph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(edgeClass));\n}","methodRange":"(line 77,col 5)-(line 82,col 5)","methodTokenRange":"public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends Pseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)\n    {\n        return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(\n            new Pseudograph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.Pseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Pseudograph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(new Pseudograph<V, E>(ef));\n}","methodRange":"(line 84,col 5)-(line 89,col 5)","methodTokenRange":"public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends Pseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedGraphBuilder<V, E, Pseudograph<V, E>>(\n            new Pseudograph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.Pseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedGraphBuilderBase<V, E, ? extends Pseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Pseudograph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A pseudograph. A pseudograph is a non-simple undirected graph in which both\n * graph loops and multiple edges are permitted. If you're unsure about\n * pseudographs, see: <a href=\"http:\/\/mathworld.wolfram.com\/Pseudograph.html\">\n * http:\/\/mathworld.wolfram.com\/Pseudograph.html<\/a>.\n *\/\n","className":"Pseudograph","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3833183614484755253L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 55,col 50)-(line 55,col 69)","literalExprId":1,"literalExpr":"3833183614484755253L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3833183614484755253L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":33,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.MaskFunctor","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isEdgeMasked(E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 54,col 5)-(line 54,col 40)","methodTokenRange":"public boolean isEdgeMasked(E edge);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if the edge is masked, <code>false<\/code>\n     * otherwise.\n     *\n     * @param edge edge.\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"isEdgeMasked","methodQualifiedSignature":"org.jgrapht.graph.MaskFunctor.isEdgeMasked","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if the edge is masked, <code>false<\/code>\notherwise.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskFunctor.isEdgeMasked(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isVertexMasked(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 64,col 5)-(line 64,col 44)","methodTokenRange":"public boolean isVertexMasked(V vertex);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if the vertex is masked, <code>false<\/code>\n     * otherwise.\n     *\n     * @param vertex vertex.\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"isVertexMasked","methodQualifiedSignature":"org.jgrapht.graph.MaskFunctor.isVertexMasked","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if the vertex is masked, <code>false<\/code>\notherwise.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskFunctor.isVertexMasked(V)"}],"classJavadoc":"\/**\n * A functor interface for masking out vertices and edges of a graph.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"MaskFunctor","fields":[]}],"sourceFileId":34,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.GraphUnion","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"GraphUnion","constructorQualifiedName":"org.jgrapht.graph.GraphUnion.GraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.GraphUnion.GraphUnion(G, G, org.jgrapht.util.WeightCombiner)","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G g1","parameterName":"g1"},{"parameterType":"G","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G g2","parameterName":"g2"},{"parameterType":"WeightCombiner","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner","parameter":"WeightCombiner operator","parameterName":"operator"}],"literalExprs":[{"literalExprRange":"(line 71,col 19)-(line 71,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 72,col 44)-(line 72,col 55)","literalExprId":2,"literalExpr":"\"g1 is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 74,col 19)-(line 74,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 75,col 44)-(line 75,col 55)","literalExprId":4,"literalExpr":"\"g2 is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 48)-(line 78,col 66)","literalExprId":5,"literalExpr":"\"g1 is equal to g2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public GraphUnion(G g1, G g2, WeightCombiner operator)\n    {\n        if (g1 == null) {\n            throw new NullPointerException(\"g1 is null\");\n        }\n        if (g2 == null) {\n            throw new NullPointerException(\"g2 is null\");\n        }\n        if (g1 == g2) {\n            throw new IllegalArgumentException(\"g1 is equal to g2\");\n        }\n        this.g1 = g1;\n        this.g2 = g2;\n        this.operator = operator;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 83,col 5)","constructorJavadocComment":"","constructorDeclaration":"public GraphUnion(G g1, G g2, WeightCombiner operator)","constructorBody":"{\n    if (g1 == null) {\n        throw new NullPointerException(\"g1 is null\");\n    }\n    if (g2 == null) {\n        throw new NullPointerException(\"g2 is null\");\n    }\n    if (g1 == g2) {\n        throw new IllegalArgumentException(\"g1 is equal to g2\");\n    }\n    this.g1 = g1;\n    this.g2 = g2;\n    this.operator = operator;\n}","constructorJavadoc":""},{"constructorName":"GraphUnion","constructorQualifiedName":"org.jgrapht.graph.GraphUnion.GraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.GraphUnion.GraphUnion(G, G)","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G g1","parameterName":"g1"},{"parameterType":"G","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G g2","parameterName":"g2"}],"literalExprs":[],"constructorTokenRange":"public GraphUnion(G g1, G g2)\n    {\n        this(g1, g2, WeightCombiner.SUM);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 85,col 5)-(line 88,col 5)","constructorJavadocComment":"","constructorDeclaration":"public GraphUnion(G g1, G g2)","constructorBody":"{\n    this(g1, g2, WeightCombiner.SUM);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new LinkedHashSet<E>();\n    if (g1.containsVertex(sourceVertex) && g1.containsVertex(targetVertex)) {\n        res.addAll(g1.getAllEdges(sourceVertex, targetVertex));\n    }\n    if (g2.containsVertex(sourceVertex) && g2.containsVertex(targetVertex)) {\n        res.addAll(g2.getAllEdges(sourceVertex, targetVertex));\n    }\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 90,col 5)-(line 104,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        if (g1.containsVertex(sourceVertex)\n            && g1.containsVertex(targetVertex))\n        {\n            res.addAll(g1.getAllEdges(sourceVertex, targetVertex));\n        }\n        if (g2.containsVertex(sourceVertex)\n            && g2.containsVertex(targetVertex))\n        {\n            res.addAll(g2.getAllEdges(sourceVertex, targetVertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getAllEdges","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getAllEdges(V, V)"},{"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E res = null;\n    if (g1.containsVertex(sourceVertex) && g1.containsVertex(targetVertex)) {\n        res = g1.getEdge(sourceVertex, targetVertex);\n    }\n    if ((res == null) && g2.containsVertex(sourceVertex) && g2.containsVertex(targetVertex)) {\n        res = g2.getEdge(sourceVertex, targetVertex);\n    }\n    return res;\n}","methodRange":"(line 106,col 5)-(line 121,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        E res = null;\n        if (g1.containsVertex(sourceVertex)\n            && g1.containsVertex(targetVertex))\n        {\n            res = g1.getEdge(sourceVertex, targetVertex);\n        }\n        if ((res == null)\n            && g2.containsVertex(sourceVertex)\n            && g2.containsVertex(targetVertex))\n        {\n            res = g2.getEdge(sourceVertex, targetVertex);\n        }\n        return res;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getEdge","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 108,col 17)-(line 108,col 20)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 114,col 21)-(line 114,col 24)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getEdge(V, V)"},{"javadocBlockTags":[],"methodDeclaration":"public EdgeFactory<V, E> getEdgeFactory()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 127,col 5)-(line 130,col 5)","methodTokenRange":"@Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[],"methodName":"getEdgeFactory","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getEdgeFactory","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"EdgeFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getEdgeFactory()"},{"javadocBlockTags":[],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 136,col 5)-(line 139,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.addEdge(V, V)"},{"javadocBlockTags":[],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 145,col 5)-(line 148,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.addEdge(V, V, E)"},{"javadocBlockTags":[],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 154,col 5)-(line 157,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.addVertex(V)"},{"methodDeclaration":"public boolean containsEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return g1.containsEdge(e) || g2.containsEdge(e);\n}","methodRange":"(line 159,col 5)-(line 162,col 5)","methodTokenRange":"@Override public boolean containsEdge(E e)\n    {\n        return g1.containsEdge(e) || g2.containsEdge(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.containsEdge","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.containsEdge(E)"},{"methodDeclaration":"public boolean containsVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return g1.containsVertex(v) || g2.containsVertex(v);\n}","methodRange":"(line 164,col 5)-(line 167,col 5)","methodTokenRange":"@Override public boolean containsVertex(V v)\n    {\n        return g1.containsVertex(v) || g2.containsVertex(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"containsVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.containsVertex","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.containsVertex(V)"},{"methodDeclaration":"public Set<E> edgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new LinkedHashSet<E>();\n    res.addAll(g1.edgeSet());\n    res.addAll(g2.edgeSet());\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 169,col 5)-(line 175,col 5)","methodTokenRange":"@Override public Set<E> edgeSet()\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        res.addAll(g1.edgeSet());\n        res.addAll(g2.edgeSet());\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"edgeSet","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.edgeSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.edgeSet()"},{"methodDeclaration":"public Set<E> edgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new LinkedHashSet<E>();\n    if (g1.containsVertex(vertex)) {\n        res.addAll(g1.edgesOf(vertex));\n    }\n    if (g2.containsVertex(vertex)) {\n        res.addAll(g2.edgesOf(vertex));\n    }\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 177,col 5)-(line 187,col 5)","methodTokenRange":"@Override public Set<E> edgesOf(V vertex)\n    {\n        Set<E> res = new LinkedHashSet<E>();\n        if (g1.containsVertex(vertex)) {\n            res.addAll(g1.edgesOf(vertex));\n        }\n        if (g2.containsVertex(vertex)) {\n            res.addAll(g2.edgesOf(vertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOf","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.edgesOf","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.edgesOf(V)"},{"javadocBlockTags":[],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 193,col 5)-(line 196,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.removeEdge(V, V)"},{"javadocBlockTags":[],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 202,col 5)-(line 205,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.removeEdge(E)"},{"javadocBlockTags":[],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(READ_ONLY);\n}","methodRange":"(line 211,col 5)-(line 214,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        throw new UnsupportedOperationException(READ_ONLY);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\n     * GraphUnion<\/tt> is read-only.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws <tt>UnsupportedOperationException<\/tt>, because <tt>\nGraphUnion<\/tt> is read-only.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.removeVertex(V)"},{"methodDeclaration":"public Set<V> vertexSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> res = new HashSet<V>();\n    res.addAll(g1.vertexSet());\n    res.addAll(g2.vertexSet());\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 216,col 5)-(line 222,col 5)","methodTokenRange":"@Override public Set<V> vertexSet()\n    {\n        Set<V> res = new HashSet<V>();\n        res.addAll(g1.vertexSet());\n        res.addAll(g2.vertexSet());\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"vertexSet","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.vertexSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.vertexSet()"},{"methodDeclaration":"public V getEdgeSource(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (g1.containsEdge(e)) {\n        return g1.getEdgeSource(e);\n    }\n    if (g2.containsEdge(e)) {\n        return g2.getEdgeSource(e);\n    }\n    return null;\n}","methodRange":"(line 224,col 5)-(line 233,col 5)","methodTokenRange":"@Override public V getEdgeSource(E e)\n    {\n        if (g1.containsEdge(e)) {\n            return g1.getEdgeSource(e);\n        }\n        if (g2.containsEdge(e)) {\n            return g2.getEdgeSource(e);\n        }\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getEdgeSource","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 232,col 16)-(line 232,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getEdgeSource(E)"},{"methodDeclaration":"public V getEdgeTarget(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (g1.containsEdge(e)) {\n        return g1.getEdgeTarget(e);\n    }\n    if (g2.containsEdge(e)) {\n        return g2.getEdgeTarget(e);\n    }\n    return null;\n}","methodRange":"(line 235,col 5)-(line 244,col 5)","methodTokenRange":"@Override public V getEdgeTarget(E e)\n    {\n        if (g1.containsEdge(e)) {\n            return g1.getEdgeTarget(e);\n        }\n        if (g2.containsEdge(e)) {\n            return g2.getEdgeTarget(e);\n        }\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getEdgeTarget","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 243,col 16)-(line 243,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getEdgeTarget(E)"},{"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (g1.containsEdge(e) && g2.containsEdge(e)) {\n        return operator.combine(g1.getEdgeWeight(e), g2.getEdgeWeight(e));\n    }\n    if (g1.containsEdge(e)) {\n        return g1.getEdgeWeight(e);\n    }\n    if (g2.containsEdge(e)) {\n        return g2.getEdgeWeight(e);\n    }\n    throw new IllegalArgumentException(\"no such edge in the union\");\n}","methodRange":"(line 246,col 5)-(line 258,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E e)\n    {\n        if (g1.containsEdge(e) && g2.containsEdge(e)) {\n            return operator.combine(g1.getEdgeWeight(e), g2.getEdgeWeight(e));\n        }\n        if (g1.containsEdge(e)) {\n            return g1.getEdgeWeight(e);\n        }\n        if (g2.containsEdge(e)) {\n            return g2.getEdgeWeight(e);\n        }\n        throw new IllegalArgumentException(\"no such edge in the union\");\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getEdgeWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 257,col 44)-(line 257,col 70)","literalExprId":1,"literalExpr":"\"no such edge in the union\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getEdgeWeight(E)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"G<sub>1<\/sub>","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='G<sub>1<\/sub>'}]}', name=Optional.empty}"}],"methodDeclaration":"public G getG1()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return g1;\n}","methodRange":"(line 263,col 5)-(line 266,col 5)","methodTokenRange":"public G getG1()\n    {\n        return g1;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","methodJavadocComment":"\n     * @return G<sub>1<\/sub>\n     ","methodParameters":[],"methodName":"getG1","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getG1","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='G<sub>1<\/sub>'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"G","methodType":"G","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getG1()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"G<sub>2<\/sub>","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='G<sub>2<\/sub>'}]}', name=Optional.empty}"}],"methodDeclaration":"public G getG2()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return g2;\n}","methodRange":"(line 271,col 5)-(line 274,col 5)","methodTokenRange":"public G getG2()\n    {\n        return g2;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","methodJavadocComment":"\n     * @return G<sub>2<\/sub>\n     ","methodParameters":[],"methodName":"getG2","methodQualifiedSignature":"org.jgrapht.graph.GraphUnion.getG2","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='G<sub>2<\/sub>'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"G","methodType":"G","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphUnion.getG2()"}],"classJavadoc":"\/**\n * <p>Read-only union of two graphs: G<sub>1<\/sub> and G<sub>2<\/sub>. If\n * G<sub>1<\/sub> = (V<sub>1<\/sub>, E<sub>1<\/sub>) and G<sub>2<\/sub> =\n * (V<sub>2<\/sub>, E<sub>2<\/sub>) then their union G = (V, E), where V is the\n * union of V<sub>1<\/sub> and V<sub>2<\/sub>, and E is the union of E<sub>1<\/sub>\n * and E<sub>1<\/sub>.<\/p>\n *\n * <p><tt>GraphUnion<\/tt> implements <tt>Graph<\/tt> interface. <tt>\n * GraphUnion<\/tt> uses <tt>WeightCombiner<\/tt> to choose policy for calculating\n * edge weight.<\/p>\n *\/\n","className":"GraphUnion","fields":[{"fieldRange":"(line 61,col 5)-(line 61,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -740199233080172450L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 61,col 51)-(line 61,col 69)","literalExprId":1,"literalExpr":"740199233080172450L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-740199233080172450L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 63,col 5)-(line 63,col 75)","fieldName":"READ_ONLY","fieldJavadocComment":"","fieldTokenRange":"private static final String READ_ONLY = \"union of graphs is read-only\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 63,col 45)-(line 63,col 74)","literalExprId":1,"literalExpr":"\"union of graphs is read-only\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"union of graphs is read-only\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 65,col 5)-(line 65,col 17)","fieldName":"g1","fieldJavadocComment":"","fieldTokenRange":"private G g1;","fieldTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"G","fieldJavadoc":"","fieldTypeResolvedDescribed":"G"},{"fieldRange":"(line 66,col 5)-(line 66,col 17)","fieldName":"g2","fieldJavadocComment":"","fieldTokenRange":"private G g2;","fieldTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"G","fieldJavadoc":"","fieldTypeResolvedDescribed":"G"},{"fieldRange":"(line 67,col 5)-(line 67,col 36)","fieldName":"operator","fieldJavadocComment":"","fieldTokenRange":"private WeightCombiner operator;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeightCombiner","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner"}]}],"sourceFileId":35,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedMaskSubgraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"DirectedMaskSubgraph","constructorQualifiedName":"org.jgrapht.graph.DirectedMaskSubgraph.DirectedMaskSubgraph","constructorQualifiedSignature":"org.jgrapht.graph.DirectedMaskSubgraph.DirectedMaskSubgraph(org.jgrapht.DirectedGraph<V, E>, org.jgrapht.graph.MaskFunctor<V, E>)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> base","parameterName":"base"},{"parameterType":"MaskFunctor<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>","parameter":"MaskFunctor<V, E> mask","parameterName":"mask"}],"literalExprs":[],"constructorTokenRange":"public DirectedMaskSubgraph(\n        DirectedGraph<V, E> base,\n        MaskFunctor<V, E> mask)\n    {\n        super(base, mask);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 51,col 5)-(line 56,col 5)","constructorJavadocComment":"","constructorDeclaration":"public DirectedMaskSubgraph(DirectedGraph<V, E> base, MaskFunctor<V, E> mask)","constructorBody":"{\n    super(base, mask);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * A directed graph that is a {@link MaskSubgraph} on another graph.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"DirectedMaskSubgraph","fields":[]}],"sourceFileId":36,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedMultigraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedMultigraph.DirectedMultigraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new directed multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public DirectedMultigraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"DirectedMultigraph","constructorQualifiedName":"org.jgrapht.graph.DirectedMultigraph.DirectedMultigraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public DirectedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed multigraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedMultigraph.DirectedMultigraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 71,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Creates a new directed multigraph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public DirectedMultigraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, true, false);\n}","constructorName":"DirectedMultigraph","constructorQualifiedName":"org.jgrapht.graph.DirectedMultigraph.DirectedMultigraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 73,col 19)-(line 73,col 22)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 73,col 25)-(line 73,col 29)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public DirectedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, true, false);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed multigraph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(edgeClass));\n}","methodRange":"(line 76,col 5)-(line 82,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends DirectedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(\n            new DirectedMultigraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedMultigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedMultigraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(new DirectedMultigraph<V, E>(ef));\n}","methodRange":"(line 84,col 5)-(line 89,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends DirectedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new DirectedGraphBuilder<V, E, DirectedMultigraph<V, E>>(\n            new DirectedMultigraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedMultigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends DirectedMultigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedMultigraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A directed multigraph. A directed multigraph is a non-simple directed graph\n * in which no loops are permitted, but multiple edges between any two vertices\n * are.\n *\/\n","className":"DirectedMultigraph","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3258408413590599219L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"3258408413590599219L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3258408413590599219L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":37,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AbstractBaseGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to allow multiple edges or not.","javadocBlockTagName":"allowMultipleEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to allow multiple edges or not.'}]}', name=Optional[allowMultipleEdges]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to allow edges that are self-loops or not.","javadocBlockTagName":"allowLoops","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to allow edges that are self-loops or not.'}]}', name=Optional[allowLoops]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified edge factory is <code>\nnull<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified edge factory is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.AbstractBaseGraph(org.jgrapht.EdgeFactory<V, E>, boolean, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 100,col 5)-(line 117,col 5)","constructorJavadocComment":"\n     * Construct a new graph. The graph can either be directed or undirected,\n     * depending on the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     * @param allowMultipleEdges whether to allow multiple edges or not.\n     * @param allowLoops whether to allow edges that are self-loops or not.\n     *\n     * @throws NullPointerException if the specified edge factory is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"protected AbstractBaseGraph(EdgeFactory<V, E> ef, boolean allowMultipleEdges, boolean allowLoops)","constructorBody":"{\n    if (ef == null) {\n        throw new NullPointerException();\n    }\n    edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n    edgeFactory = ef;\n    allowingLoops = allowLoops;\n    allowingMultipleEdges = allowMultipleEdges;\n    specifics = createSpecifics();\n    this.edgeSetFactory = new ArrayListFactory<V, E>();\n}","constructorName":"AbstractBaseGraph","constructorQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.AbstractBaseGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean allowMultipleEdges","parameterName":"allowMultipleEdges"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean allowLoops","parameterName":"allowLoops"}],"literalExprs":[{"literalExprRange":"(line 105,col 19)-(line 105,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"protected AbstractBaseGraph(\n        EdgeFactory<V, E> ef,\n        boolean allowMultipleEdges,\n        boolean allowLoops)\n    {\n        if (ef == null) {\n            throw new NullPointerException();\n        }\n\n        edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n        edgeFactory = ef;\n        allowingLoops = allowLoops;\n        allowingMultipleEdges = allowMultipleEdges;\n\n        specifics = createSpecifics();\n\n        this.edgeSetFactory = new ArrayListFactory<V, E>();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new graph. The graph can either be directed or undirected,\ndepending on the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to allow multiple edges or not.'}]}', name=Optional[allowMultipleEdges]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to allow edges that are self-loops or not.'}]}', name=Optional[allowLoops]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified edge factory is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 535,col 5)-(line 634,col 5)","classOrInterfaceTokenRange":"private abstract class Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 785196247314761183L;\n\n        public abstract void addVertex(V vertex);\n\n        public abstract Set<V> getVertexSet();\n\n        \/**\n         * .\n         *\n         * @param sourceVertex\n         * @param targetVertex\n         *\n         * @return\n         *\/\n        public abstract Set<E> getAllEdges(V sourceVertex,\n            V targetVertex);\n\n        \/**\n         * .\n         *\n         * @param sourceVertex\n         * @param targetVertex\n         *\n         * @return\n         *\/\n        public abstract E getEdge(V sourceVertex, V targetVertex);\n\n        \/**\n         * Adds the specified edge to the edge containers of its source and\n         * target vertices.\n         *\n         * @param e\n         *\/\n        public abstract void addEdgeToTouchingVertices(E e);\n\n        \/**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         *\/\n        public abstract int degreeOf(V vertex);\n\n        \/**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         *\/\n        public abstract Set<E> edgesOf(V vertex);\n\n        \/**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         *\/\n        public abstract int inDegreeOf(V vertex);\n\n        \/**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         *\/\n        public abstract Set<E> incomingEdgesOf(V vertex);\n\n        \/**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         *\/\n        public abstract int outDegreeOf(V vertex);\n\n        \/**\n         * .\n         *\n         * @param vertex\n         *\n         * @return\n         *\/\n        public abstract Set<E> outgoingEdgesOf(V vertex);\n\n        \/**\n         * Removes the specified edge from the edge containers of its source and\n         * target vertices.\n         *\n         * @param e\n         *\/\n        public abstract void removeEdgeFromTouchingVertices(E e);\n    }","classOrInterfaceJavadocComment":"\n     * .\n     *\n     * @author Barak Naveh\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 636,col 5)-(line 651,col 5)","classOrInterfaceTokenRange":"private static class ArrayListFactory<VV, EE>\n        implements EdgeSetFactory<VV, EE>,\n            Serializable\n    {\n        private static final long serialVersionUID = 5936902837403445985L;\n\n        \/**\n         * @see EdgeSetFactory.createEdgeSet\n         *\/\n        @Override public Set<EE> createEdgeSet(VV vertex)\n        {\n            \/\/ NOTE:  use size 1 to keep memory usage under control\n            \/\/ for the common case of vertices with low degree\n            return new ArrayUnenforcedSet<EE>(1);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 662,col 5)-(line 745,col 5)","classOrInterfaceTokenRange":"protected static class DirectedEdgeContainer<VV, EE>\n        implements Serializable\n    {\n        private static final long serialVersionUID = 7494242245729767106L;\n        Set<EE> incoming;\n        Set<EE> outgoing;\n        private transient Set<EE> unmodifiableIncoming = null;\n        private transient Set<EE> unmodifiableOutgoing = null;\n\n        DirectedEdgeContainer(EdgeSetFactory<VV, EE> edgeSetFactory,\n            VV vertex)\n        {\n            incoming = edgeSetFactory.createEdgeSet(vertex);\n            outgoing = edgeSetFactory.createEdgeSet(vertex);\n        }\n\n        \/**\n         * A lazy build of unmodifiable incoming edge set.\n         *\n         * @return\n         *\/\n        public Set<EE> getUnmodifiableIncomingEdges()\n        {\n            if (unmodifiableIncoming == null) {\n                unmodifiableIncoming = Collections.unmodifiableSet(incoming);\n            }\n\n            return unmodifiableIncoming;\n        }\n\n        \/**\n         * A lazy build of unmodifiable outgoing edge set.\n         *\n         * @return\n         *\/\n        public Set<EE> getUnmodifiableOutgoingEdges()\n        {\n            if (unmodifiableOutgoing == null) {\n                unmodifiableOutgoing = Collections.unmodifiableSet(outgoing);\n            }\n\n            return unmodifiableOutgoing;\n        }\n\n        \/**\n         * .\n         *\n         * @param e\n         *\/\n        public void addIncomingEdge(EE e)\n        {\n            incoming.add(e);\n        }\n\n        \/**\n         * .\n         *\n         * @param e\n         *\/\n        public void addOutgoingEdge(EE e)\n        {\n            outgoing.add(e);\n        }\n\n        \/**\n         * .\n         *\n         * @param e\n         *\/\n        public void removeIncomingEdge(EE e)\n        {\n            incoming.remove(e);\n        }\n\n        \/**\n         * .\n         *\n         * @param e\n         *\/\n        public void removeOutgoingEdge(EE e)\n        {\n            outgoing.remove(e);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A container for vertex edges.\n     *\n     * <p>In this edge container we use array lists to minimize memory toll.\n     * However, for high-degree vertices we replace the entire edge container\n     * with a direct access subclass (to be implemented).<\/p>\n     *\n     * @author Barak Naveh\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A container for vertex edges.\n\n<p>In this edge container we use array lists to minimize memory toll.\nHowever, for high-degree vertices we replace the entire edge container\nwith a direct access subclass (to be implemented).<\/p>'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 752,col 5)-(line 941,col 5)","classOrInterfaceTokenRange":"protected class DirectedSpecifics\n        extends Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 8971725103718958232L;\n        private static final String NOT_IN_DIRECTED_GRAPH =\n            \"no such operation in a directed graph\";\n\n        protected Map<V, DirectedEdgeContainer<V, E>> vertexMapDirected;\n\n        public DirectedSpecifics()\n        {\n            this(new LinkedHashMap<V, DirectedEdgeContainer<V, E>>());\n        }\n\n        public DirectedSpecifics(Map<V, DirectedEdgeContainer<V, E>> vertexMap)\n        {\n            this.vertexMapDirected = vertexMap;\n        }\n\n        @Override public void addVertex(V v)\n        {\n            \/\/ add with a lazy edge container entry\n            vertexMapDirected.put(v, null);\n        }\n\n        @Override public Set<V> getVertexSet()\n        {\n            return vertexMapDirected.keySet();\n        }\n\n        \/**\n         * @see Graph#getAllEdges(Object, Object)\n         *\/\n        @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n        {\n            Set<E> edges = null;\n\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                edges = new ArrayUnenforcedSet<E>();\n\n                DirectedEdgeContainer<V, E> ec = getEdgeContainer(sourceVertex);\n\n                Iterator<E> iter = ec.outgoing.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    if (getEdgeTarget(e).equals(targetVertex)) {\n                        edges.add(e);\n                    }\n                }\n            }\n\n            return edges;\n        }\n\n        \/**\n         * @see Graph#getEdge(Object, Object)\n         *\/\n        @Override public E getEdge(V sourceVertex, V targetVertex)\n        {\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                DirectedEdgeContainer<V, E> ec = getEdgeContainer(sourceVertex);\n\n                Iterator<E> iter = ec.outgoing.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    if (getEdgeTarget(e).equals(targetVertex)) {\n                        return e;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        @Override public void addEdgeToTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).addOutgoingEdge(e);\n            getEdgeContainer(target).addIncomingEdge(e);\n        }\n\n        \/**\n         * @see UndirectedGraph#degreeOf(Object)\n         *\/\n        @Override public int degreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_DIRECTED_GRAPH);\n        }\n\n        \/**\n         * @see Graph#edgesOf(Object)\n         *\/\n        @Override public Set<E> edgesOf(V vertex)\n        {\n            ArrayUnenforcedSet<E> inAndOut =\n                new ArrayUnenforcedSet<E>(getEdgeContainer(vertex).incoming);\n            inAndOut.addAll(getEdgeContainer(vertex).outgoing);\n\n            \/\/ we have two copies for each self-loop - remove one of them.\n            if (allowingLoops) {\n                Set<E> loops = getAllEdges(vertex, vertex);\n\n                for (int i = 0; i < inAndOut.size();) {\n                    Object e = inAndOut.get(i);\n\n                    if (loops.contains(e)) {\n                        inAndOut.remove(i);\n                        loops.remove(e); \/\/ so we remove it only once\n                    } else {\n                        i++;\n                    }\n                }\n            }\n\n            return Collections.unmodifiableSet(inAndOut);\n        }\n\n        \/**\n         * @see DirectedGraph#inDegreeOf(Object)\n         *\/\n        @Override public int inDegreeOf(V vertex)\n        {\n            return getEdgeContainer(vertex).incoming.size();\n        }\n\n        \/**\n         * @see DirectedGraph#incomingEdgesOf(Object)\n         *\/\n        @Override public Set<E> incomingEdgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableIncomingEdges();\n        }\n\n        \/**\n         * @see DirectedGraph#outDegreeOf(Object)\n         *\/\n        @Override public int outDegreeOf(V vertex)\n        {\n            return getEdgeContainer(vertex).outgoing.size();\n        }\n\n        \/**\n         * @see DirectedGraph#outgoingEdgesOf(Object)\n         *\/\n        @Override public Set<E> outgoingEdgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableOutgoingEdges();\n        }\n\n        @Override public void removeEdgeFromTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).removeOutgoingEdge(e);\n            getEdgeContainer(target).removeIncomingEdge(e);\n        }\n\n        \/**\n         * A lazy build of edge container for specified vertex.\n         *\n         * @param vertex a vertex in this graph.\n         *\n         * @return EdgeContainer\n         *\/\n        private DirectedEdgeContainer<V, E> getEdgeContainer(V vertex)\n        {\n            assertVertexExist(vertex);\n\n            DirectedEdgeContainer<V, E> ec = vertexMapDirected.get(vertex);\n\n            if (ec == null) {\n                ec = new DirectedEdgeContainer<V, E>(edgeSetFactory, vertex);\n                vertexMapDirected.put(vertex, ec);\n            }\n\n            return ec;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * .\n     *\n     * @author Barak Naveh\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 952,col 5)-(line 1010,col 5)","classOrInterfaceTokenRange":"private static class UndirectedEdgeContainer<VV, EE>\n        implements Serializable\n    {\n        private static final long serialVersionUID = -6623207588411170010L;\n        Set<EE> vertexEdges;\n        private transient Set<EE> unmodifiableVertexEdges = null;\n\n        UndirectedEdgeContainer(\n            EdgeSetFactory<VV, EE> edgeSetFactory,\n            VV vertex)\n        {\n            vertexEdges = edgeSetFactory.createEdgeSet(vertex);\n        }\n\n        \/**\n         * A lazy build of unmodifiable list of vertex edges\n         *\n         * @return\n         *\/\n        public Set<EE> getUnmodifiableVertexEdges()\n        {\n            if (unmodifiableVertexEdges == null) {\n                unmodifiableVertexEdges =\n                    Collections.unmodifiableSet(vertexEdges);\n            }\n\n            return unmodifiableVertexEdges;\n        }\n\n        \/**\n         * .\n         *\n         * @param e\n         *\/\n        public void addEdge(EE e)\n        {\n            vertexEdges.add(e);\n        }\n\n        \/**\n         * .\n         *\n         * @return\n         *\/\n        public int edgeCount()\n        {\n            return vertexEdges.size();\n        }\n\n        \/**\n         * .\n         *\n         * @param e\n         *\/\n        public void removeEdge(EE e)\n        {\n            vertexEdges.remove(e);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A container of for vertex edges.\n     *\n     * <p>In this edge container we use array lists to minimize memory toll.\n     * However, for high-degree vertices we replace the entire edge container\n     * with a direct access subclass (to be implemented).<\/p>\n     *\n     * @author Barak Naveh\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A container of for vertex edges.\n\n<p>In this edge container we use array lists to minimize memory toll.\nHowever, for high-degree vertices we replace the entire edge container\nwith a direct access subclass (to be implemented).<\/p>'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 1017,col 5)-(line 1233,col 5)","classOrInterfaceTokenRange":"protected class UndirectedSpecifics\n        extends Specifics\n        implements Serializable\n    {\n        private static final long serialVersionUID = 6494588405178655873L;\n        private static final String NOT_IN_UNDIRECTED_GRAPH =\n            \"no such operation in an undirected graph\";\n\n        private Map<V, UndirectedEdgeContainer<V, E>> vertexMapUndirected;\n\n        public UndirectedSpecifics()\n        {\n            this(new LinkedHashMap<V, UndirectedEdgeContainer<V, E>>());\n        }\n\n        public UndirectedSpecifics(\n            Map<V, UndirectedEdgeContainer<V, E>> vertexMap)\n        {\n            this.vertexMapUndirected = vertexMap;\n        }\n\n        @Override public void addVertex(V v)\n        {\n            \/\/ add with a lazy edge container entry\n            vertexMapUndirected.put(v, null);\n        }\n\n        @Override public Set<V> getVertexSet()\n        {\n            return vertexMapUndirected.keySet();\n        }\n\n        \/**\n         * @see Graph#getAllEdges(Object, Object)\n         *\/\n        @Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n        {\n            Set<E> edges = null;\n\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                edges = new ArrayUnenforcedSet<E>();\n\n                Iterator<E> iter =\n                    getEdgeContainer(sourceVertex).vertexEdges.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    boolean equal =\n                        isEqualsStraightOrInverted(\n                            sourceVertex,\n                            targetVertex,\n                            e);\n\n                    if (equal) {\n                        edges.add(e);\n                    }\n                }\n            }\n\n            return edges;\n        }\n\n        \/**\n         * @see Graph#getEdge(Object, Object)\n         *\/\n        @Override public E getEdge(V sourceVertex, V targetVertex)\n        {\n            if (containsVertex(sourceVertex)\n                && containsVertex(targetVertex))\n            {\n                Iterator<E> iter =\n                    getEdgeContainer(sourceVertex).vertexEdges.iterator();\n\n                while (iter.hasNext()) {\n                    E e = iter.next();\n\n                    boolean equal =\n                        isEqualsStraightOrInverted(\n                            sourceVertex,\n                            targetVertex,\n                            e);\n\n                    if (equal) {\n                        return e;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        private boolean isEqualsStraightOrInverted(\n            Object sourceVertex,\n            Object targetVertex,\n            E e)\n        {\n            boolean equalStraight =\n                sourceVertex.equals(getEdgeSource(e))\n                && targetVertex.equals(getEdgeTarget(e));\n\n            boolean equalInverted =\n                sourceVertex.equals(getEdgeTarget(e))\n                && targetVertex.equals(getEdgeSource(e));\n            return equalStraight || equalInverted;\n        }\n\n        @Override public void addEdgeToTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).addEdge(e);\n\n            if (!source.equals(target)) {\n                getEdgeContainer(target).addEdge(e);\n            }\n        }\n\n        @Override public int degreeOf(V vertex)\n        {\n            if (allowingLoops) { \/\/ then we must count, and add loops twice\n\n                int degree = 0;\n                Set<E> edges = getEdgeContainer(vertex).vertexEdges;\n\n                for (E e : edges) {\n                    if (getEdgeSource(e).equals(getEdgeTarget(e))) {\n                        degree += 2;\n                    } else {\n                        degree += 1;\n                    }\n                }\n\n                return degree;\n            } else {\n                return getEdgeContainer(vertex).edgeCount();\n            }\n        }\n\n        \/**\n         * @see Graph#edgesOf(Object)\n         *\/\n        @Override public Set<E> edgesOf(V vertex)\n        {\n            return getEdgeContainer(vertex).getUnmodifiableVertexEdges();\n        }\n\n        \/**\n         * @see DirectedGraph#inDegreeOf(Object)\n         *\/\n        @Override public int inDegreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        \/**\n         * @see DirectedGraph#incomingEdgesOf(Object)\n         *\/\n        @Override public Set<E> incomingEdgesOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        \/**\n         * @see DirectedGraph#outDegreeOf(Object)\n         *\/\n        @Override public int outDegreeOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        \/**\n         * @see DirectedGraph#outgoingEdgesOf(Object)\n         *\/\n        @Override public Set<E> outgoingEdgesOf(V vertex)\n        {\n            throw new UnsupportedOperationException(NOT_IN_UNDIRECTED_GRAPH);\n        }\n\n        @Override public void removeEdgeFromTouchingVertices(E e)\n        {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            getEdgeContainer(source).removeEdge(e);\n\n            if (!source.equals(target)) {\n                getEdgeContainer(target).removeEdge(e);\n            }\n        }\n\n        \/**\n         * A lazy build of edge container for specified vertex.\n         *\n         * @param vertex a vertex in this graph.\n         *\n         * @return EdgeContainer\n         *\/\n        private UndirectedEdgeContainer<V, E> getEdgeContainer(V vertex)\n        {\n            assertVertexExist(vertex);\n\n            UndirectedEdgeContainer<V, E> ec = vertexMapUndirected.get(vertex);\n\n            if (ec == null) {\n                ec = new UndirectedEdgeContainer<V, E>(\n                    edgeSetFactory,\n                    vertex);\n                vertexMapUndirected.put(vertex, ec);\n            }\n\n            return ec;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * .\n     *\n     * @author Barak Naveh\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.getAllEdges(sourceVertex, targetVertex);\n}","methodRange":"(line 122,col 5)-(line 125,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        return specifics.getAllEdges(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#getAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if and only if graph loops are allowed.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if graph loops are allowed.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isAllowingLoops()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return allowingLoops;\n}","methodRange":"(line 134,col 5)-(line 137,col 5)","methodTokenRange":"public boolean isAllowingLoops()\n    {\n        return allowingLoops;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if and only if self-loops are allowed in this\n     * graph. A self loop is an edge that its source and target vertices are the\n     * same.\n     *\n     * @return <code>true<\/code> if and only if graph loops are allowed.\n     ","methodParameters":[],"methodName":"isAllowingLoops","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.isAllowingLoops","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if and only if self-loops are allowed in this\ngraph. A self loop is an edge that its source and target vertices are the\nsame.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if graph loops are allowed.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.isAllowingLoops()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if and only if multiple edges are allowed.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if multiple edges are allowed.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isAllowingMultipleEdges()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return allowingMultipleEdges;\n}","methodRange":"(line 146,col 5)-(line 149,col 5)","methodTokenRange":"public boolean isAllowingMultipleEdges()\n    {\n        return allowingMultipleEdges;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if and only if multiple edges are allowed in\n     * this graph. The meaning of multiple edges is that there can be many edges\n     * going from vertex v1 to vertex v2.\n     *\n     * @return <code>true<\/code> if and only if multiple edges are allowed.\n     ","methodParameters":[],"methodName":"isAllowingMultipleEdges","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.isAllowingMultipleEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if and only if multiple edges are allowed in\nthis graph. The meaning of multiple edges is that there can be many edges\ngoing from vertex v1 to vertex v2.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if multiple edges are allowed.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.isAllowingMultipleEdges()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.getEdge(sourceVertex, targetVertex);\n}","methodRange":"(line 154,col 5)-(line 157,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        return specifics.getEdge(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeFactory()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeFactory()'}]}', name=Optional.empty}"}],"methodDeclaration":"public EdgeFactory<V, E> getEdgeFactory()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeFactory;\n}","methodRange":"(line 162,col 5)-(line 165,col 5)","methodTokenRange":"@Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return edgeFactory;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @see Graph#getEdgeFactory()\n     ","methodParameters":[],"methodName":"getEdgeFactory","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getEdgeFactory","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeFactory()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"EdgeFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getEdgeFactory()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"factory to use for subsequently created edge sets\n(this call has no effect on existing edge sets)","javadocBlockTagName":"edgeSetFactory","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='factory to use for subsequently created edge sets\n(this call has no effect on existing edge sets)'}]}', name=Optional[edgeSetFactory]}"}],"methodDeclaration":"public void setEdgeSetFactory(EdgeSetFactory<V, E> edgeSetFactory)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.edgeSetFactory = edgeSetFactory;\n}","methodRange":"(line 175,col 5)-(line 178,col 5)","methodTokenRange":"public void setEdgeSetFactory(EdgeSetFactory<V, E> edgeSetFactory)\n    {\n        this.edgeSetFactory = edgeSetFactory;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Set the {@link EdgeSetFactory} to use for this graph. Initially, a graph\n     * is created with a default implementation which always supplies an {@link\n     * java.util.ArrayList} with capacity 1.\n     *\n     * @param edgeSetFactory factory to use for subsequently created edge sets\n     * (this call has no effect on existing edge sets)\n     ","methodParameters":[{"parameterType":"EdgeSetFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.EdgeSetFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.EdgeSetFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.EdgeSetFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.EdgeSetFactory<V, E>","parameter":"EdgeSetFactory<V, E> edgeSetFactory","parameterName":"edgeSetFactory"}],"methodName":"setEdgeSetFactory","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.setEdgeSetFactory","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the '}, JavadocInlineTag{tagName='link', type=LINK, content=' EdgeSetFactory'}, JavadocSnippet{text=' to use for this graph. Initially, a graph\nis created with a default implementation which always supplies an '}, JavadocInlineTag{tagName='link', type=LINK, content='\njava.util.ArrayList'}, JavadocSnippet{text=' with capacity 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='factory to use for subsequently created edge sets\n(this call has no effect on existing edge sets)'}]}', name=Optional[edgeSetFactory]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.setEdgeSetFactory(org.jgrapht.graph.EdgeSetFactory<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    if (!allowingMultipleEdges && containsEdge(sourceVertex, targetVertex)) {\n        return null;\n    }\n    if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n        throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n    }\n    E e = edgeFactory.createEdge(sourceVertex, targetVertex);\n    if (containsEdge(e)) {\n        return null;\n    } else {\n        IntrusiveEdge intrusiveEdge = createIntrusiveEdge(e, sourceVertex, targetVertex);\n        edgeMap.put(e, intrusiveEdge);\n        specifics.addEdgeToTouchingVertices(e);\n        return e;\n    }\n}","methodRange":"(line 183,col 5)-(line 212,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!allowingMultipleEdges\n            && containsEdge(sourceVertex, targetVertex))\n        {\n            return null;\n        }\n\n        if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n        }\n\n        E e = edgeFactory.createEdge(sourceVertex, targetVertex);\n\n        if (containsEdge(e)) { \/\/ this restriction should stay!\n\n            return null;\n        } else {\n            IntrusiveEdge intrusiveEdge =\n                createIntrusiveEdge(e, sourceVertex, targetVertex);\n\n            edgeMap.put(e, intrusiveEdge);\n            specifics.addEdgeToTouchingVertices(e);\n\n            return e;\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 191,col 20)-(line 191,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 202,col 20)-(line 202,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (e == null) {\n        throw new NullPointerException();\n    } else if (containsEdge(e)) {\n        return false;\n    }\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    if (!allowingMultipleEdges && containsEdge(sourceVertex, targetVertex)) {\n        return false;\n    }\n    if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n        throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n    }\n    IntrusiveEdge intrusiveEdge = createIntrusiveEdge(e, sourceVertex, targetVertex);\n    edgeMap.put(e, intrusiveEdge);\n    specifics.addEdgeToTouchingVertices(e);\n    return true;\n}","methodRange":"(line 217,col 5)-(line 245,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else if (containsEdge(e)) {\n            return false;\n        }\n\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!allowingMultipleEdges\n            && containsEdge(sourceVertex, targetVertex))\n        {\n            return false;\n        }\n\n        if (!allowingLoops && sourceVertex.equals(targetVertex)) {\n            throw new IllegalArgumentException(LOOPS_NOT_ALLOWED);\n        }\n\n        IntrusiveEdge intrusiveEdge =\n            createIntrusiveEdge(e, sourceVertex, targetVertex);\n\n        edgeMap.put(e, intrusiveEdge);\n        specifics.addEdgeToTouchingVertices(e);\n\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 219,col 18)-(line 219,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 222,col 20)-(line 222,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 231,col 20)-(line 231,col 24)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 244,col 16)-(line 244,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.addEdge(V, V, E)"},{"methodDeclaration":"private IntrusiveEdge createIntrusiveEdge(E e, V sourceVertex, V targetVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    IntrusiveEdge intrusiveEdge;\n    if (e instanceof IntrusiveEdge) {\n        intrusiveEdge = (IntrusiveEdge) e;\n    } else {\n        intrusiveEdge = new IntrusiveEdge();\n    }\n    intrusiveEdge.source = sourceVertex;\n    intrusiveEdge.target = targetVertex;\n    return intrusiveEdge;\n}","methodRange":"(line 247,col 5)-(line 261,col 5)","methodTokenRange":"private IntrusiveEdge createIntrusiveEdge(\n        E e,\n        V sourceVertex,\n        V targetVertex)\n    {\n        IntrusiveEdge intrusiveEdge;\n        if (e instanceof IntrusiveEdge) {\n            intrusiveEdge = (IntrusiveEdge) e;\n        } else {\n            intrusiveEdge = new IntrusiveEdge();\n        }\n        intrusiveEdge.source = sourceVertex;\n        intrusiveEdge.target = targetVertex;\n        return intrusiveEdge;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"createIntrusiveEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.createIntrusiveEdge","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IntrusiveEdge","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.createIntrusiveEdge(E, V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (v == null) {\n        throw new NullPointerException();\n    } else if (containsVertex(v)) {\n        return false;\n    } else {\n        specifics.addVertex(v);\n        return true;\n    }\n}","methodRange":"(line 266,col 5)-(line 277,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        if (v == null) {\n            throw new NullPointerException();\n        } else if (containsVertex(v)) {\n            return false;\n        } else {\n            specifics.addVertex(v);\n\n            return true;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 268,col 18)-(line 268,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 271,col 20)-(line 271,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 275,col 20)-(line 275,col 23)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeSource(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeSource(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return TypeUtil.uncheckedCast(getIntrusiveEdge(e).source, vertexTypeDecl);\n}","methodRange":"(line 282,col 5)-(line 287,col 5)","methodTokenRange":"@Override public V getEdgeSource(E e)\n    {\n        return TypeUtil.uncheckedCast(\n            getIntrusiveEdge(e).source,\n            vertexTypeDecl);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeSource(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getEdgeSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getEdgeSource(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeTarget(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeTarget(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return TypeUtil.uncheckedCast(getIntrusiveEdge(e).target, vertexTypeDecl);\n}","methodRange":"(line 292,col 5)-(line 297,col 5)","methodTokenRange":"@Override public V getEdgeTarget(E e)\n    {\n        return TypeUtil.uncheckedCast(\n            getIntrusiveEdge(e).target,\n            vertexTypeDecl);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeTarget(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getEdgeTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getEdgeTarget(E)"},{"methodDeclaration":"private IntrusiveEdge getIntrusiveEdge(E e)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (e instanceof IntrusiveEdge) {\n        return (IntrusiveEdge) e;\n    }\n    return edgeMap.get(e);\n}","methodRange":"(line 299,col 5)-(line 306,col 5)","methodTokenRange":"private IntrusiveEdge getIntrusiveEdge(E e)\n    {\n        if (e instanceof IntrusiveEdge) {\n            return (IntrusiveEdge) e;\n        }\n\n        return edgeMap.get(e);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getIntrusiveEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getIntrusiveEdge","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IntrusiveEdge","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getIntrusiveEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a shallow copy of this set.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a shallow copy of this set.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"RuntimeException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[RuntimeException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.lang.Object#clone()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#clone()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Object clone()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;\n        AbstractBaseGraph<V, E> newGraph = TypeUtil.uncheckedCast(super.clone(), typeDecl);\n        newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n        newGraph.edgeFactory = this.edgeFactory;\n        newGraph.unmodifiableEdgeSet = null;\n        newGraph.unmodifiableVertexSet = null;\n        newGraph.specifics = newGraph.createSpecifics();\n        Graphs.addGraph(newGraph, this);\n        return newGraph;\n    } catch (CloneNotSupportedException e) {\n        e.printStackTrace();\n        throw new RuntimeException();\n    }\n}","methodRange":"(line 318,col 5)-(line 344,col 5)","methodTokenRange":"@Override public Object clone()\n    {\n        try {\n            TypeUtil<AbstractBaseGraph<V, E>> typeDecl = null;\n\n            AbstractBaseGraph<V, E> newGraph =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n\n            newGraph.edgeMap = new LinkedHashMap<E, IntrusiveEdge>();\n\n            newGraph.edgeFactory = this.edgeFactory;\n            newGraph.unmodifiableEdgeSet = null;\n            newGraph.unmodifiableVertexSet = null;\n\n            \/\/ NOTE:  it's important for this to happen in an object\n            \/\/ method so that the new inner class instance gets associated with\n            \/\/ the right outer class instance\n            newGraph.specifics = newGraph.createSpecifics();\n\n            Graphs.addGraph(newGraph, this);\n\n            return newGraph;\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n            throw new RuntimeException();\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Returns a shallow copy of this graph instance. Neither edges nor vertices\n     * are cloned.\n     *\n     * @return a shallow copy of this set.\n     *\n     * @throws RuntimeException\n     *\n     * @see java.lang.Object#clone()\n     ","methodParameters":[],"methodName":"clone","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.clone","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a shallow copy of this graph instance. Neither edges nor vertices\nare cloned.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a shallow copy of this set.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[RuntimeException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#clone()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 321,col 58)-(line 321,col 61)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 329,col 44)-(line 329,col 47)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 330,col 46)-(line 330,col 49)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.clone()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeMap.containsKey(e);\n}","methodRange":"(line 349,col 5)-(line 352,col 5)","methodTokenRange":"@Override public boolean containsEdge(E e)\n    {\n        return edgeMap.containsKey(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.containsEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.containsEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.getVertexSet().contains(v);\n}","methodRange":"(line 357,col 5)-(line 360,col 5)","methodTokenRange":"@Override public boolean containsVertex(V v)\n    {\n        return specifics.getVertexSet().contains(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"containsVertex","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.containsVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.containsVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"UndirectedGraph#degreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.degreeOf(vertex);\n}","methodRange":"(line 365,col 5)-(line 368,col 5)","methodTokenRange":"public int degreeOf(V vertex)\n    {\n        return specifics.degreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see UndirectedGraph#degreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.degreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.degreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#edgeSet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgeSet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (unmodifiableEdgeSet == null) {\n        unmodifiableEdgeSet = Collections.unmodifiableSet(edgeMap.keySet());\n    }\n    return unmodifiableEdgeSet;\n}","methodRange":"(line 373,col 5)-(line 380,col 5)","methodTokenRange":"@Override public Set<E> edgeSet()\n    {\n        if (unmodifiableEdgeSet == null) {\n            unmodifiableEdgeSet = Collections.unmodifiableSet(edgeMap.keySet());\n        }\n\n        return unmodifiableEdgeSet;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#edgeSet()\n     ","methodParameters":[],"methodName":"edgeSet","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.edgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgeSet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 375,col 36)-(line 375,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.edgeSet()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#edgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.edgesOf(vertex);\n}","methodRange":"(line 385,col 5)-(line 388,col 5)","methodTokenRange":"@Override public Set<E> edgesOf(V vertex)\n    {\n        return specifics.edgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#edgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOf","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.edgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.edgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#inDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.inDegreeOf(vertex);\n}","methodRange":"(line 393,col 5)-(line 396,col 5)","methodTokenRange":"public int inDegreeOf(V vertex)\n    {\n        return specifics.inDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#inDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#incomingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.incomingEdgesOf(vertex);\n}","methodRange":"(line 401,col 5)-(line 404,col 5)","methodTokenRange":"public Set<E> incomingEdgesOf(V vertex)\n    {\n        return specifics.incomingEdgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.outDegreeOf(vertex);\n}","methodRange":"(line 409,col 5)-(line 412,col 5)","methodTokenRange":"public int outDegreeOf(V vertex)\n    {\n        return specifics.outDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#outDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outgoingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return specifics.outgoingEdgesOf(vertex);\n}","methodRange":"(line 417,col 5)-(line 420,col 5)","methodTokenRange":"public Set<E> outgoingEdgesOf(V vertex)\n    {\n        return specifics.outgoingEdgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.outgoingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E e = getEdge(sourceVertex, targetVertex);\n    if (e != null) {\n        specifics.removeEdgeFromTouchingVertices(e);\n        edgeMap.remove(e);\n    }\n    return e;\n}","methodRange":"(line 425,col 5)-(line 435,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = getEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            specifics.removeEdgeFromTouchingVertices(e);\n            edgeMap.remove(e);\n        }\n\n        return e;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 429,col 18)-(line 429,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (containsEdge(e)) {\n        specifics.removeEdgeFromTouchingVertices(e);\n        edgeMap.remove(e);\n        return true;\n    } else {\n        return false;\n    }\n}","methodRange":"(line 440,col 5)-(line 450,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        if (containsEdge(e)) {\n            specifics.removeEdgeFromTouchingVertices(e);\n            edgeMap.remove(e);\n\n            return true;\n        } else {\n            return false;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 446,col 20)-(line 446,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 448,col 20)-(line 448,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (containsVertex(v)) {\n        Set<E> touchingEdgesList = edgesOf(v);\n        removeAllEdges(new ArrayList<E>(touchingEdgesList));\n        specifics.getVertexSet().remove(v);\n        return true;\n    } else {\n        return false;\n    }\n}","methodRange":"(line 455,col 5)-(line 470,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            \/\/ cannot iterate over list - will cause\n            \/\/ ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            specifics.getVertexSet().remove(v); \/\/ remove the vertex itself\n\n            return true;\n        } else {\n            return false;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 466,col 20)-(line 466,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 468,col 20)-(line 468,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.removeVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#vertexSet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#vertexSet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> vertexSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (unmodifiableVertexSet == null) {\n        unmodifiableVertexSet = Collections.unmodifiableSet(specifics.getVertexSet());\n    }\n    return unmodifiableVertexSet;\n}","methodRange":"(line 475,col 5)-(line 483,col 5)","methodTokenRange":"@Override public Set<V> vertexSet()\n    {\n        if (unmodifiableVertexSet == null) {\n            unmodifiableVertexSet =\n                Collections.unmodifiableSet(specifics.getVertexSet());\n        }\n\n        return unmodifiableVertexSet;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#vertexSet()\n     ","methodParameters":[],"methodName":"vertexSet","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.vertexSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#vertexSet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 477,col 38)-(line 477,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.vertexSet()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (e instanceof DefaultWeightedEdge) {\n        return ((DefaultWeightedEdge) e).getWeight();\n    } else if (e == null) {\n        throw new NullPointerException();\n    } else {\n        return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n    }\n}","methodRange":"(line 488,col 5)-(line 497,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E e)\n    {\n        if (e instanceof DefaultWeightedEdge) {\n            return ((DefaultWeightedEdge) e).getWeight();\n        } else if (e == null) {\n            throw new NullPointerException();\n        } else {\n            return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @see Graph#getEdgeWeight(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.getEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 492,col 25)-(line 492,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.getEdgeWeight(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"WeightedGraph#setEdgeWeight(Object, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight(Object, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void setEdgeWeight(E e, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert (e instanceof DefaultWeightedEdge) : e.getClass();\n    ((DefaultWeightedEdge) e).weight = weight;\n}","methodRange":"(line 502,col 5)-(line 506,col 5)","methodTokenRange":"public void setEdgeWeight(E e, double weight)\n    {\n        assert (e instanceof DefaultWeightedEdge) : e.getClass();\n        ((DefaultWeightedEdge) e).weight = weight;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"setEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.setEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight(Object, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.setEdgeWeight(E, double)"},{"methodDeclaration":"private Specifics createSpecifics()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (this instanceof DirectedGraph<?, ?>) {\n        return createDirectedSpecifics();\n    } else if (this instanceof UndirectedGraph<?, ?>) {\n        return createUndirectedSpecifics();\n    } else {\n        throw new IllegalArgumentException(\"must be instance of either DirectedGraph or UndirectedGraph\");\n    }\n}","methodRange":"(line 508,col 5)-(line 518,col 5)","methodTokenRange":"private Specifics createSpecifics()\n    {\n        if (this instanceof DirectedGraph<?, ?>) {\n            return createDirectedSpecifics();\n        } else if (this instanceof UndirectedGraph<?, ?>) {\n            return createUndirectedSpecifics();\n        } else {\n            throw new IllegalArgumentException(\n                \"must be instance of either DirectedGraph or UndirectedGraph\");\n        }\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.AbstractBaseGraph.Specifics, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"createSpecifics","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.createSpecifics","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.AbstractBaseGraph.Specifics","methodType":"Specifics","literalExprs":[{"literalExprRange":"(line 516,col 17)-(line 516,col 77)","literalExprId":1,"literalExpr":"\"must be instance of either DirectedGraph or UndirectedGraph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.createSpecifics()"},{"methodDeclaration":"protected UndirectedSpecifics createUndirectedSpecifics()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return new UndirectedSpecifics();\n}","methodRange":"(line 520,col 5)-(line 523,col 5)","methodTokenRange":"protected UndirectedSpecifics createUndirectedSpecifics()\n    {\n        return new UndirectedSpecifics();\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"createUndirectedSpecifics","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.createUndirectedSpecifics","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.AbstractBaseGraph.UndirectedSpecifics","methodType":"UndirectedSpecifics","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.createUndirectedSpecifics()"},{"methodDeclaration":"protected DirectedSpecifics createDirectedSpecifics()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return new DirectedSpecifics();\n}","methodRange":"(line 525,col 5)-(line 528,col 5)","methodTokenRange":"protected DirectedSpecifics createDirectedSpecifics()\n    {\n        return new DirectedSpecifics();\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"createDirectedSpecifics","methodQualifiedSignature":"org.jgrapht.graph.AbstractBaseGraph.createDirectedSpecifics","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.AbstractBaseGraph.DirectedSpecifics","methodType":"DirectedSpecifics","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractBaseGraph.createDirectedSpecifics()"}],"classJavadoc":"\/**\n * The most general implementation of the {@link org.jgrapht.Graph} interface.\n * Its subclasses add various restrictions to get more specific graphs. The\n * decision whether it is directed or undirected is decided at construction time\n * and cannot be later modified (see constructor for details).\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashMap} and {@link LinkedHashSet}).<\/p>\n *\n * @author Barak Naveh\n * @since Jul 24, 2003\n *\/\n","className":"AbstractBaseGraph","fields":[{"fieldRange":"(line 73,col 5)-(line 73,col 71)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -1263088497616142427L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 73,col 51)-(line 73,col 70)","literalExprId":1,"literalExpr":"1263088497616142427L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-1263088497616142427L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 75,col 5)-(line 75,col 72)","fieldName":"LOOPS_NOT_ALLOWED","fieldJavadocComment":"","fieldTokenRange":"private static final String LOOPS_NOT_ALLOWED = \"loops not allowed\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 75,col 53)-(line 75,col 71)","literalExprId":1,"literalExpr":"\"loops not allowed\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"loops not allowed\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 77,col 5)-(line 77,col 26)","fieldName":"allowingLoops","fieldJavadocComment":"","fieldTokenRange":"boolean allowingLoops;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 79,col 5)-(line 79,col 42)","fieldName":"edgeFactory","fieldJavadocComment":"","fieldTokenRange":"private EdgeFactory<V, E> edgeFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"EdgeFactory<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>"},{"fieldRange":"(line 80,col 5)-(line 80,col 48)","fieldName":"edgeSetFactory","fieldJavadocComment":"","fieldTokenRange":"private EdgeSetFactory<V, E> edgeSetFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.EdgeSetFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.EdgeSetFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.EdgeSetFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"EdgeSetFactory<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.EdgeSetFactory<V, E>"},{"fieldRange":"(line 81,col 5)-(line 81,col 42)","fieldName":"edgeMap","fieldJavadocComment":"","fieldTokenRange":"private Map<E, IntrusiveEdge> edgeMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.graph.IntrusiveEdge, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<E, IntrusiveEdge>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<E, org.jgrapht.graph.IntrusiveEdge>"},{"fieldRange":"(line 82,col 5)-(line 82,col 56)","fieldName":"unmodifiableEdgeSet","fieldJavadocComment":"","fieldTokenRange":"private transient Set<E> unmodifiableEdgeSet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 82,col 52)-(line 82,col 55)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 83,col 5)-(line 83,col 58)","fieldName":"unmodifiableVertexSet","fieldJavadocComment":"","fieldTokenRange":"private transient Set<V> unmodifiableVertexSet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 83,col 54)-(line 83,col 57)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 84,col 5)-(line 84,col 32)","fieldName":"specifics","fieldJavadocComment":"","fieldTokenRange":"private Specifics specifics;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.AbstractBaseGraph.Specifics, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Specifics","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.AbstractBaseGraph.Specifics"},{"fieldRange":"(line 85,col 5)-(line 85,col 42)","fieldName":"allowingMultipleEdges","fieldJavadocComment":"","fieldTokenRange":"private boolean allowingMultipleEdges;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 87,col 5)-(line 87,col 56)","fieldName":"vertexTypeDecl","fieldJavadocComment":"","fieldTokenRange":"private transient TypeUtil<V> vertexTypeDecl = null;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.TypeUtil, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.TypeUtil.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 87,col 52)-(line 87,col 55)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"TypeUtil<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.TypeUtil<V>"}]}],"sourceFileId":38,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedWeightedPseudograph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedWeightedPseudograph.DirectedWeightedPseudograph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new directed weighted pseudograph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public DirectedWeightedPseudograph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"DirectedWeightedPseudograph","constructorQualifiedName":"org.jgrapht.graph.DirectedWeightedPseudograph.DirectedWeightedPseudograph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedPseudograph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed weighted pseudograph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedWeightedPseudograph.DirectedWeightedPseudograph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * Creates a new directed weighted pseudograph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public DirectedWeightedPseudograph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"DirectedWeightedPseudograph","constructorQualifiedName":"org.jgrapht.graph.DirectedWeightedPseudograph.DirectedWeightedPseudograph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedPseudograph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed weighted pseudograph with the specified edge\nfactory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(edgeClass));\n}","methodRange":"(line 77,col 5)-(line 84,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedPseudograph<V, E>>(\n                new DirectedWeightedPseudograph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedWeightedPseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedWeightedPseudograph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedPseudograph<V, E>>(new DirectedWeightedPseudograph<V, E>(ef));\n}","methodRange":"(line 86,col 5)-(line 93,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedPseudograph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedPseudograph<V, E>>(\n                new DirectedWeightedPseudograph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedWeightedPseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedPseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedWeightedPseudograph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A directed weighted pseudograph. A directed weighted pseudograph is a\n * non-simple directed graph in which both graph loops and multiple edges are\n * permitted, and edges have weights.\n *\/\n","className":"DirectedWeightedPseudograph","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 8762514879586423517L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"8762514879586423517L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[8762514879586423517L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":39,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.Multigraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.Multigraph.Multigraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 66,col 5)","constructorJavadocComment":"\n     * Creates a new multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public Multigraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"Multigraph","constructorQualifiedName":"org.jgrapht.graph.Multigraph.Multigraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public Multigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new multigraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.Multigraph.Multigraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a new multigraph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public Multigraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, true, false);\n}","constructorName":"Multigraph","constructorQualifiedName":"org.jgrapht.graph.Multigraph.Multigraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 75,col 19)-(line 75,col 22)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 75,col 25)-(line 75,col 29)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public Multigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, true, false);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new multigraph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(edgeClass));\n}","methodRange":"(line 78,col 5)-(line 83,col 5)","methodTokenRange":"public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends Multigraph<V, E>, ?> builder(Class<? extends E> edgeClass)\n    {\n        return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(\n            new Multigraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.Multigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Multigraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(new Multigraph<V, E>(ef));\n}","methodRange":"(line 85,col 5)-(line 90,col 5)","methodTokenRange":"public static <V, E> UndirectedGraphBuilderBase<V,\n        E, ? extends Multigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedGraphBuilder<V, E, Multigraph<V, E>>(\n            new Multigraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.Multigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedGraphBuilderBase<V, E, ? extends Multigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Multigraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A multigraph. A multigraph is a non-simple undirected graph in which no loops\n * are permitted, but multiple edges between any two vertices are. If you're\n * unsure about multigraphs, see: <a\n * href=\"http:\/\/mathworld.wolfram.com\/Multigraph.html\">\n * http:\/\/mathworld.wolfram.com\/Multigraph.html<\/a>.\n *\/\n","className":"Multigraph","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3257001055819871795L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 50)-(line 56,col 69)","literalExprId":1,"literalExpr":"3257001055819871795L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3257001055819871795L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":40,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DefaultDirectedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultDirectedGraph.DefaultDirectedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 67,col 5)","constructorJavadocComment":"\n     * Creates a new directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public DefaultDirectedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"DefaultDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.DefaultDirectedGraph.DefaultDirectedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public DefaultDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultDirectedGraph.DefaultDirectedGraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 74,col 5)-(line 77,col 5)","constructorJavadocComment":"\n     * Creates a new directed graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public DefaultDirectedGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, false, true);\n}","constructorName":"DefaultDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.DefaultDirectedGraph.DefaultDirectedGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 76,col 19)-(line 76,col 23)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 76,col 26)-(line 76,col 29)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public DefaultDirectedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, false, true);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed graph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(edgeClass));\n}","methodRange":"(line 79,col 5)-(line 85,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends DefaultDirectedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(\n            new DefaultDirectedGraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DefaultDirectedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultDirectedGraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(new DefaultDirectedGraph<V, E>(ef));\n}","methodRange":"(line 87,col 5)-(line 93,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends DefaultDirectedGraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedGraphBuilder<V, E, DefaultDirectedGraph<V, E>>(\n            new DefaultDirectedGraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DefaultDirectedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends DefaultDirectedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultDirectedGraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A directed graph. A default directed graph is a non-simple directed graph in\n * which multiple edges between any two vertices are <i>not<\/i> permitted, but\n * loops are.\n *\n * <p>prefixed 'Default' to avoid name collision with the DirectedGraph\n * interface.<\/p>\n *\/\n","className":"DefaultDirectedGraph","fields":[{"fieldRange":"(line 57,col 5)-(line 57,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3544953246956466230L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 57,col 50)-(line 57,col 69)","literalExprId":1,"literalExpr":"3544953246956466230L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3544953246956466230L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":41,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DefaultWeightedEdge","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"weight of this edge","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='weight of this edge'}]}', name=Optional.empty}"}],"methodDeclaration":"protected double getWeight()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return weight;\n}","methodRange":"(line 62,col 5)-(line 65,col 5)","methodTokenRange":"protected double getWeight()\n    {\n        return weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Retrieves the weight of this edge. This is protected, for use by\n     * subclasses only (e.g. for implementing toString).\n     *\n     * @return weight of this edge\n     ","methodParameters":[],"methodName":"getWeight","methodQualifiedSignature":"org.jgrapht.graph.DefaultWeightedEdge.getWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the weight of this edge. This is protected, for use by\nsubclasses only (e.g. for implementing toString).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='weight of this edge'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultWeightedEdge.getWeight()"}],"classJavadoc":"\/**\n * A default implementation for edges in a {@link WeightedGraph}. All access to\n * the weight of an edge must go through the graph interface, which is why this\n * class doesn't expose any public methods.\n *\n * @author John V. Sichi\n *\/\n","className":"DefaultWeightedEdge","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 69)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 229708706467350994L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 68)","literalExprId":1,"literalExpr":"229708706467350994L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[229708706467350994L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 54,col 5)-(line 54,col 54)","fieldName":"weight","fieldJavadocComment":"","fieldTokenRange":"double weight = WeightedGraph.DEFAULT_EDGE_WEIGHT;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[WeightedGraph.DEFAULT_EDGE_WEIGHT]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":42,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.ListenableDirectedWeightedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableDirectedWeightedGraph.ListenableDirectedWeightedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new listenable directed weighted graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public ListenableDirectedWeightedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}","constructorName":"ListenableDirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableDirectedWeightedGraph.ListenableDirectedWeightedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public ListenableDirectedWeightedGraph(Class<? extends E> edgeClass)\n    {\n        this(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable directed weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableDirectedWeightedGraph.ListenableDirectedWeightedGraph(org.jgrapht.WeightedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 71,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Creates a new listenable directed weighted graph.\n     *\n     * @param base the backing graph.\n     ","constructorDeclaration":"public ListenableDirectedWeightedGraph(WeightedGraph<V, E> base)","constructorBody":"{\n    super((DirectedGraph<V, E>) base);\n}","constructorName":"ListenableDirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableDirectedWeightedGraph.ListenableDirectedWeightedGraph","constructorParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> base","parameterName":"base"}],"literalExprs":[],"constructorTokenRange":"public ListenableDirectedWeightedGraph(WeightedGraph<V, E> base)\n    {\n        super((DirectedGraph<V, E>) base);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable directed weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * A directed weighted graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n *\/\n","className":"ListenableDirectedWeightedGraph","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3977582476627621938L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"3977582476627621938L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3977582476627621938L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":43,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedGraphUnion","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"DirectedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.DirectedGraphUnion.DirectedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.DirectedGraphUnion.DirectedGraphUnion(org.jgrapht.DirectedGraph<V, E>, org.jgrapht.DirectedGraph<V, E>, org.jgrapht.util.WeightCombiner)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"DirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g2","parameterName":"g2"},{"parameterType":"WeightCombiner","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.WeightCombiner, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.WeightCombiner","parameter":"WeightCombiner operator","parameterName":"operator"}],"literalExprs":[],"constructorTokenRange":"public DirectedGraphUnion(\n        DirectedGraph<V, E> g1,\n        DirectedGraph<V, E> g2,\n        WeightCombiner operator)\n    {\n        super(g1, g2, operator);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 50,col 5)-(line 56,col 5)","constructorJavadocComment":"","constructorDeclaration":"public DirectedGraphUnion(DirectedGraph<V, E> g1, DirectedGraph<V, E> g2, WeightCombiner operator)","constructorBody":"{\n    super(g1, g2, operator);\n}","constructorJavadoc":""},{"constructorName":"DirectedGraphUnion","constructorQualifiedName":"org.jgrapht.graph.DirectedGraphUnion.DirectedGraphUnion","constructorQualifiedSignature":"org.jgrapht.graph.DirectedGraphUnion.DirectedGraphUnion(org.jgrapht.DirectedGraph<V, E>, org.jgrapht.DirectedGraph<V, E>)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g1","parameterName":"g1"},{"parameterType":"DirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g2","parameterName":"g2"}],"literalExprs":[],"constructorTokenRange":"public DirectedGraphUnion(DirectedGraph<V, E> g1, DirectedGraph<V, E> g2)\n    {\n        super(g1, g2);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 58,col 5)-(line 61,col 5)","constructorJavadocComment":"","constructorDeclaration":"public DirectedGraphUnion(DirectedGraph<V, E> g1, DirectedGraph<V, E> g2)","constructorBody":"{\n    super(g1, g2);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = incomingEdgesOf(vertex);\n    return res.size();\n}","methodRange":"(line 63,col 5)-(line 67,col 5)","methodTokenRange":"@Override public int inDegreeOf(V vertex)\n    {\n        Set<E> res = incomingEdgesOf(vertex);\n        return res.size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedGraphUnion.inDegreeOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedGraphUnion.inDegreeOf(V)"},{"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new HashSet<E>();\n    if (getG1().containsVertex(vertex)) {\n        res.addAll(getG1().incomingEdgesOf(vertex));\n    }\n    if (getG2().containsVertex(vertex)) {\n        res.addAll(getG2().incomingEdgesOf(vertex));\n    }\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 69,col 5)-(line 79,col 5)","methodTokenRange":"@Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        Set<E> res = new HashSet<E>();\n        if (getG1().containsVertex(vertex)) {\n            res.addAll(getG1().incomingEdgesOf(vertex));\n        }\n        if (getG2().containsVertex(vertex)) {\n            res.addAll(getG2().incomingEdgesOf(vertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedGraphUnion.incomingEdgesOf","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedGraphUnion.incomingEdgesOf(V)"},{"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = outgoingEdgesOf(vertex);\n    return res.size();\n}","methodRange":"(line 81,col 5)-(line 85,col 5)","methodTokenRange":"@Override public int outDegreeOf(V vertex)\n    {\n        Set<E> res = outgoingEdgesOf(vertex);\n        return res.size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedGraphUnion.outDegreeOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedGraphUnion.outDegreeOf(V)"},{"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> res = new HashSet<E>();\n    if (getG1().containsVertex(vertex)) {\n        res.addAll(getG1().outgoingEdgesOf(vertex));\n    }\n    if (getG2().containsVertex(vertex)) {\n        res.addAll(getG2().outgoingEdgesOf(vertex));\n    }\n    return Collections.unmodifiableSet(res);\n}","methodRange":"(line 87,col 5)-(line 97,col 5)","methodTokenRange":"@Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        Set<E> res = new HashSet<E>();\n        if (getG1().containsVertex(vertex)) {\n            res.addAll(getG1().outgoingEdgesOf(vertex));\n        }\n        if (getG2().containsVertex(vertex)) {\n            res.addAll(getG2().outgoingEdgesOf(vertex));\n        }\n        return Collections.unmodifiableSet(res);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedGraphUnion.outgoingEdgesOf","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedGraphUnion.outgoingEdgesOf(V)"}],"classJavadoc":"","className":"DirectedGraphUnion","fields":[{"fieldRange":"(line 48,col 5)-(line 48,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -740199233080172450L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 48,col 51)-(line 48,col 69)","literalExprId":1,"literalExpr":"740199233080172450L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-740199233080172450L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":44,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AsUnweightedGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph over which an unweighted view is to be\ncreated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which an unweighted view is to be\ncreated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.AsUnweightedGraph.AsUnweightedGraph(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 78,col 5)-(line 81,col 5)","constructorJavadocComment":"\n     * Constructor for AsUnweightedGraph.\n     *\n     * @param g the backing graph over which an unweighted view is to be\n     * created.\n     ","constructorDeclaration":"public AsUnweightedGraph(Graph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"AsUnweightedGraph","constructorQualifiedName":"org.jgrapht.graph.AsUnweightedGraph.AsUnweightedGraph","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public AsUnweightedGraph(Graph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for AsUnweightedGraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which an unweighted view is to be\ncreated.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (e == null) {\n        throw new NullPointerException();\n    } else {\n        return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n    }\n}","methodRange":"(line 86,col 5)-(line 93,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E e)\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        } else {\n            return WeightedGraph.DEFAULT_EDGE_WEIGHT;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @see Graph#getEdgeWeight\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.AsUnweightedGraph.getEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 88,col 18)-(line 88,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AsUnweightedGraph.getEdgeWeight(E)"}],"classJavadoc":"","className":"AsUnweightedGraph","fields":[{"fieldRange":"(line 70,col 5)-(line 70,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"\n     ","fieldTokenRange":"private static final long serialVersionUID = 7175505077601824663L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 70,col 50)-(line 70,col 69)","literalExprId":1,"literalExpr":"7175505077601824663L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[7175505077601824663L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":45,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.EdgeSetFactory","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex for which the edge set is being created;\nsophisticated factories may be able to use this information to choose an\noptimal set representation (e.g. ArrayUnenforcedSet for a vertex expected\nto have low degree, and LinkedHashSet for a vertex expected to have high\ndegree)","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the edge set is being created;\nsophisticated factories may be able to use this information to choose an\noptimal set representation (e.g. ArrayUnenforcedSet for a vertex expected\nto have low degree, and LinkedHashSet for a vertex expected to have high\ndegree)'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"new set","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new set'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> createEdgeSet(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 65,col 5)-(line 65,col 42)","methodTokenRange":"public Set<E> createEdgeSet(V vertex);","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Create a new edge set for a particular vertex.\n     *\n     * @param vertex the vertex for which the edge set is being created;\n     * sophisticated factories may be able to use this information to choose an\n     * optimal set representation (e.g. ArrayUnenforcedSet for a vertex expected\n     * to have low degree, and LinkedHashSet for a vertex expected to have high\n     * degree)\n     *\n     * @return new set\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"createEdgeSet","methodQualifiedSignature":"org.jgrapht.graph.EdgeSetFactory.createEdgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new edge set for a particular vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the edge set is being created;\nsophisticated factories may be able to use this information to choose an\noptimal set representation (e.g. ArrayUnenforcedSet for a vertex expected\nto have low degree, and LinkedHashSet for a vertex expected to have high\ndegree)'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new set'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeSetFactory.createEdgeSet(V)"}],"classJavadoc":"\/**\n * A factory for edge sets. This interface allows the creator of a graph to\n * choose the {@link java.util.Set} implementation used internally by the graph\n * to maintain sets of edges. This provides control over performance tradeoffs\n * between memory and CPU usage.\n *\n * @author John V. Sichi\n *\/\n","className":"EdgeSetFactory","fields":[]}],"sourceFileId":46,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.GraphDelegator","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph (the delegate).","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph (the delegate).'}]}', name=Optional[g]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"iff <code>g==null<\/code>","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='iff <code>g==null<\/code>'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.GraphDelegator.GraphDelegator(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 83,col 5)-(line 92,col 5)","constructorJavadocComment":"\n     * Constructor for GraphDelegator.\n     *\n     * @param g the backing graph (the delegate).\n     *\n     * @throws IllegalArgumentException iff <code>g==null<\/code>\n     ","constructorDeclaration":"public GraphDelegator(Graph<V, E> g)","constructorBody":"{\n    super();\n    if (g == null) {\n        throw new IllegalArgumentException(\"g must not be null.\");\n    }\n    delegate = g;\n}","constructorName":"GraphDelegator","constructorQualifiedName":"org.jgrapht.graph.GraphDelegator.GraphDelegator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 87,col 18)-(line 87,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 88,col 48)-(line 88,col 68)","literalExprId":2,"literalExpr":"\"g must not be null.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public GraphDelegator(Graph<V, E> g)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"g must not be null.\");\n        }\n\n        delegate = g;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for GraphDelegator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph (the delegate).'}]}', name=Optional[g]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='iff <code>g==null<\/code>'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.getAllEdges(sourceVertex, targetVertex);\n}","methodRange":"(line 97,col 5)-(line 100,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        return delegate.getAllEdges(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#getAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.getAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.getAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.getEdge(sourceVertex, targetVertex);\n}","methodRange":"(line 105,col 5)-(line 108,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        return delegate.getEdge(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.getEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeFactory()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeFactory()'}]}', name=Optional.empty}"}],"methodDeclaration":"public EdgeFactory<V, E> getEdgeFactory()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.getEdgeFactory();\n}","methodRange":"(line 113,col 5)-(line 116,col 5)","methodTokenRange":"@Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return delegate.getEdgeFactory();\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @see Graph#getEdgeFactory()\n     ","methodParameters":[],"methodName":"getEdgeFactory","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.getEdgeFactory","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeFactory()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"EdgeFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.getEdgeFactory()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.addEdge(sourceVertex, targetVertex);\n}","methodRange":"(line 121,col 5)-(line 124,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        return delegate.addEdge(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.addEdge(sourceVertex, targetVertex, e);\n}","methodRange":"(line 129,col 5)-(line 132,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        return delegate.addEdge(sourceVertex, targetVertex, e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.addVertex(v);\n}","methodRange":"(line 137,col 5)-(line 140,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        return delegate.addVertex(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.containsEdge(e);\n}","methodRange":"(line 145,col 5)-(line 148,col 5)","methodTokenRange":"@Override public boolean containsEdge(E e)\n    {\n        return delegate.containsEdge(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.containsEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.containsEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.containsVertex(v);\n}","methodRange":"(line 153,col 5)-(line 156,col 5)","methodTokenRange":"@Override public boolean containsVertex(V v)\n    {\n        return delegate.containsVertex(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"containsVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.containsVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.containsVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"UndirectedGraph#degreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((UndirectedGraph<V, E>) delegate).degreeOf(vertex);\n}","methodRange":"(line 161,col 5)-(line 164,col 5)","methodTokenRange":"public int degreeOf(V vertex)\n    {\n        return ((UndirectedGraph<V, E>) delegate).degreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see UndirectedGraph#degreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.degreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.degreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#edgeSet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgeSet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.edgeSet();\n}","methodRange":"(line 169,col 5)-(line 172,col 5)","methodTokenRange":"@Override public Set<E> edgeSet()\n    {\n        return delegate.edgeSet();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#edgeSet()\n     ","methodParameters":[],"methodName":"edgeSet","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.edgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgeSet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.edgeSet()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#edgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.edgesOf(vertex);\n}","methodRange":"(line 177,col 5)-(line 180,col 5)","methodTokenRange":"@Override public Set<E> edgesOf(V vertex)\n    {\n        return delegate.edgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#edgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOf","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.edgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.edgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#inDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((DirectedGraph<V, ? extends E>) delegate).inDegreeOf(vertex);\n}","methodRange":"(line 185,col 5)-(line 188,col 5)","methodTokenRange":"public int inDegreeOf(V vertex)\n    {\n        return ((DirectedGraph<V, ? extends E>) delegate).inDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#inDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#incomingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((DirectedGraph<V, E>) delegate).incomingEdgesOf(vertex);\n}","methodRange":"(line 193,col 5)-(line 196,col 5)","methodTokenRange":"public Set<E> incomingEdgesOf(V vertex)\n    {\n        return ((DirectedGraph<V, E>) delegate).incomingEdgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((DirectedGraph<V, ? extends E>) delegate).outDegreeOf(vertex);\n}","methodRange":"(line 201,col 5)-(line 204,col 5)","methodTokenRange":"public int outDegreeOf(V vertex)\n    {\n        return ((DirectedGraph<V, ? extends E>) delegate).outDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#outDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outgoingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((DirectedGraph<V, E>) delegate).outgoingEdgesOf(vertex);\n}","methodRange":"(line 209,col 5)-(line 212,col 5)","methodTokenRange":"public Set<E> outgoingEdgesOf(V vertex)\n    {\n        return ((DirectedGraph<V, E>) delegate).outgoingEdgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.outgoingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.removeEdge(e);\n}","methodRange":"(line 217,col 5)-(line 220,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        return delegate.removeEdge(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.removeEdge(sourceVertex, targetVertex);\n}","methodRange":"(line 225,col 5)-(line 228,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        return delegate.removeEdge(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.removeVertex(v);\n}","methodRange":"(line 233,col 5)-(line 236,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        return delegate.removeVertex(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.removeVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.lang.Object#toString()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#toString()'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.toString();\n}","methodRange":"(line 241,col 5)-(line 244,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return delegate.toString();\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * @see java.lang.Object#toString()\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#toString()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.toString()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#vertexSet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#vertexSet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> vertexSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.vertexSet();\n}","methodRange":"(line 249,col 5)-(line 252,col 5)","methodTokenRange":"@Override public Set<V> vertexSet()\n    {\n        return delegate.vertexSet();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#vertexSet()\n     ","methodParameters":[],"methodName":"vertexSet","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.vertexSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#vertexSet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.vertexSet()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeSource(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeSource(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.getEdgeSource(e);\n}","methodRange":"(line 257,col 5)-(line 260,col 5)","methodTokenRange":"@Override public V getEdgeSource(E e)\n    {\n        return delegate.getEdgeSource(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeSource(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.getEdgeSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.getEdgeSource(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeTarget(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeTarget(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.getEdgeTarget(e);\n}","methodRange":"(line 265,col 5)-(line 268,col 5)","methodTokenRange":"@Override public V getEdgeTarget(E e)\n    {\n        return delegate.getEdgeTarget(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeTarget(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.getEdgeTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.getEdgeTarget(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.getEdgeWeight(e);\n}","methodRange":"(line 273,col 5)-(line 276,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E e)\n    {\n        return delegate.getEdgeWeight(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @see Graph#getEdgeWeight(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.getEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.getEdgeWeight(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"WeightedGraph#setEdgeWeight(Object, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight(Object, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void setEdgeWeight(E e, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ((WeightedGraph<V, E>) delegate).setEdgeWeight(e, weight);\n}","methodRange":"(line 281,col 5)-(line 284,col 5)","methodTokenRange":"public void setEdgeWeight(E e, double weight)\n    {\n        ((WeightedGraph<V, E>) delegate).setEdgeWeight(e, weight);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"setEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.GraphDelegator.setEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight(Object, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphDelegator.setEdgeWeight(E, double)"}],"classJavadoc":"\/**\n * A graph backed by the the graph specified at the constructor, which delegates\n * all its methods to the backing graph. Operations on this graph \"pass through\"\n * to the to the backing graph. Any modification made to this graph or the\n * backing graph is reflected by the other.\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods.<\/p>\n *\n * <p>This class is mostly used as a base for extending subclasses.<\/p>\n *\n * @author Barak Naveh\n * @since Jul 20, 2003\n *\/\n","className":"GraphDelegator","fields":[{"fieldRange":"(line 69,col 5)-(line 69,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3257005445226181425L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 69,col 50)-(line 69,col 69)","literalExprId":1,"literalExpr":"3257005445226181425L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3257005445226181425L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 74,col 5)-(line 74,col 33)","fieldName":"delegate","fieldJavadocComment":"\n     * The graph to which operations are delegated.\n     ","fieldTokenRange":"private Graph<V, E> delegate;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"The graph to which operations are delegated.\n","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"}]}],"sourceFileId":47,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DefaultListenableGraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.event.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.DefaultListenableGraph(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 88,col 5)-(line 91,col 5)","constructorJavadocComment":"\n     * Creates a new listenable graph.\n     *\n     * @param g the backing graph.\n     ","constructorDeclaration":"public DefaultListenableGraph(Graph<V, E> g)","constructorBody":"{\n    this(g, false);\n}","constructorName":"DefaultListenableGraph","constructorQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.DefaultListenableGraph","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 90,col 17)-(line 90,col 21)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public DefaultListenableGraph(Graph<V, E> g)\n    {\n        this(g, false);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to reuse previously fired event objects\ninstead of creating a new event object for each event.","javadocBlockTagName":"reuseEvents","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to reuse previously fired event objects\ninstead of creating a new event object for each event.'}]}', name=Optional[reuseEvents]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the backing graph is already a\nlistenable graph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the backing graph is already a\nlistenable graph.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.DefaultListenableGraph(org.jgrapht.Graph<V, E>, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 107,col 5)-(line 119,col 5)","constructorJavadocComment":"\n     * Creates a new listenable graph. If the <code>reuseEvents<\/code> flag is\n     * set to <code>true<\/code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @param g the backing graph.\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     *\n     * @throws IllegalArgumentException if the backing graph is already a\n     * listenable graph.\n     ","constructorDeclaration":"public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)","constructorBody":"{\n    super(g);\n    this.reuseEvents = reuseEvents;\n    reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n    reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n    if (g instanceof ListenableGraph<?, ?>) {\n        throw new IllegalArgumentException(\"base graph cannot be listenable\");\n    }\n}","constructorName":"DefaultListenableGraph","constructorQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.DefaultListenableGraph","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean reuseEvents","parameterName":"reuseEvents"}],"literalExprs":[{"literalExprRange":"(line 111,col 66)-(line 111,col 66)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 111,col 69)-(line 111,col 72)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 112,col 67)-(line 112,col 67)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 112,col 70)-(line 112,col 73)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 117,col 17)-(line 117,col 49)","literalExprId":5,"literalExpr":"\"base graph cannot be listenable\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public DefaultListenableGraph(Graph<V, E> g, boolean reuseEvents)\n    {\n        super(g);\n        this.reuseEvents = reuseEvents;\n        reuseableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, -1, null);\n        reuseableVertexEvent = new FlyweightVertexEvent<V>(this, -1, null);\n\n        \/\/ the following restriction could be probably relaxed in the future.\n        if (g instanceof ListenableGraph<?, ?>) {\n            throw new IllegalArgumentException(\n                \"base graph cannot be listenable\");\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable graph. If the <code>reuseEvents<\/code> flag is\nset to <code>true<\/code> this class will reuse previously fired events\nand will not create a new object for each event. This option increases\nperformance but should be used with care, especially in multithreaded\nenvironment.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to reuse previously fired event objects\ninstead of creating a new event object for each event.'}]}', name=Optional[reuseEvents]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the backing graph is already a\nlistenable graph.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 432,col 5)-(line 474,col 5)","classOrInterfaceTokenRange":"private static class FlyweightEdgeEvent<VV, EE>\n        extends GraphEdgeChangeEvent<VV, EE>\n    {\n        private static final long serialVersionUID = 3907207152526636089L;\n\n        \/**\n         * @see GraphEdgeChangeEvent#GraphEdgeChangeEvent(Object, int, Edge)\n         *\/\n        public FlyweightEdgeEvent(Object eventSource, int type, EE e)\n        {\n            super(eventSource, type, e);\n        }\n\n        \/**\n         * Sets the edge of this event.\n         *\n         * @param e the edge to be set.\n         *\/\n        protected void setEdge(EE e)\n        {\n            this.edge = e;\n        }\n\n        protected void setEdgeSource(VV v)\n        {\n            this.edgeSource = v;\n        }\n\n        protected void setEdgeTarget(VV v)\n        {\n            this.edgeTarget = v;\n        }\n\n        \/**\n         * Set the event type of this event.\n         *\n         * @param type the type to be set.\n         *\/\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A reuseable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A reuseable edge event.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 10, 2003'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 482,col 5)-(line 515,col 5)","classOrInterfaceTokenRange":"private static class FlyweightVertexEvent<VV>\n        extends GraphVertexChangeEvent<VV>\n    {\n        private static final long serialVersionUID = 3257848787857585716L;\n\n        \/**\n         * @see GraphVertexChangeEvent#GraphVertexChangeEvent(Object, int,\n         * Object)\n         *\/\n        public FlyweightVertexEvent(Object eventSource, int type, VV vertex)\n        {\n            super(eventSource, type, vertex);\n        }\n\n        \/**\n         * Set the event type of this event.\n         *\n         * @param type type to be set.\n         *\/\n        protected void setType(int type)\n        {\n            this.type = type;\n        }\n\n        \/**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         *\/\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A reuseable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 10, 2003\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A reuseable vertex event.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 10, 2003'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to reuse previously fired event objects\ninstead of creating a new event object for each event.","javadocBlockTagName":"reuseEvents","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to reuse previously fired event objects\ninstead of creating a new event object for each event.'}]}', name=Optional[reuseEvents]}"}],"methodDeclaration":"public void setReuseEvents(boolean reuseEvents)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.reuseEvents = reuseEvents;\n}","methodRange":"(line 130,col 5)-(line 133,col 5)","methodTokenRange":"public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * If the <code>reuseEvents<\/code> flag is set to <code>true<\/code> this\n     * class will reuse previously fired events and will not create a new object\n     * for each event. This option increases performance but should be used with\n     * care, especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean reuseEvents","parameterName":"reuseEvents"}],"methodName":"setReuseEvents","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.setReuseEvents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='If the <code>reuseEvents<\/code> flag is set to <code>true<\/code> this\nclass will reuse previously fired events and will not create a new object\nfor each event. This option increases performance but should be used with\ncare, especially in multithreaded environment.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to reuse previously fired event objects\ninstead of creating a new event object for each event.'}]}', name=Optional[reuseEvents]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.setReuseEvents(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the value of the <code>reuseEvents<\/code> flag.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value of the <code>reuseEvents<\/code> flag.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isReuseEvents()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return reuseEvents;\n}","methodRange":"(line 144,col 5)-(line 147,col 5)","methodTokenRange":"public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Tests whether the <code>reuseEvents<\/code> flag is set. If the flag is\n     * set to <code>true<\/code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents<\/code> flag.\n     ","methodParameters":[],"methodName":"isReuseEvents","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.isReuseEvents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests whether the <code>reuseEvents<\/code> flag is set. If the flag is\nset to <code>true<\/code> this class will reuse previously fired events\nand will not create a new object for each event. This option increases\nperformance but should be used with care, especially in multithreaded\nenvironment.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value of the <code>reuseEvents<\/code> flag.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.isReuseEvents()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E e = super.addEdge(sourceVertex, targetVertex);\n    if (e != null) {\n        fireEdgeAdded(e, sourceVertex, targetVertex);\n    }\n    return e;\n}","methodRange":"(line 152,col 5)-(line 161,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.addEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 156,col 18)-(line 156,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean added = super.addEdge(sourceVertex, targetVertex, e);\n    if (added) {\n        fireEdgeAdded(e, sourceVertex, targetVertex);\n    }\n    return added;\n}","methodRange":"(line 166,col 5)-(line 175,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        boolean added = super.addEdge(sourceVertex, targetVertex, e);\n\n        if (added) {\n            fireEdgeAdded(e, sourceVertex, targetVertex);\n        }\n\n        return added;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"ListenableGraph#addGraphListener(GraphListener)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#addGraphListener(GraphListener)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void addGraphListener(GraphListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    addToListenerList(graphListeners, l);\n}","methodRange":"(line 180,col 5)-(line 183,col 5)","methodTokenRange":"@Override public void addGraphListener(GraphListener<V, E> l)\n    {\n        addToListenerList(graphListeners, l);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see ListenableGraph#addGraphListener(GraphListener)\n     ","methodParameters":[{"parameterType":"GraphListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphListener<V, E>","parameter":"GraphListener<V, E> l","parameterName":"l"}],"methodName":"addGraphListener","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.addGraphListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#addGraphListener(GraphListener)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.addGraphListener(org.jgrapht.event.GraphListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean modified = super.addVertex(v);\n    if (modified) {\n        fireVertexAdded(v);\n    }\n    return modified;\n}","methodRange":"(line 188,col 5)-(line 197,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        boolean modified = super.addVertex(v);\n\n        if (modified) {\n            fireVertexAdded(v);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"ListenableGraph#addVertexSetListener(VertexSetListener)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#addVertexSetListener(VertexSetListener)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void addVertexSetListener(VertexSetListener<V> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    addToListenerList(vertexSetListeners, l);\n}","methodRange":"(line 202,col 5)-(line 205,col 5)","methodTokenRange":"@Override public void addVertexSetListener(VertexSetListener<V> l)\n    {\n        addToListenerList(vertexSetListeners, l);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see ListenableGraph#addVertexSetListener(VertexSetListener)\n     ","methodParameters":[{"parameterType":"VertexSetListener<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexSetListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexSetListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexSetListener<V>","parameter":"VertexSetListener<V> l","parameterName":"l"}],"methodName":"addVertexSetListener","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.addVertexSetListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#addVertexSetListener(VertexSetListener)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.addVertexSetListener(org.jgrapht.event.VertexSetListener<V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.lang.Object#clone()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#clone()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Object clone()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n        DefaultListenableGraph<V, E> g = TypeUtil.uncheckedCast(super.clone(), typeDecl);\n        g.graphListeners = new ArrayList<GraphListener<V, E>>();\n        g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n        return g;\n    } catch (CloneNotSupportedException e) {\n        e.printStackTrace();\n        throw new RuntimeException(\"internal error\");\n    }\n}","methodRange":"(line 210,col 5)-(line 226,col 5)","methodTokenRange":"@Override public Object clone()\n    {\n        try {\n            TypeUtil<DefaultListenableGraph<V, E>> typeDecl = null;\n\n            DefaultListenableGraph<V, E> g =\n                TypeUtil.uncheckedCast(super.clone(), typeDecl);\n            g.graphListeners = new ArrayList<GraphListener<V, E>>();\n            g.vertexSetListeners = new ArrayList<VertexSetListener<V>>();\n\n            return g;\n        } catch (CloneNotSupportedException e) {\n            \/\/ should never get here since we're Cloneable\n            e.printStackTrace();\n            throw new RuntimeException(\"internal error\");\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * @see java.lang.Object#clone()\n     ","methodParameters":[],"methodName":"clone","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.clone","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#clone()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 213,col 63)-(line 213,col 66)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 224,col 40)-(line 224,col 55)","literalExprId":2,"literalExpr":"\"internal error\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.clone()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E e = super.removeEdge(sourceVertex, targetVertex);\n    if (e != null) {\n        fireEdgeRemoved(e, sourceVertex, targetVertex);\n    }\n    return e;\n}","methodRange":"(line 231,col 5)-(line 240,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = super.removeEdge(sourceVertex, targetVertex);\n\n        if (e != null) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return e;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 235,col 18)-(line 235,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V sourceVertex = getEdgeSource(e);\n    V targetVertex = getEdgeTarget(e);\n    boolean modified = super.removeEdge(e);\n    if (modified) {\n        fireEdgeRemoved(e, sourceVertex, targetVertex);\n    }\n    return modified;\n}","methodRange":"(line 245,col 5)-(line 257,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        V sourceVertex = getEdgeSource(e);\n        V targetVertex = getEdgeTarget(e);\n\n        boolean modified = super.removeEdge(e);\n\n        if (modified) {\n            fireEdgeRemoved(e, sourceVertex, targetVertex);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"ListenableGraph#removeGraphListener(GraphListener)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#removeGraphListener(GraphListener)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void removeGraphListener(GraphListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    graphListeners.remove(l);\n}","methodRange":"(line 262,col 5)-(line 265,col 5)","methodTokenRange":"@Override public void removeGraphListener(GraphListener<V, E> l)\n    {\n        graphListeners.remove(l);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see ListenableGraph#removeGraphListener(GraphListener)\n     ","methodParameters":[{"parameterType":"GraphListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphListener<V, E>","parameter":"GraphListener<V, E> l","parameterName":"l"}],"methodName":"removeGraphListener","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.removeGraphListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#removeGraphListener(GraphListener)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.removeGraphListener(org.jgrapht.event.GraphListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (containsVertex(v)) {\n        Set<E> touchingEdgesList = edgesOf(v);\n        removeAllEdges(new ArrayList<E>(touchingEdgesList));\n        super.removeVertex(v);\n        fireVertexRemoved(v);\n        return true;\n    } else {\n        return false;\n    }\n}","methodRange":"(line 270,col 5)-(line 286,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        if (containsVertex(v)) {\n            Set<E> touchingEdgesList = edgesOf(v);\n\n            \/\/ copy set to avoid ConcurrentModificationException\n            removeAllEdges(new ArrayList<E>(touchingEdgesList));\n\n            super.removeVertex(v); \/\/ remove the vertex itself\n\n            fireVertexRemoved(v);\n\n            return true;\n        } else {\n            return false;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 282,col 20)-(line 282,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 284,col 20)-(line 284,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.removeVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"ListenableGraph#removeVertexSetListener(VertexSetListener)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#removeVertexSetListener(VertexSetListener)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void removeVertexSetListener(VertexSetListener<V> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    vertexSetListeners.remove(l);\n}","methodRange":"(line 291,col 5)-(line 294,col 5)","methodTokenRange":"@Override public void removeVertexSetListener(VertexSetListener<V> l)\n    {\n        vertexSetListeners.remove(l);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see ListenableGraph#removeVertexSetListener(VertexSetListener)\n     ","methodParameters":[{"parameterType":"VertexSetListener<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexSetListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexSetListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexSetListener<V>","parameter":"VertexSetListener<V> l","parameterName":"l"}],"methodName":"removeVertexSetListener","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.removeVertexSetListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='ListenableGraph#removeVertexSetListener(VertexSetListener)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.removeVertexSetListener(org.jgrapht.event.VertexSetListener<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge that was added.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that was added.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge source","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge source'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge target","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge target'}]}', name=Optional[target]}"}],"methodDeclaration":"protected void fireEdgeAdded(E edge, V source, V target)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    GraphEdgeChangeEvent<V, E> e = createGraphEdgeChangeEvent(GraphEdgeChangeEvent.EDGE_ADDED, edge, source, target);\n    for (GraphListener<V, E> l : graphListeners) {\n        l.edgeAdded(e);\n    }\n}","methodRange":"(line 303,col 5)-(line 315,col 5)","methodTokenRange":"protected void fireEdgeAdded(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_ADDED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeAdded(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notify listeners that the specified edge was added.\n     *\n     * @param edge the edge that was added.\n     * @param source edge source\n     * @param target edge target\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"}],"methodName":"fireEdgeAdded","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.fireEdgeAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notify listeners that the specified edge was added.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that was added.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge source'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge target'}]}', name=Optional[target]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.fireEdgeAdded(E, V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge that was removed.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that was removed.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge source","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge source'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge target","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge target'}]}', name=Optional[target]}"}],"methodDeclaration":"protected void fireEdgeRemoved(E edge, V source, V target)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    GraphEdgeChangeEvent<V, E> e = createGraphEdgeChangeEvent(GraphEdgeChangeEvent.EDGE_REMOVED, edge, source, target);\n    for (GraphListener<V, E> l : graphListeners) {\n        l.edgeRemoved(e);\n    }\n}","methodRange":"(line 324,col 5)-(line 336,col 5)","methodTokenRange":"protected void fireEdgeRemoved(E edge, V source, V target)\n    {\n        GraphEdgeChangeEvent<V, E> e =\n            createGraphEdgeChangeEvent(\n                GraphEdgeChangeEvent.EDGE_REMOVED,\n                edge,\n                source,\n                target);\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.edgeRemoved(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notify listeners that the specified edge was removed.\n     *\n     * @param edge the edge that was removed.\n     * @param source edge source\n     * @param target edge target\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"}],"methodName":"fireEdgeRemoved","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.fireEdgeRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notify listeners that the specified edge was removed.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that was removed.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge source'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge target'}]}', name=Optional[target]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.fireEdgeRemoved(E, V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex that was added.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that was added.'}]}', name=Optional[vertex]}"}],"methodDeclaration":"protected void fireVertexAdded(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    GraphVertexChangeEvent<V> e = createGraphVertexChangeEvent(GraphVertexChangeEvent.VERTEX_ADDED, vertex);\n    for (VertexSetListener<V> l : vertexSetListeners) {\n        l.vertexAdded(e);\n    }\n    for (GraphListener<V, E> l : graphListeners) {\n        l.vertexAdded(e);\n    }\n}","methodRange":"(line 343,col 5)-(line 357,col 5)","methodTokenRange":"protected void fireVertexAdded(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_ADDED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexAdded(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexAdded(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notify listeners that the specified vertex was added.\n     *\n     * @param vertex the vertex that was added.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"fireVertexAdded","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.fireVertexAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notify listeners that the specified vertex was added.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that was added.'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.fireVertexAdded(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex that was removed.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that was removed.'}]}', name=Optional[vertex]}"}],"methodDeclaration":"protected void fireVertexRemoved(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    GraphVertexChangeEvent<V> e = createGraphVertexChangeEvent(GraphVertexChangeEvent.VERTEX_REMOVED, vertex);\n    for (VertexSetListener<V> l : vertexSetListeners) {\n        l.vertexRemoved(e);\n    }\n    for (GraphListener<V, E> l : graphListeners) {\n        l.vertexRemoved(e);\n    }\n}","methodRange":"(line 364,col 5)-(line 378,col 5)","methodTokenRange":"protected void fireVertexRemoved(V vertex)\n    {\n        GraphVertexChangeEvent<V> e =\n            createGraphVertexChangeEvent(\n                GraphVertexChangeEvent.VERTEX_REMOVED,\n                vertex);\n\n        for (VertexSetListener<V> l : vertexSetListeners) {\n            l.vertexRemoved(e);\n        }\n\n        for (GraphListener<V, E> l : graphListeners) {\n            l.vertexRemoved(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notify listeners that the specified vertex was removed.\n     *\n     * @param vertex the vertex that was removed.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"fireVertexRemoved","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.fireVertexRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notify listeners that the specified vertex was removed.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that was removed.'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.fireVertexRemoved(V)"},{"methodDeclaration":"private static void addToListenerList(List<L> list, L l)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!list.contains(l)) {\n        list.add(l);\n    }\n}","methodRange":"(line 380,col 5)-(line 387,col 5)","methodTokenRange":"private static <L extends EventListener> void addToListenerList(\n        List<L> list,\n        L l)\n    {\n        if (!list.contains(l)) {\n            list.add(l);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"List<L>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(L, bounds=[EventListener])}}}}","parameterTypeResolvedDescribed":"java.util.List<L>","parameter":"List<L> list","parameterName":"list"},{"parameterType":"L","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(L, bounds=[EventListener])}","parameterTypeResolvedDescribed":"L","parameter":"L l","parameterName":"l"}],"methodName":"addToListenerList","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.addToListenerList","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.addToListenerList(java.util.List<L>, L)"},{"methodDeclaration":"private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(int eventType, E edge, V source, V target)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (reuseEvents) {\n        reuseableEdgeEvent.setType(eventType);\n        reuseableEdgeEvent.setEdge(edge);\n        reuseableEdgeEvent.setEdgeSource(source);\n        reuseableEdgeEvent.setEdgeTarget(target);\n        return reuseableEdgeEvent;\n    } else {\n        return new GraphEdgeChangeEvent<V, E>(this, eventType, edge, source, target);\n    }\n}","methodRange":"(line 389,col 5)-(line 410,col 5)","methodTokenRange":"private GraphEdgeChangeEvent<V, E> createGraphEdgeChangeEvent(\n        int eventType,\n        E edge,\n        V source,\n        V target)\n    {\n        if (reuseEvents) {\n            reuseableEdgeEvent.setType(eventType);\n            reuseableEdgeEvent.setEdge(edge);\n            reuseableEdgeEvent.setEdgeSource(source);\n            reuseableEdgeEvent.setEdgeTarget(target);\n\n            return reuseableEdgeEvent;\n        } else {\n            return new GraphEdgeChangeEvent<V, E>(\n                this,\n                eventType,\n                edge,\n                source,\n                target);\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int eventType","parameterName":"eventType"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":4,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"}],"methodName":"createGraphEdgeChangeEvent","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.createGraphEdgeChangeEvent","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"GraphEdgeChangeEvent<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.createGraphEdgeChangeEvent(int, E, V, V)"},{"methodDeclaration":"private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(int eventType, V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (reuseEvents) {\n        reuseableVertexEvent.setType(eventType);\n        reuseableVertexEvent.setVertex(vertex);\n        return reuseableVertexEvent;\n    } else {\n        return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n    }\n}","methodRange":"(line 412,col 5)-(line 424,col 5)","methodTokenRange":"private GraphVertexChangeEvent<V> createGraphVertexChangeEvent(\n        int eventType,\n        V vertex)\n    {\n        if (reuseEvents) {\n            reuseableVertexEvent.setType(eventType);\n            reuseableVertexEvent.setVertex(vertex);\n\n            return reuseableVertexEvent;\n        } else {\n            return new GraphVertexChangeEvent<V>(this, eventType, vertex);\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int eventType","parameterName":"eventType"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"createGraphVertexChangeEvent","methodQualifiedSignature":"org.jgrapht.graph.DefaultListenableGraph.createGraphVertexChangeEvent","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"GraphVertexChangeEvent<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultListenableGraph.createGraphVertexChangeEvent(int, V)"}],"classJavadoc":"\/**\n * A graph backed by the the graph specified at the constructor, which can be\n * listened by <code>GraphListener<\/code> s and by <code>\n * VertexSetListener<\/code> s. Operations on this graph \"pass through\" to the to\n * the backing graph. Any modification made to this graph or the backing graph\n * is reflected by the other.\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods.<\/p>\n *\n * @author Barak Naveh\n * @see GraphListener\n * @see VertexSetListener\n * @since Jul 20, 2003\n *\/\n","className":"DefaultListenableGraph","fields":[{"fieldRange":"(line 73,col 5)-(line 73,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3977575900898471984L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 73,col 50)-(line 73,col 69)","literalExprId":1,"literalExpr":"3977575900898471984L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3977575900898471984L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 75,col 5)-(line 76,col 45)","fieldName":"graphListeners","fieldJavadocComment":"","fieldTokenRange":"private List<GraphListener<V, E>> graphListeners =\n        new ArrayList<GraphListener<V, E>>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.event.GraphListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<GraphListener<V, E>>()]","fieldType":"List<GraphListener<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<org.jgrapht.event.GraphListener<V, E>>"},{"fieldRange":"(line 77,col 5)-(line 78,col 46)","fieldName":"vertexSetListeners","fieldJavadocComment":"","fieldTokenRange":"private List<VertexSetListener<V>> vertexSetListeners =\n        new ArrayList<VertexSetListener<V>>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.event.VertexSetListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexSetListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<VertexSetListener<V>>()]","fieldType":"List<VertexSetListener<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<org.jgrapht.event.VertexSetListener<V>>"},{"fieldRange":"(line 79,col 5)-(line 79,col 56)","fieldName":"reuseableEdgeEvent","fieldJavadocComment":"","fieldTokenRange":"private FlyweightEdgeEvent<V, E> reuseableEdgeEvent;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.DefaultListenableGraph.FlyweightEdgeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.DefaultListenableGraph.FlyweightEdgeEvent.VV=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.DefaultListenableGraph.FlyweightEdgeEvent.EE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"FlyweightEdgeEvent<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.DefaultListenableGraph.FlyweightEdgeEvent<V, E>"},{"fieldRange":"(line 80,col 5)-(line 80,col 57)","fieldName":"reuseableVertexEvent","fieldJavadocComment":"","fieldTokenRange":"private FlyweightVertexEvent<V> reuseableVertexEvent;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.DefaultListenableGraph.FlyweightVertexEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.DefaultListenableGraph.FlyweightVertexEvent.VV=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"FlyweightVertexEvent<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.DefaultListenableGraph.FlyweightVertexEvent<V>"},{"fieldRange":"(line 81,col 5)-(line 81,col 32)","fieldName":"reuseEvents","fieldJavadocComment":"","fieldTokenRange":"private boolean reuseEvents;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":48,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AsUndirectedGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing directed graph over which an undirected view is to\nbe created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing directed graph over which an undirected view is to\nbe created.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.AsUndirectedGraph(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 92,col 5)-(line 95,col 5)","constructorJavadocComment":"\n     * Constructor for AsUndirectedGraph.\n     *\n     * @param g the backing directed graph over which an undirected view is to\n     * be created.\n     ","constructorDeclaration":"public AsUndirectedGraph(DirectedGraph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"AsUndirectedGraph","constructorQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.AsUndirectedGraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public AsUndirectedGraph(DirectedGraph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for AsUndirectedGraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing directed graph over which an undirected view is to\nbe created.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> forwardList = super.getAllEdges(sourceVertex, targetVertex);\n    if (sourceVertex.equals(targetVertex)) {\n        return forwardList;\n    }\n    Set<E> reverseList = super.getAllEdges(targetVertex, sourceVertex);\n    Set<E> list = new ArrayUnenforcedSet<E>(forwardList.size() + reverseList.size());\n    list.addAll(forwardList);\n    list.addAll(reverseList);\n    return list;\n}","methodRange":"(line 100,col 5)-(line 117,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> forwardList = super.getAllEdges(sourceVertex, targetVertex);\n\n        if (sourceVertex.equals(targetVertex)) {\n            \/\/ avoid duplicating loops\n            return forwardList;\n        }\n\n        Set<E> reverseList = super.getAllEdges(targetVertex, sourceVertex);\n        Set<E> list =\n            new ArrayUnenforcedSet<E>(\n                forwardList.size() + reverseList.size());\n        list.addAll(forwardList);\n        list.addAll(reverseList);\n\n        return list;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#getAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.getAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.getAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E edge = super.getEdge(sourceVertex, targetVertex);\n    if (edge != null) {\n        return edge;\n    }\n    return super.getEdge(targetVertex, sourceVertex);\n}","methodRange":"(line 122,col 5)-(line 132,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        E edge = super.getEdge(sourceVertex, targetVertex);\n\n        if (edge != null) {\n            return edge;\n        }\n\n        \/\/ try the other direction\n        return super.getEdge(targetVertex, sourceVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 126,col 21)-(line 126,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.getEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(NO_EDGE_ADD);\n}","methodRange":"(line 137,col 5)-(line 140,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(NO_EDGE_ADD);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(NO_EDGE_ADD);\n}","methodRange":"(line 145,col 5)-(line 148,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        throw new UnsupportedOperationException(NO_EDGE_ADD);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"UndirectedGraph#degreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.inDegreeOf(vertex) + super.outDegreeOf(vertex);\n}","methodRange":"(line 153,col 5)-(line 157,col 5)","methodTokenRange":"@Override public int degreeOf(V vertex)\n    {\n        \/\/ this counts loops twice, which is consistent with AbstractBaseGraph\n        return super.inDegreeOf(vertex) + super.outDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see UndirectedGraph#degreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.degreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.degreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#inDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNDIRECTED);\n}","methodRange":"(line 162,col 5)-(line 165,col 5)","methodTokenRange":"@Override public int inDegreeOf(V vertex)\n    {\n        throw new UnsupportedOperationException(UNDIRECTED);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#inDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#incomingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNDIRECTED);\n}","methodRange":"(line 170,col 5)-(line 173,col 5)","methodTokenRange":"@Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        throw new UnsupportedOperationException(UNDIRECTED);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNDIRECTED);\n}","methodRange":"(line 178,col 5)-(line 181,col 5)","methodTokenRange":"@Override public int outDegreeOf(V vertex)\n    {\n        throw new UnsupportedOperationException(UNDIRECTED);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#outDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outgoingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNDIRECTED);\n}","methodRange":"(line 186,col 5)-(line 189,col 5)","methodTokenRange":"@Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        throw new UnsupportedOperationException(UNDIRECTED);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.outgoingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"AbstractBaseGraph#toString()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AbstractBaseGraph#toString()'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.toStringFromSets(vertexSet(), edgeSet(), false);\n}","methodRange":"(line 194,col 5)-(line 197,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return super.toStringFromSets(vertexSet(), edgeSet(), false);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * @see AbstractBaseGraph#toString()\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.graph.AsUndirectedGraph.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AbstractBaseGraph#toString()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 196,col 63)-(line 196,col 67)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AsUndirectedGraph.toString()"}],"classJavadoc":"\/**\n * An undirected view of the backing directed graph specified in the\n * constructor. This graph allows modules to apply algorithms designed for\n * undirected graphs to a directed graph by simply ignoring edge direction. If\n * the backing directed graph is an <a\n * href=\"http:\/\/mathworld.wolfram.com\/OrientedGraph.html\">oriented graph<\/a>,\n * then the view will be a simple graph; otherwise, it will be a multigraph.\n * Query operations on this graph \"read through\" to the backing graph. Attempts\n * to add edges will result in an <code>UnsupportedOperationException<\/code>,\n * but vertex addition\/removal and edge removal are all supported (and\n * immediately reflected in the backing graph).\n *\n * <p>Note that edges returned by this graph's accessors are really just the\n * edges of the underlying directed graph. Since there is no interface\n * distinction between directed and undirected edges, this detail should be\n * irrelevant to algorithms.<\/p>\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods. This graph will be serializable if the backing\n * graph is serializable.<\/p>\n *\n * @author John V. Sichi\n * @since Aug 14, 2003\n *\/\n","className":"AsUndirectedGraph","fields":[{"fieldRange":"(line 80,col 5)-(line 80,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":" @todo renew","fieldTokenRange":"private static final long serialVersionUID = 3257845485078065462L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 80,col 50)-(line 80,col 69)","literalExprId":1,"literalExpr":"3257845485078065462L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3257845485078065462L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 81,col 5)-(line 82,col 52)","fieldName":"NO_EDGE_ADD","fieldJavadocComment":"","fieldTokenRange":"private static final String NO_EDGE_ADD =\n        \"this graph does not support edge addition\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 82,col 9)-(line 82,col 51)","literalExprId":1,"literalExpr":"\"this graph does not support edge addition\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"this graph does not support edge addition\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 83,col 5)-(line 84,col 57)","fieldName":"UNDIRECTED","fieldJavadocComment":"","fieldTokenRange":"private static final String UNDIRECTED =\n        \"this graph only supports undirected operations\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 84,col 9)-(line 84,col 56)","literalExprId":1,"literalExpr":"\"this graph only supports undirected operations\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"this graph only supports undirected operations\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":49,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.ClassBasedVertexFactory","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"ClassBasedVertexFactory","constructorQualifiedName":"org.jgrapht.graph.ClassBasedVertexFactory.ClassBasedVertexFactory","constructorQualifiedSignature":"org.jgrapht.graph.ClassBasedVertexFactory.ClassBasedVertexFactory(java.lang.Class<? extends V>)","constructorParameters":[{"parameterType":"Class<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends V>","parameter":"Class<? extends V> vertexClass","parameterName":"vertexClass"}],"literalExprs":[],"constructorTokenRange":"public ClassBasedVertexFactory(Class<? extends V> vertexClass)\n    {\n        this.vertexClass = vertexClass;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 52,col 5)-(line 55,col 5)","constructorJavadocComment":"","constructorDeclaration":"public ClassBasedVertexFactory(Class<? extends V> vertexClass)","constructorBody":"{\n    this.vertexClass = vertexClass;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexFactory#createVertex()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexFactory#createVertex()'}]}', name=Optional.empty}"}],"methodDeclaration":"public V createVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        return this.vertexClass.newInstance();\n    } catch (Exception e) {\n        throw new RuntimeException(\"Vertex factory failed\", e);\n    }\n}","methodRange":"(line 60,col 5)-(line 67,col 5)","methodTokenRange":"@Override public V createVertex()\n    {\n        try {\n            return this.vertexClass.newInstance();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Vertex factory failed\", e);\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see VertexFactory#createVertex()\n     ","methodParameters":[],"methodName":"createVertex","methodQualifiedSignature":"org.jgrapht.graph.ClassBasedVertexFactory.createVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexFactory#createVertex()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 65,col 40)-(line 65,col 62)","literalExprId":1,"literalExpr":"\"Vertex factory failed\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.ClassBasedVertexFactory.createVertex()"}],"classJavadoc":"\/**\n * A {@link VertexFactory} for producing vertices by using a class as a factory.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"ClassBasedVertexFactory","fields":[{"fieldRange":"(line 50,col 5)-(line 50,col 49)","fieldName":"vertexClass","fieldJavadocComment":"","fieldTokenRange":"private final Class<? extends V> vertexClass;","fieldTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Class<? extends V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Class<? extends V>"}]}],"sourceFileId":50,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DefaultEdge","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"source of this edge","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='source of this edge'}]}', name=Optional.empty}"}],"methodDeclaration":"protected Object getSource()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return source;\n}","methodRange":"(line 62,col 5)-(line 65,col 5)","methodTokenRange":"protected Object getSource()\n    {\n        return source;\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Retrieves the source of this edge. This is protected, for use by\n     * subclasses only (e.g. for implementing toString).\n     *\n     * @return source of this edge\n     ","methodParameters":[],"methodName":"getSource","methodQualifiedSignature":"org.jgrapht.graph.DefaultEdge.getSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the source of this edge. This is protected, for use by\nsubclasses only (e.g. for implementing toString).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='source of this edge'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultEdge.getSource()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"target of this edge","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='target of this edge'}]}', name=Optional.empty}"}],"methodDeclaration":"protected Object getTarget()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return target;\n}","methodRange":"(line 73,col 5)-(line 76,col 5)","methodTokenRange":"protected Object getTarget()\n    {\n        return target;\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Retrieves the target of this edge. This is protected, for use by\n     * subclasses only (e.g. for implementing toString).\n     *\n     * @return target of this edge\n     ","methodParameters":[],"methodName":"getTarget","methodQualifiedSignature":"org.jgrapht.graph.DefaultEdge.getTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the target of this edge. This is protected, for use by\nsubclasses only (e.g. for implementing toString).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='target of this edge'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultEdge.getTarget()"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return \"(\" + source + \" : \" + target + \")\";\n}","methodRange":"(line 78,col 5)-(line 81,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return \"(\" + source + \" : \" + target + \")\";\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.graph.DefaultEdge.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 80,col 16)-(line 80,col 18)","literalExprId":1,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 80,col 31)-(line 80,col 35)","literalExprId":2,"literalExpr":"\" : \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 80,col 48)-(line 80,col 50)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DefaultEdge.toString()"}],"classJavadoc":"\/**\n * A default implementation for edges in a {@link Graph}.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n *\/\n","className":"DefaultEdge","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3258408452177932855L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"3258408452177932855L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3258408452177932855L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":51,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.MaskVertexSet","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.util.*;\n"},{"importId":3,"import":"import org.jgrapht.util.PrefetchIterator.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"MaskVertexSet","constructorQualifiedName":"org.jgrapht.graph.MaskVertexSet.MaskVertexSet","constructorQualifiedSignature":"org.jgrapht.graph.MaskVertexSet.MaskVertexSet(java.util.Set<V>, org.jgrapht.graph.MaskFunctor<V, E>)","constructorParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSet","parameterName":"vertexSet"},{"parameterType":"MaskFunctor<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>","parameter":"MaskFunctor<V, E> mask","parameterName":"mask"}],"literalExprs":[{"literalExprRange":"(line 65,col 22)-(line 65,col 22)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public MaskVertexSet(Set<V> vertexSet, MaskFunctor<V, E> mask)\n    {\n        this.vertexSet = vertexSet;\n        this.mask = mask;\n        this.size = -1;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 66,col 5)","constructorJavadocComment":"","constructorDeclaration":"public MaskVertexSet(Set<V> vertexSet, MaskFunctor<V, E> mask)","constructorBody":"{\n    this.vertexSet = vertexSet;\n    this.mask = mask;\n    this.size = -1;\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 101,col 5)-(line 120,col 5)","classOrInterfaceTokenRange":"private class MaskVertexSetNextElementFunctor\n        implements NextElementFunctor<V>\n    {\n        private Iterator<V> iter;\n\n        public MaskVertexSetNextElementFunctor()\n        {\n            this.iter = MaskVertexSet.this.vertexSet.iterator();\n        }\n\n        @Override public V nextElement()\n            throws NoSuchElementException\n        {\n            V element = this.iter.next();\n            while (MaskVertexSet.this.mask.isVertexMasked(element)) {\n                element = this.iter.next();\n            }\n            return element;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Collection#contains(java.lang.Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Collection#contains(java.lang.Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean contains(Object o)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return !this.mask.isVertexMasked(TypeUtil.uncheckedCast(o, vertexTypeDecl)) && this.vertexSet.contains(o);\n}","methodRange":"(line 71,col 5)-(line 76,col 5)","methodTokenRange":"@Override public boolean contains(Object o)\n    {\n        return\n            !this.mask.isVertexMasked(TypeUtil.uncheckedCast(o, vertexTypeDecl))\n            && this.vertexSet.contains(o);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see java.util.Collection#contains(java.lang.Object)\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"contains","methodQualifiedSignature":"org.jgrapht.graph.MaskVertexSet.contains","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Collection#contains(java.lang.Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskVertexSet.contains(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Set#iterator()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#iterator()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Iterator<V> iterator()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new PrefetchIterator<V>(new MaskVertexSetNextElementFunctor());\n}","methodRange":"(line 81,col 5)-(line 84,col 5)","methodTokenRange":"@Override public Iterator<V> iterator()\n    {\n        return new PrefetchIterator<V>(new MaskVertexSetNextElementFunctor());\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * @see java.util.Set#iterator()\n     ","methodParameters":[],"methodName":"iterator","methodQualifiedSignature":"org.jgrapht.graph.MaskVertexSet.iterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#iterator()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<V>","methodType":"Iterator<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskVertexSet.iterator()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Set#size()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#size()'}]}', name=Optional.empty}"}],"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (this.size == -1) {\n        this.size = 0;\n        for (Iterator<V> iter = iterator(); iter.hasNext(); ) {\n            iter.next();\n            this.size++;\n        }\n    }\n    return this.size;\n}","methodRange":"(line 89,col 5)-(line 99,col 5)","methodTokenRange":"@Override public int size()\n    {\n        if (this.size == -1) {\n            this.size = 0;\n            for (Iterator<V> iter = iterator(); iter.hasNext();) {\n                iter.next();\n                this.size++;\n            }\n        }\n        return this.size;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see java.util.Set#size()\n     ","methodParameters":[],"methodName":"size","methodQualifiedSignature":"org.jgrapht.graph.MaskVertexSet.size","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Set#size()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 91,col 27)-(line 91,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 25)-(line 92,col 25)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.MaskVertexSet.size()"}],"classJavadoc":"\/**\n * Helper for {@link MaskSubgraph}.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"MaskVertexSet","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 35)","fieldName":"mask","fieldJavadocComment":"","fieldTokenRange":"private MaskFunctor<V, E> mask;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"MaskFunctor<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>"},{"fieldRange":"(line 55,col 5)-(line 55,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 57,col 5)-(line 57,col 29)","fieldName":"vertexSet","fieldJavadocComment":"","fieldTokenRange":"private Set<V> vertexSet;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 59,col 5)-(line 59,col 56)","fieldName":"vertexTypeDecl","fieldJavadocComment":"","fieldTokenRange":"private transient TypeUtil<V> vertexTypeDecl = null;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.TypeUtil, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.TypeUtil.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 59,col 52)-(line 59,col 55)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"TypeUtil<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.TypeUtil<V>"}]}],"sourceFileId":52,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.ListenableUndirectedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableUndirectedGraph.ListenableUndirectedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * Creates a new listenable undirected simple graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public ListenableUndirectedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new SimpleGraph<V, E>(edgeClass));\n}","constructorName":"ListenableUndirectedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableUndirectedGraph.ListenableUndirectedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public ListenableUndirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new SimpleGraph<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable undirected simple graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableUndirectedGraph.ListenableUndirectedGraph(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 73,col 5)","constructorJavadocComment":"\n     * Creates a new listenable undirected graph.\n     *\n     * @param base the backing graph.\n     ","constructorDeclaration":"public ListenableUndirectedGraph(UndirectedGraph<V, E> base)","constructorBody":"{\n    super(base);\n}","constructorName":"ListenableUndirectedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableUndirectedGraph.ListenableUndirectedGraph","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> base","parameterName":"base"}],"literalExprs":[],"constructorTokenRange":"public ListenableUndirectedGraph(UndirectedGraph<V, E> base)\n    {\n        super(base);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable undirected graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * An undirected graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n *\/\n","className":"ListenableUndirectedGraph","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3256999969193145905L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3256999969193145905L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3256999969193145905L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":53,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedWeightedSubgraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.","javadocBlockTagName":"vertexSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.","javadocBlockTagName":"edgeSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedWeightedSubgraph.DirectedWeightedSubgraph(org.jgrapht.WeightedGraph<V, E>, java.util.Set<V>, java.util.Set<E>)","variableDeclarationExprs":[],"constructorRange":"(line 67,col 5)-(line 73,col 5)","constructorJavadocComment":"\n     * Creates a new weighted directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null<\/code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null<\/code> then all the edges whose vertices found in the graph are\n     * included.\n     ","constructorDeclaration":"public DirectedWeightedSubgraph(WeightedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset)","constructorBody":"{\n    super((DirectedGraph<V, E>) base, vertexSubset, edgeSubset);\n}","constructorName":"DirectedWeightedSubgraph","constructorQualifiedName":"org.jgrapht.graph.DirectedWeightedSubgraph.DirectedWeightedSubgraph","constructorParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> base","parameterName":"base"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSubset","parameterName":"vertexSubset"},{"parameterType":"Set<E>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSubset","parameterName":"edgeSubset"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedSubgraph(\n        WeightedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super((DirectedGraph<V, E>) base, vertexSubset, edgeSubset);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new weighted directed subgraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * A directed weighted graph that is a subgraph on other graph.\n *\n * @see Subgraph\n *\/\n","className":"DirectedWeightedSubgraph","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3905799799168250680L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 55,col 50)-(line 55,col 69)","literalExprId":1,"literalExpr":"3905799799168250680L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3905799799168250680L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":54,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.ListenableUndirectedWeightedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableUndirectedWeightedGraph.ListenableUndirectedWeightedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 62,col 5)-(line 65,col 5)","constructorJavadocComment":"\n     * Creates a new listenable undirected weighted graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public ListenableUndirectedWeightedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new SimpleWeightedGraph<V, E>(edgeClass));\n}","constructorName":"ListenableUndirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableUndirectedWeightedGraph.ListenableUndirectedWeightedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public ListenableUndirectedWeightedGraph(Class<? extends E> edgeClass)\n    {\n        this(new SimpleWeightedGraph<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable undirected weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableUndirectedWeightedGraph.ListenableUndirectedWeightedGraph(org.jgrapht.WeightedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * Creates a new listenable undirected weighted graph.\n     *\n     * @param base the backing graph.\n     ","constructorDeclaration":"public ListenableUndirectedWeightedGraph(WeightedGraph<V, E> base)","constructorBody":"{\n    super((UndirectedGraph<V, E>) base);\n}","constructorName":"ListenableUndirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableUndirectedWeightedGraph.ListenableUndirectedWeightedGraph","constructorParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> base","parameterName":"base"}],"literalExprs":[],"constructorTokenRange":"public ListenableUndirectedWeightedGraph(WeightedGraph<V, E> base)\n    {\n        super((UndirectedGraph<V, E>) base);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable undirected weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * An undirected weighted graph which is also {@link\n * org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n *\/\n","className":"ListenableUndirectedWeightedGraph","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3690762799613949747L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 55,col 50)-(line 55,col 69)","literalExprId":1,"literalExpr":"3690762799613949747L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3690762799613949747L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":55,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AsUnweightedDirectedGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph over which an unweighted view is to be\ncreated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which an unweighted view is to be\ncreated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.AsUnweightedDirectedGraph.AsUnweightedDirectedGraph(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 74,col 5)-(line 77,col 5)","constructorJavadocComment":"\n     * Constructor for AsUnweightedGraph.\n     *\n     * @param g the backing graph over which an unweighted view is to be\n     * created.\n     ","constructorDeclaration":"public AsUnweightedDirectedGraph(DirectedGraph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"AsUnweightedDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.AsUnweightedDirectedGraph.AsUnweightedDirectedGraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public AsUnweightedDirectedGraph(DirectedGraph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for AsUnweightedGraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which an unweighted view is to be\ncreated.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * An unweighted view of the backing weighted graph specified in the\n * constructor. This graph allows modules to apply algorithms designed for\n * unweighted graphs to a weighted graph by simply ignoring edge weights. Query\n * operations on this graph \"read through\" to the backing graph. Vertex\n * addition\/removal and edge addition\/removal are all supported (and immediately\n * reflected in the backing graph).\n *\n * <p>Note that edges returned by this graph's accessors are really just the\n * edges of the underlying directed graph.<\/p>\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods. This graph will be serializable if the backing\n * graph is serializable.<\/p>\n *\n * @author Lucas J. Scharenbroich\n * @author Joris Kinable\n * @since Sep 7, 2007\n *\/\n","className":"AsUnweightedDirectedGraph","fields":[]}],"sourceFileId":56,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DefaultDirectedWeightedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultDirectedWeightedGraph.DefaultDirectedWeightedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 66,col 5)","constructorJavadocComment":"\n     * Creates a new directed weighted graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public DefaultDirectedWeightedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"DefaultDirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.DefaultDirectedWeightedGraph.DefaultDirectedWeightedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public DefaultDirectedWeightedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DefaultDirectedWeightedGraph.DefaultDirectedWeightedGraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a new directed weighted graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public DefaultDirectedWeightedGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"DefaultDirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.DefaultDirectedWeightedGraph.DefaultDirectedWeightedGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public DefaultDirectedWeightedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed weighted graph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n}","methodRange":"(line 78,col 5)-(line 85,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DefaultDirectedWeightedGraph<V, E>>(\n                new DefaultDirectedWeightedGraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DefaultDirectedWeightedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultDirectedWeightedGraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, DefaultDirectedWeightedGraph<V, E>>(new DefaultDirectedWeightedGraph<V, E>(ef));\n}","methodRange":"(line 87,col 5)-(line 94,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DefaultDirectedWeightedGraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DefaultDirectedWeightedGraph<V, E>>(\n                new DefaultDirectedWeightedGraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DefaultDirectedWeightedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends DefaultDirectedWeightedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DefaultDirectedWeightedGraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A directed weighted graph. A directed weighted graph is a non-simple directed\n * graph in which multiple edges between any two vertices are <i>not<\/i>\n * permitted, but loops are. The graph has weights on its edges.\n *\n * @see DefaultDirectedGraph\n *\/\n","className":"DefaultDirectedWeightedGraph","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3761405317841171513L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 50)-(line 56,col 69)","literalExprId":1,"literalExpr":"3761405317841171513L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3761405317841171513L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":57,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.IntrusiveEdge","imports":[{"importId":1,"import":"import java.io.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Object#clone()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Object#clone()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Object clone()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        return super.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new InternalError();\n    }\n}","methodRange":"(line 62,col 5)-(line 70,col 5)","methodTokenRange":"@Override public Object clone()\n    {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            \/\/ shouldn't happen as we are Cloneable\n            throw new InternalError();\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * @see Object#clone()\n     ","methodParameters":[],"methodName":"clone","methodQualifiedSignature":"org.jgrapht.graph.IntrusiveEdge.clone","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Object#clone()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.IntrusiveEdge.clone()"}],"classJavadoc":"\/**\n * IntrusiveEdge encapsulates the internals for the default edge implementation.\n * It is not intended to be referenced directly (which is why it's not public);\n * use DefaultEdge for that.\n *\n * @author John V. Sichi\n *\/\n","className":"IntrusiveEdge","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3258408452177932855L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3258408452177932855L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3258408452177932855L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 55,col 5)-(line 55,col 18)","fieldName":"source","fieldJavadocComment":"","fieldTokenRange":"Object source;","fieldTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Object","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Object"},{"fieldRange":"(line 57,col 5)-(line 57,col 18)","fieldName":"target","fieldJavadocComment":"","fieldTokenRange":"Object target;","fieldTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Object","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Object"}]}],"sourceFileId":58,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.UnmodifiableGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph on which an unmodifiable graph is to be\ncreated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph on which an unmodifiable graph is to be\ncreated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.UnmodifiableGraph(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 77,col 5)-(line 80,col 5)","constructorJavadocComment":"\n     * Creates a new unmodifiable graph based on the specified backing graph.\n     *\n     * @param g the backing graph on which an unmodifiable graph is to be\n     * created.\n     ","constructorDeclaration":"public UnmodifiableGraph(Graph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"UnmodifiableGraph","constructorQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.UnmodifiableGraph","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public UnmodifiableGraph(Graph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new unmodifiable graph based on the specified backing graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph on which an unmodifiable graph is to be\ncreated.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 85,col 5)-(line 88,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 93,col 5)-(line 96,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 101,col 5)-(line 104,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllEdges(Collection<? extends E> edges)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 109,col 5)-(line 112,col 5)","methodTokenRange":"@Override public boolean removeAllEdges(Collection<? extends E> edges)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edges","parameterName":"edges"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.removeAllEdges(java.util.Collection<? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> removeAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 117,col 5)-(line 120,col 5)","methodTokenRange":"@Override public Set<E> removeAllEdges(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.removeAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllVertices(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllVertices(Collection<? extends V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 125,col 5)-(line 128,col 5)","methodTokenRange":"@Override public boolean removeAllVertices(Collection<? extends V> vertices)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllVertices(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertices","parameterName":"vertices"}],"methodName":"removeAllVertices","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.removeAllVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.removeAllVertices(java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 133,col 5)-(line 136,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 141,col 5)-(line 144,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 149,col 5)-(line 152,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.UnmodifiableGraph.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.UnmodifiableGraph.removeVertex(V)"}],"classJavadoc":"\/**\n * An unmodifiable view of the backing graph specified in the constructor. This\n * graph allows modules to provide users with \"read-only\" access to internal\n * graphs. Query operations on this graph \"read through\" to the backing graph,\n * and attempts to modify this graph result in an <code>\n * UnsupportedOperationException<\/code>.\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods. This graph will be serializable if the backing\n * graph is serializable.<\/p>\n *\n * @author Barak Naveh\n * @since Jul 24, 2003\n *\/\n","className":"UnmodifiableGraph","fields":[{"fieldRange":"(line 68,col 5)-(line 68,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3544957670722713913L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 68,col 50)-(line 68,col 69)","literalExprId":1,"literalExpr":"3544957670722713913L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3544957670722713913L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 69,col 5)-(line 69,col 76)","fieldName":"UNMODIFIABLE","fieldJavadocComment":"","fieldTokenRange":"private static final String UNMODIFIABLE = \"this graph is unmodifiable\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 69,col 48)-(line 69,col 75)","literalExprId":1,"literalExpr":"\"this graph is unmodifiable\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"this graph is unmodifiable\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":59,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.GraphPathImpl","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"GraphPathImpl","constructorQualifiedName":"org.jgrapht.graph.GraphPathImpl.GraphPathImpl","constructorQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.GraphPathImpl(org.jgrapht.Graph<V, E>, V, V, java.util.List<E>, double)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"},{"parameterType":"List<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<E>","parameter":"List<E> edgeList","parameterName":"edgeList"},{"parameterType":"double","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"literalExprs":[],"constructorTokenRange":"public GraphPathImpl(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex,\n        List<E> edgeList,\n        double weight)\n    {\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.endVertex = endVertex;\n        this.edgeList = edgeList;\n        this.weight = weight;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 62,col 5)-(line 74,col 5)","constructorJavadocComment":"","constructorDeclaration":"public GraphPathImpl(Graph<V, E> graph, V startVertex, V endVertex, List<E> edgeList, double weight)","constructorBody":"{\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.endVertex = endVertex;\n    this.edgeList = edgeList;\n    this.weight = weight;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public Graph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 77,col 5)-(line 80,col 5)","methodTokenRange":"@Override public Graph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":" implement GraphPath","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.getGraph","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Graph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphPathImpl.getGraph()"},{"methodDeclaration":"public V getStartVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return startVertex;\n}","methodRange":"(line 83,col 5)-(line 86,col 5)","methodTokenRange":"@Override public V getStartVertex()\n    {\n        return startVertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":" implement GraphPath","methodParameters":[],"methodName":"getStartVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.getStartVertex","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphPathImpl.getStartVertex()"},{"methodDeclaration":"public V getEndVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return endVertex;\n}","methodRange":"(line 89,col 5)-(line 92,col 5)","methodTokenRange":"@Override public V getEndVertex()\n    {\n        return endVertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":" implement GraphPath","methodParameters":[],"methodName":"getEndVertex","methodQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.getEndVertex","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphPathImpl.getEndVertex()"},{"methodDeclaration":"public List<E> getEdgeList()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeList;\n}","methodRange":"(line 95,col 5)-(line 98,col 5)","methodTokenRange":"@Override public List<E> getEdgeList()\n    {\n        return edgeList;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":" implement GraphPath","methodParameters":[],"methodName":"getEdgeList","methodQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.getEdgeList","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphPathImpl.getEdgeList()"},{"methodDeclaration":"public double getWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return weight;\n}","methodRange":"(line 101,col 5)-(line 104,col 5)","methodTokenRange":"@Override public double getWeight()\n    {\n        return weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":" implement GraphPath","methodParameters":[],"methodName":"getWeight","methodQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.getWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphPathImpl.getWeight()"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeList.toString();\n}","methodRange":"(line 107,col 5)-(line 110,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return edgeList.toString();\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" override Object","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.graph.GraphPathImpl.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.GraphPathImpl.toString()"}],"classJavadoc":"\/**\n * GraphPathImpl is a default implementation of {@link GraphPath}.\n *\n * @author John Sichi\n * @version $Id$\n *\/\n","className":"GraphPathImpl","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 30)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 54,col 5)-(line 54,col 29)","fieldName":"edgeList","fieldJavadocComment":"","fieldTokenRange":"private List<E> edgeList;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<E>"},{"fieldRange":"(line 56,col 5)-(line 56,col 26)","fieldName":"startVertex","fieldJavadocComment":"","fieldTokenRange":"private V startVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 58,col 5)-(line 58,col 24)","fieldName":"endVertex","fieldJavadocComment":"","fieldTokenRange":"private V endVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 60,col 5)-(line 60,col 26)","fieldName":"weight","fieldJavadocComment":"","fieldTokenRange":"private double weight;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":60,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.Subgraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.event.*;\n"},{"importId":5,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.","javadocBlockTagName":"vertexSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.","javadocBlockTagName":"edgeSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.Subgraph.Subgraph(G, java.util.Set<V>, java.util.Set<E>)","variableDeclarationExprs":[],"constructorRange":"(line 137,col 5)-(line 154,col 5)","constructorJavadocComment":"\n     * Creates a new Subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null<\/code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null<\/code> then all the edges whose vertices found in the graph are\n     * included.\n     ","constructorDeclaration":"public Subgraph(G base, Set<V> vertexSubset, Set<E> edgeSubset)","constructorBody":"{\n    super();\n    this.base = base;\n    if (edgeSubset == null) {\n        isInduced = true;\n    }\n    if (base instanceof ListenableGraph<?, ?>) {\n        ((ListenableGraph<V, E>) base).addGraphListener(new BaseGraphListener());\n    }\n    addVerticesUsingFilter(base.vertexSet(), vertexSubset);\n    addEdgesUsingFilter(base.edgeSet(), edgeSubset);\n}","constructorName":"Subgraph","constructorQualifiedName":"org.jgrapht.graph.Subgraph.Subgraph","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G base","parameterName":"base"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSubset","parameterName":"vertexSubset"},{"parameterType":"Set<E>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSubset","parameterName":"edgeSubset"}],"literalExprs":[{"literalExprRange":"(line 143,col 27)-(line 143,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 144,col 25)-(line 144,col 28)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public Subgraph(G base, Set<V> vertexSubset, Set<E> edgeSubset)\n    {\n        super();\n\n        this.base = base;\n\n        if (edgeSubset == null) {\n            isInduced = true;\n        }\n\n        if (base instanceof ListenableGraph<?, ?>) {\n            ((ListenableGraph<V, E>) base).addGraphListener(\n                new BaseGraphListener());\n        }\n\n        addVerticesUsingFilter(base.vertexSet(), vertexSubset);\n        addEdgesUsingFilter(base.edgeSet(), edgeSubset);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new Subgraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.","javadocBlockTagName":"vertexSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.Subgraph.Subgraph(G, java.util.Set<V>)","variableDeclarationExprs":[],"constructorRange":"(line 166,col 5)-(line 169,col 5)","constructorJavadocComment":"\n     * Creates a new induced Subgraph. The subgraph will keep track of edges\n     * being added to its vertex subset as well as deletion of edges and\n     * vertices. If base it not listenable, this is identical to the call\n     * Subgraph(base, vertexSubset, null) .\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null<\/code> then all vertices are included.\n     ","constructorDeclaration":"public Subgraph(G base, Set<V> vertexSubset)","constructorBody":"{\n    this(base, vertexSubset, null);\n}","constructorName":"Subgraph","constructorQualifiedName":"org.jgrapht.graph.Subgraph.Subgraph","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G base","parameterName":"base"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSubset","parameterName":"vertexSubset"}],"literalExprs":[{"literalExprRange":"(line 168,col 34)-(line 168,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public Subgraph(G base, Set<V> vertexSubset)\n    {\n        this(base, vertexSubset, null);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new induced Subgraph. The subgraph will keep track of edges\nbeing added to its vertex subset as well as deletion of edges and\nvertices. If base it not listenable, this is identical to the call\nSubgraph(base, vertexSubset, null) .'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 479,col 5)-(line 530,col 5)","classOrInterfaceTokenRange":"private class BaseGraphListener\n        implements GraphListener<V, E>,\n            Serializable\n    {\n        private static final long serialVersionUID = 4343535244243546391L;\n\n        \/**\n         * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n         *\/\n        @Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n        {\n            if (isInduced) {\n                E edge = e.getEdge();\n                V source = e.getEdgeSource();\n                V target = e.getEdgeTarget();\n                if (containsVertex(source) && containsVertex(target)) {\n                    addEdge(\n                        source,\n                        target,\n                        edge);\n                }\n            }\n        }\n\n        \/**\n         * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n         *\/\n        @Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n        {\n            E edge = e.getEdge();\n\n            removeEdge(edge);\n        }\n\n        \/**\n         * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n         *\/\n        @Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n        {\n            \/\/ we don't care\n        }\n\n        \/**\n         * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n         *\/\n        @Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n        {\n            V vertex = e.getVertex();\n\n            removeVertex(vertex);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * An internal listener on the base graph.\n     *\n     * @author Barak Naveh\n     * @since Jul 20, 2003\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An internal listener on the base graph.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Jul 20, 2003'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> edges = null;\n    if (containsVertex(sourceVertex) && containsVertex(targetVertex)) {\n        edges = new ArrayUnenforcedSet<E>();\n        Set<E> baseEdges = base.getAllEdges(sourceVertex, targetVertex);\n        for (Iterator<E> iter = baseEdges.iterator(); iter.hasNext(); ) {\n            E e = iter.next();\n            if (edgeSet.contains(e)) {\n                edges.add(e);\n            }\n        }\n    }\n    return edges;\n}","methodRange":"(line 174,col 5)-(line 194,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = null;\n\n        if (containsVertex(sourceVertex) && containsVertex(targetVertex)) {\n            edges = new ArrayUnenforcedSet<E>();\n\n            Set<E> baseEdges = base.getAllEdges(sourceVertex, targetVertex);\n\n            for (Iterator<E> iter = baseEdges.iterator(); iter.hasNext();) {\n                E e = iter.next();\n\n                if (edgeSet.contains(e)) { \/\/ add if subgraph also contains\n                                           \/\/ it\n                    edges.add(e);\n                }\n            }\n        }\n\n        return edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#getAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 176,col 24)-(line 176,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> edges = getAllEdges(sourceVertex, targetVertex);\n    if ((edges == null) || edges.isEmpty()) {\n        return null;\n    } else {\n        return edges.iterator().next();\n    }\n}","methodRange":"(line 199,col 5)-(line 208,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = getAllEdges(sourceVertex, targetVertex);\n\n        if ((edges == null) || edges.isEmpty()) {\n            return null;\n        } else {\n            return edges.iterator().next();\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 203,col 23)-(line 203,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 204,col 20)-(line 204,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeFactory()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeFactory()'}]}', name=Optional.empty}"}],"methodDeclaration":"public EdgeFactory<V, E> getEdgeFactory()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return base.getEdgeFactory();\n}","methodRange":"(line 213,col 5)-(line 216,col 5)","methodTokenRange":"@Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return base.getEdgeFactory();\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @see Graph#getEdgeFactory()\n     ","methodParameters":[],"methodName":"getEdgeFactory","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getEdgeFactory","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeFactory()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"EdgeFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getEdgeFactory()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    if (!base.containsEdge(sourceVertex, targetVertex)) {\n        throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n    }\n    Set<E> edges = base.getAllEdges(sourceVertex, targetVertex);\n    for (Iterator<E> iter = edges.iterator(); iter.hasNext(); ) {\n        E e = iter.next();\n        if (!containsEdge(e)) {\n            edgeSet.add(e);\n            return e;\n        }\n    }\n    return null;\n}","methodRange":"(line 221,col 5)-(line 243,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        if (!base.containsEdge(sourceVertex, targetVertex)) {\n            throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n        }\n\n        Set<E> edges = base.getAllEdges(sourceVertex, targetVertex);\n\n        for (Iterator<E> iter = edges.iterator(); iter.hasNext();) {\n            E e = iter.next();\n\n            if (!containsEdge(e)) {\n                edgeSet.add(e);\n\n                return e;\n            }\n        }\n\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 242,col 16)-(line 242,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (e == null) {\n        throw new NullPointerException();\n    }\n    if (!base.containsEdge(e)) {\n        throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n    }\n    assertVertexExist(sourceVertex);\n    assertVertexExist(targetVertex);\n    assert (base.getEdgeSource(e) == sourceVertex);\n    assert (base.getEdgeTarget(e) == targetVertex);\n    if (containsEdge(e)) {\n        return false;\n    } else {\n        edgeSet.add(e);\n        return true;\n    }\n}","methodRange":"(line 248,col 5)-(line 271,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        if (e == null) {\n            throw new NullPointerException();\n        }\n\n        if (!base.containsEdge(e)) {\n            throw new IllegalArgumentException(NO_SUCH_EDGE_IN_BASE);\n        }\n\n        assertVertexExist(sourceVertex);\n        assertVertexExist(targetVertex);\n\n        assert (base.getEdgeSource(e) == sourceVertex);\n        assert (base.getEdgeTarget(e) == targetVertex);\n\n        if (containsEdge(e)) {\n            return false;\n        } else {\n            edgeSet.add(e);\n\n            return true;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 250,col 18)-(line 250,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 265,col 20)-(line 265,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 269,col 20)-(line 269,col 23)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to be added.","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to be added.'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the vertex was added, otherwise <code>\nfalse<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the vertex was added, otherwise <code>\nfalse<\/code>.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Subgraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Subgraph'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (v == null) {\n        throw new NullPointerException();\n    }\n    if (!base.containsVertex(v)) {\n        throw new IllegalArgumentException(NO_SUCH_VERTEX_IN_BASE);\n    }\n    if (containsVertex(v)) {\n        return false;\n    } else {\n        vertexSet.add(v);\n        return true;\n    }\n}","methodRange":"(line 287,col 5)-(line 304,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        if (v == null) {\n            throw new NullPointerException();\n        }\n\n        if (!base.containsVertex(v)) {\n            throw new IllegalArgumentException(NO_SUCH_VERTEX_IN_BASE);\n        }\n\n        if (containsVertex(v)) {\n            return false;\n        } else {\n            vertexSet.add(v);\n\n            return true;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds the specified vertex to this subgraph.\n     *\n     * @param v the vertex to be added.\n     *\n     * @return <code>true<\/code> if the vertex was added, otherwise <code>\n     * false<\/code>.\n     *\n     * @throws NullPointerException\n     * @throws IllegalArgumentException\n     *\n     * @see Subgraph\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified vertex to this subgraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to be added.'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the vertex was added, otherwise <code>\nfalse<\/code>.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Subgraph'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 289,col 18)-(line 289,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 298,col 20)-(line 298,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 302,col 20)-(line 302,col 23)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeSet.contains(e);\n}","methodRange":"(line 309,col 5)-(line 312,col 5)","methodTokenRange":"@Override public boolean containsEdge(E e)\n    {\n        return edgeSet.contains(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.containsEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.containsEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return vertexSet.contains(v);\n}","methodRange":"(line 317,col 5)-(line 320,col 5)","methodTokenRange":"@Override public boolean containsVertex(V v)\n    {\n        return vertexSet.contains(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"containsVertex","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.containsVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.containsVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#edgeSet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgeSet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (unmodifiableEdgeSet == null) {\n        unmodifiableEdgeSet = Collections.unmodifiableSet(edgeSet);\n    }\n    return unmodifiableEdgeSet;\n}","methodRange":"(line 325,col 5)-(line 332,col 5)","methodTokenRange":"@Override public Set<E> edgeSet()\n    {\n        if (unmodifiableEdgeSet == null) {\n            unmodifiableEdgeSet = Collections.unmodifiableSet(edgeSet);\n        }\n\n        return unmodifiableEdgeSet;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#edgeSet()\n     ","methodParameters":[],"methodName":"edgeSet","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.edgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgeSet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 327,col 36)-(line 327,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.edgeSet()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#edgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> edgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    Set<E> edges = new ArrayUnenforcedSet<E>();\n    Set<E> baseEdges = base.edgesOf(vertex);\n    for (E e : baseEdges) {\n        if (containsEdge(e)) {\n            edges.add(e);\n        }\n    }\n    return edges;\n}","methodRange":"(line 337,col 5)-(line 351,col 5)","methodTokenRange":"@Override public Set<E> edgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n        Set<E> baseEdges = base.edgesOf(vertex);\n\n        for (E e : baseEdges) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#edgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOf","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.edgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#edgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.edgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeSet.remove(e);\n}","methodRange":"(line 356,col 5)-(line 359,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        return edgeSet.remove(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E e = getEdge(sourceVertex, targetVertex);\n    return edgeSet.remove(e) ? e : null;\n}","methodRange":"(line 364,col 5)-(line 369,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        E e = getEdge(sourceVertex, targetVertex);\n\n        return edgeSet.remove(e) ? e : null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 368,col 40)-(line 368,col 43)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (containsVertex(v) && base.containsVertex(v)) {\n        removeAllEdges(edgesOf(v));\n    }\n    return vertexSet.remove(v);\n}","methodRange":"(line 374,col 5)-(line 384,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        \/\/ If the base graph does NOT contain v it means we are here in\n        \/\/ response to removal of v from the base. In such case we don't need\n        \/\/ to remove all the edges of v as they were already removed.\n        if (containsVertex(v) && base.containsVertex(v)) {\n            removeAllEdges(edgesOf(v));\n        }\n\n        return vertexSet.remove(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.removeVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#vertexSet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#vertexSet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> vertexSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (unmodifiableVertexSet == null) {\n        unmodifiableVertexSet = Collections.unmodifiableSet(vertexSet);\n    }\n    return unmodifiableVertexSet;\n}","methodRange":"(line 389,col 5)-(line 396,col 5)","methodTokenRange":"@Override public Set<V> vertexSet()\n    {\n        if (unmodifiableVertexSet == null) {\n            unmodifiableVertexSet = Collections.unmodifiableSet(vertexSet);\n        }\n\n        return unmodifiableVertexSet;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#vertexSet()\n     ","methodParameters":[],"methodName":"vertexSet","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.vertexSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#vertexSet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 391,col 38)-(line 391,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.vertexSet()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeSource(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeSource(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return base.getEdgeSource(e);\n}","methodRange":"(line 401,col 5)-(line 404,col 5)","methodTokenRange":"@Override public V getEdgeSource(E e)\n    {\n        return base.getEdgeSource(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeSource(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getEdgeSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getEdgeSource(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeTarget(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeTarget(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return base.getEdgeTarget(e);\n}","methodRange":"(line 409,col 5)-(line 412,col 5)","methodTokenRange":"@Override public V getEdgeTarget(E e)\n    {\n        return base.getEdgeTarget(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeTarget(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getEdgeTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getEdgeTarget(E)"},{"methodDeclaration":"private void addEdgesUsingFilter(Set<E> edgeSet, Set<E> filter)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    E e;\n    boolean containsVertices;\n    boolean edgeIncluded;\n    for (Iterator<E> iter = edgeSet.iterator(); iter.hasNext(); ) {\n        e = iter.next();\n        V sourceVertex = base.getEdgeSource(e);\n        V targetVertex = base.getEdgeTarget(e);\n        containsVertices = containsVertex(sourceVertex) && containsVertex(targetVertex);\n        edgeIncluded = (filter == null) || filter.contains(e);\n        if (containsVertices && edgeIncluded) {\n            addEdge(sourceVertex, targetVertex, e);\n        }\n    }\n}","methodRange":"(line 414,col 5)-(line 436,col 5)","methodTokenRange":"private void addEdgesUsingFilter(Set<E> edgeSet, Set<E> filter)\n    {\n        E e;\n        boolean containsVertices;\n        boolean edgeIncluded;\n\n        for (Iterator<E> iter = edgeSet.iterator(); iter.hasNext();) {\n            e = iter.next();\n\n            V sourceVertex = base.getEdgeSource(e);\n            V targetVertex = base.getEdgeTarget(e);\n            containsVertices =\n                containsVertex(sourceVertex)\n                && containsVertex(targetVertex);\n\n            \/\/ note the use of short circuit evaluation\n            edgeIncluded = (filter == null) || filter.contains(e);\n\n            if (containsVertices && edgeIncluded) {\n                addEdge(sourceVertex, targetVertex, e);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSet","parameterName":"edgeSet"},{"parameterType":"Set<E>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> filter","parameterName":"filter"}],"methodName":"addEdgesUsingFilter","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.addEdgesUsingFilter","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 430,col 39)-(line 430,col 42)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.addEdgesUsingFilter(java.util.Set<E>, java.util.Set<E>)"},{"methodDeclaration":"private void addVerticesUsingFilter(Set<V> vertexSet, Set<V> filter)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V v;\n    for (Iterator<V> iter = vertexSet.iterator(); iter.hasNext(); ) {\n        v = iter.next();\n        if ((filter == null) || filter.contains(v)) {\n            addVertex(v);\n        }\n    }\n}","methodRange":"(line 438,col 5)-(line 450,col 5)","methodTokenRange":"private void addVerticesUsingFilter(Set<V> vertexSet, Set<V> filter)\n    {\n        V v;\n\n        for (Iterator<V> iter = vertexSet.iterator(); iter.hasNext();) {\n            v = iter.next();\n\n            \/\/ note the use of short circuit evaluation\n            if ((filter == null) || filter.contains(v)) {\n                addVertex(v);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSet","parameterName":"vertexSet"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> filter","parameterName":"filter"}],"methodName":"addVerticesUsingFilter","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.addVerticesUsingFilter","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 446,col 28)-(line 446,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.Subgraph.addVerticesUsingFilter(java.util.Set<V>, java.util.Set<V>)"},{"methodDeclaration":"public G getBase()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return base;\n}","methodRange":"(line 452,col 5)-(line 455,col 5)","methodTokenRange":"public G getBase()\n    {\n        return base;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","methodJavadocComment":"","methodParameters":[],"methodName":"getBase","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getBase","methodJavadoc":"","methodReturnTypeDescribed":"G","methodType":"G","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getBase()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return base.getEdgeWeight(e);\n}","methodRange":"(line 460,col 5)-(line 463,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E e)\n    {\n        return base.getEdgeWeight(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @see Graph#getEdgeWeight(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.getEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.getEdgeWeight(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"WeightedGraph#setEdgeWeight(Object, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight(Object, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void setEdgeWeight(E e, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ((WeightedGraph<V, E>) base).setEdgeWeight(e, weight);\n}","methodRange":"(line 468,col 5)-(line 471,col 5)","methodTokenRange":"public void setEdgeWeight(E e, double weight)\n    {\n        ((WeightedGraph<V, E>) base).setEdgeWeight(e, weight);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see WeightedGraph#setEdgeWeight(Object, double)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"setEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.Subgraph.setEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight(Object, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.Subgraph.setEdgeWeight(E, double)"}],"classJavadoc":"\/**\n * A subgraph is a graph that has a subset of vertices and a subset of edges\n * with respect to some base graph. More formally, a subgraph G(V,E) that is\n * based on a base graph Gb(Vb,Eb) satisfies the following <b><i>subgraph\n * property<\/i><\/b>: V is a subset of Vb and E is a subset of Eb. Other than\n * this property, a subgraph is a graph with any respect and fully complies with\n * the <code>Graph<\/code> interface.\n *\n * <p>If the base graph is a {@link org.jgrapht.ListenableGraph}, the subgraph\n * listens on the base graph and guarantees the subgraph property. If an edge or\n * a vertex is removed from the base graph, it is automatically removed from the\n * subgraph. Subgraph listeners are informed on such removal only if it results\n * in a cascaded removal from the subgraph. If the subgraph has been created as\n * an induced subgraph it also keeps track of edges being added to its vertices.\n * If vertices are added to the base graph, the subgraph remains unaffected.<\/p>\n *\n * <p>If the base graph is <i>not<\/i> a ListenableGraph, then the subgraph\n * property cannot be guaranteed. If edges or vertices are removed from the base\n * graph, they are <i>not<\/i> removed from the subgraph.<\/p>\n *\n * <p>Modifications to Subgraph are allowed as long as the subgraph property is\n * maintained. Addition of vertices or edges are allowed as long as they also\n * exist in the base graph. Removal of vertices or edges is always allowed. The\n * base graph is <i>never<\/i> affected by any modification made to the\n * subgraph.<\/p>\n *\n * <p>A subgraph may provide a \"live-window\" on a base graph, so that changes\n * made to its vertices or edges are immediately reflected in the base graph,\n * and vice versa. For that to happen, vertices and edges added to the subgraph\n * must be <i>identical<\/i> (that is, reference-equal and not only value-equal)\n * to their respective ones in the base graph. Previous versions of this class\n * enforced such identity, at a severe performance cost. Currently it is no\n * longer enforced. If you want to achieve a \"live-window\"functionality, your\n * safest tactics would be to NOT override the <code>equals()<\/code> methods of\n * your vertices and edges. If you use a class that has already overridden the\n * <code>equals()<\/code> method, such as <code>String<\/code>, than you can use a\n * wrapper around it, or else use it directly but exercise a great care to avoid\n * having different-but-equal instances in the subgraph and the base graph.<\/p>\n *\n * <p>This graph implementation guarantees deterministic vertex and edge set\n * ordering (via {@link LinkedHashSet}).<\/p>\n *\n * @author Barak Naveh\n * @see Graph\n * @see Set\n * @since Jul 18, 2003\n *\/\n","className":"Subgraph","fields":[{"fieldRange":"(line 109,col 5)-(line 109,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3208313055169665387L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 109,col 50)-(line 109,col 69)","literalExprId":1,"literalExpr":"3208313055169665387L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3208313055169665387L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 110,col 5)-(line 111,col 37)","fieldName":"NO_SUCH_EDGE_IN_BASE","fieldJavadocComment":"","fieldTokenRange":"private static final String NO_SUCH_EDGE_IN_BASE =\n        \"no such edge in base graph\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 111,col 9)-(line 111,col 36)","literalExprId":1,"literalExpr":"\"no such edge in base graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"no such edge in base graph\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 112,col 5)-(line 113,col 39)","fieldName":"NO_SUCH_VERTEX_IN_BASE","fieldJavadocComment":"","fieldTokenRange":"private static final String NO_SUCH_VERTEX_IN_BASE =\n        \"no such vertex in base graph\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 113,col 9)-(line 113,col 38)","literalExprId":1,"literalExpr":"\"no such vertex in base graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"no such vertex in base graph\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 116,col 5)-(line 116,col 44)","fieldName":"edgeSet","fieldJavadocComment":" friendly to improve performance","fieldTokenRange":"Set<E> edgeSet = new LinkedHashSet<E>();","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new LinkedHashSet<E>()]","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 117,col 5)-(line 117,col 46)","fieldName":"vertexSet","fieldJavadocComment":" friendly to improve","fieldTokenRange":"Set<V> vertexSet = new LinkedHashSet<V>();","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new LinkedHashSet<V>()]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 122,col 5)-(line 122,col 56)","fieldName":"unmodifiableEdgeSet","fieldJavadocComment":"","fieldTokenRange":"private transient Set<E> unmodifiableEdgeSet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 122,col 52)-(line 122,col 55)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 123,col 5)-(line 123,col 58)","fieldName":"unmodifiableVertexSet","fieldJavadocComment":"","fieldTokenRange":"private transient Set<V> unmodifiableVertexSet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 123,col 54)-(line 123,col 57)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 124,col 5)-(line 124,col 19)","fieldName":"base","fieldJavadocComment":"","fieldTokenRange":"private G base;","fieldTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"G","fieldJavadoc":"","fieldTypeResolvedDescribed":"G"},{"fieldRange":"(line 125,col 5)-(line 125,col 38)","fieldName":"isInduced","fieldJavadocComment":"","fieldTokenRange":"private boolean isInduced = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 125,col 33)-(line 125,col 37)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":61,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.UndirectedWeightedSubgraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.","javadocBlockTagName":"vertexSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.","javadocBlockTagName":"edgeSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.UndirectedWeightedSubgraph.UndirectedWeightedSubgraph(org.jgrapht.WeightedGraph<V, E>, java.util.Set<V>, java.util.Set<E>)","variableDeclarationExprs":[],"constructorRange":"(line 66,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Creates a new undirected weighted subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null<\/code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null<\/code> then all the edges whose vertices found in the graph are\n     * included.\n     ","constructorDeclaration":"public UndirectedWeightedSubgraph(WeightedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset)","constructorBody":"{\n    super((UndirectedGraph<V, E>) base, vertexSubset, edgeSubset);\n}","constructorName":"UndirectedWeightedSubgraph","constructorQualifiedName":"org.jgrapht.graph.UndirectedWeightedSubgraph.UndirectedWeightedSubgraph","constructorParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> base","parameterName":"base"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSubset","parameterName":"vertexSubset"},{"parameterType":"Set<E>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSubset","parameterName":"edgeSubset"}],"literalExprs":[],"constructorTokenRange":"public UndirectedWeightedSubgraph(\n        WeightedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super((UndirectedGraph<V, E>) base, vertexSubset, edgeSubset);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new undirected weighted subgraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * An undirected weighted graph that is a subgraph on other graph.\n *\n * @see Subgraph\n *\/\n","className":"UndirectedWeightedSubgraph","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3689346615735236409L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"3689346615735236409L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3689346615735236409L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":62,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedPseudograph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"AbstractBaseGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AbstractBaseGraph'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedPseudograph.DirectedPseudograph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * @see AbstractBaseGraph\n     ","constructorDeclaration":"public DirectedPseudograph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"DirectedPseudograph","constructorQualifiedName":"org.jgrapht.graph.DirectedPseudograph.DirectedPseudograph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public DirectedPseudograph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AbstractBaseGraph'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"AbstractBaseGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AbstractBaseGraph'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedPseudograph.DirectedPseudograph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 68,col 5)-(line 71,col 5)","constructorJavadocComment":"\n     * @see AbstractBaseGraph\n     ","constructorDeclaration":"public DirectedPseudograph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, true, true);\n}","constructorName":"DirectedPseudograph","constructorQualifiedName":"org.jgrapht.graph.DirectedPseudograph.DirectedPseudograph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 70,col 19)-(line 70,col 22)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 70,col 25)-(line 70,col 28)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public DirectedPseudograph(EdgeFactory<V, E> ef)\n    {\n        super(ef, true, true);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AbstractBaseGraph'}]}', name=Optional.empty}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(edgeClass));\n}","methodRange":"(line 73,col 5)-(line 79,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends DirectedPseudograph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(\n            new DirectedPseudograph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedPseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedPseudograph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(new DirectedPseudograph<V, E>(ef));\n}","methodRange":"(line 81,col 5)-(line 86,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends DirectedPseudograph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new DirectedGraphBuilder<V, E, DirectedPseudograph<V, E>>(\n            new DirectedPseudograph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedPseudograph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends DirectedPseudograph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedPseudograph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A directed pseudograph. A directed pseudograph is a non-simple directed graph\n * in which both graph loops and multiple edges are permitted. If you're unsure\n * about pseudographs, see: <a\n * href=\"http:\/\/mathworld.wolfram.com\/Pseudograph.html\">\n * http:\/\/mathworld.wolfram.com\/Pseudograph.html<\/a>.\n *\/\n","className":"DirectedPseudograph","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 71)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = -8300409752893486415L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 55,col 51)-(line 55,col 70)","literalExprId":1,"literalExpr":"8300409752893486415L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-8300409752893486415L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":63,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AbstractGraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.graph.AbstractGraph.AbstractGraph()","variableDeclarationExprs":[],"constructorRange":"(line 66,col 5)-(line 68,col 5)","constructorJavadocComment":"\n     * Construct a new empty graph object.\n     ","constructorDeclaration":"protected AbstractGraph()","constructorBody":"{\n}","constructorName":"AbstractGraph","constructorQualifiedName":"org.jgrapht.graph.AbstractGraph.AbstractGraph","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"protected AbstractGraph()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new empty graph object.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean containsEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getEdge(sourceVertex, targetVertex) != null;\n}","methodRange":"(line 73,col 5)-(line 76,col 5)","methodTokenRange":"@Override public boolean containsEdge(V sourceVertex, V targetVertex)\n    {\n        return getEdge(sourceVertex, targetVertex) != null;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#containsEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.containsEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 75,col 55)-(line 75,col 58)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.containsEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllEdges(Collection<? extends E> edges)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean modified = false;\n    for (E e : edges) {\n        modified |= removeEdge(e);\n    }\n    return modified;\n}","methodRange":"(line 81,col 5)-(line 90,col 5)","methodTokenRange":"@Override public boolean removeAllEdges(Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            modified |= removeEdge(e);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edges","parameterName":"edges"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 83,col 28)-(line 83,col 32)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.removeAllEdges(java.util.Collection<? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> removeAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> removed = getAllEdges(sourceVertex, targetVertex);\n    if (removed == null) {\n        return null;\n    }\n    removeAllEdges(removed);\n    return removed;\n}","methodRange":"(line 95,col 5)-(line 104,col 5)","methodTokenRange":"@Override public Set<E> removeAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> removed = getAllEdges(sourceVertex, targetVertex);\n        if (removed == null) {\n            return null;\n        }\n        removeAllEdges(removed);\n\n        return removed;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 98,col 24)-(line 98,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 99,col 20)-(line 99,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.removeAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllVertices(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllVertices(Collection<? extends V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= removeVertex(v);\n    }\n    return modified;\n}","methodRange":"(line 109,col 5)-(line 118,col 5)","methodTokenRange":"@Override public boolean removeAllVertices(Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= removeVertex(v);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllVertices(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertices","parameterName":"vertices"}],"methodName":"removeAllVertices","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.removeAllVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 111,col 28)-(line 111,col 32)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.removeAllVertices(java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of this graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of this graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return toStringFromSets(vertexSet(), edgeSet(), (this instanceof DirectedGraph<?, ?>));\n}","methodRange":"(line 127,col 5)-(line 133,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return toStringFromSets(\n            vertexSet(),\n            edgeSet(),\n            (this instanceof DirectedGraph<?, ?>));\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Returns a string of the parenthesized pair (V, E) representing this\n     * G=(V,E) graph. 'V' is the string representation of the vertex set, and\n     * 'E' is the string representation of the edge set.\n     *\n     * @return a string representation of this graph.\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string of the parenthesized pair (V, E) representing this\nG=(V,E) graph. 'V' is the string representation of the vertex set, and\n'E' is the string representation of the edge set.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of this graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.toString()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if this assertion holds.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if this assertion holds.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if specified vertex is <code>null<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if specified vertex is <code>null<\/code>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if specified vertex does not exist in\nthis graph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if specified vertex does not exist in\nthis graph.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":"protected boolean assertVertexExist(V v)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (containsVertex(v)) {\n        return true;\n    } else if (v == null) {\n        throw new NullPointerException();\n    } else {\n        throw new IllegalArgumentException(\"no such vertex in graph: \" + v.toString());\n    }\n}","methodRange":"(line 147,col 5)-(line 157,col 5)","methodTokenRange":"protected boolean assertVertexExist(V v)\n    {\n        if (containsVertex(v)) {\n            return true;\n        } else if (v == null) {\n            throw new NullPointerException();\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex in graph: \" + v.toString());\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Ensures that the specified vertex exists in this graph, or else throws\n     * exception.\n     *\n     * @param v vertex\n     *\n     * @return <code>true<\/code> if this assertion holds.\n     *\n     * @throws NullPointerException if specified vertex is <code>null<\/code>.\n     * @throws IllegalArgumentException if specified vertex does not exist in\n     * this graph.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"assertVertexExist","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.assertVertexExist","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Ensures that the specified vertex exists in this graph, or else throws\nexception.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if this assertion holds.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if specified vertex is <code>null<\/code>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if specified vertex does not exist in\nthis graph.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 150,col 20)-(line 150,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 151,col 25)-(line 151,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 155,col 17)-(line 155,col 43)","literalExprId":3,"literalExpr":"\"no such vertex in graph: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.assertVertexExist(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to be removed from this graph.","javadocBlockTagName":"edges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to be removed from this graph.'}]}', name=Optional[edges]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph changed as a result of the call.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call.'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#containsEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean removeAllEdges(E[] edges)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    boolean modified = false;\n    for (int i = 0; i < edges.length; i++) {\n        modified |= removeEdge(edges[i]);\n    }\n    return modified;\n}","methodRange":"(line 172,col 5)-(line 181,col 5)","methodTokenRange":"protected boolean removeAllEdges(E [] edges)\n    {\n        boolean modified = false;\n\n        for (int i = 0; i < edges.length; i++) {\n            modified |= removeEdge(edges[i]);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Removes all the edges in this graph that are also contained in the\n     * specified edge array. After this call returns, this graph will contain no\n     * edges in common with the specified edges. This method will invoke the\n     * {@link Graph#removeEdge(Object)} method.\n     *\n     * @param edges edges to be removed from this graph.\n     *\n     * @return <tt>true<\/tt> if this graph changed as a result of the call.\n     *\n     * @see Graph#removeEdge(Object)\n     * @see Graph#containsEdge(Object)\n     ","methodParameters":[{"parameterType":"E[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(E, bounds=[])}}","parameterTypeResolvedDescribed":"E[]","parameter":"E[] edges","parameterName":"edges"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all the edges in this graph that are also contained in the\nspecified edge array. After this call returns, this graph will contain no\nedges in common with the specified edges. This method will invoke the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' Graph#removeEdge(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to be removed from this graph.'}]}', name=Optional[edges]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call.'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#containsEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 174,col 28)-(line 174,col 32)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 176,col 22)-(line 176,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.removeAllEdges(E[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex set V to be printed","javadocBlockTagName":"vertexSet","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex set V to be printed'}]}', name=Optional[vertexSet]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge set E to be printed","javadocBlockTagName":"edgeSet","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge set E to be printed'}]}', name=Optional[edgeSet]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"true to use parens for each edge (representing directed);\nfalse to use curly braces (representing undirected)","javadocBlockTagName":"directed","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='true to use parens for each edge (representing directed);\nfalse to use curly braces (representing undirected)'}]}', name=Optional[directed]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of (V,E)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of (V,E)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected String toStringFromSets(Collection<? extends V> vertexSet, Collection<? extends E> edgeSet, boolean directed)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    List<String> renderedEdges = new ArrayList<String>();\n    StringBuffer sb = new StringBuffer();\n    for (E e : edgeSet) {\n        if ((e.getClass() != DefaultEdge.class) && (e.getClass() != DefaultWeightedEdge.class)) {\n            sb.append(e.toString());\n            sb.append(\"=\");\n        }\n        if (directed) {\n            sb.append(\"(\");\n        } else {\n            sb.append(\"{\");\n        }\n        sb.append(getEdgeSource(e));\n        sb.append(\",\");\n        sb.append(getEdgeTarget(e));\n        if (directed) {\n            sb.append(\")\");\n        } else {\n            sb.append(\"}\");\n        }\n        renderedEdges.add(sb.toString());\n        sb.setLength(0);\n    }\n    return \"(\" + vertexSet + \", \" + renderedEdges + \")\";\n}","methodRange":"(line 193,col 5)-(line 228,col 5)","methodTokenRange":"protected String toStringFromSets(\n        Collection<? extends V> vertexSet,\n        Collection<? extends E> edgeSet,\n        boolean directed)\n    {\n        List<String> renderedEdges = new ArrayList<String>();\n\n        StringBuffer sb = new StringBuffer();\n        for (E e : edgeSet) {\n            if ((e.getClass() != DefaultEdge.class)\n                && (e.getClass() != DefaultWeightedEdge.class))\n            {\n                sb.append(e.toString());\n                sb.append(\"=\");\n            }\n            if (directed) {\n                sb.append(\"(\");\n            } else {\n                sb.append(\"{\");\n            }\n            sb.append(getEdgeSource(e));\n            sb.append(\",\");\n            sb.append(getEdgeTarget(e));\n            if (directed) {\n                sb.append(\")\");\n            } else {\n                sb.append(\"}\");\n            }\n\n            \/\/ REVIEW jvs 29-May-2006:  dump weight somewhere?\n            renderedEdges.add(sb.toString());\n            sb.setLength(0);\n        }\n\n        return \"(\" + vertexSet + \", \" + renderedEdges + \")\";\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Helper for subclass implementations of toString( ).\n     *\n     * @param vertexSet the vertex set V to be printed\n     * @param edgeSet the edge set E to be printed\n     * @param directed true to use parens for each edge (representing directed);\n     * false to use curly braces (representing undirected)\n     *\n     * @return a string representation of (V,E)\n     ","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertexSet","parameterName":"vertexSet"},{"parameterType":"Collection<? extends E>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edgeSet","parameterName":"edgeSet"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean directed","parameterName":"directed"}],"methodName":"toStringFromSets","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.toStringFromSets","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Helper for subclass implementations of toString( ).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex set V to be printed'}]}', name=Optional[vertexSet]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge set E to be printed'}]}', name=Optional[edgeSet]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='true to use parens for each edge (representing directed);\nfalse to use curly braces (representing undirected)'}]}', name=Optional[directed]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of (V,E)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 206,col 27)-(line 206,col 29)","literalExprId":1,"literalExpr":"\"=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 27)-(line 209,col 29)","literalExprId":2,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 211,col 27)-(line 211,col 29)","literalExprId":3,"literalExpr":"\"{\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 214,col 23)-(line 214,col 25)","literalExprId":4,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 217,col 27)-(line 217,col 29)","literalExprId":5,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 219,col 27)-(line 219,col 29)","literalExprId":6,"literalExpr":"\"}\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 224,col 26)-(line 224,col 26)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 227,col 16)-(line 227,col 18)","literalExprId":8,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 227,col 34)-(line 227,col 37)","literalExprId":9,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 227,col 57)-(line 227,col 59)","literalExprId":10,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.toStringFromSets(java.util.Collection<? extends V>, java.util.Collection<? extends E>, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the hash code value this graph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the hash code value this graph'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Object#hashCode()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Object#hashCode()'}]}', name=Optional.empty}"}],"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int hash = vertexSet().hashCode();\n    for (E e : edgeSet()) {\n        int part = e.hashCode();\n        int source = getEdgeSource(e).hashCode();\n        int target = getEdgeTarget(e).hashCode();\n        int pairing = ((source + target) * (source + target + 1) \/ 2) + target;\n        part = (27 * part) + pairing;\n        long weight = (long) getEdgeWeight(e);\n        part = (27 * part) + (int) (weight ^ (weight >>> 32));\n        hash += part;\n    }\n    return hash;\n}","methodRange":"(line 239,col 5)-(line 262,col 5)","methodTokenRange":"@Override public int hashCode()\n    {\n        int hash = vertexSet().hashCode();\n\n        for (E e : edgeSet()) {\n            int part = e.hashCode();\n\n            int source = getEdgeSource(e).hashCode();\n            int target = getEdgeTarget(e).hashCode();\n\n            \/\/ see http:\/\/en.wikipedia.org\/wiki\/Pairing_function (VK);\n            int pairing =\n                ((source + target)\n                    * (source + target + 1) \/ 2) + target;\n            part = (27 * part) + pairing;\n\n            long weight = (long) getEdgeWeight(e);\n            part = (27 * part) + (int) (weight ^ (weight >>> 32));\n\n            hash += part;\n        }\n\n        return hash;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns a hash code value for this graph. The hash code of a graph is\n     * defined to be the sum of the hash codes of vertices and edges in the\n     * graph. It is also based on graph topology and edges weights.\n     *\n     * @return the hash code value this graph\n     *\n     * @see Object#hashCode()\n     ","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.hashCode","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a hash code value for this graph. The hash code of a graph is\ndefined to be the sum of the hash codes of vertices and edges in the\ngraph. It is also based on graph topology and edges weights.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the hash code value this graph'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Object#hashCode()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 252,col 42)-(line 252,col 42)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 252,col 47)-(line 252,col 47)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 253,col 21)-(line 253,col 22)","literalExprId":3,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 256,col 21)-(line 256,col 22)","literalExprId":4,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 256,col 62)-(line 256,col 63)","literalExprId":5,"literalExpr":"32","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.hashCode()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"object to be compared for equality with this graph","javadocBlockTagName":"obj","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object to be compared for equality with this graph'}]}', name=Optional[obj]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the specified object is equal to this graph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the specified object is equal to this graph'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Object#equals(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Object#equals(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean equals(Object obj)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (this == obj) {\n        return true;\n    }\n    if ((obj == null) || (getClass() != obj.getClass())) {\n        return false;\n    }\n    TypeUtil<Graph<V, E>> typeDecl = null;\n    Graph<V, E> g = TypeUtil.uncheckedCast(obj, typeDecl);\n    if (!vertexSet().equals(g.vertexSet())) {\n        return false;\n    }\n    if (edgeSet().size() != g.edgeSet().size()) {\n        return false;\n    }\n    for (E e : edgeSet()) {\n        V source = getEdgeSource(e);\n        V target = getEdgeTarget(e);\n        if (!g.containsEdge(e)) {\n            return false;\n        }\n        if (!g.getEdgeSource(e).equals(source) || !g.getEdgeTarget(e).equals(target)) {\n            return false;\n        }\n        if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 276,col 5)-(line 315,col 5)","methodTokenRange":"@Override public boolean equals(Object obj)\n    {\n        if (this == obj) {\n            return true;\n        }\n        if ((obj == null) || (getClass() != obj.getClass())) {\n            return false;\n        }\n\n        TypeUtil<Graph<V, E>> typeDecl = null;\n        Graph<V, E> g = TypeUtil.uncheckedCast(obj, typeDecl);\n\n        if (!vertexSet().equals(g.vertexSet())) {\n            return false;\n        }\n        if (edgeSet().size() != g.edgeSet().size()) {\n            return false;\n        }\n\n        for (E e : edgeSet()) {\n            V source = getEdgeSource(e);\n            V target = getEdgeTarget(e);\n\n            if (!g.containsEdge(e)) {\n                return false;\n            }\n\n            if (!g.getEdgeSource(e).equals(source)\n                || !g.getEdgeTarget(e).equals(target))\n            {\n                return false;\n            }\n\n            if (Math.abs(getEdgeWeight(e) - g.getEdgeWeight(e)) > 10e-7) {\n                return false;\n            }\n        }\n\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Indicates whether some other object is \"equal to\" this graph. Returns\n     * <code>true<\/code> if the given object is also a graph, the two graphs are\n     * instances of the same graph class, have identical vertices and edges sets\n     * with the same weights.\n     *\n     * @param obj object to be compared for equality with this graph\n     *\n     * @return <code>true<\/code> if the specified object is equal to this graph\n     *\n     * @see Object#equals(Object)\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"equals","methodQualifiedSignature":"org.jgrapht.graph.AbstractGraph.equals","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Indicates whether some other object is \"equal to\" this graph. Returns\n<code>true<\/code> if the given object is also a graph, the two graphs are\ninstances of the same graph class, have identical vertices and edges sets\nwith the same weights.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object to be compared for equality with this graph'}]}', name=Optional[obj]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the specified object is equal to this graph'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Object#equals(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 279,col 20)-(line 279,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 281,col 21)-(line 281,col 24)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 282,col 20)-(line 282,col 24)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 285,col 42)-(line 285,col 45)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 289,col 20)-(line 289,col 24)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 292,col 20)-(line 292,col 24)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 300,col 24)-(line 300,col 28)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 306,col 24)-(line 306,col 28)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 309,col 67)-(line 309,col 71)","literalExprId":9,"literalExpr":"10e-7","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 310,col 24)-(line 310,col 28)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 314,col 16)-(line 314,col 19)","literalExprId":11,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.AbstractGraph.equals(java.lang.Object)"}],"classJavadoc":"\/**\n * A skeletal implementation of the <tt>Graph<\/tt> interface, to minimize the\n * effort required to implement graph interfaces. This implementation is\n * applicable to both: directed graphs and undirected graphs.\n *\n * @author Barak Naveh\n * @see Graph\n * @see DirectedGraph\n * @see UndirectedGraph\n *\/\n","className":"AbstractGraph","fields":[]}],"sourceFileId":64,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.MaskSubgraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices and edges to exclude in the subgraph. If a\nvertex\/edge is masked, it is as if it is not in the subgraph.","javadocBlockTagName":"mask","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices and edges to exclude in the subgraph. If a\nvertex\/edge is masked, it is as if it is not in the subgraph.'}]}', name=Optional[mask]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.MaskSubgraph(org.jgrapht.Graph<V, E>, org.jgrapht.graph.MaskFunctor<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 74,col 5)-(line 82,col 5)","constructorJavadocComment":"\n     * Creates a new induced subgraph. Running-time = O(1).\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param mask vertices and edges to exclude in the subgraph. If a\n     * vertex\/edge is masked, it is as if it is not in the subgraph.\n     ","constructorDeclaration":"public MaskSubgraph(Graph<V, E> base, MaskFunctor<V, E> mask)","constructorBody":"{\n    super();\n    this.base = base;\n    this.mask = mask;\n    this.vertices = new MaskVertexSet<V, E>(base.vertexSet(), mask);\n    this.edges = new MaskEdgeSet<V, E>(base, base.edgeSet(), mask);\n}","constructorName":"MaskSubgraph","constructorQualifiedName":"org.jgrapht.graph.MaskSubgraph.MaskSubgraph","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> base","parameterName":"base"},{"parameterType":"MaskFunctor<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>","parameter":"MaskFunctor<V, E> mask","parameterName":"mask"}],"literalExprs":[],"constructorTokenRange":"public MaskSubgraph(Graph<V, E> base, MaskFunctor<V, E> mask)\n    {\n        super();\n        this.base = base;\n        this.mask = mask;\n\n        this.vertices = new MaskVertexSet<V, E>(base.vertexSet(), mask);\n        this.edges = new MaskEdgeSet<V, E>(base, base.edgeSet(), mask);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new induced subgraph. Running-time = O(1).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices and edges to exclude in the subgraph. If a\nvertex\/edge is masked, it is as if it is not in the subgraph.'}]}', name=Optional[mask]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 87,col 5)-(line 90,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.addEdge(V, V)"},{"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 92,col 5)-(line 95,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E edge)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.addEdge","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 100,col 5)-(line 103,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.addVertex(V)"},{"methodDeclaration":"public boolean containsEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeSet().contains(e);\n}","methodRange":"(line 105,col 5)-(line 108,col 5)","methodTokenRange":"@Override public boolean containsEdge(E e)\n    {\n        return edgeSet().contains(e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"containsEdge","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.containsEdge","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.containsEdge(E)"},{"methodDeclaration":"public boolean containsVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return !this.mask.isVertexMasked(v) && this.base.containsVertex(v);\n}","methodRange":"(line 110,col 5)-(line 113,col 5)","methodTokenRange":"@Override public boolean containsVertex(V v)\n    {\n        return !this.mask.isVertexMasked(v) && this.base.containsVertex(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"containsVertex","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.containsVertex","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.containsVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"UndirectedGraph#degreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgesOf(vertex).size();\n}","methodRange":"(line 118,col 5)-(line 121,col 5)","methodTokenRange":"public int degreeOf(V vertex)\n    {\n        return edgesOf(vertex).size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see UndirectedGraph#degreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.degreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.degreeOf(V)"},{"methodDeclaration":"public Set<E> edgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.edges;\n}","methodRange":"(line 123,col 5)-(line 126,col 5)","methodTokenRange":"@Override public Set<E> edgeSet()\n    {\n        return this.edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"edgeSet","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.edgeSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.edgeSet()"},{"methodDeclaration":"public Set<E> edgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    return new MaskEdgeSet<V, E>(this.base, this.base.edgesOf(vertex), this.mask);\n}","methodRange":"(line 128,col 5)-(line 136,col 5)","methodTokenRange":"@Override public Set<E> edgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        return new MaskEdgeSet<V, E>(\n            this.base,\n            this.base.edgesOf(vertex),\n            this.mask);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOf","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.edgesOf","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.edgesOf(V)"},{"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> edges = null;\n    if (containsVertex(sourceVertex) && containsVertex(targetVertex)) {\n        return new MaskEdgeSet<V, E>(this.base, this.base.getAllEdges(sourceVertex, targetVertex), this.mask);\n    }\n    return edges;\n}","methodRange":"(line 138,col 5)-(line 152,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = null;\n\n        if (containsVertex(sourceVertex) && containsVertex(targetVertex)) {\n            return new MaskEdgeSet<V, E>(\n                this.base,\n                this.base.getAllEdges(\n                    sourceVertex,\n                    targetVertex),\n                this.mask);\n        }\n\n        return edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.getAllEdges","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 140,col 24)-(line 140,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.getAllEdges(V, V)"},{"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> edges = getAllEdges(sourceVertex, targetVertex);\n    if ((edges == null) || edges.isEmpty()) {\n        return null;\n    } else {\n        return edges.iterator().next();\n    }\n}","methodRange":"(line 154,col 5)-(line 163,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        Set<E> edges = getAllEdges(sourceVertex, targetVertex);\n\n        if ((edges == null) || edges.isEmpty()) {\n            return null;\n        } else {\n            return edges.iterator().next();\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.getEdge","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 158,col 23)-(line 158,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 159,col 20)-(line 159,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.getEdge(V, V)"},{"methodDeclaration":"public EdgeFactory<V, E> getEdgeFactory()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.base.getEdgeFactory();\n}","methodRange":"(line 165,col 5)-(line 168,col 5)","methodTokenRange":"@Override public EdgeFactory<V, E> getEdgeFactory()\n    {\n        return this.base.getEdgeFactory();\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getEdgeFactory","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.getEdgeFactory","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"EdgeFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.getEdgeFactory()"},{"methodDeclaration":"public V getEdgeSource(E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert (edgeSet().contains(edge));\n    return this.base.getEdgeSource(edge);\n}","methodRange":"(line 170,col 5)-(line 175,col 5)","methodTokenRange":"@Override public V getEdgeSource(E edge)\n    {\n        assert (edgeSet().contains(edge));\n\n        return this.base.getEdgeSource(edge);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.getEdgeSource","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.getEdgeSource(E)"},{"methodDeclaration":"public V getEdgeTarget(E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert (edgeSet().contains(edge));\n    return this.base.getEdgeTarget(edge);\n}","methodRange":"(line 177,col 5)-(line 182,col 5)","methodTokenRange":"@Override public V getEdgeTarget(E edge)\n    {\n        assert (edgeSet().contains(edge));\n\n        return this.base.getEdgeTarget(edge);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.getEdgeTarget","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.getEdgeTarget(E)"},{"methodDeclaration":"public double getEdgeWeight(E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert (edgeSet().contains(edge));\n    return this.base.getEdgeWeight(edge);\n}","methodRange":"(line 184,col 5)-(line 189,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E edge)\n    {\n        assert (edgeSet().contains(edge));\n\n        return this.base.getEdgeWeight(edge);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.getEdgeWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.getEdgeWeight(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#incomingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    return new MaskEdgeSet<V, E>(this.base, ((DirectedGraph<V, E>) this.base).incomingEdgesOf(vertex), this.mask);\n}","methodRange":"(line 194,col 5)-(line 202,col 5)","methodTokenRange":"public Set<E> incomingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        return new MaskEdgeSet<V, E>(\n            this.base,\n            ((DirectedGraph<V, E>) this.base).incomingEdgesOf(vertex),\n            this.mask);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#inDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return incomingEdgesOf(vertex).size();\n}","methodRange":"(line 207,col 5)-(line 210,col 5)","methodTokenRange":"public int inDegreeOf(V vertex)\n    {\n        return incomingEdgesOf(vertex).size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#inDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return outgoingEdgesOf(vertex).size();\n}","methodRange":"(line 215,col 5)-(line 218,col 5)","methodTokenRange":"public int outDegreeOf(V vertex)\n    {\n        return outgoingEdgesOf(vertex).size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#outDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outgoingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    return new MaskEdgeSet<V, E>(this.base, ((DirectedGraph<V, E>) this.base).outgoingEdgesOf(vertex), this.mask);\n}","methodRange":"(line 223,col 5)-(line 231,col 5)","methodTokenRange":"public Set<E> outgoingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        return new MaskEdgeSet<V, E>(\n            this.base,\n            ((DirectedGraph<V, E>) this.base).outgoingEdgesOf(vertex),\n            this.mask);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.outgoingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllEdges(Collection<? extends E> edges)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 236,col 5)-(line 239,col 5)","methodTokenRange":"@Override public boolean removeAllEdges(Collection<? extends E> edges)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edges","parameterName":"edges"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.removeAllEdges(java.util.Collection<? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> removeAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 244,col 5)-(line 247,col 5)","methodTokenRange":"@Override public Set<E> removeAllEdges(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#removeAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeAllEdges","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.removeAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.removeAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeAllVertices(Collection)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeAllVertices(Collection<? extends V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 252,col 5)-(line 255,col 5)","methodTokenRange":"@Override public boolean removeAllVertices(Collection<? extends V> vertices)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeAllVertices(Collection)\n     ","methodParameters":[{"parameterType":"Collection<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertices","parameterName":"vertices"}],"methodName":"removeAllVertices","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.removeAllVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeAllVertices(Collection)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.removeAllVertices(java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeEdge(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 260,col 5)-(line 263,col 5)","methodTokenRange":"@Override public boolean removeEdge(E e)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.removeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 268,col 5)-(line 271,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean removeVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(UNMODIFIABLE);\n}","methodRange":"(line 276,col 5)-(line 279,col 5)","methodTokenRange":"@Override public boolean removeVertex(V v)\n    {\n        throw new UnsupportedOperationException(UNMODIFIABLE);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.removeVertex(V)"},{"methodDeclaration":"public Set<V> vertexSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.vertices;\n}","methodRange":"(line 281,col 5)-(line 284,col 5)","methodTokenRange":"@Override public Set<V> vertexSet()\n    {\n        return this.vertices;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"vertexSet","methodQualifiedSignature":"org.jgrapht.graph.MaskSubgraph.vertexSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.MaskSubgraph.vertexSet()"}],"classJavadoc":"\/**\n * An unmodifiable subgraph induced by a vertex\/edge masking function. The\n * subgraph will keep track of edges being added to its vertex subset as well as\n * deletion of edges and vertices. When iterating over the vertices\/edges, it\n * will iterate over the vertices\/edges of the base graph and discard\n * vertices\/edges that are masked (an edge with a masked extremity vertex is\n * discarded as well).\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"MaskSubgraph","fields":[{"fieldRange":"(line 57,col 5)-(line 57,col 76)","fieldName":"UNMODIFIABLE","fieldJavadocComment":"","fieldTokenRange":"private static final String UNMODIFIABLE = \"this graph is unmodifiable\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 57,col 48)-(line 57,col 75)","literalExprId":1,"literalExpr":"\"this graph is unmodifiable\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"this graph is unmodifiable\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 59,col 5)-(line 59,col 29)","fieldName":"base","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> base;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 61,col 5)-(line 61,col 25)","fieldName":"edges","fieldJavadocComment":"","fieldTokenRange":"private Set<E> edges;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 63,col 5)-(line 63,col 35)","fieldName":"mask","fieldJavadocComment":"","fieldTokenRange":"private MaskFunctor<V, E> mask;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.MaskFunctor, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.MaskFunctor.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.MaskFunctor.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"MaskFunctor<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.MaskFunctor<V, E>"},{"fieldRange":"(line 65,col 5)-(line 65,col 28)","fieldName":"vertices","fieldJavadocComment":"","fieldTokenRange":"private Set<V> vertices;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"}]}],"sourceFileId":65,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.ClassBasedEdgeFactory","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"ClassBasedEdgeFactory","constructorQualifiedName":"org.jgrapht.graph.ClassBasedEdgeFactory.ClassBasedEdgeFactory","constructorQualifiedSignature":"org.jgrapht.graph.ClassBasedEdgeFactory.ClassBasedEdgeFactory(java.lang.Class<? extends E>)","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public ClassBasedEdgeFactory(Class<? extends E> edgeClass)\n    {\n        this.edgeClass = edgeClass;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 62,col 5)-(line 65,col 5)","constructorJavadocComment":"","constructorDeclaration":"public ClassBasedEdgeFactory(Class<? extends E> edgeClass)","constructorBody":"{\n    this.edgeClass = edgeClass;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"EdgeFactory#createEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='EdgeFactory#createEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E createEdge(V source, V target)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        return edgeClass.newInstance();\n    } catch (Exception ex) {\n        throw new RuntimeException(\"Edge factory failed\", ex);\n    }\n}","methodRange":"(line 70,col 5)-(line 77,col 5)","methodTokenRange":"@Override public E createEdge(V source, V target)\n    {\n        try {\n            return edgeClass.newInstance();\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Edge factory failed\", ex);\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see EdgeFactory#createEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"}],"methodName":"createEdge","methodQualifiedSignature":"org.jgrapht.graph.ClassBasedEdgeFactory.createEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='EdgeFactory#createEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 75,col 40)-(line 75,col 60)","literalExprId":1,"literalExpr":"\"Edge factory failed\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.ClassBasedEdgeFactory.createEdge(V, V)"}],"classJavadoc":"\/**\n * An {@link EdgeFactory} for producing edges by using a class as a factory.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n *\/\n","className":"ClassBasedEdgeFactory","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3618135658586388792L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 58,col 50)-(line 58,col 69)","literalExprId":1,"literalExpr":"3618135658586388792L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3618135658586388792L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 60,col 5)-(line 60,col 47)","fieldName":"edgeClass","fieldJavadocComment":"","fieldTokenRange":"private final Class<? extends E> edgeClass;","fieldTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Class<? extends E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Class<? extends E>"}]}],"sourceFileId":66,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.SimpleWeightedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleWeightedGraph.SimpleWeightedGraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * Creates a new simple weighted graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public SimpleWeightedGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"SimpleWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleWeightedGraph.SimpleWeightedGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public SimpleWeightedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple weighted graph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleWeightedGraph.SimpleWeightedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 73,col 5)","constructorJavadocComment":"\n     * Creates a new simple weighted graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public SimpleWeightedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"SimpleWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleWeightedGraph.SimpleWeightedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public SimpleWeightedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(edgeClass));\n}","methodRange":"(line 75,col 5)-(line 82,col 5)","methodTokenRange":"public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends SimpleWeightedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, SimpleWeightedGraph<V, E>>(\n                new SimpleWeightedGraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleWeightedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleWeightedGraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedWeightedGraphBuilder<V, E, SimpleWeightedGraph<V, E>>(new SimpleWeightedGraph<V, E>(ef));\n}","methodRange":"(line 84,col 5)-(line 90,col 5)","methodTokenRange":"public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends SimpleWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, SimpleWeightedGraph<V, E>>(\n                new SimpleWeightedGraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleWeightedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedWeightedGraphBuilderBase<V, E, ? extends SimpleWeightedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleWeightedGraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A simple weighted graph. A simple weighted graph is a simple graph for which\n * edges are assigned weights.\n *\/\n","className":"SimpleWeightedGraph","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3906088949100655922L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3906088949100655922L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3906088949100655922L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":67,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AsWeightedDirectedGraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph over which a weighted view is to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which a weighted view is to be created.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the","javadocBlockTagName":"weightMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the'}]}', name=Optional[weightMap]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.AsWeightedDirectedGraph.AsWeightedDirectedGraph(org.jgrapht.DirectedGraph<V, E>, java.util.Map<E, java.lang.Double>)","variableDeclarationExprs":[],"constructorRange":"(line 82,col 5)-(line 87,col 5)","constructorJavadocComment":"\n     * Constructor for AsWeightedGraph.\n     *\n     * @param g the backing graph over which a weighted view is to be created.\n     * @param weightMap A mapping of edges to weights. If an edge is not present\n     * in the weight map, the edge weight for the underlying graph is returned.\n     * Note that a live reference to this map is retained, so if the caller\n     * changes the map after construction, the changes will affect the\n     ","constructorDeclaration":"public AsWeightedDirectedGraph(DirectedGraph<V, E> g, Map<E, Double> weightMap)","constructorBody":"{\n    super(g, weightMap);\n}","constructorName":"AsWeightedDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.AsWeightedDirectedGraph.AsWeightedDirectedGraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"},{"parameterType":"Map<E, Double>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<E, java.lang.Double>","parameter":"Map<E, Double> weightMap","parameterName":"weightMap"}],"literalExprs":[],"constructorTokenRange":"public AsWeightedDirectedGraph(\n        DirectedGraph<V, E> g,\n        Map<E, Double> weightMap)\n    {\n        super(g, weightMap);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for AsWeightedGraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which a weighted view is to be created.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the'}]}', name=Optional[weightMap]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * <p>A weighted view of the backing graph specified in the constructor. This\n * allows you to apply algorithms designed for weighted graphs to an unweighted\n * graph by providing an explicit edge weight mapping. The implementation also\n * allows for \"masking\" weights for a subset of the edges in an existing\n * weighted graph.<\/p>\n *\n * <p>Query operations on this graph \"read through\" to the backing graph. Vertex\n * addition\/removal and edge addition\/removal are all supported (and immediately\n * reflected in the backing graph). Setting an edge weight will pass the\n * operation to the backing graph as well if the backing graph implements the\n * WeightedGraph interface. Setting an edge weight will modify the weight map in\n * order to maintain a consistent graph.<\/p>\n *\n * <p>Note that edges returned by this graph's accessors are really just the\n * edges of the underlying directed graph.<\/p>\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods. This graph will be serializable if the backing\n * graph is serializable.<\/p>\n *\n * @author Joris Kinable\n * @since Aug 20, 2015\n *\/\n","className":"AsWeightedDirectedGraph","fields":[]}],"sourceFileId":68,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.SimpleDirectedWeightedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleDirectedWeightedGraph.SimpleDirectedWeightedGraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new simple directed weighted graph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public SimpleDirectedWeightedGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"SimpleDirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleDirectedWeightedGraph.SimpleDirectedWeightedGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public SimpleDirectedWeightedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple directed weighted graph with the specified edge\nfactory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleDirectedWeightedGraph.SimpleDirectedWeightedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 71,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Creates a new simple directed weighted graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public SimpleDirectedWeightedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"SimpleDirectedWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleDirectedWeightedGraph.SimpleDirectedWeightedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public SimpleDirectedWeightedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple directed weighted graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n}","methodRange":"(line 76,col 5)-(line 83,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, SimpleDirectedWeightedGraph<V, E>>(\n                new SimpleDirectedWeightedGraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleDirectedWeightedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleDirectedWeightedGraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, SimpleDirectedWeightedGraph<V, E>>(new SimpleDirectedWeightedGraph<V, E>(ef));\n}","methodRange":"(line 85,col 5)-(line 92,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedWeightedGraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, SimpleDirectedWeightedGraph<V, E>>(\n                new SimpleDirectedWeightedGraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleDirectedWeightedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends SimpleDirectedWeightedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleDirectedWeightedGraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A simple directed weighted graph. A simple directed weighted graph is a\n * simple directed graph for which edges are assigned weights.\n *\/\n","className":"SimpleDirectedWeightedGraph","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3904960841681220919L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3904960841681220919L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3904960841681220919L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":69,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.UnmodifiableUndirectedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph on which an unmodifiable graph is to be\ncreated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph on which an unmodifiable graph is to be\ncreated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.UnmodifiableUndirectedGraph.UnmodifiableUndirectedGraph(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new unmodifiable undirected graph based on the specified\n     * backing graph.\n     *\n     * @param g the backing graph on which an unmodifiable graph is to be\n     * created.\n     ","constructorDeclaration":"public UnmodifiableUndirectedGraph(UndirectedGraph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"UnmodifiableUndirectedGraph","constructorQualifiedName":"org.jgrapht.graph.UnmodifiableUndirectedGraph.UnmodifiableUndirectedGraph","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public UnmodifiableUndirectedGraph(UndirectedGraph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new unmodifiable undirected graph based on the specified\nbacking graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph on which an unmodifiable graph is to be\ncreated.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * An undirected graph that cannot be modified.\n *\n * @see UnmodifiableGraph\n *\/\n","className":"UnmodifiableUndirectedGraph","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3258134639355704624L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 69)","literalExprId":1,"literalExpr":"3258134639355704624L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3258134639355704624L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":70,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.UndirectedSubgraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.","javadocBlockTagName":"vertexSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.","javadocBlockTagName":"edgeSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.UndirectedSubgraph.UndirectedSubgraph(org.jgrapht.UndirectedGraph<V, E>, java.util.Set<V>, java.util.Set<E>)","variableDeclarationExprs":[],"constructorRange":"(line 66,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Creates a new undirected subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null<\/code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null<\/code> then all the edges whose vertices found in the graph are\n     * included.\n     ","constructorDeclaration":"public UndirectedSubgraph(UndirectedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset)","constructorBody":"{\n    super(base, vertexSubset, edgeSubset);\n}","constructorName":"UndirectedSubgraph","constructorQualifiedName":"org.jgrapht.graph.UndirectedSubgraph.UndirectedSubgraph","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> base","parameterName":"base"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSubset","parameterName":"vertexSubset"},{"parameterType":"Set<E>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSubset","parameterName":"edgeSubset"}],"literalExprs":[],"constructorTokenRange":"public UndirectedSubgraph(\n        UndirectedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super(base, vertexSubset, edgeSubset);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new undirected subgraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"UndirectedGraph#degreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    int degree = 0;\n    for (E e : getBase().edgesOf(vertex)) {\n        if (containsEdge(e)) {\n            degree++;\n            if (getEdgeSource(e).equals(getEdgeTarget(e))) {\n                degree++;\n            }\n        }\n    }\n    return degree;\n}","methodRange":"(line 77,col 5)-(line 94,col 5)","methodTokenRange":"@Override public int degreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().edgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n\n                if (getEdgeSource(e).equals(getEdgeTarget(e))) {\n                    degree++;\n                }\n            }\n        }\n\n        return degree;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see UndirectedGraph#degreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.graph.UndirectedSubgraph.degreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='UndirectedGraph#degreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 81,col 22)-(line 81,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.UndirectedSubgraph.degreeOf(V)"}],"classJavadoc":"\/**\n * An undirected graph that is a subgraph on other graph.\n *\n * @see Subgraph\n *\/\n","className":"UndirectedSubgraph","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3256728359772631350L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"3256728359772631350L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3256728359772631350L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":71,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.WeightedMultigraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.WeightedMultigraph.WeightedMultigraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 66,col 5)","constructorJavadocComment":"\n     * Creates a new weighted multigraph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public WeightedMultigraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"WeightedMultigraph","constructorQualifiedName":"org.jgrapht.graph.WeightedMultigraph.WeightedMultigraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public WeightedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new weighted multigraph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.WeightedMultigraph.WeightedMultigraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a new weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public WeightedMultigraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"WeightedMultigraph","constructorQualifiedName":"org.jgrapht.graph.WeightedMultigraph.WeightedMultigraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public WeightedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new weighted multigraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(edgeClass));\n}","methodRange":"(line 78,col 5)-(line 85,col 5)","methodTokenRange":"public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedMultigraph<V, E>>(\n                new WeightedMultigraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.WeightedMultigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.WeightedMultigraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UndirectedWeightedGraphBuilder<V, E, WeightedMultigraph<V, E>>(new WeightedMultigraph<V, E>(ef));\n}","methodRange":"(line 87,col 5)-(line 93,col 5)","methodTokenRange":"public static <V, E> UndirectedWeightedGraphBuilderBase<V,\n        E, ? extends WeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new UndirectedWeightedGraphBuilder<V,\n            E, WeightedMultigraph<V, E>>(\n                new WeightedMultigraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.WeightedMultigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UndirectedWeightedGraphBuilderBase<V, E, ? extends WeightedMultigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.WeightedMultigraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A weighted multigraph. A weighted multigraph is a non-simple undirected graph\n * in which no loops are permitted, but multiple edges between any two vertices\n * are. The edges of a weighted multigraph have weights. If you're unsure about\n * multigraphs, see: <a href=\"http:\/\/mathworld.wolfram.com\/Multigraph.html\">\n * http:\/\/mathworld.wolfram.com\/Multigraph.html<\/a>.\n *\/\n","className":"WeightedMultigraph","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3544671793370640696L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 50)-(line 56,col 69)","literalExprId":1,"literalExpr":"3544671793370640696L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3544671793370640696L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":72,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.EdgeReversedGraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the edge-reversed view will be\nbased.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the edge-reversed view will be\nbased.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.EdgeReversedGraph(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a new EdgeReversedGraph.\n     *\n     * @param g the base (backing) graph on which the edge-reversed view will be\n     * based.\n     ","constructorDeclaration":"public EdgeReversedGraph(DirectedGraph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"EdgeReversedGraph","constructorQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.EdgeReversedGraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public EdgeReversedGraph(DirectedGraph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new EdgeReversedGraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the edge-reversed view will be\nbased.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.getEdge(targetVertex, sourceVertex);\n}","methodRange":"(line 81,col 5)-(line 84,col 5)","methodTokenRange":"@Override public E getEdge(V sourceVertex, V targetVertex)\n    {\n        return super.getEdge(targetVertex, sourceVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.getEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getAllEdges(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getAllEdges(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.getAllEdges(targetVertex, sourceVertex);\n}","methodRange":"(line 89,col 5)-(line 92,col 5)","methodTokenRange":"@Override public Set<E> getAllEdges(V sourceVertex, V targetVertex)\n    {\n        return super.getAllEdges(targetVertex, sourceVertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see Graph#getAllEdges(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getAllEdges","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.getAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getAllEdges(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.getAllEdges(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E addEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.addEdge(targetVertex, sourceVertex);\n}","methodRange":"(line 97,col 5)-(line 100,col 5)","methodTokenRange":"@Override public E addEdge(V sourceVertex, V targetVertex)\n    {\n        return super.addEdge(targetVertex, sourceVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.addEdge(targetVertex, sourceVertex, e);\n}","methodRange":"(line 105,col 5)-(line 108,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        return super.addEdge(targetVertex, sourceVertex, e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#inDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.outDegreeOf(vertex);\n}","methodRange":"(line 113,col 5)-(line 116,col 5)","methodTokenRange":"@Override public int inDegreeOf(V vertex)\n    {\n        return super.outDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#inDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.inDegreeOf(vertex);\n}","methodRange":"(line 121,col 5)-(line 124,col 5)","methodTokenRange":"@Override public int outDegreeOf(V vertex)\n    {\n        return super.inDegreeOf(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#outDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#incomingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.outgoingEdgesOf(vertex);\n}","methodRange":"(line 129,col 5)-(line 132,col 5)","methodTokenRange":"@Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        return super.outgoingEdgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outgoingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.incomingEdgesOf(vertex);\n}","methodRange":"(line 137,col 5)-(line 140,col 5)","methodTokenRange":"@Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        return super.incomingEdgesOf(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.outgoingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public E removeEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.removeEdge(targetVertex, sourceVertex);\n}","methodRange":"(line 145,col 5)-(line 148,col 5)","methodTokenRange":"@Override public E removeEdge(V sourceVertex, V targetVertex)\n    {\n        return super.removeEdge(targetVertex, sourceVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @see Graph#removeEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeSource(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeSource(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.getEdgeTarget(e);\n}","methodRange":"(line 153,col 5)-(line 156,col 5)","methodTokenRange":"@Override public V getEdgeSource(E e)\n    {\n        return super.getEdgeTarget(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeSource(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.getEdgeSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeSource(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.getEdgeSource(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeTarget(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeTarget(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return super.getEdgeSource(e);\n}","methodRange":"(line 161,col 5)-(line 164,col 5)","methodTokenRange":"@Override public V getEdgeTarget(E e)\n    {\n        return super.getEdgeSource(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see Graph#getEdgeTarget(Object)\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.getEdgeTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeTarget(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.getEdgeTarget(E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.lang.Object#toString()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#toString()'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return toStringFromSets(vertexSet(), edgeSet(), true);\n}","methodRange":"(line 169,col 5)-(line 175,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        return toStringFromSets(\n            vertexSet(),\n            edgeSet(),\n            true);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * @see java.lang.Object#toString()\n     ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.graph.EdgeReversedGraph.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.lang.Object#toString()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 174,col 13)-(line 174,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.EdgeReversedGraph.toString()"}],"classJavadoc":"\/**\n * Provides an edge-reversed view g' of a directed graph g. The vertex sets for\n * the two graphs are the same, but g' contains an edge (v2, v1) iff g contains\n * an edge (v1, v2). g' is backed by g, so changes to g are reflected in g', and\n * vice versa.\n *\n * <p>This class allows you to use a directed graph algorithm in reverse. For\n * example, suppose you have a directed graph representing a tree, with edges\n * from parent to child, and you want to find all of the parents of a node. To\n * do this, simply create an edge-reversed graph and pass that as input to\n * {@link org.jgrapht.traverse.DepthFirstIterator}.\n *\n * @author John V. Sichi\n * @see AsUndirectedGraph\n *\/\n","className":"EdgeReversedGraph","fields":[{"fieldRange":"(line 65,col 5)-(line 65,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"\n     ","fieldTokenRange":"private static final long serialVersionUID = 9091361782455418631L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 65,col 50)-(line 65,col 69)","literalExprId":1,"literalExpr":"9091361782455418631L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[9091361782455418631L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":73,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.AsWeightedGraph","imports":[{"importId":1,"import":"import java.io.*;\n"},{"importId":2,"import":"import java.util.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph over which a weighted view is to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which a weighted view is to be created.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the\nAsWeightedGraph instance as well.","javadocBlockTagName":"weightMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the\nAsWeightedGraph instance as well.'}]}', name=Optional[weightMap]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.AsWeightedGraph.AsWeightedGraph(org.jgrapht.Graph<V, E>, java.util.Map<E, java.lang.Double>)","variableDeclarationExprs":[],"constructorRange":"(line 93,col 5)-(line 102,col 5)","constructorJavadocComment":"\n     * Constructor for AsWeightedGraph.\n     *\n     * @param g the backing graph over which a weighted view is to be created.\n     * @param weightMap A mapping of edges to weights. If an edge is not present\n     * in the weight map, the edge weight for the underlying graph is returned.\n     * Note that a live reference to this map is retained, so if the caller\n     * changes the map after construction, the changes will affect the\n     * AsWeightedGraph instance as well.\n     ","constructorDeclaration":"public AsWeightedGraph(Graph<V, E> g, Map<E, Double> weightMap)","constructorBody":"{\n    super(g);\n    assert (weightMap != null);\n    this.weightMap = weightMap;\n    this.isWeightedGraph = (g instanceof WeightedGraph<?, ?>);\n}","constructorName":"AsWeightedGraph","constructorQualifiedName":"org.jgrapht.graph.AsWeightedGraph.AsWeightedGraph","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"Map<E, Double>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<E, java.lang.Double>","parameter":"Map<E, Double> weightMap","parameterName":"weightMap"}],"literalExprs":[{"literalExprRange":"(line 96,col 30)-(line 96,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public AsWeightedGraph(Graph<V, E> g, Map<E, Double> weightMap)\n    {\n        super(g);\n        assert (weightMap != null);\n        this.weightMap = weightMap;\n\n        \/\/ Remember whether the backing graph implements the WeightedGraph\n        \/\/ interface\n        this.isWeightedGraph = (g instanceof WeightedGraph<?, ?>);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for AsWeightedGraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph over which a weighted view is to be created.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A mapping of edges to weights. If an edge is not present\nin the weight map, the edge weight for the underlying graph is returned.\nNote that a live reference to this map is retained, so if the caller\nchanges the map after construction, the changes will affect the\nAsWeightedGraph instance as well.'}]}', name=Optional[weightMap]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"WeightedGraph#setEdgeWeight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight'}]}', name=Optional.empty}"}],"methodDeclaration":"public void setEdgeWeight(E e, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (isWeightedGraph) {\n        super.setEdgeWeight(e, weight);\n    }\n    weightMap.put(e, weight);\n}","methodRange":"(line 107,col 5)-(line 116,col 5)","methodTokenRange":"@Override public void setEdgeWeight(E e, double weight)\n    {\n        if (isWeightedGraph) {\n            super.setEdgeWeight(e, weight);\n        }\n\n        \/\/ Always modify the weight map.  It would be a terrible violation\n        \/\/ of the use contract to silently ignore changes to the weights.\n        weightMap.put(e, weight);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see WeightedGraph#setEdgeWeight\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"setEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.AsWeightedGraph.setEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='WeightedGraph#setEdgeWeight'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsWeightedGraph.setEdgeWeight(E, double)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getEdgeWeight(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double weight;\n    if (weightMap.containsKey(e)) {\n        weight = weightMap.get(e);\n    } else {\n        weight = super.getEdgeWeight(e);\n    }\n    return weight;\n}","methodRange":"(line 121,col 5)-(line 134,col 5)","methodTokenRange":"@Override public double getEdgeWeight(E e)\n    {\n        double weight;\n\n        \/\/ Always return the value from the weight map first and\n        \/\/ only pass the call through as a backup\n        if (weightMap.containsKey(e)) {\n            weight = weightMap.get(e);\n        } else {\n            weight = super.getEdgeWeight(e);\n        }\n\n        return weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @see Graph#getEdgeWeight\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeWeight","methodQualifiedSignature":"org.jgrapht.graph.AsWeightedGraph.getEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.AsWeightedGraph.getEdgeWeight(E)"}],"classJavadoc":"\/**\n * <p>A weighted view of the backing graph specified in the constructor. This\n * graph allows modules to apply algorithms designed for weighted graphs to an\n * unweighted graph by providing an explicit edge weight mapping. The\n * implementation also allows for \"masking\" weights for a subset of the edges in\n * an existing weighted graph.<\/p>\n *\n * <p>Query operations on this graph \"read through\" to the backing graph. Vertex\n * addition\/removal and edge addition\/removal are all supported (and immediately\n * reflected in the backing graph). Setting an edge weight will pass the\n * operation to the backing graph as well if the backing graph implements the\n * WeightedGraph interface. Setting an edge weight will modify the weight map in\n * order to maintain a consistent graph.<\/p>\n *\n * <p>Note that edges returned by this graph's accessors are really just the\n * edges of the underlying directed graph.<\/p>\n *\n * <p>This graph does <i>not<\/i> pass the hashCode and equals operations through\n * to the backing graph, but relies on <tt>Object<\/tt>'s <tt>equals<\/tt> and\n * <tt>hashCode<\/tt> methods. This graph will be serializable if the backing\n * graph is serializable.<\/p>\n *\n * @author Lucas J. Scharenbroich\n * @since Sep 10, 2007\n *\/\n","className":"AsWeightedGraph","fields":[{"fieldRange":"(line 78,col 5)-(line 78,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"\n     ","fieldTokenRange":"private static final long serialVersionUID = -716810639338971372L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 78,col 51)-(line 78,col 69)","literalExprId":1,"literalExpr":"716810639338971372L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-716810639338971372L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 80,col 5)-(line 80,col 45)","fieldName":"weightMap","fieldJavadocComment":"","fieldTokenRange":"protected final Map<E, Double> weightMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Map<E, Double>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<E, java.lang.Double>"},{"fieldRange":"(line 81,col 5)-(line 81,col 42)","fieldName":"isWeightedGraph","fieldJavadocComment":"","fieldTokenRange":"private final boolean isWeightedGraph;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":74,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.builder.DirectedGraphBuilder","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.DirectedGraphBuilder.DirectedGraphBuilder(G)","variableDeclarationExprs":[],"constructorRange":"(line 62,col 5)-(line 65,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * DirectedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public DirectedGraphBuilder(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"DirectedGraphBuilder","constructorQualifiedName":"org.jgrapht.graph.builder.DirectedGraphBuilder.DirectedGraphBuilder","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[DirectedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public DirectedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.\n\n<p>The recomended way to use this constructor is: '}, JavadocInlineTag{tagName='code', type=CODE, content=' new\nDirectedGraphBuilder<...>(new YourGraph<...>(...))'}, JavadocSnippet{text='.\n\n<p>NOTE: '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' should not be an existing graph. If you want\nto add an existing graph to the graph being built, you should use the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #addVertex(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"protected DirectedGraphBuilder<V, E, G> self()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this;\n}","methodRange":"(line 67,col 5)-(line 70,col 5)","methodTokenRange":"@Override protected DirectedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.builder.DirectedGraphBuilder, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.builder.DirectedGraphBuilder.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.builder.DirectedGraphBuilder.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.builder.DirectedGraphBuilder.G=TypeVariable {JPTypeParameter(G, bounds=[DirectedGraph<V, E>])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"self","methodQualifiedSignature":"org.jgrapht.graph.builder.DirectedGraphBuilder.self","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.builder.DirectedGraphBuilder<V, E, G>","methodType":"DirectedGraphBuilder<V, E, G>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.DirectedGraphBuilder.self()"}],"classJavadoc":"\/**\n * A builder class for {@link Graph}. If you want to extend this class, see\n * {@link DirectedGraphBuilderBase}.\n *\/\n","className":"DirectedGraphBuilder","fields":[]}],"sourceFileId":75,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.UndirectedGraphBuilderBase","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.UndirectedGraphBuilderBase.UndirectedGraphBuilderBase(G)","variableDeclarationExprs":[],"constructorRange":"(line 58,col 5)-(line 61,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public UndirectedGraphBuilderBase(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"UndirectedGraphBuilderBase","constructorQualifiedName":"org.jgrapht.graph.builder.UndirectedGraphBuilderBase.UndirectedGraphBuilderBase","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[UndirectedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public UndirectedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public UnmodifiableUndirectedGraph<V, E> buildUnmodifiable()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UnmodifiableUndirectedGraph<V, E>(this.graph);\n}","methodRange":"(line 63,col 5)-(line 66,col 5)","methodTokenRange":"@Override public UnmodifiableUndirectedGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableUndirectedGraph<V, E>(this.graph);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"buildUnmodifiable","methodQualifiedSignature":"org.jgrapht.graph.builder.UndirectedGraphBuilderBase.buildUnmodifiable","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UnmodifiableUndirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.UndirectedGraphBuilderBase.buildUnmodifiable()"}],"classJavadoc":"\/**\n * Base class for {@link UndirectedGraphBuilder} for extending.\n *\/\n","className":"UndirectedGraphBuilderBase","fields":[]}],"sourceFileId":76,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.UndirectedGraphBuilder","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.UndirectedGraphBuilder.UndirectedGraphBuilder(G)","variableDeclarationExprs":[],"constructorRange":"(line 62,col 5)-(line 65,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * UndirectedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public UndirectedGraphBuilder(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"UndirectedGraphBuilder","constructorQualifiedName":"org.jgrapht.graph.builder.UndirectedGraphBuilder.UndirectedGraphBuilder","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[UndirectedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public UndirectedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.\n\n<p>The recomended way to use this constructor is: '}, JavadocInlineTag{tagName='code', type=CODE, content=' new\nUndirectedGraphBuilder<...>(new YourGraph<...>(...))'}, JavadocSnippet{text='.\n\n<p>NOTE: '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' should not be an existing graph. If you want\nto add an existing graph to the graph being built, you should use the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #addVertex(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"protected UndirectedGraphBuilder<V, E, G> self()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this;\n}","methodRange":"(line 67,col 5)-(line 70,col 5)","methodTokenRange":"@Override protected UndirectedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.builder.UndirectedGraphBuilder, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.builder.UndirectedGraphBuilder.G=TypeVariable {JPTypeParameter(G, bounds=[UndirectedGraph<V, E>])}, org.jgrapht.graph.builder.UndirectedGraphBuilder.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.builder.UndirectedGraphBuilder.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"self","methodQualifiedSignature":"org.jgrapht.graph.builder.UndirectedGraphBuilder.self","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.builder.UndirectedGraphBuilder<V, E, G>","methodType":"UndirectedGraphBuilder<V, E, G>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.UndirectedGraphBuilder.self()"}],"classJavadoc":"\/**\n * A builder class for {@link Graph}. If you want to extend this class, see\n * {@link UndirectedGraphBuilderBase}.\n *\/\n","className":"UndirectedGraphBuilder","fields":[]}],"sourceFileId":77,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.UndirectedWeightedGraphBuilder(G)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 67,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * UndirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public UndirectedWeightedGraphBuilder(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"UndirectedWeightedGraphBuilder","constructorQualifiedName":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.UndirectedWeightedGraphBuilder","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[UndirectedGraph<V, E>, WeightedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public UndirectedWeightedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.\n\n<p>The recomended way to use this constructor is: '}, JavadocInlineTag{tagName='code', type=CODE, content=' new\nUndirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))'}, JavadocSnippet{text='.\n\n<p>NOTE: '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' should not be an existing graph. If you want\nto add an existing graph to the graph being built, you should use the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #addVertex(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"protected UndirectedWeightedGraphBuilder<V, E, G> self()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this;\n}","methodRange":"(line 69,col 5)-(line 72,col 5)","methodTokenRange":"@Override protected UndirectedWeightedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.G=TypeVariable {JPTypeParameter(G, bounds=[UndirectedGraph<V, E>, WeightedGraph<V, E>])}, org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"self","methodQualifiedSignature":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.self","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder<V, E, G>","methodType":"UndirectedWeightedGraphBuilder<V, E, G>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilder.self()"}],"classJavadoc":"\/**\n * A builder class for undirected weighted graphs. If you want to extend this\n * class, see {@link UndirectedWeightedGraphBuilderBase}.\n *\/\n","className":"UndirectedWeightedGraphBuilder","fields":[]}],"sourceFileId":78,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilderBase","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilderBase.UndirectedWeightedGraphBuilderBase(G)","variableDeclarationExprs":[],"constructorRange":"(line 57,col 5)-(line 60,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public UndirectedWeightedGraphBuilderBase(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"UndirectedWeightedGraphBuilderBase","constructorQualifiedName":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilderBase.UndirectedWeightedGraphBuilderBase","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[UndirectedGraph<V, E>, WeightedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public UndirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"weight of the edge.","javadocBlockTagName":"weight","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graphs#addEdgeWithVertices(Graph, Object, Object, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addEdgeWithVertices(Graph, Object, Object, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addEdge(V source, V target, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","methodRange":"(line 74,col 5)-(line 78,col 5)","methodTokenRange":"public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[UndirectedWeightedGraphBuilderBase<V, E, G, B>])}","methodJavadocComment":"\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilderBase.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an weighted edge to the graph being built. The source and target\nvertices are added to the graph, if not already included.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addEdgeWithVertices(Graph, Object, Object, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.UndirectedWeightedGraphBuilderBase.addEdge(V, V, double)"}],"classJavadoc":"\/**\n * Base class for {@link UndirectedWeightedGraphBuilder} for extending.\n *\/\n","className":"UndirectedWeightedGraphBuilderBase","fields":[]}],"sourceFileId":79,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilderBase","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilderBase.DirectedWeightedGraphBuilderBase(G)","variableDeclarationExprs":[],"constructorRange":"(line 57,col 5)-(line 60,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public DirectedWeightedGraphBuilderBase(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"DirectedWeightedGraphBuilderBase","constructorQualifiedName":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilderBase.DirectedWeightedGraphBuilderBase","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[DirectedGraph<V, E>, WeightedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"weight of the edge.","javadocBlockTagName":"weight","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graphs#addEdgeWithVertices(Graph, Object, Object, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addEdgeWithVertices(Graph, Object, Object, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addEdge(V source, V target, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n    return this.self();\n}","methodRange":"(line 74,col 5)-(line 78,col 5)","methodTokenRange":"public B addEdge(V source, V target, double weight)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target, weight);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[DirectedWeightedGraphBuilderBase<V, E, G, B>])}","methodJavadocComment":"\n     * Adds an weighted edge to the graph being built. The source and target\n     * vertices are added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object, double)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilderBase.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an weighted edge to the graph being built. The source and target\nvertices are added to the graph, if not already included.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addEdgeWithVertices(Graph, Object, Object, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilderBase.addEdge(V, V, double)"}],"classJavadoc":"\/**\n * Base class for {@link DirectedWeightedGraphBuilder} for extending.\n *\/\n","className":"DirectedWeightedGraphBuilderBase","fields":[]}],"sourceFileId":80,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.AbstractGraphBuilder","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.AbstractGraphBuilder(G)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public AbstractGraphBuilder(G baseGraph)","constructorBody":"{\n    this.graph = baseGraph;\n}","constructorName":"AbstractGraphBuilder","constructorQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.AbstractGraphBuilder","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public AbstractGraphBuilder(G baseGraph)\n    {\n        this.graph = baseGraph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the {@code this} object.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='code', type=CODE, content=' this'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected abstract B self()","methodAccessSpecifier":"PROTECTED","methodBody":"","methodRange":"(line 68,col 5)-(line 68,col 32)","methodTokenRange":"protected abstract B self();","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * @return the {@code this} object.\n     ","methodParameters":[],"methodName":"self","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.self","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the '}, JavadocInlineTag{tagName='code', type=CODE, content=' this'}, JavadocSnippet{text=' object.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.self()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to add","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to add'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addVertex(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.graph.addVertex(vertex);\n    return this.self();\n}","methodRange":"(line 79,col 5)-(line 83,col 5)","methodTokenRange":"public B addVertex(V vertex)\n    {\n        this.graph.addVertex(vertex);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Adds {@code vertex} to the graph being built.\n     *\n     * @param vertex the vertex to add\n     *\n     * @return this builder object\n     *\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds '}, JavadocInlineTag{tagName='code', type=CODE, content=' vertex'}, JavadocSnippet{text=' to the graph being built.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to add'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.addVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertices to add","javadocBlockTagName":"vertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to add'}]}', name=Optional[vertices]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addVertices(V... vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (V vertex : vertices) {\n        this.addVertex(vertex);\n    }\n    return this.self();\n}","methodRange":"(line 94,col 5)-(line 100,col 5)","methodTokenRange":"public B addVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.addVertex(vertex);\n        }\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Adds each vertex of {@code vertices} to the graph being built.\n     *\n     * @param vertices the vertices to add\n     *\n     * @return this builder object\n     *\n     * @see #addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(V, bounds=[])}}","parameterTypeResolvedDescribed":"V...","parameter":"V... vertices","parameterName":"vertices"}],"methodName":"addVertices","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.addVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds each vertex of '}, JavadocInlineTag{tagName='code', type=CODE, content=' vertices'}, JavadocSnippet{text=' to the graph being built.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to add'}]}', name=Optional[vertices]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.addVertices(V...)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graphs#addEdgeWithVertices(Graph, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addEdgeWithVertices(Graph, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addEdge(V source, V target)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Graphs.addEdgeWithVertices(this.graph, source, target);\n    return this.self();\n}","methodRange":"(line 113,col 5)-(line 117,col 5)","methodTokenRange":"public B addEdge(V source, V target)\n    {\n        Graphs.addEdgeWithVertices(this.graph, source, target);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Adds an edge to the graph being built. The source and target vertices are\n     * added to the graph, if not already included.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addEdgeWithVertices(Graph, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds an edge to the graph being built. The source and target vertices are\nadded to the graph, if not already included.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addEdgeWithVertices(Graph, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.addEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addEdgeChain(V first, V second, V... rest)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.addEdge(first, second);\n    V last = second;\n    for (V vertex : rest) {\n        this.addEdge(last, vertex);\n        last = vertex;\n    }\n    return this.self();\n}","methodRange":"(line 127,col 5)-(line 136,col 5)","methodTokenRange":"public B addEdgeChain(V first, V second, V ... rest)\n    {\n        this.addEdge(first, second);\n        V last = second;\n        for (V vertex : rest) {\n            this.addEdge(last, vertex);\n            last = vertex;\n        }\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Adds a chain of edges to the graph being built. The vertices are added to\n     * the graph, if not already included.\n     *\n     * @return this builder object\n     *\n     * @see #addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V first","parameterName":"first"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V second","parameterName":"second"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(V, bounds=[])}}","parameterTypeResolvedDescribed":"V...","parameter":"V... rest","parameterName":"rest"}],"methodName":"addEdgeChain","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.addEdgeChain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a chain of edges to the graph being built. The vertices are added to\nthe graph, if not already included.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.addEdgeChain(V, V, V...)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graphs#addGraph(Graph, Graph)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addGraph(Graph, Graph)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B addGraph(Graph<? extends V, ? extends E> sourceGraph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Graphs.addGraph(this.graph, sourceGraph);\n    return this.self();\n}","methodRange":"(line 146,col 5)-(line 150,col 5)","methodTokenRange":"public B addGraph(Graph<? extends V, ? extends E> sourceGraph)\n    {\n        Graphs.addGraph(this.graph, sourceGraph);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Adds all the vertices and all the edges of the {@code sourceGraph} to the\n     * graph being built.\n     *\n     * @return this builder object\n     *\n     * @see Graphs#addGraph(Graph, Graph)\n     ","methodParameters":[{"parameterType":"Graph<? extends V, ? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}, org.jgrapht.Graph.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<? extends V, ? extends E>","parameter":"Graph<? extends V, ? extends E> sourceGraph","parameterName":"sourceGraph"}],"methodName":"addGraph","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.addGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds all the vertices and all the edges of the '}, JavadocInlineTag{tagName='code', type=CODE, content=' sourceGraph'}, JavadocSnippet{text=' to the\ngraph being built.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graphs#addGraph(Graph, Graph)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.addGraph(org.jgrapht.Graph<? extends V, ? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to remove","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to remove'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B removeVertex(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.graph.removeVertex(vertex);\n    return this.self();\n}","methodRange":"(line 162,col 5)-(line 166,col 5)","methodTokenRange":"public B removeVertex(V vertex)\n    {\n        this.graph.removeVertex(vertex);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Removes {@code vertex} from the graph being built, if such vertex exist\n     * in graph.\n     *\n     * @param vertex the vertex to remove\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"removeVertex","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.removeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes '}, JavadocInlineTag{tagName='code', type=CODE, content=' vertex'}, JavadocSnippet{text=' from the graph being built, if such vertex exist\nin graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to remove'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.removeVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertices to remove","javadocBlockTagName":"vertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to remove'}]}', name=Optional[vertices]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B removeVertices(V... vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (V vertex : vertices) {\n        this.removeVertex(vertex);\n    }\n    return this.self();\n}","methodRange":"(line 178,col 5)-(line 184,col 5)","methodTokenRange":"public B removeVertices(V ... vertices)\n    {\n        for (V vertex : vertices) {\n            this.removeVertex(vertex);\n        }\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Removes each vertex of {@code vertices} from the graph being built, if\n     * such vertices exist in graph.\n     *\n     * @param vertices the vertices to remove\n     *\n     * @return this builder object\n     *\n     * @see #removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(V, bounds=[])}}","parameterTypeResolvedDescribed":"V...","parameter":"V... vertices","parameterName":"vertices"}],"methodName":"removeVertices","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.removeVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes each vertex of '}, JavadocInlineTag{tagName='code', type=CODE, content=' vertices'}, JavadocSnippet{text=' from the graph being built, if\nsuch vertices exist in graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to remove'}]}', name=Optional[vertices]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.removeVertices(V...)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"this builder object","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#removeVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public B removeEdge(V source, V target)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.graph.removeEdge(source, target);\n    return this.self();\n}","methodRange":"(line 197,col 5)-(line 201,col 5)","methodTokenRange":"public B removeEdge(V source, V target)\n    {\n        this.graph.removeEdge(source, target);\n        return this.self();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[AbstractGraphBuilder<V, E, G, B>])}","methodJavadocComment":"\n     * Removes an edge going from source vertex to target vertex from the graph\n     * being built, if such vertices and such edge exist in the graph.\n     *\n     * @param source source vertex of the edge.\n     * @param target target vertex of the edge.\n     *\n     * @return this builder object\n     *\n     * @see Graph#removeVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V target","parameterName":"target"}],"methodName":"removeEdge","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.removeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes an edge going from source vertex to target vertex from the graph\nbeing built, if such vertices and such edge exist in the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[target]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='this builder object'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#removeVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"B","methodType":"B","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.removeEdge(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the built graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public G build()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.graph;\n}","methodRange":"(line 209,col 5)-(line 212,col 5)","methodTokenRange":"public G build()\n    {\n        return this.graph;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","methodJavadocComment":"\n     * Build the graph. Calling any method (including this method) on this\n     * builder object after calling this method is undefined behaviour.\n     *\n     * @return the built graph.\n     ","methodParameters":[],"methodName":"build","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.build","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Build the graph. Calling any method (including this method) on this\nbuilder object after calling this method is undefined behaviour.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"G","methodType":"G","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.build()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the built unmodifiable graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built unmodifiable graph.'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#build()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#build()'}]}', name=Optional.empty}"}],"methodDeclaration":"public UnmodifiableGraph<V, E> buildUnmodifiable()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UnmodifiableGraph<V, E>(this.graph);\n}","methodRange":"(line 223,col 5)-(line 226,col 5)","methodTokenRange":"public UnmodifiableGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableGraph<V, E>(this.graph);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Build an unmodifiable version graph. Calling any method (including this\n     * method) on this builder object after calling this method is undefined\n     * behaviour.\n     *\n     * @return the built unmodifiable graph.\n     *\n     * @see #build()\n     ","methodParameters":[],"methodName":"buildUnmodifiable","methodQualifiedSignature":"org.jgrapht.graph.builder.AbstractGraphBuilder.buildUnmodifiable","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Build an unmodifiable version graph. Calling any method (including this\nmethod) on this builder object after calling this method is undefined\nbehaviour.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the built unmodifiable graph.'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#build()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"UnmodifiableGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.AbstractGraphBuilder.buildUnmodifiable()"}],"classJavadoc":"\/**\n * Base class for builders of {@link Graph}\n *\n * @see DirectedGraphBuilderBase\n * @see UndirectedGraphBuilderBase\n *\/\n","className":"AbstractGraphBuilder","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 28)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"protected final G graph;","fieldTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[Graph<V, E>])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"G","fieldJavadoc":"","fieldTypeResolvedDescribed":"G"}]}],"sourceFileId":81,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilder","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.DirectedWeightedGraphBuilder(G)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 67,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * <p>The recomended way to use this constructor is: {@code new\n     * DirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))}.\n     *\n     * <p>NOTE: {@code baseGraph} should not be an existing graph. If you want\n     * to add an existing graph to the graph being built, you should use the\n     * {@link #addVertex(Object)} method.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public DirectedWeightedGraphBuilder(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"DirectedWeightedGraphBuilder","constructorQualifiedName":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.DirectedWeightedGraphBuilder","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[DirectedGraph<V, E>, WeightedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedGraphBuilder(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.\n\n<p>The recomended way to use this constructor is: '}, JavadocInlineTag{tagName='code', type=CODE, content=' new\nDirectedWeightedGraphBuilder<...>(new YourGraph<...>(...))'}, JavadocSnippet{text='.\n\n<p>NOTE: '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' should not be an existing graph. If you want\nto add an existing graph to the graph being built, you should use the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #addVertex(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"protected DirectedWeightedGraphBuilder<V, E, G> self()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this;\n}","methodRange":"(line 69,col 5)-(line 72,col 5)","methodTokenRange":"@Override protected DirectedWeightedGraphBuilder<V, E, G> self()\n    {\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.graph.builder.DirectedWeightedGraphBuilder, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.G=TypeVariable {JPTypeParameter(G, bounds=[DirectedGraph<V, E>, WeightedGraph<V, E>])}, org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"self","methodQualifiedSignature":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.self","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilder<V, E, G>","methodType":"DirectedWeightedGraphBuilder<V, E, G>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.DirectedWeightedGraphBuilder.self()"}],"classJavadoc":"\/**\n * A builder class for directed weighted graphs}. If you want to extend this\n * class, see {@link DirectedWeightedGraphBuilderBase}.\n *\/\n","className":"DirectedWeightedGraphBuilder","fields":[]}],"sourceFileId":82,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.builder.DirectedGraphBuilderBase","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph object to base building on","javadocBlockTagName":"baseGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.builder.DirectedGraphBuilderBase.DirectedGraphBuilderBase(G)","variableDeclarationExprs":[],"constructorRange":"(line 58,col 5)-(line 61,col 5)","constructorJavadocComment":"\n     * Creates a builder based on {@code baseGraph}. {@code baseGraph} must be\n     * mutable.\n     *\n     * @param baseGraph the graph object to base building on\n     ","constructorDeclaration":"public DirectedGraphBuilderBase(G baseGraph)","constructorBody":"{\n    super(baseGraph);\n}","constructorName":"DirectedGraphBuilderBase","constructorQualifiedName":"org.jgrapht.graph.builder.DirectedGraphBuilderBase.DirectedGraphBuilderBase","constructorParameters":[{"parameterType":"G","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(G, bounds=[DirectedGraph<V, E>])}","parameterTypeResolvedDescribed":"G","parameter":"G baseGraph","parameterName":"baseGraph"}],"literalExprs":[],"constructorTokenRange":"public DirectedGraphBuilderBase(G baseGraph)\n    {\n        super(baseGraph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a builder based on '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text='. '}, JavadocInlineTag{tagName='code', type=CODE, content=' baseGraph'}, JavadocSnippet{text=' must be\nmutable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph object to base building on'}]}', name=Optional[baseGraph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public UnmodifiableDirectedGraph<V, E> buildUnmodifiable()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new UnmodifiableDirectedGraph<V, E>(this.graph);\n}","methodRange":"(line 63,col 5)-(line 66,col 5)","methodTokenRange":"@Override public UnmodifiableDirectedGraph<V, E> buildUnmodifiable()\n    {\n        return new UnmodifiableDirectedGraph<V, E>(this.graph);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"buildUnmodifiable","methodQualifiedSignature":"org.jgrapht.graph.builder.DirectedGraphBuilderBase.buildUnmodifiable","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"UnmodifiableDirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.builder.DirectedGraphBuilderBase.buildUnmodifiable()"}],"classJavadoc":"\/**\n * Base class for {@link DirectedGraphBuilder} for extending.\n *\/\n","className":"DirectedGraphBuilderBase","fields":[]}],"sourceFileId":83,"packageName":"org.jgrapht.graph.builder"},{"sourceFileName":"org.jgrapht.graph.ListenableDirectedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableDirectedGraph.ListenableDirectedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * Creates a new listenable directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public ListenableDirectedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new DefaultDirectedGraph<V, E>(edgeClass));\n}","constructorName":"ListenableDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableDirectedGraph.ListenableDirectedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public ListenableDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new DefaultDirectedGraph<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable directed graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.ListenableDirectedGraph.ListenableDirectedGraph(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 73,col 5)","constructorJavadocComment":"\n     * Creates a new listenable directed graph.\n     *\n     * @param base the backing graph.\n     ","constructorDeclaration":"public ListenableDirectedGraph(DirectedGraph<V, E> base)","constructorBody":"{\n    super(base);\n}","constructorName":"ListenableDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.ListenableDirectedGraph.ListenableDirectedGraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> base","parameterName":"base"}],"literalExprs":[],"constructorTokenRange":"public ListenableDirectedGraph(DirectedGraph<V, E> base)\n    {\n        super(base);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new listenable directed graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph.'}]}', name=Optional[base]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * A directed graph which is also {@link org.jgrapht.ListenableGraph}.\n *\n * @see DefaultListenableGraph\n *\/\n","className":"ListenableDirectedGraph","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3257571698126368824L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3257571698126368824L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3257571698126368824L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":84,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.UnmodifiableDirectedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the backing graph on which an unmodifiable graph is to be\ncreated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph on which an unmodifiable graph is to be\ncreated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.UnmodifiableDirectedGraph.UnmodifiableDirectedGraph(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new unmodifiable directed graph based on the specified backing\n     * graph.\n     *\n     * @param g the backing graph on which an unmodifiable graph is to be\n     * created.\n     ","constructorDeclaration":"public UnmodifiableDirectedGraph(DirectedGraph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorName":"UnmodifiableDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.UnmodifiableDirectedGraph.UnmodifiableDirectedGraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public UnmodifiableDirectedGraph(DirectedGraph<V, E> g)\n    {\n        super(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new unmodifiable directed graph based on the specified backing\ngraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the backing graph on which an unmodifiable graph is to be\ncreated.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * A directed graph that cannot be modified.\n *\n * @see UnmodifiableGraph\n *\/\n","className":"UnmodifiableDirectedGraph","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3978701783725913906L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 69)","literalExprId":1,"literalExpr":"3978701783725913906L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3978701783725913906L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":85,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.SimpleGraphPath","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The simple graph where the path is.","javadocBlockTagName":"simpleGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The simple graph where the path is.'}]}', name=Optional[simpleGraph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"A list of vertices that make up the path.","javadocBlockTagName":"vertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A list of vertices that make up the path.'}]}', name=Optional[vertices]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the vertices are not in the path or\nif they do not define a path in the graph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the vertices are not in the path or\nif they do not define a path in the graph.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.SimpleGraphPath(org.jgrapht.graph.SimpleGraph<V, E>, java.util.List<V>, double)","variableDeclarationExprs":[{"variableType":"int","variableName":"i","variableDeclarationExprId":1,"variableDeclarationExpr":"int i = 0","variableDeclarationExprRange":"(line 78,col 14)-(line 78,col 22)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 78,col 18)-(line 78,col 22)"},{"variableType":"E","variableName":"currentEdge","variableDeclarationExprId":2,"variableDeclarationExpr":"E currentEdge = getGraph().getEdge(getVertexList().get(i), getVertexList().get(i + 1))","variableDeclarationExprRange":"(line 79,col 13)-(line 82,col 47)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 79,col 15)-(line 82,col 47)"}],"constructorRange":"(line 63,col 5)-(line 90,col 5)","constructorJavadocComment":"\n     * @param simpleGraph The simple graph where the path is.\n     * @param vertices A list of vertices that make up the path.\n     *\n     * @throws IllegalArgumentException if the vertices are not in the path or\n     * if they do not define a path in the graph.\n     ","constructorDeclaration":"public SimpleGraphPath(SimpleGraph<V, E> simpleGraph, List<V> vertices, double weight)","constructorBody":"{\n    this.graph = simpleGraph;\n    this.vertices = vertices;\n    this.edges = new ArrayList<E>();\n    this.weight = weight;\n    if (vertices.size() < 2) {\n        throw new IllegalArgumentException(\"At least two vertices are required to form a path\");\n    }\n    for (int i = 0; i < (getVertexList().size() - 1); i++) {\n        E currentEdge = getGraph().getEdge(getVertexList().get(i), getVertexList().get(i + 1));\n        if (currentEdge != null) {\n            edges.add(currentEdge);\n        } else {\n            throw new IllegalArgumentException(\"The specified vertices do not form a path\");\n        }\n    }\n}","constructorName":"SimpleGraphPath","constructorQualifiedName":"org.jgrapht.graph.SimpleGraphPath.SimpleGraphPath","constructorParameters":[{"parameterType":"SimpleGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.SimpleGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.SimpleGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.SimpleGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.SimpleGraph<V, E>","parameter":"SimpleGraph<V, E> simpleGraph","parameterName":"simpleGraph"},{"parameterType":"List<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> vertices","parameterName":"vertices"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"literalExprs":[{"literalExprRange":"(line 73,col 31)-(line 73,col 31)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 75,col 17)-(line 75,col 67)","literalExprId":2,"literalExpr":"\"At least two vertices are required to form a path\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 22)-(line 78,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 55)-(line 78,col 55)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 82,col 45)-(line 82,col 45)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 83,col 32)-(line 83,col 35)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 87,col 21)-(line 87,col 63)","literalExprId":7,"literalExpr":"\"The specified vertices do not form a path\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public SimpleGraphPath(\n        SimpleGraph<V, E> simpleGraph,\n        List<V> vertices,\n        double weight)\n    {\n        this.graph = simpleGraph;\n        this.vertices = vertices;\n        this.edges = new ArrayList<E>();\n        this.weight = weight;\n\n        if (vertices.size() < 2) {\n            throw new IllegalArgumentException(\n                \"At least two vertices are required to form a path\");\n        }\n\n        for (int i = 0; i < (getVertexList().size() - 1); i++) {\n            E currentEdge =\n                getGraph().getEdge(\n                    getVertexList().get(i),\n                    getVertexList().get(i + 1));\n            if (currentEdge != null) {\n                edges.add(currentEdge);\n            } else {\n                throw new IllegalArgumentException(\n                    \"The specified vertices do not form a path\");\n            }\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The simple graph where the path is.'}]}', name=Optional[simpleGraph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='A list of vertices that make up the path.'}]}', name=Optional[vertices]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the vertices are not in the path or\nif they do not define a path in the graph.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public SimpleGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.graph;\n}","methodRange":"(line 92,col 5)-(line 95,col 5)","methodTokenRange":"@Override public SimpleGraph<V, E> getGraph()\n    {\n        return this.graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.getGraph","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"SimpleGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleGraphPath.getGraph()"},{"methodDeclaration":"public V getStartVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.getVertexList().get(0);\n}","methodRange":"(line 97,col 5)-(line 100,col 5)","methodTokenRange":"@Override public V getStartVertex()\n    {\n        return this.getVertexList().get(0);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[],"methodName":"getStartVertex","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.getStartVertex","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 99,col 41)-(line 99,col 41)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.SimpleGraphPath.getStartVertex()"},{"methodDeclaration":"public V getEndVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.getVertexList().get(getVertexList().size() - 1);\n}","methodRange":"(line 102,col 5)-(line 105,col 5)","methodTokenRange":"@Override public V getEndVertex()\n    {\n        return this.getVertexList().get(getVertexList().size() - 1);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[],"methodName":"getEndVertex","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.getEndVertex","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 104,col 66)-(line 104,col 66)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.SimpleGraphPath.getEndVertex()"},{"methodDeclaration":"public List<E> getEdgeList()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.edges;\n}","methodRange":"(line 107,col 5)-(line 110,col 5)","methodTokenRange":"@Override public List<E> getEdgeList()\n    {\n        return this.edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getEdgeList","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.getEdgeList","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleGraphPath.getEdgeList()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"A list of the vertices that define the path.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A list of the vertices that define the path.'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<V> getVertexList()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.vertices;\n}","methodRange":"(line 115,col 5)-(line 118,col 5)","methodTokenRange":"public List<V> getVertexList()\n    {\n        return this.vertices;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * @return A list of the vertices that define the path.\n     ","methodParameters":[],"methodName":"getVertexList","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.getVertexList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A list of the vertices that define the path.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleGraphPath.getVertexList()"},{"methodDeclaration":"public double getWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return weight;\n}","methodRange":"(line 120,col 5)-(line 123,col 5)","methodTokenRange":"@Override public double getWeight()\n    {\n        return weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[],"methodName":"getWeight","methodQualifiedSignature":"org.jgrapht.graph.SimpleGraphPath.getWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleGraphPath.getWeight()"}],"classJavadoc":"\/**\n * A vertex-based representation of a simple path. The graph must be simple for\n * the vertices to uniquely determine a path. See {@link SimpleGraph}\n *\/\n","className":"SimpleGraphPath","fields":[{"fieldRange":"(line 51,col 5)-(line 51,col 36)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private SimpleGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.graph.SimpleGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.SimpleGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.graph.SimpleGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"SimpleGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.graph.SimpleGraph<V, E>"},{"fieldRange":"(line 52,col 5)-(line 52,col 29)","fieldName":"vertices","fieldJavadocComment":"","fieldTokenRange":"private List<V> vertices;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"},{"fieldRange":"(line 53,col 5)-(line 53,col 26)","fieldName":"edges","fieldJavadocComment":"","fieldTokenRange":"private List<E> edges;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<E>"},{"fieldRange":"(line 54,col 5)-(line 54,col 26)","fieldName":"weight","fieldJavadocComment":"","fieldTokenRange":"private double weight;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":86,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.ParanoidGraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"ParanoidGraph","constructorQualifiedName":"org.jgrapht.graph.ParanoidGraph.ParanoidGraph","constructorQualifiedSignature":"org.jgrapht.graph.ParanoidGraph.ParanoidGraph(org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public ParanoidGraph(Graph<V, E> g)\n    {\n        super(g);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"","constructorDeclaration":"public ParanoidGraph(Graph<V, E> g)","constructorBody":"{\n    super(g);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addEdge(V sourceVertex, V targetVertex, E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    verifyAdd(edgeSet(), e);\n    return super.addEdge(sourceVertex, targetVertex, e);\n}","methodRange":"(line 68,col 5)-(line 72,col 5)","methodTokenRange":"@Override public boolean addEdge(V sourceVertex, V targetVertex, E e)\n    {\n        verifyAdd(edgeSet(), e);\n        return super.addEdge(sourceVertex, targetVertex, e);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addEdge(Object, Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.graph.ParanoidGraph.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.ParanoidGraph.addEdge(V, V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    verifyAdd(vertexSet(), v);\n    return super.addVertex(v);\n}","methodRange":"(line 77,col 5)-(line 81,col 5)","methodTokenRange":"@Override public boolean addVertex(V v)\n    {\n        verifyAdd(vertexSet(), v);\n        return super.addVertex(v);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"addVertex","methodQualifiedSignature":"org.jgrapht.graph.ParanoidGraph.addVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.ParanoidGraph.addVertex(V)"},{"methodDeclaration":"private static void verifyAdd(Set<T> set, T t)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (T o : set) {\n        if (o == t) {\n            continue;\n        }\n        if (o.equals(t) && (o.hashCode() != t.hashCode())) {\n            throw new IllegalArgumentException(\"ParanoidGraph detected objects \" + \"o1 (hashCode=\" + o.hashCode() + \") and o2 (hashCode=\" + t.hashCode() + \") where o1.equals(o2) \" + \"but o1.hashCode() != o2.hashCode()\");\n        }\n    }\n}","methodRange":"(line 83,col 5)-(line 98,col 5)","methodTokenRange":"private static <T> void verifyAdd(Set<T> set, T t)\n    {\n        for (T o : set) {\n            if (o == t) {\n                continue;\n            }\n            if (o.equals(t) && (o.hashCode() != t.hashCode())) {\n                throw new IllegalArgumentException(\n                    \"ParanoidGraph detected objects \"\n                    + \"o1 (hashCode=\" + o.hashCode()\n                    + \") and o2 (hashCode=\" + t.hashCode()\n                    + \") where o1.equals(o2) \"\n                    + \"but o1.hashCode() != o2.hashCode()\");\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<T>","parameter":"Set<T> set","parameterName":"set"},{"parameterType":"T","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T t","parameterName":"t"}],"methodName":"verifyAdd","methodQualifiedSignature":"org.jgrapht.graph.ParanoidGraph.verifyAdd","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 91,col 21)-(line 91,col 53)","literalExprId":1,"literalExpr":"\"ParanoidGraph detected objects \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 92,col 23)-(line 92,col 37)","literalExprId":2,"literalExpr":"\"o1 (hashCode=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 93,col 23)-(line 93,col 43)","literalExprId":3,"literalExpr":"\") and o2 (hashCode=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 94,col 23)-(line 94,col 46)","literalExprId":4,"literalExpr":"\") where o1.equals(o2) \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 23)-(line 95,col 58)","literalExprId":5,"literalExpr":"\"but o1.hashCode() != o2.hashCode()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.ParanoidGraph.verifyAdd(java.util.Set<T>, T)"}],"classJavadoc":"\/**\n * ParanoidGraph provides a way to verify that objects added to a graph obey the\n * standard equals\/hashCode contract. It can be used to wrap an underlying graph\n * to be verified. Note that the verification is very expensive, so\n * ParanoidGraph should only be used during debugging.\n *\n * @author John Sichi\n * @version $Id$\n *\/\n","className":"ParanoidGraph","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"\n     ","fieldTokenRange":"private static final long serialVersionUID = 5075284167422166539L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 58,col 50)-(line 58,col 69)","literalExprId":1,"literalExpr":"5075284167422166539L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[5075284167422166539L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":87,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedWeightedMultigraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedWeightedMultigraph.DirectedWeightedMultigraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Creates a new directed weighted multigraph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public DirectedWeightedMultigraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"DirectedWeightedMultigraph","constructorQualifiedName":"org.jgrapht.graph.DirectedWeightedMultigraph.DirectedWeightedMultigraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedMultigraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed weighted multigraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedWeightedMultigraph.DirectedWeightedMultigraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * Creates a new directed weighted multigraph with the specified edge\n     * factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public DirectedWeightedMultigraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef);\n}","constructorName":"DirectedWeightedMultigraph","constructorQualifiedName":"org.jgrapht.graph.DirectedWeightedMultigraph.DirectedWeightedMultigraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[],"constructorTokenRange":"public DirectedWeightedMultigraph(EdgeFactory<V, E> ef)\n    {\n        super(ef);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed weighted multigraph with the specified edge\nfactory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(edgeClass));\n}","methodRange":"(line 77,col 5)-(line 84,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedMultigraph<V, E>>(\n                new DirectedWeightedMultigraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedWeightedMultigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedWeightedMultigraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedWeightedGraphBuilder<V, E, DirectedWeightedMultigraph<V, E>>(new DirectedWeightedMultigraph<V, E>(ef));\n}","methodRange":"(line 86,col 5)-(line 93,col 5)","methodTokenRange":"public static <V, E> DirectedWeightedGraphBuilderBase<V,\n        E, ? extends DirectedWeightedMultigraph<V, E>, ?> builder(\n        EdgeFactory<V, E> ef)\n    {\n        return new DirectedWeightedGraphBuilder<V,\n            E, DirectedWeightedMultigraph<V, E>>(\n                new DirectedWeightedMultigraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.DirectedWeightedMultigraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedWeightedGraphBuilderBase<V, E, ? extends DirectedWeightedMultigraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedWeightedMultigraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A directed weighted multigraph. A directed weighted multigraph is a\n * non-simple directed graph in which no loops are permitted, but multiple edges\n * between any two vertices are permitted, and edges have weights.\n *\/\n","className":"DirectedWeightedMultigraph","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 4049071636005206066L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 54,col 50)-(line 54,col 69)","literalExprId":1,"literalExpr":"4049071636005206066L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[4049071636005206066L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":88,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.DirectedSubgraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base (backing) graph on which the subgraph will be based.","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.","javadocBlockTagName":"vertexSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.","javadocBlockTagName":"edgeSubset","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.DirectedSubgraph.DirectedSubgraph(org.jgrapht.DirectedGraph<V, E>, java.util.Set<V>, java.util.Set<E>)","variableDeclarationExprs":[],"constructorRange":"(line 68,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Creates a new directed subgraph.\n     *\n     * @param base the base (backing) graph on which the subgraph will be based.\n     * @param vertexSubset vertices to include in the subgraph. If <code>\n     * null<\/code> then all vertices are included.\n     * @param edgeSubset edges to in include in the subgraph. If <code>\n     * null<\/code> then all the edges whose vertices found in the graph are\n     * included.\n     ","constructorDeclaration":"public DirectedSubgraph(DirectedGraph<V, E> base, Set<V> vertexSubset, Set<E> edgeSubset)","constructorBody":"{\n    super(base, vertexSubset, edgeSubset);\n}","constructorName":"DirectedSubgraph","constructorQualifiedName":"org.jgrapht.graph.DirectedSubgraph.DirectedSubgraph","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> base","parameterName":"base"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSubset","parameterName":"vertexSubset"},{"parameterType":"Set<E>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> edgeSubset","parameterName":"edgeSubset"}],"literalExprs":[],"constructorTokenRange":"public DirectedSubgraph(\n        DirectedGraph<V, E> base,\n        Set<V> vertexSubset,\n        Set<E> edgeSubset)\n    {\n        super(base, vertexSubset, edgeSubset);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new directed subgraph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base (backing) graph on which the subgraph will be based.'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertices to include in the subgraph. If <code>\nnull<\/code> then all vertices are included.'}]}', name=Optional[vertexSubset]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edges to in include in the subgraph. If <code>\nnull<\/code> then all the edges whose vertices found in the graph are\nincluded.'}]}', name=Optional[edgeSubset]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#inDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    int degree = 0;\n    for (E e : getBase().incomingEdgesOf(vertex)) {\n        if (containsEdge(e)) {\n            degree++;\n        }\n    }\n    return degree;\n}","methodRange":"(line 79,col 5)-(line 92,col 5)","methodTokenRange":"@Override public int inDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#inDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedSubgraph.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#inDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 83,col 22)-(line 83,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DirectedSubgraph.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#incomingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    Set<E> edges = new ArrayUnenforcedSet<E>();\n    for (E e : getBase().incomingEdgesOf(vertex)) {\n        if (containsEdge(e)) {\n            edges.add(e);\n        }\n    }\n    return edges;\n}","methodRange":"(line 97,col 5)-(line 110,col 5)","methodTokenRange":"@Override public Set<E> incomingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().incomingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#incomingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedSubgraph.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#incomingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedSubgraph.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outDegreeOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    int degree = 0;\n    for (E e : getBase().outgoingEdgesOf(vertex)) {\n        if (containsEdge(e)) {\n            degree++;\n        }\n    }\n    return degree;\n}","methodRange":"(line 115,col 5)-(line 128,col 5)","methodTokenRange":"@Override public int outDegreeOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        int degree = 0;\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                degree++;\n            }\n        }\n\n        return degree;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @see DirectedGraph#outDegreeOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedSubgraph.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outDegreeOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 119,col 22)-(line 119,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.graph.DirectedSubgraph.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"DirectedGraph#outgoingEdgesOf(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertVertexExist(vertex);\n    Set<E> edges = new ArrayUnenforcedSet<E>();\n    for (E e : getBase().outgoingEdgesOf(vertex)) {\n        if (containsEdge(e)) {\n            edges.add(e);\n        }\n    }\n    return edges;\n}","methodRange":"(line 133,col 5)-(line 146,col 5)","methodTokenRange":"@Override public Set<E> outgoingEdgesOf(V vertex)\n    {\n        assertVertexExist(vertex);\n\n        Set<E> edges = new ArrayUnenforcedSet<E>();\n\n        for (E e : getBase().outgoingEdgesOf(vertex)) {\n            if (containsEdge(e)) {\n                edges.add(e);\n            }\n        }\n\n        return edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @see DirectedGraph#outgoingEdgesOf(Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.graph.DirectedSubgraph.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='DirectedGraph#outgoingEdgesOf(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.DirectedSubgraph.outgoingEdgesOf(V)"}],"classJavadoc":"\/**\n * A directed graph that is a subgraph on other graph.\n *\n * @see Subgraph\n *\/\n","className":"DirectedSubgraph","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3616445700507054133L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 56,col 50)-(line 56,col 69)","literalExprId":1,"literalExpr":"3616445700507054133L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3616445700507054133L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":89,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.graph.SimpleDirectedGraph","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.builder.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class on which to base factory for edges","javadocBlockTagName":"edgeClass","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleDirectedGraph.SimpleDirectedGraph(java.lang.Class<? extends E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 63,col 5)","constructorJavadocComment":"\n     * Creates a new simple directed graph.\n     *\n     * @param edgeClass class on which to base factory for edges\n     ","constructorDeclaration":"public SimpleDirectedGraph(Class<? extends E> edgeClass)","constructorBody":"{\n    this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n}","constructorName":"SimpleDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleDirectedGraph.SimpleDirectedGraph","constructorParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"literalExprs":[],"constructorTokenRange":"public SimpleDirectedGraph(Class<? extends E> edgeClass)\n    {\n        this(new ClassBasedEdgeFactory<V, E>(edgeClass));\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple directed graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class on which to base factory for edges'}]}', name=Optional[edgeClass]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge factory of the new graph.","javadocBlockTagName":"ef","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}"}],"constructorQualifiedSignature":"org.jgrapht.graph.SimpleDirectedGraph.SimpleDirectedGraph(org.jgrapht.EdgeFactory<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 73,col 5)","constructorJavadocComment":"\n     * Creates a new simple directed graph with the specified edge factory.\n     *\n     * @param ef the edge factory of the new graph.\n     ","constructorDeclaration":"public SimpleDirectedGraph(EdgeFactory<V, E> ef)","constructorBody":"{\n    super(ef, false, false);\n}","constructorName":"SimpleDirectedGraph","constructorQualifiedName":"org.jgrapht.graph.SimpleDirectedGraph.SimpleDirectedGraph","constructorParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"literalExprs":[{"literalExprRange":"(line 72,col 19)-(line 72,col 23)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 72,col 26)-(line 72,col 30)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public SimpleDirectedGraph(EdgeFactory<V, E> ef)\n    {\n        super(ef, false, false);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new simple directed graph with the specified edge factory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge factory of the new graph.'}]}', name=Optional[ef]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(edgeClass));\n}","methodRange":"(line 75,col 5)-(line 81,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedGraph<V, E>, ?> builder(\n        Class<? extends E> edgeClass)\n    {\n        return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(\n            new SimpleDirectedGraph<V, E>(edgeClass));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleDirectedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleDirectedGraph.builder(java.lang.Class<? extends E>)"},{"methodDeclaration":"public static DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(new SimpleDirectedGraph<V, E>(ef));\n}","methodRange":"(line 83,col 5)-(line 88,col 5)","methodTokenRange":"public static <V, E> DirectedGraphBuilderBase<V,\n        E, ? extends SimpleDirectedGraph<V, E>, ?> builder(EdgeFactory<V, E> ef)\n    {\n        return new DirectedGraphBuilder<V, E, SimpleDirectedGraph<V, E>>(\n            new SimpleDirectedGraph<V, E>(ef));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> ef","parameterName":"ef"}],"methodName":"builder","methodQualifiedSignature":"org.jgrapht.graph.SimpleDirectedGraph.builder","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraphBuilderBase<V, E, ? extends SimpleDirectedGraph<V, E>, ?>","literalExprs":[],"methodQualifiedName":"org.jgrapht.graph.SimpleDirectedGraph.builder(org.jgrapht.EdgeFactory<V, E>)"}],"classJavadoc":"\/**\n * A simple directed graph. A simple directed graph is a directed graph in which\n * neither multiple edges between any two vertices nor loops are permitted.\n *\/\n","className":"SimpleDirectedGraph","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 4049358608472879671L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"4049358608472879671L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[4049358608472879671L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":90,"packageName":"org.jgrapht.graph"},{"sourceFileName":"org.jgrapht.GraphHelper","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * A collection of utilities to assist the working with graphs.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n * @deprecated Use {@link Graphs} instead.\n *\/\n","className":"GraphHelper","fields":[]}],"sourceFileId":91,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.Graphs","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which the edge to be added.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the edge to be added.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"weight of the edge.","javadocBlockTagName":"weight","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addEdge(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static E addEdge(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    EdgeFactory<V, E> ef = g.getEdgeFactory();\n    E e = ef.createEdge(sourceVertex, targetVertex);\n    assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n    ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n    return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n}","methodRange":"(line 71,col 5)-(line 87,col 5)","methodTokenRange":"public static <V, E> E addEdge(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        EdgeFactory<V, E> ef = g.getEdgeFactory();\n        E e = ef.createEdge(sourceVertex, targetVertex);\n\n        \/\/ we first create the edge and set the weight to make sure that\n        \/\/ listeners will see the correct weight upon addEdge.\n\n        assert (g instanceof WeightedGraph<?, ?>) : g.getClass();\n        ((WeightedGraph<V, E>) g).setEdgeWeight(e, weight);\n\n        return g.addEdge(sourceVertex, targetVertex, e) ? e : null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Creates a new edge and adds it to the specified graph similarly to the\n     * {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null<\/code>.\n     *\n     * @see Graph#addEdge(Object, Object)\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"addEdge","methodQualifiedSignature":"org.jgrapht.Graphs.addEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new edge and adds it to the specified graph similarly to the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' Graph#addEdge(Object, Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the edge to be added.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addEdge(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 86,col 63)-(line 86,col 66)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.Graphs.addEdge(org.jgrapht.Graph<V, E>, V, V, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which the specified edge to be added.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the specified edge to be added.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return g.addEdge(sourceVertex, targetVertex);\n}","methodRange":"(line 101,col 5)-(line 110,col 5)","methodTokenRange":"public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return g.addEdge(sourceVertex, targetVertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new edge and adds it to the specified\n     * graph similarly to the {@link Graph#addEdge(Object, Object)} method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null<\/code>.\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"addEdgeWithVertices","methodQualifiedSignature":"org.jgrapht.Graphs.addEdgeWithVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified source and target vertices to the graph, if not\nalready included, and creates a new edge and adds it to the specified\ngraph similarly to the '}, JavadocInlineTag{tagName='link', type=LINK, content=' Graph#addEdge(Object, Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the specified edge to be added.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.addEdgeWithVertices(org.jgrapht.Graph<V, E>, V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which the specified edge to be added.","javadocBlockTagName":"targetGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the specified edge to be added.'}]}', name=Optional[targetGraph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph in which the specified edge is already\npresent","javadocBlockTagName":"sourceGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph in which the specified edge is already\npresent'}]}', name=Optional[sourceGraph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge to add","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge to add'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if the target graph did not already contain the\nspecified edge.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if the target graph did not already contain the\nspecified edge.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean addEdgeWithVertices(Graph<V, E> targetGraph, Graph<V, E> sourceGraph, E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V sourceVertex = sourceGraph.getEdgeSource(edge);\n    V targetVertex = sourceGraph.getEdgeTarget(edge);\n    targetGraph.addVertex(sourceVertex);\n    targetGraph.addVertex(targetVertex);\n    return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n}","methodRange":"(line 124,col 5)-(line 136,col 5)","methodTokenRange":"public static <V, E> boolean addEdgeWithVertices(\n        Graph<V, E> targetGraph,\n        Graph<V, E> sourceGraph,\n        E edge)\n    {\n        V sourceVertex = sourceGraph.getEdgeSource(edge);\n        V targetVertex = sourceGraph.getEdgeTarget(edge);\n\n        targetGraph.addVertex(sourceVertex);\n        targetGraph.addVertex(targetVertex);\n\n        return targetGraph.addEdge(sourceVertex, targetVertex, edge);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds the specified edge to the graph, including its vertices if not\n     * already included.\n     *\n     * @param targetGraph the graph for which the specified edge to be added.\n     * @param sourceGraph the graph in which the specified edge is already\n     * present\n     * @param edge edge to add\n     *\n     * @return <tt>true<\/tt> if the target graph did not already contain the\n     * specified edge.\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> targetGraph","parameterName":"targetGraph"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> sourceGraph","parameterName":"sourceGraph"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"addEdgeWithVertices","methodQualifiedSignature":"org.jgrapht.Graphs.addEdgeWithVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified edge to the graph, including its vertices if not\nalready included.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the specified edge to be added.'}]}', name=Optional[targetGraph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph in which the specified edge is already\npresent'}]}', name=Optional[sourceGraph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge to add'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if the target graph did not already contain the\nspecified edge.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.addEdgeWithVertices(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which the specified edge to be added.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the specified edge to be added.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex of the edge.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the edge.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"weight of the edge.","javadocBlockTagName":"weight","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static E addEdgeWithVertices(Graph<V, E> g, V sourceVertex, V targetVertex, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    g.addVertex(sourceVertex);\n    g.addVertex(targetVertex);\n    return addEdge(g, sourceVertex, targetVertex, weight);\n}","methodRange":"(line 152,col 5)-(line 162,col 5)","methodTokenRange":"public static <V, E> E addEdgeWithVertices(\n        Graph<V, E> g,\n        V sourceVertex,\n        V targetVertex,\n        double weight)\n    {\n        g.addVertex(sourceVertex);\n        g.addVertex(targetVertex);\n\n        return addEdge(g, sourceVertex, targetVertex, weight);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Adds the specified source and target vertices to the graph, if not\n     * already included, and creates a new weighted edge and adds it to the\n     * specified graph similarly to the {@link Graph#addEdge(Object, Object)}\n     * method.\n     *\n     * @param g the graph for which the specified edge to be added.\n     * @param sourceVertex source vertex of the edge.\n     * @param targetVertex target vertex of the edge.\n     * @param weight weight of the edge.\n     *\n     * @return The newly created edge if added to the graph, otherwise <code>\n     * null<\/code>.\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"addEdgeWithVertices","methodQualifiedSignature":"org.jgrapht.Graphs.addEdgeWithVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified source and target vertices to the graph, if not\nalready included, and creates a new weighted edge and adds it to the\nspecified graph similarly to the '}, JavadocInlineTag{tagName='link', type=LINK, content=' Graph#addEdge(Object, Object)'}, JavadocSnippet{text='\nmethod.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which the specified edge to be added.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex of the edge.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the edge.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='weight of the edge.'}]}', name=Optional[weight]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The newly created edge if added to the graph, otherwise <code>\nnull<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.addEdgeWithVertices(org.jgrapht.Graph<V, E>, V, V, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to which vertices and edges are added.","javadocBlockTagName":"destination","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which vertices and edges are added.'}]}', name=Optional[destination]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph used as source for vertices and edges to add.","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph used as source for vertices and edges to add.'}]}', name=Optional[source]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if and only if the destination graph has been\nchanged as a result of this operation.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if the destination graph has been\nchanged as a result of this operation.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean addGraph(Graph<? super V, ? super E> destination, Graph<V, E> source)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean modified = addAllVertices(destination, source.vertexSet());\n    modified |= addAllEdges(destination, source, source.edgeSet());\n    return modified;\n}","methodRange":"(line 181,col 5)-(line 189,col 5)","methodTokenRange":"public static <V, E> boolean addGraph(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source)\n    {\n        boolean modified = addAllVertices(destination, source.vertexSet());\n        modified |= addAllEdges(destination, source, source.edgeSet());\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds all the vertices and all the edges of the specified source graph to\n     * the specified destination graph. First all vertices of the source graph\n     * are added to the destination graph. Then every edge of the source graph\n     * is added to the destination graph. This method returns <code>true<\/code>\n     * if the destination graph has been modified as a result of this operation,\n     * otherwise it returns <code>false<\/code>.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.<\/p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @return <code>true<\/code> if and only if the destination graph has been\n     * changed as a result of this operation.\n     ","methodParameters":[{"parameterType":"Graph<? super V, ? super E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}, org.jgrapht.Graph.E=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<? super V, ? super E>","parameter":"Graph<? super V, ? super E> destination","parameterName":"destination"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> source","parameterName":"source"}],"methodName":"addGraph","methodQualifiedSignature":"org.jgrapht.Graphs.addGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds all the vertices and all the edges of the specified source graph to\nthe specified destination graph. First all vertices of the source graph\nare added to the destination graph. Then every edge of the source graph\nis added to the destination graph. This method returns <code>true<\/code>\nif the destination graph has been modified as a result of this operation,\notherwise it returns <code>false<\/code>.\n\n<p>The behavior of this operation is undefined if any of the specified\ngraphs is modified while operation is in progress.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which vertices and edges are added.'}]}', name=Optional[destination]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph used as source for vertices and edges to add.'}]}', name=Optional[source]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if the destination graph has been\nchanged as a result of this operation.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.addGraph(org.jgrapht.Graph<? super V, ? super E>, org.jgrapht.Graph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to which vertices and edges are added.","javadocBlockTagName":"destination","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which vertices and edges are added.'}]}', name=Optional[destination]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph used as source for vertices and edges to add.","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph used as source for vertices and edges to add.'}]}', name=Optional[source]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"EdgeReversedGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='EdgeReversedGraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public static void addGraphReversed(DirectedGraph<? super V, ? super E> destination, DirectedGraph<V, E> source)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    addAllVertices(destination, source.vertexSet());\n    for (E edge : source.edgeSet()) {\n        destination.addEdge(source.getEdgeTarget(edge), source.getEdgeSource(edge));\n    }\n}","methodRange":"(line 205,col 5)-(line 216,col 5)","methodTokenRange":"public static <V, E> void addGraphReversed(\n        DirectedGraph<? super V, ? super E> destination,\n        DirectedGraph<V, E> source)\n    {\n        addAllVertices(destination, source.vertexSet());\n\n        for (E edge : source.edgeSet()) {\n            destination.addEdge(\n                source.getEdgeTarget(edge),\n                source.getEdgeSource(edge));\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds all the vertices and all the edges of the specified source digraph\n     * to the specified destination digraph, reversing all of the edges. If you\n     * want to do this as a linked view of the source graph (rather than by\n     * copying to a destination graph), use {@link EdgeReversedGraph} instead.\n     *\n     * <p>The behavior of this operation is undefined if any of the specified\n     * graphs is modified while operation is in progress.<\/p>\n     *\n     * @param destination the graph to which vertices and edges are added.\n     * @param source the graph used as source for vertices and edges to add.\n     *\n     * @see EdgeReversedGraph\n     ","methodParameters":[{"parameterType":"DirectedGraph<? super V, ? super E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}, org.jgrapht.DirectedGraph.E=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<? super V, ? super E>","parameter":"DirectedGraph<? super V, ? super E> destination","parameterName":"destination"},{"parameterType":"DirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> source","parameterName":"source"}],"methodName":"addGraphReversed","methodQualifiedSignature":"org.jgrapht.Graphs.addGraphReversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds all the vertices and all the edges of the specified source digraph\nto the specified destination digraph, reversing all of the edges. If you\nwant to do this as a linked view of the source graph (rather than by\ncopying to a destination graph), use '}, JavadocInlineTag{tagName='link', type=LINK, content=' EdgeReversedGraph'}, JavadocSnippet{text=' instead.\n\n<p>The behavior of this operation is undefined if any of the specified\ngraphs is modified while operation is in progress.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which vertices and edges are added.'}]}', name=Optional[destination]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph used as source for vertices and edges to add.'}]}', name=Optional[source]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='EdgeReversedGraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.addGraphReversed(org.jgrapht.DirectedGraph<? super V, ? super E>, org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to which edges are to be added","javadocBlockTagName":"destination","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which edges are to be added'}]}', name=Optional[destination]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph used as a source for edges to add","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph used as a source for edges to add'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edges to be added","javadocBlockTagName":"edges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edges to be added'}]}', name=Optional[edges]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if this graph changed as a result of the call","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean addAllEdges(Graph<? super V, ? super E> destination, Graph<V, E> source, Collection<? extends E> edges)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean modified = false;\n    for (E e : edges) {\n        V s = source.getEdgeSource(e);\n        V t = source.getEdgeTarget(e);\n        destination.addVertex(s);\n        destination.addVertex(t);\n        modified |= destination.addEdge(s, t, e);\n    }\n    return modified;\n}","methodRange":"(line 231,col 5)-(line 247,col 5)","methodTokenRange":"public static <V, E> boolean addAllEdges(\n        Graph<? super V, ? super E> destination,\n        Graph<V, E> source,\n        Collection<? extends E> edges)\n    {\n        boolean modified = false;\n\n        for (E e : edges) {\n            V s = source.getEdgeSource(e);\n            V t = source.getEdgeTarget(e);\n            destination.addVertex(s);\n            destination.addVertex(t);\n            modified |= destination.addEdge(s, t, e);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds a subset of the edges of the specified source graph to the specified\n     * destination graph. The behavior of this operation is undefined if either\n     * of the graphs is modified while the operation is in progress. {@link\n     * #addEdgeWithVertices} is used for the transfer, so source vertexes will\n     * be added automatically to the target graph.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param source the graph used as a source for edges to add\n     * @param edges the edges to be added\n     *\n     * @return <tt>true<\/tt> if this graph changed as a result of the call\n     ","methodParameters":[{"parameterType":"Graph<? super V, ? super E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}, org.jgrapht.Graph.E=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<? super V, ? super E>","parameter":"Graph<? super V, ? super E> destination","parameterName":"destination"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> source","parameterName":"source"},{"parameterType":"Collection<? extends E>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends E>","parameter":"Collection<? extends E> edges","parameterName":"edges"}],"methodName":"addAllEdges","methodQualifiedSignature":"org.jgrapht.Graphs.addAllEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a subset of the edges of the specified source graph to the specified\ndestination graph. The behavior of this operation is undefined if either\nof the graphs is modified while the operation is in progress. '}, JavadocInlineTag{tagName='link', type=LINK, content='\n#addEdgeWithVertices'}, JavadocSnippet{text=' is used for the transfer, so source vertexes will\nbe added automatically to the target graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which edges are to be added'}]}', name=Optional[destination]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph used as a source for edges to add'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edges to be added'}]}', name=Optional[edges]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if this graph changed as a result of the call'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 236,col 28)-(line 236,col 32)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.Graphs.addAllEdges(org.jgrapht.Graph<? super V, ? super E>, org.jgrapht.Graph<V, E>, java.util.Collection<? extends E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to which edges are to be added","javadocBlockTagName":"destination","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which edges are to be added'}]}', name=Optional[destination]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertices to be added to the graph.","javadocBlockTagName":"vertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to be added to the graph.'}]}', name=Optional[vertices]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if graph changed as a result of the call","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if graph changed as a result of the call'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified vertices contains one or\nmore null vertices, or if the specified vertex collection is <tt>\nnull<\/tt>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified vertices contains one or\nmore null vertices, or if the specified vertex collection is <tt>\nnull<\/tt>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#addVertex(Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean addAllVertices(Graph<? super V, ? super E> destination, Collection<? extends V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean modified = false;\n    for (V v : vertices) {\n        modified |= destination.addVertex(v);\n    }\n    return modified;\n}","methodRange":"(line 266,col 5)-(line 277,col 5)","methodTokenRange":"public static <V, E> boolean addAllVertices(\n        Graph<? super V, ? super E> destination,\n        Collection<? extends V> vertices)\n    {\n        boolean modified = false;\n\n        for (V v : vertices) {\n            modified |= destination.addVertex(v);\n        }\n\n        return modified;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Adds all of the specified vertices to the destination graph. The behavior\n     * of this operation is undefined if the specified vertex collection is\n     * modified while the operation is in progress. This method will invoke the\n     * {@link Graph#addVertex(Object)} method.\n     *\n     * @param destination the graph to which edges are to be added\n     * @param vertices the vertices to be added to the graph.\n     *\n     * @return <tt>true<\/tt> if graph changed as a result of the call\n     *\n     * @throws NullPointerException if the specified vertices contains one or\n     * more null vertices, or if the specified vertex collection is <tt>\n     * null<\/tt>.\n     *\n     * @see Graph#addVertex(Object)\n     ","methodParameters":[{"parameterType":"Graph<? super V, ? super E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}, org.jgrapht.Graph.E=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<? super V, ? super E>","parameter":"Graph<? super V, ? super E> destination","parameterName":"destination"},{"parameterType":"Collection<? extends V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Collection<? extends V>","parameter":"Collection<? extends V> vertices","parameterName":"vertices"}],"methodName":"addAllVertices","methodQualifiedSignature":"org.jgrapht.Graphs.addAllVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds all of the specified vertices to the destination graph. The behavior\nof this operation is undefined if the specified vertex collection is\nmodified while the operation is in progress. This method will invoke the\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' Graph#addVertex(Object)'}, JavadocSnippet{text=' method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to which edges are to be added'}]}', name=Optional[destination]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to be added to the graph.'}]}', name=Optional[vertices]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if graph changed as a result of the call'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified vertices contains one or\nmore null vertices, or if the specified vertex collection is <tt>\nnull<\/tt>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#addVertex(Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 270,col 28)-(line 270,col 32)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.Graphs.addAllVertices(org.jgrapht.Graph<? super V, ? super E>, java.util.Collection<? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to look for neighbors in.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to look for neighbors in.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to get the neighbors of.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to get the neighbors of.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of the vertices that are the neighbors of the specified\nvertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of the vertices that are the neighbors of the specified\nvertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<V> neighborListOf(Graph<V, E> g, V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<V> neighbors = new ArrayList<V>();\n    for (E e : g.edgesOf(vertex)) {\n        neighbors.add(getOppositeVertex(g, e, vertex));\n    }\n    return neighbors;\n}","methodRange":"(line 290,col 5)-(line 300,col 5)","methodTokenRange":"public static <V, E> List<V> neighborListOf(Graph<V, E> g,\n        V vertex)\n    {\n        List<V> neighbors = new ArrayList<V>();\n\n        for (E e : g.edgesOf(vertex)) {\n            neighbors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return neighbors;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a list of vertices that are the neighbors of a specified vertex.\n     * If the graph is a multigraph vertices may appear more than once in the\n     * returned list.\n     *\n     * @param g the graph to look for neighbors in.\n     * @param vertex the vertex to get the neighbors of.\n     *\n     * @return a list of the vertices that are the neighbors of the specified\n     * vertex.\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"neighborListOf","methodQualifiedSignature":"org.jgrapht.Graphs.neighborListOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of vertices that are the neighbors of a specified vertex.\nIf the graph is a multigraph vertices may appear more than once in the\nreturned list.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to look for neighbors in.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to get the neighbors of.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of the vertices that are the neighbors of the specified\nvertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.neighborListOf(org.jgrapht.Graph<V, E>, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to look for predecessors in.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to look for predecessors in.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to get the predecessors of.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to get the predecessors of.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of the vertices that are the direct predecessors of the\nspecified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of the vertices that are the direct predecessors of the\nspecified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<V> predecessorListOf(DirectedGraph<V, E> g, V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<V> predecessors = new ArrayList<V>();\n    Set<? extends E> edges = g.incomingEdgesOf(vertex);\n    for (E e : edges) {\n        predecessors.add(getOppositeVertex(g, e, vertex));\n    }\n    return predecessors;\n}","methodRange":"(line 313,col 5)-(line 325,col 5)","methodTokenRange":"public static <V, E> List<V> predecessorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> predecessors = new ArrayList<V>();\n        Set<? extends E> edges = g.incomingEdgesOf(vertex);\n\n        for (E e : edges) {\n            predecessors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return predecessors;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a list of vertices that are the direct predecessors of a\n     * specified vertex. If the graph is a multigraph, vertices may appear more\n     * than once in the returned list.\n     *\n     * @param g the graph to look for predecessors in.\n     * @param vertex the vertex to get the predecessors of.\n     *\n     * @return a list of the vertices that are the direct predecessors of the\n     * specified vertex.\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"predecessorListOf","methodQualifiedSignature":"org.jgrapht.Graphs.predecessorListOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of vertices that are the direct predecessors of a\nspecified vertex. If the graph is a multigraph, vertices may appear more\nthan once in the returned list.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to look for predecessors in.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to get the predecessors of.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of the vertices that are the direct predecessors of the\nspecified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.predecessorListOf(org.jgrapht.DirectedGraph<V, E>, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to look for successors in.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to look for successors in.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to get the successors of.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to get the successors of.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of the vertices that are the direct successors of the\nspecified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of the vertices that are the direct successors of the\nspecified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<V> successorListOf(DirectedGraph<V, E> g, V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<V> successors = new ArrayList<V>();\n    Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        successors.add(getOppositeVertex(g, e, vertex));\n    }\n    return successors;\n}","methodRange":"(line 338,col 5)-(line 350,col 5)","methodTokenRange":"public static <V, E> List<V> successorListOf(\n        DirectedGraph<V, E> g,\n        V vertex)\n    {\n        List<V> successors = new ArrayList<V>();\n        Set<? extends E> edges = g.outgoingEdgesOf(vertex);\n\n        for (E e : edges) {\n            successors.add(getOppositeVertex(g, e, vertex));\n        }\n\n        return successors;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a list of vertices that are the direct successors of a specified\n     * vertex. If the graph is a multigraph vertices may appear more than once\n     * in the returned list.\n     *\n     * @param g the graph to look for successors in.\n     * @param vertex the vertex to get the successors of.\n     *\n     * @return a list of the vertices that are the direct successors of the\n     * specified vertex.\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"successorListOf","methodQualifiedSignature":"org.jgrapht.Graphs.successorListOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of vertices that are the direct successors of a specified\nvertex. If the graph is a multigraph vertices may appear more than once\nin the returned list.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to look for successors in.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to get the successors of.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of the vertices that are the direct successors of the\nspecified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.successorListOf(org.jgrapht.DirectedGraph<V, E>, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which an undirected view is to be returned.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which an undirected view is to be returned.'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an undirected view of the specified graph, if it is directed, or\nor the specified graph itself if it is already undirected.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an undirected view of the specified graph, if it is directed, or\nor the specified graph itself if it is already undirected.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph is neither DirectedGraph\nnor UndirectedGraph.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph is neither DirectedGraph\nnor UndirectedGraph.'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"AsUndirectedGraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AsUndirectedGraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public static UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n    } else if (g instanceof UndirectedGraph<?, ?>) {\n        return (UndirectedGraph<V, E>) g;\n    } else {\n        throw new IllegalArgumentException(\"Graph must be either DirectedGraph or UndirectedGraph\");\n    }\n}","methodRange":"(line 367,col 5)-(line 377,col 5)","methodTokenRange":"public static <V, E> UndirectedGraph<V, E> undirectedGraph(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new AsUndirectedGraph<V, E>((DirectedGraph<V, E>) g);\n        } else if (g instanceof UndirectedGraph<?, ?>) {\n            return (UndirectedGraph<V, E>) g;\n        } else {\n            throw new IllegalArgumentException(\n                \"Graph must be either DirectedGraph or UndirectedGraph\");\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns an undirected view of the specified graph. If the specified graph\n     * is directed, returns an undirected view of it. If the specified graph is\n     * already undirected, just returns it.\n     *\n     * @param g the graph for which an undirected view is to be returned.\n     *\n     * @return an undirected view of the specified graph, if it is directed, or\n     * or the specified graph itself if it is already undirected.\n     *\n     * @throws IllegalArgumentException if the graph is neither DirectedGraph\n     * nor UndirectedGraph.\n     *\n     * @see AsUndirectedGraph\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"undirectedGraph","methodQualifiedSignature":"org.jgrapht.Graphs.undirectedGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an undirected view of the specified graph. If the specified graph\nis directed, returns an undirected view of it. If the specified graph is\nalready undirected, just returns it.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which an undirected view is to be returned.'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an undirected view of the specified graph, if it is directed, or\nor the specified graph itself if it is already undirected.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph is neither DirectedGraph\nnor UndirectedGraph.'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='AsUndirectedGraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[{"literalExprRange":"(line 375,col 17)-(line 375,col 71)","literalExprId":1,"literalExpr":"\"Graph must be either DirectedGraph or UndirectedGraph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.Graphs.undirectedGraph(org.jgrapht.Graph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph containing e and v","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph containing e and v'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge in g","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge in g'}]}', name=Optional[e]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in g","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in g'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff e is incident on v","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff e is incident on v'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean testIncidence(Graph<V, E> g, E e, V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (g.getEdgeSource(e).equals(v)) || (g.getEdgeTarget(e).equals(v));\n}","methodRange":"(line 388,col 5)-(line 392,col 5)","methodTokenRange":"public static <V, E> boolean testIncidence(Graph<V, E> g, E e, V v)\n    {\n        return (g.getEdgeSource(e).equals(v))\n            || (g.getEdgeTarget(e).equals(v));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Tests whether an edge is incident to a vertex.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return true iff e is incident on v\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"testIncidence","methodQualifiedSignature":"org.jgrapht.Graphs.testIncidence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests whether an edge is incident to a vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph containing e and v'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge in g'}]}', name=Optional[e]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in g'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff e is incident on v'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.testIncidence(org.jgrapht.Graph<V, E>, E, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph containing e and v","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph containing e and v'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge in g","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge in g'}]}', name=Optional[e]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in g","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in g'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"vertex opposite to v across e","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vertex opposite to v across e'}]}', name=Optional.empty}"}],"methodDeclaration":"public static V getOppositeVertex(Graph<V, E> g, E e, V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V source = g.getEdgeSource(e);\n    V target = g.getEdgeTarget(e);\n    if (v.equals(source)) {\n        return target;\n    } else if (v.equals(target)) {\n        return source;\n    } else {\n        throw new IllegalArgumentException(\"no such vertex: \" + v.toString());\n    }\n}","methodRange":"(line 403,col 5)-(line 415,col 5)","methodTokenRange":"public static <V, E> V getOppositeVertex(Graph<V, E> g, E e, V v)\n    {\n        V source = g.getEdgeSource(e);\n        V target = g.getEdgeTarget(e);\n        if (v.equals(source)) {\n            return target;\n        } else if (v.equals(target)) {\n            return source;\n        } else {\n            throw new IllegalArgumentException(\n                \"no such vertex: \" + v.toString());\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Gets the vertex opposite another vertex across an edge.\n     *\n     * @param g graph containing e and v\n     * @param e edge in g\n     * @param v vertex in g\n     *\n     * @return vertex opposite to v across e\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getOppositeVertex","methodQualifiedSignature":"org.jgrapht.Graphs.getOppositeVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the vertex opposite another vertex across an edge.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph containing e and v'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge in g'}]}', name=Optional[e]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in g'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vertex opposite to v across e'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 413,col 17)-(line 413,col 34)","literalExprId":1,"literalExpr":"\"no such vertex: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.Graphs.getOppositeVertex(org.jgrapht.Graph<V, E>, E, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"path of interest","javadocBlockTagName":"path","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='path of interest'}]}', name=Optional[path]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"corresponding vertex list","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='corresponding vertex list'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<V> getPathVertexList(GraphPath<V, E> path)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Graph<V, E> g = path.getGraph();\n    List<V> list = new ArrayList<V>();\n    V v = path.getStartVertex();\n    list.add(v);\n    for (E e : path.getEdgeList()) {\n        v = getOppositeVertex(g, e, v);\n        list.add(v);\n    }\n    return list;\n}","methodRange":"(line 424,col 5)-(line 435,col 5)","methodTokenRange":"public static <V, E> List<V> getPathVertexList(GraphPath<V, E> path)\n    {\n        Graph<V, E> g = path.getGraph();\n        List<V> list = new ArrayList<V>();\n        V v = path.getStartVertex();\n        list.add(v);\n        for (E e : path.getEdgeList()) {\n            v = getOppositeVertex(g, e, v);\n            list.add(v);\n        }\n        return list;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Gets the list of vertices visited by a path.\n     *\n     * @param path path of interest\n     *\n     * @return corresponding vertex list\n     ","methodParameters":[{"parameterType":"GraphPath<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.GraphPath, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.GraphPath.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.GraphPath.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.GraphPath<V, E>","parameter":"GraphPath<V, E> path","parameterName":"path"}],"methodName":"getPathVertexList","methodQualifiedSignature":"org.jgrapht.Graphs.getPathVertexList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the list of vertices visited by a path.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='path of interest'}]}', name=Optional[path]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='corresponding vertex list'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.Graphs.getPathVertexList(org.jgrapht.GraphPath<V, E>)"}],"classJavadoc":"\/**\n * A collection of utilities to assist with graph manipulation.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n *\/\n","className":"Graphs","fields":[]}],"sourceFileId":92,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.DirectedGraph","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex whose degree is to be calculated.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose degree is to be calculated.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the degree of the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the degree of the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int inDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 68,col 5)-(line 68,col 36)","methodTokenRange":"public int inDegreeOf(V vertex);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the \"in degree\" of the specified vertex. An in degree of a vertex\n     * in a directed graph is the number of inward directed edges from that\n     * vertex. See <a href=\"http:\/\/mathworld.wolfram.com\/Indegree.html\">\n     * http:\/\/mathworld.wolfram.com\/Indegree.html<\/a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"inDegreeOf","methodQualifiedSignature":"org.jgrapht.DirectedGraph.inDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the \"in degree\" of the specified vertex. An in degree of a vertex\nin a directed graph is the number of inward directed edges from that\nvertex. See <a href=\"http:\/\/mathworld.wolfram.com\/Indegree.html\">\nhttp:\/\/mathworld.wolfram.com\/Indegree.html<\/a>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose degree is to be calculated.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the degree of the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.DirectedGraph.inDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex for which the list of incoming edges to be\nreturned.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the list of incoming edges to be\nreturned.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of all edges incoming into the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges incoming into the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> incomingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 78,col 5)-(line 78,col 44)","methodTokenRange":"public Set<E> incomingEdgesOf(V vertex);","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of all edges incoming into the specified vertex.\n     *\n     * @param vertex the vertex for which the list of incoming edges to be\n     * returned.\n     *\n     * @return a set of all edges incoming into the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"incomingEdgesOf","methodQualifiedSignature":"org.jgrapht.DirectedGraph.incomingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of all edges incoming into the specified vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the list of incoming edges to be\nreturned.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges incoming into the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.DirectedGraph.incomingEdgesOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex whose degree is to be calculated.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose degree is to be calculated.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the degree of the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the degree of the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int outDegreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 90,col 5)-(line 90,col 37)","methodTokenRange":"public int outDegreeOf(V vertex);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the \"out degree\" of the specified vertex. An out degree of a\n     * vertex in a directed graph is the number of outward directed edges from\n     * that vertex. See <a href=\"http:\/\/mathworld.wolfram.com\/Outdegree.html\">\n     * http:\/\/mathworld.wolfram.com\/Outdegree.html<\/a>.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outDegreeOf","methodQualifiedSignature":"org.jgrapht.DirectedGraph.outDegreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the \"out degree\" of the specified vertex. An out degree of a\nvertex in a directed graph is the number of outward directed edges from\nthat vertex. See <a href=\"http:\/\/mathworld.wolfram.com\/Outdegree.html\">\nhttp:\/\/mathworld.wolfram.com\/Outdegree.html<\/a>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose degree is to be calculated.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the degree of the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.DirectedGraph.outDegreeOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex for which the list of outgoing edges to be\nreturned.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the list of outgoing edges to be\nreturned.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of all edges outgoing from the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges outgoing from the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> outgoingEdgesOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 100,col 5)-(line 100,col 44)","methodTokenRange":"public Set<E> outgoingEdgesOf(V vertex);","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of all edges outgoing from the specified vertex.\n     *\n     * @param vertex the vertex for which the list of outgoing edges to be\n     * returned.\n     *\n     * @return a set of all edges outgoing from the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"outgoingEdgesOf","methodQualifiedSignature":"org.jgrapht.DirectedGraph.outgoingEdgesOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of all edges outgoing from the specified vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the list of outgoing edges to be\nreturned.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all edges outgoing from the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.DirectedGraph.outgoingEdgesOf(V)"}],"classJavadoc":"\/**\n * A graph whose all edges are directed. This is the root interface of all\n * directed graphs.\n *\n * <p>See <a href=\"http:\/\/mathworld.wolfram.com\/DirectedGraph.html\">\n * http:\/\/mathworld.wolfram.com\/DirectedGraph.html<\/a> for more on directed\n * graphs.<\/p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n *\/\n","className":"DirectedGraph","fields":[]}],"sourceFileId":93,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.WeightedGraph","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge on which to set weight","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge on which to set weight'}]}', name=Optional[e]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"new weight for edge","javadocBlockTagName":"weight","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new weight for edge'}]}', name=Optional[weight]}"}],"methodDeclaration":"public void setEdgeWeight(E e, double weight)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 61,col 5)-(line 61,col 50)","methodTokenRange":"public void setEdgeWeight(E e, double weight);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Assigns a weight to an edge.\n     *\n     * @param e edge on which to set weight\n     * @param weight new weight for edge\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"setEdgeWeight","methodQualifiedSignature":"org.jgrapht.WeightedGraph.setEdgeWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Assigns a weight to an edge.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge on which to set weight'}]}', name=Optional[e]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new weight for edge'}]}', name=Optional[weight]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.WeightedGraph.setEdgeWeight(E, double)"}],"classJavadoc":"\/**\n * An interface for a graph whose edges have non-uniform weights.\n *\n * @author Barak Naveh\n * @since Jul 23, 2003\n *\/\n","className":"WeightedGraph","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 51)","fieldName":"DEFAULT_EDGE_WEIGHT","fieldJavadocComment":"\n     * The default weight for an edge.\n     ","fieldTokenRange":"public static double DEFAULT_EDGE_WEIGHT = 1.0;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 53,col 48)-(line 53,col 50)","literalExprId":1,"literalExpr":"1.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[1.0]","fieldType":"double","fieldJavadoc":"The default weight for an edge.\n","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":94,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.generate.HyperCubeGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"This is the dimension of the hypercube.","javadocBlockTagName":"dim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='This is the dimension of the hypercube.'}]}', name=Optional[dim]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.HyperCubeGraphGenerator.HyperCubeGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 67,col 5)","constructorJavadocComment":"\n     * Creates a new HyperCubeGraphGenerator object.\n     *\n     * @param dim This is the dimension of the hypercube.\n     ","constructorDeclaration":"public HyperCubeGraphGenerator(int dim)","constructorBody":"{\n    this.dim = dim;\n}","constructorName":"HyperCubeGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.HyperCubeGraphGenerator.HyperCubeGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int dim","parameterName":"dim"}],"literalExprs":[],"constructorTokenRange":"public HyperCubeGraphGenerator(int dim)\n    {\n        this.dim = dim;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new HyperCubeGraphGenerator object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='This is the dimension of the hypercube.'}]}', name=Optional[dim]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, final VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int order = (int) Math.pow(2, dim);\n    LinkedList<V> vertices = new LinkedList<V>();\n    for (int i = 0; i < order; i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n        vertices.add(newVertex);\n        if (resultMap != null) {\n            String s = Integer.toBinaryString(i);\n            while (s.length() < dim) {\n                s = \"0\" + s;\n            }\n            resultMap.put(s, newVertex);\n        }\n    }\n    for (int i = 0; i < order; i++) {\n        for (int j = i + 1; j < order; j++) {\n            for (int z = 0; z < dim; z++) {\n                if ((j ^ i) == (1 << z)) {\n                    target.addEdge(vertices.get(i), vertices.get(j));\n                    break;\n                }\n            }\n        }\n    }\n}","methodRange":"(line 72,col 5)-(line 106,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        \/\/Vertices are created, and they are included in the resultmap as their\n        \/\/bitstring representation\n        int order = (int) Math.pow(2, dim);\n        LinkedList<V> vertices = new LinkedList<V>();\n        for (int i = 0; i < order; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            vertices.add(newVertex);\n            if (resultMap != null) {\n                String s = Integer.toBinaryString(i);\n                while (s.length() < dim) {\n                    s = \"0\" + s;\n                }\n                resultMap.put(s, newVertex);\n            }\n        }\n\n        \/\/Two vertices will have an edge if their bitstrings differ by exactly\n        \/\/1 element\n        for (int i = 0; i < order; i++) {\n            for (int j = i + 1; j < order; j++) {\n                for (int z = 0; z < dim; z++) {\n                    if ((j ^ i) == (1 << z)) {\n                        target.addEdge(vertices.get(i), vertices.get(j));\n                        break;\n                    }\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * This will generate the hypercube graph\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"final VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.HyperCubeGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This will generate the hypercube graph'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 79,col 36)-(line 79,col 36)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 81,col 22)-(line 81,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 85,col 30)-(line 85,col 33)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 88,col 25)-(line 88,col 27)","literalExprId":4,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 96,col 22)-(line 96,col 22)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 97,col 30)-(line 97,col 30)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 98,col 30)-(line 98,col 30)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 99,col 37)-(line 99,col 37)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.HyperCubeGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a <a href=\"http:\/\/mathworld.wolfram.com\/HypercubeGraph.html\">hyper\n * cube graph<\/a> of any size. This is a graph that can be represented by bit\n * strings, so for an n-dimensial hypercube each vertex resembles an n-length\n * bit string. Then, two vertices are adjacent if and only if their bitstring\n * differ by exactly one element.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n *\/\n","className":"HyperCubeGraphGenerator","fields":[{"fieldRange":"(line 57,col 5)-(line 57,col 20)","fieldName":"dim","fieldJavadocComment":"","fieldTokenRange":"private int dim;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":95,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.RingGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified size is negative.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.RingGraphGenerator.RingGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Construct a new RingGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     ","constructorDeclaration":"public RingGraphGenerator(int size)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}","constructorName":"RingGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.RingGraphGenerator.RingGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"}],"literalExprs":[{"literalExprRange":"(line 67,col 20)-(line 67,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 48)-(line 68,col 69)","literalExprId":2,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public RingGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new RingGraphGenerator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (size < 1) {\n        return;\n    }\n    LinearGraphGenerator<V, E> linearGenerator = new LinearGraphGenerator<V, E>(size);\n    Map<String, V> privateMap = new HashMap<String, V>();\n    linearGenerator.generateGraph(target, vertexFactory, privateMap);\n    V startVertex = privateMap.get(LinearGraphGenerator.START_VERTEX);\n    V endVertex = privateMap.get(LinearGraphGenerator.END_VERTEX);\n    target.addEdge(endVertex, startVertex);\n}","methodRange":"(line 77,col 5)-(line 94,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        LinearGraphGenerator<V, E> linearGenerator =\n            new LinearGraphGenerator<V, E>(size);\n        Map<String, V> privateMap = new HashMap<String, V>();\n        linearGenerator.generateGraph(target, vertexFactory, privateMap);\n\n        V startVertex = privateMap.get(LinearGraphGenerator.START_VERTEX);\n        V endVertex = privateMap.get(LinearGraphGenerator.END_VERTEX);\n        target.addEdge(endVertex, startVertex);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.RingGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 82,col 20)-(line 82,col 20)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.RingGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a ring graph of any size. A ring graph is a graph that contains a\n * single cycle that passes through all its vertices exactly once. For a\n * directed graph, the generated edges are oriented consistently around the\n * ring.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n *\/\n","className":"RingGraphGenerator","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":96,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public static int[] range(final int from, final int to)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] range = new int[to - from];\n    for (int i = from; i < to; ++i) {\n        range[i - from] = i;\n    }\n    return range;\n}","methodRange":"(line 27,col 5)-(line 34,col 5)","methodTokenRange":"public static int [] range(final int from, final int to)\n    {\n        int [] range = new int[to - from];\n        for (int i = from; i < to; ++i) {\n            range[i - from] = i;\n        }\n        return range;\n    }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"final int from","parameterName":"from"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"final int to","parameterName":"to"}],"methodName":"range","methodQualifiedSignature":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.range","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.range(int, int)"},{"methodDeclaration":"public SimpleWeightedGraphMatrixGenerator<V, E> vertices(List<V> vertices)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.vertices = vertices;\n    return this;\n}","methodRange":"(line 38,col 5)-(line 42,col 5)","methodTokenRange":"public SimpleWeightedGraphMatrixGenerator<V, E> vertices(List<V> vertices)\n    {\n        this.vertices = vertices;\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"List<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> vertices","parameterName":"vertices"}],"methodName":"vertices","methodQualifiedSignature":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.vertices","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator<V, E>","methodType":"SimpleWeightedGraphMatrixGenerator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.vertices(java.util.List<V>)"},{"methodDeclaration":"public void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (weights == null) {\n        throw new IllegalArgumentException(\"Graph may not be constructed without weight-matrix specified\");\n    }\n    if (vertices == null) {\n        throw new IllegalArgumentException(\"Graph may not be constructed without vertex-set specified\");\n    }\n    assert vertices.size() == weights.length;\n    for (V vertex : vertices) {\n        target.addVertex(vertex);\n    }\n    for (int i = 0; i < vertices.size(); ++i) {\n        assert vertices.size() == weights[i].length;\n        for (int j = 0; j < vertices.size(); ++j) {\n            if (i != j) {\n                target.setEdgeWeight(target.addEdge(vertices.get(i), vertices.get(j)), weights[i][j]);\n            }\n        }\n    }\n}","methodRange":"(line 44,col 5)-(line 76,col 5)","methodTokenRange":"@Override public void generateGraph(\n        WeightedGraph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (weights == null) {\n            throw new IllegalArgumentException(\n                \"Graph may not be constructed without weight-matrix specified\");\n        }\n\n        if (vertices == null) {\n            throw new IllegalArgumentException(\n                \"Graph may not be constructed without vertex-set specified\");\n        }\n\n        assert vertices.size() == weights.length;\n\n        for (V vertex : vertices) {\n            target.addVertex(vertex);\n        }\n\n        for (int i = 0; i < vertices.size(); ++i) {\n            assert vertices.size() == weights[i].length;\n\n            for (int j = 0; j < vertices.size(); ++j) {\n                if (i != j) {\n                    target.setEdgeWeight(\n                        target.addEdge(vertices.get(i), vertices.get(j)),\n                        weights[i][j]);\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.generateGraph","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 49,col 24)-(line 49,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 51,col 17)-(line 51,col 78)","literalExprId":2,"literalExpr":"\"Graph may not be constructed without weight-matrix specified\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 54,col 25)-(line 54,col 28)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 56,col 17)-(line 56,col 75)","literalExprId":4,"literalExpr":"\"Graph may not be constructed without vertex-set specified\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 65,col 22)-(line 65,col 22)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 26)-(line 68,col 26)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.SimpleWeightedGraphMatrixGenerator.generateGraph(org.jgrapht.WeightedGraph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"","className":"SimpleWeightedGraphMatrixGenerator","fields":[{"fieldRange":"(line 23,col 5)-(line 23,col 31)","fieldName":"vertices","fieldJavadocComment":"","fieldTokenRange":"protected List<V> vertices;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"}]}],"sourceFileId":97,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.WeightedGraphGenerator","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public WeightedGraphGenerator<V, E> edgeFactory(EdgeFactory<V, E> edgeFactory)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.edgeFactory = edgeFactory;\n    return this;\n}","methodRange":"(line 29,col 5)-(line 34,col 5)","methodTokenRange":"public WeightedGraphGenerator<V, E> edgeFactory(\n        EdgeFactory<V, E> edgeFactory)\n    {\n        this.edgeFactory = edgeFactory;\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.WeightedGraphGenerator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.WeightedGraphGenerator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.generate.WeightedGraphGenerator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeFactory<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>","parameter":"EdgeFactory<V, E> edgeFactory","parameterName":"edgeFactory"}],"methodName":"edgeFactory","methodQualifiedSignature":"org.jgrapht.generate.WeightedGraphGenerator.edgeFactory","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.WeightedGraphGenerator<V, E>","methodType":"WeightedGraphGenerator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.WeightedGraphGenerator.edgeFactory(org.jgrapht.EdgeFactory<V, E>)"},{"methodDeclaration":"public WeightedGraphGenerator<V, E> edgeClass(Class<? extends E> edgeClass)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.edgeClass = edgeClass;\n    return this;\n}","methodRange":"(line 36,col 5)-(line 40,col 5)","methodTokenRange":"public WeightedGraphGenerator<V, E> edgeClass(Class<? extends E> edgeClass)\n    {\n        this.edgeClass = edgeClass;\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.WeightedGraphGenerator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.WeightedGraphGenerator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.generate.WeightedGraphGenerator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Class<? extends E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<? extends E>","parameter":"Class<? extends E> edgeClass","parameterName":"edgeClass"}],"methodName":"edgeClass","methodQualifiedSignature":"org.jgrapht.generate.WeightedGraphGenerator.edgeClass","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.WeightedGraphGenerator<V, E>","methodType":"WeightedGraphGenerator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.WeightedGraphGenerator.edgeClass(java.lang.Class<? extends E>)"},{"methodDeclaration":"public WeightedGraphGenerator<V, E> weights(double[][] weights)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.weights = weights;\n    return this;\n}","methodRange":"(line 42,col 5)-(line 46,col 5)","methodTokenRange":"public WeightedGraphGenerator<V, E> weights(double [][] weights)\n    {\n        this.weights = weights;\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.WeightedGraphGenerator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.WeightedGraphGenerator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.generate.WeightedGraphGenerator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"double[][]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}","parameterTypeResolvedDescribed":"double[][]","parameter":"double[][] weights","parameterName":"weights"}],"methodName":"weights","methodQualifiedSignature":"org.jgrapht.generate.WeightedGraphGenerator.weights","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.WeightedGraphGenerator<V, E>","methodType":"WeightedGraphGenerator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.WeightedGraphGenerator.weights(double[][])"}],"classJavadoc":"","className":"WeightedGraphGenerator","fields":[{"fieldRange":"(line 21,col 5)-(line 21,col 43)","fieldName":"edgeClass","fieldJavadocComment":"","fieldTokenRange":"protected Class<? extends E> edgeClass;","fieldTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Class<? extends E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Class<? extends E>"},{"fieldRange":"(line 23,col 5)-(line 23,col 44)","fieldName":"edgeFactory","fieldJavadocComment":"","fieldTokenRange":"protected EdgeFactory<V, E> edgeFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.EdgeFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.EdgeFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.EdgeFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"EdgeFactory<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.EdgeFactory<V, E>"},{"fieldRange":"(line 25,col 5)-(line 25,col 34)","fieldName":"weights","fieldJavadocComment":"","fieldTokenRange":"protected double [][] weights;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"double[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"double[][]"}]}],"sourceFileId":98,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.WheelGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated.","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated.'}]}', name=Optional[size]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.WheelGraphGenerator.WheelGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * Creates a new WheelGraphGenerator object. This constructor is more\n     * suitable for undirected graphs, where spokes' direction is meaningless.\n     * In the directed case, spokes will be oriented from rim to hub.\n     *\n     * @param size number of vertices to be generated.\n     ","constructorDeclaration":"public WheelGraphGenerator(int size)","constructorBody":"{\n    this(size, true);\n}","constructorName":"WheelGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.WheelGraphGenerator.WheelGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"}],"literalExprs":[{"literalExprRange":"(line 74,col 20)-(line 74,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public WheelGraphGenerator(int size)\n    {\n        this(size, true);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new WheelGraphGenerator object. This constructor is more\nsuitable for undirected graphs, where spokes' direction is meaningless.\nIn the directed case, spokes will be oriented from rim to hub.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated.'}]}', name=Optional[size]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated.","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated.'}]}', name=Optional[size]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if <code>true<\/code> and graph is directed, spokes\nare oriented from rim to hub; else from hub to rim.","javadocBlockTagName":"inwardSpokes","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>true<\/code> and graph is directed, spokes\nare oriented from rim to hub; else from hub to rim.'}]}', name=Optional[inwardSpokes]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.WheelGraphGenerator.WheelGraphGenerator(int, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 94,col 5)","constructorJavadocComment":"\n     * Construct a new WheelGraphGenerator.\n     *\n     * @param size number of vertices to be generated.\n     * @param inwardSpokes if <code>true<\/code> and graph is directed, spokes\n     * are oriented from rim to hub; else from hub to rim.\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public WheelGraphGenerator(int size, boolean inwardSpokes)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n    this.inwardSpokes = inwardSpokes;\n}","constructorName":"WheelGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.WheelGraphGenerator.WheelGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean inwardSpokes","parameterName":"inwardSpokes"}],"literalExprs":[{"literalExprRange":"(line 88,col 20)-(line 88,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 89,col 48)-(line 89,col 69)","literalExprId":2,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public WheelGraphGenerator(int size, boolean inwardSpokes)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n        this.inwardSpokes = inwardSpokes;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new WheelGraphGenerator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated.'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>true<\/code> and graph is directed, spokes\nare oriented from rim to hub; else from hub to rim.'}]}', name=Optional[inwardSpokes]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, final VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (size < 1) {\n        return;\n    }\n    final Collection<V> rim = new ArrayList<V>();\n    VertexFactory<V> rimVertexFactory = new VertexFactory<V>() {\n\n        @Override\n        public V createVertex() {\n            V vertex = vertexFactory.createVertex();\n            rim.add(vertex);\n            return vertex;\n        }\n    };\n    RingGraphGenerator<V, E> ringGenerator = new RingGraphGenerator<V, E>(size - 1);\n    ringGenerator.generateGraph(target, rimVertexFactory, resultMap);\n    V hubVertex = vertexFactory.createVertex();\n    target.addVertex(hubVertex);\n    if (resultMap != null) {\n        resultMap.put(HUB_VERTEX, hubVertex);\n    }\n    for (V rimVertex : rim) {\n        if (inwardSpokes) {\n            target.addEdge(rimVertex, hubVertex);\n        } else {\n            target.addEdge(hubVertex, rimVertex);\n        }\n    }\n}","methodRange":"(line 99,col 5)-(line 141,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        \/\/ A little trickery to intercept the rim generation.  This is\n        \/\/ necessary since target may be initially non-empty, meaning we can't\n        \/\/ rely on its vertex set after the rim is generated.\n        final Collection<V> rim = new ArrayList<V>();\n        VertexFactory<V> rimVertexFactory =\n            new VertexFactory<V>() {\n                @Override public V createVertex()\n                {\n                    V vertex = vertexFactory.createVertex();\n                    rim.add(vertex);\n\n                    return vertex;\n                }\n            };\n\n        RingGraphGenerator<V, E> ringGenerator =\n            new RingGraphGenerator<V, E>(size - 1);\n        ringGenerator.generateGraph(target, rimVertexFactory, resultMap);\n\n        V hubVertex = vertexFactory.createVertex();\n        target.addVertex(hubVertex);\n\n        if (resultMap != null) {\n            resultMap.put(HUB_VERTEX, hubVertex);\n        }\n\n        for (V rimVertex : rim) {\n            if (inwardSpokes) {\n                target.addEdge(rimVertex, hubVertex);\n            } else {\n                target.addEdge(hubVertex, rimVertex);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"final VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.WheelGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 104,col 20)-(line 104,col 20)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 124,col 49)-(line 124,col 49)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 130,col 26)-(line 130,col 29)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.WheelGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a <a href=\"http:\/\/mathworld.wolfram.com\/WheelGraph.html\">wheel\n * graph<\/a> of any size. Reminding a bicycle wheel, a wheel graph has a hub\n * vertex in the center and a rim of vertices around it that are connected to\n * each other (as a ring). The rim vertices are also connected to the hub with\n * edges that are called \"spokes\".\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n *\/\n","className":"WheelGraphGenerator","fields":[{"fieldRange":"(line 60,col 5)-(line 60,col 57)","fieldName":"HUB_VERTEX","fieldJavadocComment":"\n     * Role for the hub vertex.\n     ","fieldTokenRange":"public static final String HUB_VERTEX = \"Hub Vertex\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 60,col 45)-(line 60,col 56)","literalExprId":1,"literalExpr":"\"Hub Vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"Hub Vertex\"]","fieldType":"String","fieldJavadoc":"Role for the hub vertex.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 62,col 5)-(line 62,col 33)","fieldName":"inwardSpokes","fieldJavadocComment":"","fieldTokenRange":"private boolean inwardSpokes;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 63,col 5)-(line 63,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":99,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.GridGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of rows","javadocBlockTagName":"rows","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of rows'}]}', name=Optional[rows]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of columns","javadocBlockTagName":"cols","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of columns'}]}', name=Optional[cols]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.GridGraphGenerator.GridGraphGenerator(int, int)","variableDeclarationExprs":[],"constructorRange":"(line 74,col 5)-(line 88,col 5)","constructorJavadocComment":"\n     * Creates a new GridGraphGenerator object with rows x cols dimension.\n     *\n     * @param rows the number of rows\n     * @param cols the number of columns\n     ","constructorDeclaration":"public GridGraphGenerator(int rows, int cols)","constructorBody":"{\n    if (rows < 2) {\n        throw new IllegalArgumentException(\"illegal number of rows (\" + rows + \"). there must be at least two.\");\n    }\n    if (cols < 2) {\n        throw new IllegalArgumentException(\"illegal number of columns (\" + cols + \"). there must be at least two.\");\n    }\n    this.rows = rows;\n    this.cols = cols;\n}","constructorName":"GridGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.GridGraphGenerator.GridGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int rows","parameterName":"rows"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int cols","parameterName":"cols"}],"literalExprs":[{"literalExprRange":"(line 76,col 20)-(line 76,col 20)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 17)-(line 78,col 42)","literalExprId":2,"literalExpr":"\"illegal number of rows (\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 79,col 19)-(line 79,col 50)","literalExprId":3,"literalExpr":"\"). there must be at least two.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 81,col 20)-(line 81,col 20)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 83,col 17)-(line 83,col 45)","literalExprId":5,"literalExpr":"\"illegal number of columns (\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 84,col 19)-(line 84,col 50)","literalExprId":6,"literalExpr":"\"). there must be at least two.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public GridGraphGenerator(int rows, int cols)\n    {\n        if (rows < 2) {\n            throw new IllegalArgumentException(\n                \"illegal number of rows (\" + rows\n                + \"). there must be at least two.\");\n        }\n        if (cols < 2) {\n            throw new IllegalArgumentException(\n                \"illegal number of columns (\" + cols\n                + \"). there must be at least two.\");\n        }\n        this.rows = rows;\n        this.cols = cols;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new GridGraphGenerator object with rows x cols dimension.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of rows'}]}', name=Optional[rows]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of columns'}]}', name=Optional[cols]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Map<Integer, V> map = new TreeMap<Integer, V>();\n    int cornerCtr = 0;\n    for (int i = 0; i < (rows * cols); i++) {\n        V vertex = vertexFactory.createVertex();\n        target.addVertex(vertex);\n        map.put(i + 1, vertex);\n        boolean isCorner = (i == 0) || (i == (cols - 1)) || (i == (cols * (rows - 1))) || (i == ((rows * cols) - 1));\n        if (isCorner && (resultMap != null)) {\n            resultMap.put(CORNER_VERTEX + ' ' + ++cornerCtr, vertex);\n        }\n    }\n    for (int i : map.keySet()) {\n        for (int j : map.keySet()) {\n            if ((((i % cols) > 0) && ((i + 1) == Integer.valueOf(j))) || ((i + cols) == j)) {\n                target.addEdge(map.get(i), map.get(j));\n                target.addEdge(map.get(j), map.get(i));\n            }\n        }\n    }\n}","methodRange":"(line 93,col 5)-(line 131,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        Map<Integer, V> map = new TreeMap<Integer, V>();\n\n        \/\/ Adding all vertices to the set\n        int cornerCtr = 0;\n        for (int i = 0; i < (rows * cols); i++) {\n            V vertex = vertexFactory.createVertex();\n            target.addVertex(vertex);\n            map.put(i + 1, vertex);\n\n            boolean isCorner =\n                (i == 0) || (i == (cols - 1)) || (i == (cols * (rows - 1)))\n                || (i == ((rows * cols) - 1));\n            if (isCorner && (resultMap != null)) {\n                resultMap.put(CORNER_VERTEX + ' ' + ++cornerCtr, vertex);\n            }\n        }\n\n        \/\/ Iterating twice over the key set, for undirected graph edges are\n        \/\/ added from upper vertices to lower, and from left to right. The\n        \/\/ second addEdge call will return nothing; it will not add a the edge\n        \/\/ at the opposite direction. For directed graph, edges in opposite\n        \/\/ direction are also added.\n        for (int i : map.keySet()) {\n            for (int j : map.keySet()) {\n                if ((((i % cols) > 0)\n                        && ((i + 1) == Integer.valueOf(j)))\n                    || ((i + cols) == j))\n                {\n                    target.addEdge(map.get(i), map.get(j));\n                    target.addEdge(map.get(j), map.get(i));\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.GridGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 101,col 25)-(line 101,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 102,col 22)-(line 102,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 105,col 25)-(line 105,col 25)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 23)-(line 108,col 23)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 43)-(line 108,col 43)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 72)-(line 108,col 72)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 109,col 43)-(line 109,col 43)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 110,col 43)-(line 110,col 46)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 111,col 47)-(line 111,col 49)","literalExprId":9,"literalExpr":"' '","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 122,col 36)-(line 122,col 36)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 34)-(line 123,col 34)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.GridGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a bidirectional <a\n * href=\"http:\/\/mathworld.wolfram.com\/GridGraph.html\">grid graph<\/a> of any\n * size. A grid graph is a two dimensional graph whose vertices correspond to\n * the points in the plane with integer coordinates, x-coordinates being in the\n * range 0,..., n, y-coordinates being in the range 1,...m, and two vertices are\n * connected by an edge whenever the corresponding points are at distance 1.\n * Vertices are created from left to right and from top to bottom.\n *\n * @author Assaf Mizrachi\n * @since Dec 29, 2010\n *\/\n","className":"GridGraphGenerator","fields":[{"fieldRange":"(line 62,col 5)-(line 62,col 63)","fieldName":"CORNER_VERTEX","fieldJavadocComment":"\n     * Role for the vertices at the corners.\n     ","fieldTokenRange":"public static final String CORNER_VERTEX = \"Corner Vertex\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 62,col 48)-(line 62,col 62)","literalExprId":1,"literalExpr":"\"Corner Vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"Corner Vertex\"]","fieldType":"String","fieldJavadoc":"Role for the vertices at the corners.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 64,col 5)-(line 64,col 21)","fieldName":"rows","fieldJavadocComment":"","fieldTokenRange":"private int rows;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 66,col 5)-(line 66,col 21)","fieldName":"cols","fieldJavadocComment":"","fieldTokenRange":"private int cols;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":100,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.ScaleFreeGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.ScaleFreeGraphGenerator.ScaleFreeGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 73,col 5)","constructorJavadocComment":"\n     * Constructs a new <tt>ScaleFreeGraphGenerator<\/tt>.\n     *\n     * @param size number of vertices to be generated\n     ","constructorDeclaration":"public ScaleFreeGraphGenerator(int size)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"invalid size: \" + size + \" (must be non-negative)\");\n    }\n    this.size = size;\n    random = new Random();\n    seed = random.nextLong();\n}","constructorName":"ScaleFreeGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.ScaleFreeGraphGenerator.ScaleFreeGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"}],"literalExprs":[{"literalExprRange":"(line 66,col 20)-(line 66,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 17)-(line 68,col 32)","literalExprId":2,"literalExpr":"\"invalid size: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 43)-(line 68,col 67)","literalExprId":3,"literalExpr":"\" (must be non-negative)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public ScaleFreeGraphGenerator(\n        int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\n                \"invalid size: \" + size + \" (must be non-negative)\");\n        }\n        this.size = size;\n        random = new Random();\n        seed = random.nextLong();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new <tt>ScaleFreeGraphGenerator<\/tt>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"initial seed for the random generator","javadocBlockTagName":"seed","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial seed for the random generator'}]}', name=Optional[seed]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.ScaleFreeGraphGenerator.ScaleFreeGraphGenerator(int, long)","variableDeclarationExprs":[],"constructorRange":"(line 82,col 5)-(line 93,col 5)","constructorJavadocComment":"\n     * Constructs a new <tt>ScaleFreeGraphGenerator<\/tt> using fixed <tt>\n     * seed<\/tt> for the random generator.\n     *\n     * @param size number of vertices to be generated\n     * @param seed initial seed for the random generator\n     ","constructorDeclaration":"public ScaleFreeGraphGenerator(int size, long seed)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"invalid size: \" + size + \" (must be non-negative)\");\n    }\n    this.size = size;\n    random = new Random();\n    this.seed = seed;\n}","constructorName":"ScaleFreeGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.ScaleFreeGraphGenerator.ScaleFreeGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long seed","parameterName":"seed"}],"literalExprs":[{"literalExprRange":"(line 86,col 20)-(line 86,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 88,col 17)-(line 88,col 32)","literalExprId":2,"literalExpr":"\"invalid size: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 88,col 43)-(line 88,col 67)","literalExprId":3,"literalExpr":"\" (must be non-negative)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public ScaleFreeGraphGenerator(\n        int size,\n        long seed)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\n                \"invalid size: \" + size + \" (must be non-negative)\");\n        }\n        this.size = size;\n        random = new Random();\n        this.seed = seed;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new <tt>ScaleFreeGraphGenerator<\/tt> using fixed <tt>\nseed<\/tt> for the random generator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial seed for the random generator'}]}', name=Optional[seed]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements'}]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"called to produce new vertices","javadocBlockTagName":"vertexFactory","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='called to produce new vertices'}]}', name=Optional[vertexFactory]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"unused parameter","javadocBlockTagName":"resultMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='unused parameter'}]}', name=Optional[resultMap]}"}],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    random.setSeed(seed);\n    List<V> vertexList = new ArrayList<V>();\n    List<Integer> degrees = new ArrayList<Integer>();\n    int degreeSum = 0;\n    for (int i = 0; i < size; i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n        int newDegree = 0;\n        while ((newDegree == 0) && (i != 0)) {\n            for (int j = 0; j < vertexList.size(); j++) {\n                if ((degreeSum == 0) || (random.nextInt(degreeSum) < degrees.get(j))) {\n                    degrees.set(j, degrees.get(j) + 1);\n                    newDegree++;\n                    degreeSum += 2;\n                    if (random.nextInt(2) == 0) {\n                        target.addEdge(vertexList.get(j), newVertex);\n                    } else {\n                        target.addEdge(newVertex, vertexList.get(j));\n                    }\n                }\n            }\n        }\n        vertexList.add(newVertex);\n        degrees.add(newDegree);\n    }\n}","methodRange":"(line 107,col 5)-(line 142,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        random.setSeed(seed);\n        List<V> vertexList = new ArrayList<V>();\n        List<Integer> degrees = new ArrayList<Integer>();\n        int degreeSum = 0;\n        for (int i = 0; i < size; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            int newDegree = 0;\n            while ((newDegree == 0) && (i != 0)) \/\/ we want our graph to be\n                                                 \/\/ connected\n\n            {\n                for (int j = 0; j < vertexList.size(); j++) {\n                    if ((degreeSum == 0)\n                        || (random.nextInt(degreeSum) < degrees.get(j)))\n                    {\n                        degrees.set(j, degrees.get(j) + 1);\n                        newDegree++;\n                        degreeSum += 2;\n                        if (random.nextInt(2) == 0) {\n                            target.addEdge(vertexList.get(j), newVertex);\n                        } else {\n                            target.addEdge(newVertex, vertexList.get(j));\n                        }\n                    }\n                }\n            }\n            vertexList.add(newVertex);\n            degrees.add(newDegree);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Generates scale-free network with <tt>size<\/tt> passed to the\n     * constructor. Each call of this method produces identical output (but if\n     * <tt>target<\/tt> is an undirected graph, the directions of edges will be\n     * lost).\n     *\n     * @param target receives the generated edges and vertices; if this is\n     * non-empty on entry, the result will be a disconnected graph since\n     * generated elements will not be connected to existing elements\n     * @param vertexFactory called to produce new vertices\n     * @param resultMap unused parameter\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.ScaleFreeGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generates scale-free network with <tt>size<\/tt> passed to the\nconstructor. Each call of this method produces identical output (but if\n<tt>target<\/tt> is an undirected graph, the directions of edges will be\nlost).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements'}]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='called to produce new vertices'}]}', name=Optional[vertexFactory]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='unused parameter'}]}', name=Optional[resultMap]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 115,col 25)-(line 115,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 116,col 22)-(line 116,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 119,col 29)-(line 119,col 29)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 120,col 34)-(line 120,col 34)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 120,col 46)-(line 120,col 46)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 124,col 30)-(line 124,col 30)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 125,col 39)-(line 125,col 39)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 128,col 57)-(line 128,col 57)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 130,col 38)-(line 130,col 38)","literalExprId":9,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 131,col 44)-(line 131,col 44)","literalExprId":10,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 131,col 50)-(line 131,col 50)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.ScaleFreeGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates directed or undirected <a href =\n * \"http:\/\/mathworld.wolfram.com\/Scale-FreeNetwork.html\">scale-free network<\/a>\n * of any size. Scale-free network is a connected graph, where degrees of\n * vertices are distributed in unusual way. There are many vertices with small\n * degrees and only small amount of vertices with big degrees.\n *\n * @author Ilya Razenshteyn\n *\/\n","className":"ScaleFreeGraphGenerator","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 21)","fieldName":"size","fieldJavadocComment":" size of graphs, generated by this instance of generator","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 55,col 5)-(line 55,col 22)","fieldName":"seed","fieldJavadocComment":" initial seed","fieldTokenRange":"private long seed;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 56,col 5)-(line 56,col 26)","fieldName":"random","fieldJavadocComment":" the source of randomness","fieldTokenRange":"private Random random;","fieldTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Random","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Random"}]}],"sourceFileId":101,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public SimpleWeightedBipartiteGraphMatrixGenerator<V, E> first(List<? extends V> first)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.first = new ArrayList<V>(first);\n    return this;\n}","methodRange":"(line 29,col 5)-(line 34,col 5)","methodTokenRange":"public SimpleWeightedBipartiteGraphMatrixGenerator<V, E> first(\n        List<? extends V> first)\n    {\n        this.first = new ArrayList<V>(first);\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"List<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends V>","parameter":"List<? extends V> first","parameterName":"first"}],"methodName":"first","methodQualifiedSignature":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.first","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator<V, E>","methodType":"SimpleWeightedBipartiteGraphMatrixGenerator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.first(java.util.List<? extends V>)"},{"methodDeclaration":"public SimpleWeightedBipartiteGraphMatrixGenerator<V, E> second(List<? extends V> second)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.second = new ArrayList<V>(second);\n    return this;\n}","methodRange":"(line 36,col 5)-(line 41,col 5)","methodTokenRange":"public SimpleWeightedBipartiteGraphMatrixGenerator<V, E> second(\n        List<? extends V> second)\n    {\n        this.second = new ArrayList<V>(second);\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"List<? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends V>","parameter":"List<? extends V> second","parameterName":"second"}],"methodName":"second","methodQualifiedSignature":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.second","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator<V, E>","methodType":"SimpleWeightedBipartiteGraphMatrixGenerator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.second(java.util.List<? extends V>)"},{"methodDeclaration":"public void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (weights == null) {\n        throw new IllegalArgumentException(\"Graph may not be constructed without weight-matrix specified\");\n    }\n    if ((first == null) || (second == null)) {\n        throw new IllegalArgumentException(\"Graph may not be constructed without either of vertex-set partitions specified\");\n    }\n    assert second.size() == weights.length;\n    for (V vertex : first) {\n        target.addVertex(vertex);\n    }\n    for (V vertex : second) {\n        target.addVertex(vertex);\n    }\n    for (int i = 0; i < first.size(); ++i) {\n        assert first.size() == weights[i].length;\n        for (int j = 0; j < second.size(); ++j) {\n            target.setEdgeWeight(target.addEdge(first.get(i), second.get(j)), weights[i][j]);\n        }\n    }\n}","methodRange":"(line 43,col 5)-(line 77,col 5)","methodTokenRange":"@Override public void generateGraph(\n        WeightedGraph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (weights == null) {\n            throw new IllegalArgumentException(\n                \"Graph may not be constructed without weight-matrix specified\");\n        }\n\n        if ((first == null) || (second == null)) {\n            throw new IllegalArgumentException(\n                \"Graph may not be constructed without either of vertex-set partitions specified\");\n        }\n\n        assert second.size() == weights.length;\n\n        for (V vertex : first) {\n            target.addVertex(vertex);\n        }\n\n        for (V vertex : second) {\n            target.addVertex(vertex);\n        }\n\n        for (int i = 0; i < first.size(); ++i) {\n            assert first.size() == weights[i].length;\n\n            for (int j = 0; j < second.size(); ++j) {\n                target.setEdgeWeight(\n                    target.addEdge(first.get(i), second.get(j)),\n                    weights[i][j]);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.generateGraph","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 48,col 24)-(line 48,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 50,col 17)-(line 50,col 78)","literalExprId":2,"literalExpr":"\"Graph may not be constructed without weight-matrix specified\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 53,col 23)-(line 53,col 26)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 53,col 43)-(line 53,col 46)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 55,col 17)-(line 55,col 96)","literalExprId":5,"literalExpr":"\"Graph may not be constructed without either of vertex-set partitions specified\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 22)-(line 68,col 22)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 71,col 26)-(line 71,col 26)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.SimpleWeightedBipartiteGraphMatrixGenerator.generateGraph(org.jgrapht.WeightedGraph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"","className":"SimpleWeightedBipartiteGraphMatrixGenerator","fields":[{"fieldRange":"(line 23,col 5)-(line 23,col 18)","fieldName":"first","fieldJavadocComment":"","fieldTokenRange":"List<V> first;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"},{"fieldRange":"(line 25,col 5)-(line 25,col 19)","fieldName":"second","fieldJavadocComment":"","fieldTokenRange":"List<V> second;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"}]}],"sourceFileId":102,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.LinearGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified size is negative.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.LinearGraphGenerator.LinearGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 80,col 5)","constructorJavadocComment":"\n     * Construct a new LinearGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     ","constructorDeclaration":"public LinearGraphGenerator(int size)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}","constructorName":"LinearGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.LinearGraphGenerator.LinearGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"}],"literalExprs":[{"literalExprRange":"(line 75,col 20)-(line 75,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 48)-(line 76,col 69)","literalExprId":2,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public LinearGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new LinearGraphGenerator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V lastVertex = null;\n    for (int i = 0; i < size; ++i) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n        if (lastVertex == null) {\n            if (resultMap != null) {\n                resultMap.put(START_VERTEX, newVertex);\n            }\n        } else {\n            target.addEdge(lastVertex, newVertex);\n        }\n        lastVertex = newVertex;\n    }\n    if ((resultMap != null) && (lastVertex != null)) {\n        resultMap.put(END_VERTEX, lastVertex);\n    }\n}","methodRange":"(line 85,col 5)-(line 110,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        V lastVertex = null;\n\n        for (int i = 0; i < size; ++i) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n\n            if (lastVertex == null) {\n                if (resultMap != null) {\n                    resultMap.put(START_VERTEX, newVertex);\n                }\n            } else {\n                target.addEdge(lastVertex, newVertex);\n            }\n\n            lastVertex = newVertex;\n        }\n\n        if ((resultMap != null) && (lastVertex != null)) {\n            resultMap.put(END_VERTEX, lastVertex);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.LinearGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 90,col 24)-(line 90,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 92,col 22)-(line 92,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 96,col 31)-(line 96,col 34)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 97,col 34)-(line 97,col 37)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 107,col 27)-(line 107,col 30)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 107,col 51)-(line 107,col 54)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.LinearGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a linear graph of any size. For a directed graph, the edges are\n * oriented from START_VERTEX to END_VERTEX.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n *\/\n","className":"LinearGraphGenerator","fields":[{"fieldRange":"(line 57,col 5)-(line 57,col 61)","fieldName":"START_VERTEX","fieldJavadocComment":"\n     * Role for the first vertex generated.\n     ","fieldTokenRange":"public static final String START_VERTEX = \"Start Vertex\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 57,col 47)-(line 57,col 60)","literalExprId":1,"literalExpr":"\"Start Vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"Start Vertex\"]","fieldType":"String","fieldJavadoc":"Role for the first vertex generated.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 62,col 5)-(line 62,col 57)","fieldName":"END_VERTEX","fieldJavadocComment":"\n     * Role for the last vertex generated.\n     ","fieldTokenRange":"public static final String END_VERTEX = \"End Vertex\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 62,col 45)-(line 62,col 56)","literalExprId":1,"literalExpr":"\"End Vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"End Vertex\"]","fieldType":"String","fieldJavadoc":"Role for the last vertex generated.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 64,col 5)-(line 64,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":103,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.CompleteGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified size is negative.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.CompleteGraphGenerator.CompleteGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 77,col 5)","constructorJavadocComment":"\n     * Construct a new CompleteGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     ","constructorDeclaration":"public CompleteGraphGenerator(int size)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}","constructorName":"CompleteGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.CompleteGraphGenerator.CompleteGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"}],"literalExprs":[{"literalExprRange":"(line 72,col 20)-(line 72,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 73,col 48)-(line 73,col 69)","literalExprId":2,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public CompleteGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new CompleteGraphGenerator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (size < 1) {\n        return;\n    }\n    for (int i = 0; i < size; i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n    }\n    Iterator<V> slowI = target.vertexSet().iterator();\n    Iterator<V> fastI;\n    while (slowI.hasNext()) {\n        V latestVertex = slowI.next();\n        fastI = target.vertexSet().iterator();\n        while (fastI.next() != latestVertex) {\n            ;\n        }\n        V temp;\n        while (fastI.hasNext()) {\n            temp = fastI.next();\n            target.addEdge(latestVertex, temp);\n            target.addEdge(temp, latestVertex);\n        }\n    }\n}","methodRange":"(line 82,col 5)-(line 127,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (size < 1) {\n            return;\n        }\n\n        \/\/Add all the vertices to the set\n        for (int i = 0; i < size; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n        }\n\n        \/*\n         * We want two iterators over the vertex set, one fast and one slow.\n         * The slow one will move through the set once. For each vertex,\n         * the fast iterator moves through the set, adding an edge to all\n         * vertices we haven't connected to yet.\n         *\n         * If we have an undirected graph, the second addEdge call will return\n         * nothing; it will not add a second edge.\n         *\/\n        Iterator<V> slowI = target.vertexSet().iterator();\n        Iterator<V> fastI;\n\n        while (slowI.hasNext()) { \/\/While there are more vertices in the set\n\n            V latestVertex = slowI.next();\n            fastI = target.vertexSet().iterator();\n\n            \/\/Jump to the first vertex *past* latestVertex\n            while (fastI.next() != latestVertex) {\n                ;\n            }\n\n            \/\/And, add edges to all remaining vertices\n            V temp;\n            while (fastI.hasNext()) {\n                temp = fastI.next();\n                target.addEdge(latestVertex, temp);\n                target.addEdge(temp, latestVertex);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.CompleteGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 87,col 20)-(line 87,col 20)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 22)-(line 92,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.CompleteGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a complete graph of any size. A complete graph is a graph where\n * every vertex shares an edge with every other vertex. If it is a directed\n * graph, then edges must always exist in both directions. On a side note, a\n * complete graph is the least efficient possible graph in terms of memory and\n * cpu usage. Note: This contructor was designed for a simple undirected or\n * directed graph. It will act strangely when used with certain graph types,\n * such as undirected multigraphs. Note, though, that a complete undirected\n * multigraph is rather senseless -- you can keep adding edges and the graph is\n * never truly complete.\n *\n * @author Tim Shearouse\n * @since Nov 02, 2008\n *\/\n","className":"CompleteGraphGenerator","fields":[{"fieldRange":"(line 61,col 5)-(line 61,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":104,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.RandomGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"RandomGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.RandomGraphGenerator","constructorQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.RandomGraphGenerator(int, int)","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int aNumOfVertexes","parameterName":"aNumOfVertexes"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int aNumOfEdges","parameterName":"aNumOfEdges"}],"literalExprs":[],"constructorTokenRange":"public RandomGraphGenerator(int aNumOfVertexes, int aNumOfEdges)\n    {\n        this(aNumOfVertexes, aNumOfEdges, chooseRandomSeedOnce());\n    }","variableDeclarationExprs":[],"constructorRange":"(line 67,col 5)-(line 70,col 5)","constructorJavadocComment":"","constructorDeclaration":"public RandomGraphGenerator(int aNumOfVertexes, int aNumOfEdges)","constructorBody":"{\n    this(aNumOfVertexes, aNumOfEdges, chooseRandomSeedOnce());\n}","constructorJavadoc":""},{"constructorName":"RandomGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.RandomGraphGenerator","constructorQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.RandomGraphGenerator(int, int, long)","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int aNumOfVertexes","parameterName":"aNumOfVertexes"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int aNumOfEdges","parameterName":"aNumOfEdges"},{"parameterType":"long","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long seed","parameterName":"seed"}],"literalExprs":[{"literalExprRange":"(line 74,col 31)-(line 74,col 31)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 74,col 52)-(line 74,col 52)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 75,col 48)-(line 75,col 69)","literalExprId":3,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public RandomGraphGenerator(int aNumOfVertexes, int aNumOfEdges, long seed)\n    {\n        if ((aNumOfVertexes < 0) || (aNumOfEdges < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n        this.numOfVertexes = aNumOfVertexes;\n        this.numOfEdges = aNumOfEdges;\n\n        this.randomizerSeed = seed;\n        this.randomizer = new Random(this.randomizerSeed);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 82,col 5)","constructorJavadocComment":"","constructorDeclaration":"public RandomGraphGenerator(int aNumOfVertexes, int aNumOfEdges, long seed)","constructorBody":"{\n    if ((aNumOfVertexes < 0) || (aNumOfEdges < 0)) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.numOfVertexes = aNumOfVertexes;\n    this.numOfEdges = aNumOfEdges;\n    this.randomizerSeed = seed;\n    this.randomizer = new Random(this.randomizerSeed);\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 188,col 5)-(line 222,col 5)","classOrInterfaceTokenRange":"public interface EdgeTopologyFactory<VV, EE>\n    {\n        \/**\n         * Two different calls to the createEdges() with the same parameters\n         * must result in the generation of the same. But if the randomizer is\n         * different, it should, usually, create different edge topology.\n         *\n         * @param targetGraph - guranteed to start with zero edges.\n         * @param orderToVertexMap - key=Integer of vertex order . between zero\n         * to numOfVertexes (exclusive). value = vertex from the graph. unique.\n         * @param numberOfEdges - to create in the graph\n         * @param randomizer\n         *\/\n        public void createEdges(\n            Graph<VV, EE> targetGraph,\n            Map<Integer, VV> orderToVertexMap,\n            int numberOfEdges,\n            Random randomizer);\n\n        \/**\n         * Checks if the graph can contain the givven numberOfEdges according to\n         * the graph type restrictions. For example:\n         *\n         * <ol>\n         * <li>#V means number of vertexes in graph\n         * <li>a Simple Graph, can have max of #V*(#V-1)\/2 edges. etc\n         * <\/ol>\n         *\n         * @param targetGraph guranteed to start with zero edges.\n         * @param numberOfEdges\n         *\/\n        public boolean isNumberOfEdgesValid(\n            Graph<VV, EE> targetGraph,\n            int numberOfEdges);\n    }","classOrInterfaceJavadocComment":"\n     * This class is used to generate the edge topology for a graph.\n     *\n     * @author Assaf\n     * @since Aug 6, 2005\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is used to generate the edge topology for a graph.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Assaf'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 6, 2005'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 244,col 5)-(line 380,col 5)","classOrInterfaceTokenRange":"public class DefaultEdgeTopologyFactory<VV, EE>\n        implements EdgeTopologyFactory<VV, EE>\n    {\n        @Override public void createEdges(\n            Graph<VV, EE> targetGraph,\n            Map<Integer, VV> orderToVertexMap,\n            int numberOfEdges,\n            Random randomizer)\n        {\n            int iterationsCounter = 0;\n            int edgesCounter = 0;\n            while (edgesCounter < numberOfEdges) {\n                \/\/ randomizer.nextInt(int n) return a number between zero\n                \/\/ (inclusive) and n(exclusive)\n                VV startVertex =\n                    orderToVertexMap.get(\n                        Integer.valueOf(randomizer.nextInt(numOfVertexes)));\n                VV endVertex =\n                    orderToVertexMap.get(\n                        Integer.valueOf(randomizer.nextInt(numOfVertexes)));\n                try {\n                    EE resultEdge = targetGraph.addEdge(startVertex, endVertex);\n                    if (resultEdge != null) {\n                        edgesCounter++;\n                    }\n                } catch (Exception e) {\n                    \/\/ do nothing.just ignore the edge\n                }\n\n                iterationsCounter++;\n            }\n        }\n\n        \/**\n         * checks if the numOfEdges is smaller than the Max edges according to\n         * the following table:\n         *\n         * <p>\n         * <table border=1 cellpadding=5>\n         * <caption><\/caption>\n         * <tr align=\"center\">\n         * <th>Graph Type<\/th>\n         * <th><i>Directed \/ UnDirected<\/i><\/th>\n         * <th><i>multiple edges<\/i><\/th>\n         * <th><i>loops<\/i><\/th>\n         * <th><i>Max Edges<\/i><\/th>\n         * <\/tr>\n         * <tr align=\"center\">\n         * <td>SimpleGraph<\/td>\n         * <td>UnDirected<\/td>\n         * <td>-<\/td>\n         * <td>-<\/td>\n         * <td>N(N-1)\/2<\/td>\n         * <\/tr>\n         * <tr align=\"center\">\n         * <td>Multigraph<\/td>\n         * <td>UnDirected<\/td>\n         * <td>+<\/td>\n         * <td>-<\/td>\n         * <td>Infinite<\/td>\n         * <\/tr>\n         * <tr align=\"center\">\n         * <td>Pseudograph<\/td>\n         * <td>UnDirected<\/td>\n         * <td>+<\/td>\n         * <td>+<\/td>\n         * <td>Infinite<\/td>\n         * <\/tr>\n         * <tr align=\"center\">\n         * <td>SimpleDirectedGraph<\/td>\n         * <td>Directed<\/td>\n         * <td>-<\/td>\n         * <td>-<\/td>\n         * <td>N (N-1)<\/td>\n         * <\/tr>\n         * <tr align=\"center\">\n         * <td>DefaultDirectedGraph<\/td>\n         * <td>Directed<\/td>\n         * <td>-<\/td>\n         * <td>+<\/td>\n         * <td>N*(N-1)+ N = N^2<\/td>\n         * <\/tr>\n         * <tr align=\"center\">\n         * <td>DirectedMultigraph<\/td>\n         * <td>Directed<\/td>\n         * <td>+<\/td>\n         * <td>+<\/td>\n         * <td>Infinite<\/td>\n         * <\/tr>\n         * <\/table>\n         *\n         * @see RandomGraphGenerator.EdgeTopologyFactory#isNumberOfEdgesValid(Graph,\n         * int)\n         *\/\n        @Override public boolean isNumberOfEdgesValid(\n            Graph<VV, EE> targetGraph,\n            int numberOfEdges)\n        {\n            boolean result;\n\n            boolean infinite = false;\n            int maxAllowedEdges = getMaxEdgesForVertexNum(targetGraph);\n            if (maxAllowedEdges == -1) {\n                infinite = true;\n            }\n\n            if (true == infinite) {\n                result = true;\n            } else if (numberOfEdges <= maxAllowedEdges) {\n                result = true;\n            } else {\n                result = false;\n            }\n            return result;\n        }\n\n        \/**\n         * Return max edges for that graph. If it is infinite return -1 instead.\n         *\/\n        public int getMaxEdgesForVertexNum(Graph<VV, EE> targetGraph)\n        {\n            int maxAllowedEdges = 0;\n            if (targetGraph instanceof SimpleGraph<?, ?>) {\n                maxAllowedEdges = numOfVertexes * (numOfVertexes - 1) \/ 2;\n            } else if (targetGraph instanceof SimpleDirectedGraph<?, ?>) {\n                maxAllowedEdges = numOfVertexes * (numOfVertexes - 1);\n            } else if (targetGraph instanceof DefaultDirectedGraph<?, ?>) {\n                maxAllowedEdges = numOfVertexes * numOfVertexes;\n            } else {\n                \/\/ This may be overly liberal in the case of something\n                \/\/ like a simple graph which has been wrapped with\n                \/\/ a graph adapter or view.\n                maxAllowedEdges = -1; \/\/ infinite\n            }\n            return maxAllowedEdges;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Default implementation of the EdgeTopologyFactory interface. randomly\n     * chooses an edge and tries to add it. If the add fails from any reason\n     * (like: self edge \/ multiple edges in unpermitted graph type) it will just\n     * choose another and try again. Performance:\n     *\n     * <ol>\n     * <li>when the number of possible edges becomes slim , this class will have\n     * a very poor performance , cause it will not use gready methods to choose\n     * them. for example : In simple graph , if #V = N (#x = number Of x) and we\n     * want full mesh #edges= N*(N-1)\/2 , the first added edges will do so\n     * quickly (O(1) , the last will take O(N^2). So , do not use it in this\n     * kind of graphs.<\/li>\n     * <li>If the numberOfEdges is bigger than what the graph can add, there\n     * will be an infinite loop here. It is not tested.<\/li>\n     * <\/ol>\n     *\n     * @author Assaf\n     * @since Aug 6, 2005\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Default implementation of the EdgeTopologyFactory interface. randomly\nchooses an edge and tries to add it. If the add fails from any reason\n(like: self edge \/ multiple edges in unpermitted graph type) it will just\nchoose another and try again. Performance:\n\n<ol>\n<li>when the number of possible edges becomes slim , this class will have\na very poor performance , cause it will not use gready methods to choose\nthem. for example : In simple graph , if #V = N (#x = number Of x) and we\nwant full mesh #edges= N*(N-1)\/2 , the first added edges will do so\nquickly (O(1) , the last will take O(N^2). So , do not use it in this\nkind of graphs.<\/li>\n<li>If the numberOfEdges is bigger than what the graph can add, there\nwill be an infinite loop here. It is not tested.<\/li>\n<\/ol>'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Assaf'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 6, 2005'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"AUTHOR","javadocBlockTagContent":"Assaf","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Assaf'}]}', name=Optional.empty}"},{"javadocBlockType":"SINCE","javadocBlockTagContent":"Aug 6, 2005","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 6, 2005'}]}', name=Optional.empty}"}],"methodDeclaration":"private static synchronized long chooseRandomSeedOnce()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (++seedUniquifier + System.nanoTime());\n}","methodRange":"(line 93,col 5)-(line 96,col 5)","methodTokenRange":"private synchronized static long chooseRandomSeedOnce()\n    {\n        return (++seedUniquifier + System.nanoTime());\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n     * Should be called only once on creation. Chooses a seed which can be used\n     * later to reset the randomizer before each method call. This\n     * implementation copies the java.util.Random constructor because there is\n     * no getSeed() there, and seed is protected.\n     *\n     * @author Assaf\n     * @since Aug 6, 2005\n     ","methodParameters":[],"methodName":"chooseRandomSeedOnce","methodQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.chooseRandomSeedOnce","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Should be called only once on creation. Chooses a seed which can be used\nlater to reset the randomizer before each method call. This\nimplementation copies the java.util.Random constructor because there is\nno getSeed() there, and seed is protected.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Assaf'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 6, 2005'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.chooseRandomSeedOnce()"},{"javadocBlockTags":[],"methodDeclaration":"private void resetRandomSeed()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    this.randomizer.setSeed(this.randomizerSeed);\n}","methodRange":"(line 101,col 5)-(line 104,col 5)","methodTokenRange":"private void resetRandomSeed()\n    {\n        this.randomizer.setSeed(this.randomizerSeed);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Resets seed to generate the same random stream.\n     ","methodParameters":[],"methodName":"resetRandomSeed","methodQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.resetRandomSeed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Resets seed to generate the same random stream.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.resetRandomSeed()"},{"methodDeclaration":"public long getRandomSeed()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.randomizerSeed;\n}","methodRange":"(line 106,col 5)-(line 109,col 5)","methodTokenRange":"public long getRandomSeed()\n    {\n        return this.randomizerSeed;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[],"methodName":"getRandomSeed","methodQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.getRandomSeed","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.getRandomSeed()"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the aNumOfEdges passed in the\nconstructor, cannot be created on a graph of the concrete type with\naNumOfVertexes.\norg.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\nint)","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the aNumOfEdges passed in the\nconstructor, cannot be created on a graph of the concrete type with\naNumOfVertexes.\norg.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\nint)'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphGenerator#generateGraph(Graph, VertexFactory, Map)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphGenerator#generateGraph(Graph, VertexFactory, Map)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    resetRandomSeed();\n    Map<Integer, V> orderToVertexMap = new HashMap<Integer, V>(this.numOfVertexes);\n    for (int i = 0; i < this.numOfVertexes; i++) {\n        V currVertex = vertexFactory.createVertex();\n        target.addVertex(currVertex);\n        orderToVertexMap.put(Integer.valueOf(i), currVertex);\n    }\n    if (target.vertexSet().size() != numOfVertexes) {\n        throw new IllegalArgumentException(\"Vertex factory did not produce \" + numOfVertexes + \" distinct vertices.\");\n    }\n    EdgeTopologyFactory<V, E> edgesFactory = edgeTopologyFactoryChooser(target, numOfEdges);\n    if (!edgesFactory.isNumberOfEdgesValid(target, numOfEdges)) {\n        throw new IllegalArgumentException(\"numOfEdges is not valid for the graph type \" + \"\\n-> Invalid number Of Edges=\" + numOfEdges + \" for:\" + \" graph type=\" + target.getClass() + \" ,number Of Vertexes=\" + this.numOfVertexes + \"\\n-> Advice: For the Max value , check the javadoc for\" + \" org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory\");\n    }\n    edgesFactory.createEdges(target, orderToVertexMap, this.numOfEdges, this.randomizer);\n}","methodRange":"(line 122,col 5)-(line 165,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        resetRandomSeed();\n\n        \/\/ key = generation order (1st,2nd,3rd,...) value=vertex Object\n        \/\/ will be used later\n        Map<Integer, V> orderToVertexMap =\n            new HashMap<Integer, V>(this.numOfVertexes);\n\n        for (int i = 0; i < this.numOfVertexes; i++) {\n            V currVertex = vertexFactory.createVertex();\n            target.addVertex(currVertex);\n            orderToVertexMap.put(Integer.valueOf(i), currVertex);\n        }\n\n        if (target.vertexSet().size() != numOfVertexes) {\n            throw new IllegalArgumentException(\n                \"Vertex factory did not produce \" + numOfVertexes\n                + \" distinct vertices.\");\n        }\n\n        \/\/ use specific type of edge factory, depending of the graph type\n        \/\/ and edge density\n        EdgeTopologyFactory<V, E> edgesFactory =\n            edgeTopologyFactoryChooser(target, numOfEdges);\n        if (!edgesFactory.isNumberOfEdgesValid(target, numOfEdges)) {\n            throw new IllegalArgumentException(\n                \"numOfEdges is not valid for the graph type \"\n                + \"\\n-> Invalid number Of Edges=\" + numOfEdges + \" for:\"\n                + \" graph type=\" + target.getClass()\n                + \" ,number Of Vertexes=\" + this.numOfVertexes\n                + \"\\n-> Advice: For the Max value , check the javadoc for\"\n                + \" org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory\");\n        }\n\n        edgesFactory.createEdges(\n            target,\n            orderToVertexMap,\n            this.numOfEdges,\n            this.randomizer);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * (non-Javadoc)\n     *\n     * @throws IllegalArgumentException if the aNumOfEdges passed in the\n     * constructor, cannot be created on a graph of the concrete type with\n     * aNumOfVertexes.\n     * org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\n     * int)\n     *\n     * @see GraphGenerator#generateGraph(Graph, VertexFactory, Map)\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='(non-Javadoc)'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the aNumOfEdges passed in the\nconstructor, cannot be created on a graph of the concrete type with\naNumOfVertexes.\norg.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory#isNumberOfEdgesValid(org.jgrapht.Graph,\nint)'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphGenerator#generateGraph(Graph, VertexFactory, Map)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 134,col 22)-(line 134,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 142,col 17)-(line 142,col 49)","literalExprId":2,"literalExpr":"\"Vertex factory did not produce \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 143,col 19)-(line 143,col 39)","literalExprId":3,"literalExpr":"\" distinct vertices.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 152,col 17)-(line 152,col 61)","literalExprId":4,"literalExpr":"\"numOfEdges is not valid for the graph type \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 153,col 19)-(line 153,col 49)","literalExprId":5,"literalExpr":"\"\\n-> Invalid number Of Edges=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 153,col 66)-(line 153,col 72)","literalExprId":6,"literalExpr":"\" for:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 19)-(line 154,col 32)","literalExprId":7,"literalExpr":"\" graph type=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 155,col 19)-(line 155,col 41)","literalExprId":8,"literalExpr":"\" ,number Of Vertexes=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 156,col 19)-(line 156,col 74)","literalExprId":9,"literalExpr":"\"\\n-> Advice: For the Max value , check the javadoc for\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 157,col 19)-(line 157,col 89)","literalExprId":10,"literalExpr":"\" org.jgrapht.generate.RandomGraphGenerator.DefaultEdgeTopologyFactory\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[target]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[]}', name=Optional.empty}"}],"methodDeclaration":"private EdgeTopologyFactory<V, E> edgeTopologyFactoryChooser(Graph<V, E> target, int numOfEdges)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return new DefaultEdgeTopologyFactory<V, E>();\n}","methodRange":"(line 175,col 5)-(line 180,col 5)","methodTokenRange":"private EdgeTopologyFactory<V, E> edgeTopologyFactoryChooser(\n        Graph<V, E> target,\n        int numOfEdges)\n    {\n        return new DefaultEdgeTopologyFactory<V, E>();\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.RandomGraphGenerator.EdgeTopologyFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.RandomGraphGenerator.EdgeTopologyFactory.VV=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.generate.RandomGraphGenerator.EdgeTopologyFactory.EE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a concrete EdgeTopologyFactory, depending on graph type and\n     * numOfEdges\n     *\n     * @param target\n     *\n     * @return\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numOfEdges","parameterName":"numOfEdges"}],"methodName":"edgeTopologyFactoryChooser","methodQualifiedSignature":"org.jgrapht.generate.RandomGraphGenerator.edgeTopologyFactoryChooser","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a concrete EdgeTopologyFactory, depending on graph type and\nnumOfEdges'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[target]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.generate.RandomGraphGenerator.EdgeTopologyFactory<V, E>","methodType":"EdgeTopologyFactory<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.RandomGraphGenerator.edgeTopologyFactoryChooser(org.jgrapht.Graph<V, E>, int)"}],"classJavadoc":"\/**\n * This Generator creates a random-topology graph of a specified number of\n * vertexes and edges. An instance of this generator will always return the same\n * graph-topology in calls to generateGraph(). The vertexes can be different\n * (depends on the VertexFactory implementation)\n *\n * <p>However, two instances which use the same constructor parameters will\n * produce two different random graphs (note: as with any random generator,\n * there is always a small possibility that two instances will create the same\n * results).\n *\n * @author Assaf Lehr\n * @since Aug 6, 2005\n *\/\n","className":"RandomGraphGenerator","fields":[{"fieldRange":"(line 60,col 5)-(line 60,col 59)","fieldName":"seedUniquifier","fieldJavadocComment":"","fieldTokenRange":"private static long seedUniquifier = 8682522807148012L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 60,col 42)-(line 60,col 58)","literalExprId":1,"literalExpr":"8682522807148012L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[8682522807148012L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 62,col 5)-(line 62,col 32)","fieldName":"numOfVertexes","fieldJavadocComment":"","fieldTokenRange":"protected int numOfVertexes;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 63,col 5)-(line 63,col 29)","fieldName":"numOfEdges","fieldJavadocComment":"","fieldTokenRange":"protected int numOfEdges;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 64,col 5)-(line 64,col 32)","fieldName":"randomizer","fieldJavadocComment":"","fieldTokenRange":"protected Random randomizer;","fieldTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Random","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Random"},{"fieldRange":"(line 65,col 5)-(line 65,col 32)","fieldName":"randomizerSeed","fieldJavadocComment":"","fieldTokenRange":"private long randomizerSeed;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":105,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.WeightedGraphGeneratorAdapter","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public abstract void generateGraph(WeightedGraph<V, E> target, VertexFactory<V> vertexFactory, Map<String, T> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 34,col 5)-(line 37,col 34)","methodTokenRange":"public abstract void generateGraph(\n        WeightedGraph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, T> resultMap);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"WeightedGraph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, T>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, T>","parameter":"Map<String, T> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.WeightedGraphGeneratorAdapter.generateGraph","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.WeightedGraphGeneratorAdapter.generateGraph(org.jgrapht.WeightedGraph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, T>)"},{"methodDeclaration":"public WeightedGraphGeneratorAdapter<V, E, T> weights(double[][] weights)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.weights = weights;\n    return this;\n}","methodRange":"(line 41,col 5)-(line 45,col 5)","methodTokenRange":"public WeightedGraphGeneratorAdapter<V, E, T> weights(double [][] weights)\n    {\n        this.weights = weights;\n        return this;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.generate.WeightedGraphGeneratorAdapter, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.generate.WeightedGraphGeneratorAdapter.T=TypeVariable {JPTypeParameter(T, bounds=[])}, org.jgrapht.generate.WeightedGraphGeneratorAdapter.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.generate.WeightedGraphGeneratorAdapter.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"double[][]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}","parameterTypeResolvedDescribed":"double[][]","parameter":"double[][] weights","parameterName":"weights"}],"methodName":"weights","methodQualifiedSignature":"org.jgrapht.generate.WeightedGraphGeneratorAdapter.weights","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.generate.WeightedGraphGeneratorAdapter<V, E, T>","methodType":"WeightedGraphGeneratorAdapter<V, E, T>","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.WeightedGraphGeneratorAdapter.weights(double[][])"},{"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, T> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    generateGraph((WeightedGraph<V, E>) target, vertexFactory, resultMap);\n}","methodRange":"(line 47,col 5)-(line 53,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, T> resultMap)\n    {\n        generateGraph((WeightedGraph<V, E>) target, vertexFactory, resultMap);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, T>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, T>","parameter":"Map<String, T> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.WeightedGraphGeneratorAdapter.generateGraph","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.WeightedGraphGeneratorAdapter.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, T>)"}],"classJavadoc":"\/**\n * WeightedGraphGenerator defines an interface for generating graph structures\n * having edges weighted with real values.\n *\n * @author Alexey Kudinkin\n * @since Aug 1, 2013\n *\/\n","className":"WeightedGraphGeneratorAdapter","fields":[{"fieldRange":"(line 30,col 5)-(line 30,col 34)","fieldName":"weights","fieldJavadocComment":"","fieldTokenRange":"protected double [][] weights;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"double[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"double[][]"}]}],"sourceFileId":106,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.EmptyGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of vertices to be generated","javadocBlockTagName":"size","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified size is negative.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.EmptyGraphGenerator.EmptyGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 70,col 5)","constructorJavadocComment":"\n     * Construct a new EmptyGraphGenerator.\n     *\n     * @param size number of vertices to be generated\n     *\n     * @throws IllegalArgumentException if the specified size is negative.\n     ","constructorDeclaration":"public EmptyGraphGenerator(int size)","constructorBody":"{\n    if (size < 0) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.size = size;\n}","constructorName":"EmptyGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.EmptyGraphGenerator.EmptyGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int size","parameterName":"size"}],"literalExprs":[{"literalExprRange":"(line 65,col 20)-(line 65,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 66,col 48)-(line 66,col 69)","literalExprId":2,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public EmptyGraphGenerator(int size)\n    {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n\n        this.size = size;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a new EmptyGraphGenerator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of vertices to be generated'}]}', name=Optional[size]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified size is negative.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < size; ++i) {\n        target.addVertex(vertexFactory.createVertex());\n    }\n}","methodRange":"(line 75,col 5)-(line 83,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        for (int i = 0; i < size; ++i) {\n            target.addVertex(vertexFactory.createVertex());\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.EmptyGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 80,col 22)-(line 80,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.EmptyGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates an <a href=\"http:\/\/mathworld.wolfram.com\/EmptyGraph.html\">empty\n * graph<\/a> of any size. An empty graph is a graph that has no edges.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n *\/\n","className":"EmptyGraphGenerator","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 21)","fieldName":"size","fieldJavadocComment":"","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":107,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.CompleteBipartiteGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"This is the number of vertices in the first partition","javadocBlockTagName":"partitionOne","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='This is the number of vertices in the first partition'}]}', name=Optional[partitionOne]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"This is the number of vertices in the second parition","javadocBlockTagName":"partitionTwo","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='This is the number of vertices in the second parition'}]}', name=Optional[partitionTwo]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.CompleteBipartiteGraphGenerator.CompleteBipartiteGraphGenerator(int, int)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Creates a new CompleteBipartiteGraphGenerator object.\n     *\n     * @param partitionOne This is the number of vertices in the first partition\n     * @param partitionTwo This is the number of vertices in the second parition\n     ","constructorDeclaration":"public CompleteBipartiteGraphGenerator(int partitionOne, int partitionTwo)","constructorBody":"{\n    if ((partitionOne < 0) || (partitionTwo < 0)) {\n        throw new IllegalArgumentException(\"must be non-negative\");\n    }\n    this.sizeA = partitionOne;\n    this.sizeB = partitionTwo;\n}","constructorName":"CompleteBipartiteGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.CompleteBipartiteGraphGenerator.CompleteBipartiteGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int partitionOne","parameterName":"partitionOne"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int partitionTwo","parameterName":"partitionTwo"}],"literalExprs":[{"literalExprRange":"(line 67,col 29)-(line 67,col 29)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 67,col 51)-(line 67,col 51)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 48)-(line 68,col 69)","literalExprId":3,"literalExpr":"\"must be non-negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public CompleteBipartiteGraphGenerator(int partitionOne, int partitionTwo)\n    {\n        if ((partitionOne < 0) || (partitionTwo < 0)) {\n            throw new IllegalArgumentException(\"must be non-negative\");\n        }\n        this.sizeA = partitionOne;\n        this.sizeB = partitionTwo;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new CompleteBipartiteGraphGenerator object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='This is the number of vertices in the first partition'}]}', name=Optional[partitionOne]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='This is the number of vertices in the second parition'}]}', name=Optional[partitionTwo]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, final VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if ((sizeA < 1) && (sizeB < 1)) {\n        return;\n    }\n    Set<V> a = new HashSet<V>();\n    Set<V> b = new HashSet<V>();\n    for (int i = 0; i < sizeA; i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n        a.add(newVertex);\n    }\n    for (int i = 0; i < sizeB; i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n        b.add(newVertex);\n    }\n    for (Iterator<V> iterA = a.iterator(); iterA.hasNext(); ) {\n        V v = iterA.next();\n        for (Iterator<V> iterB = b.iterator(); iterB.hasNext(); ) {\n            target.addEdge(v, iterB.next());\n        }\n    }\n}","methodRange":"(line 77,col 5)-(line 107,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if ((sizeA < 1) && (sizeB < 1)) {\n            return;\n        }\n\n        \/\/Create vertices in each of the partitions\n        Set<V> a = new HashSet<V>();\n        Set<V> b = new HashSet<V>();\n        for (int i = 0; i < sizeA; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            a.add(newVertex);\n        }\n        for (int i = 0; i < sizeB; i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n            b.add(newVertex);\n        }\n\n        \/\/Add an edge for each pair of vertices in different partitions\n        for (Iterator<V> iterA = a.iterator(); iterA.hasNext();) {\n            V v = iterA.next();\n            for (Iterator<V> iterB = b.iterator(); iterB.hasNext();) {\n                target.addEdge(v, iterB.next());\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Construct a complete bipartite graph\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"final VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.CompleteBipartiteGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Construct a complete bipartite graph'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 82,col 22)-(line 82,col 22)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 82,col 37)-(line 82,col 37)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 89,col 22)-(line 89,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 94,col 22)-(line 94,col 22)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.CompleteBipartiteGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a <a\n * href=\"http:\/\/mathworld.wolfram.com\/CompleteBipartiteGraph.html\">complete\n * bipartite graph<\/a> of any size. This is a graph with two partitions; two\n * vertices will contain an edge if and only if they belong to different\n * partitions.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n *\/\n","className":"CompleteBipartiteGraphGenerator","fields":[{"fieldRange":"(line 57,col 5)-(line 57,col 29)","fieldName":"sizeA","fieldJavadocComment":"","fieldTokenRange":"private int sizeA, sizeB;","fieldTypeResolved":"","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":""}]}],"sourceFileId":108,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.GraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements'}]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"called to produce new vertices","javadocBlockTagName":"vertexFactory","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='called to produce new vertices'}]}', name=Optional[vertexFactory]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if non-null, receives implementation-specific mappings\nfrom String roles to graph elements (or collections of graph elements)","javadocBlockTagName":"resultMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if non-null, receives implementation-specific mappings\nfrom String roles to graph elements (or collections of graph elements)'}]}', name=Optional[resultMap]}"}],"methodDeclaration":"public void generateGraph(Graph<V, E> target, VertexFactory<V> vertexFactory, Map<String, T> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 69,col 5)-(line 72,col 34)","methodTokenRange":"public void generateGraph(\n        Graph<V, E> target,\n        VertexFactory<V> vertexFactory,\n        Map<String, T> resultMap);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Generate a graph structure. The topology of the generated graph is\n     * dependent on the implementation. For graphs in which not all vertices\n     * share the same automorphism equivalence class, the generator may produce\n     * a labeling indicating the roles played by generated elements. This is the\n     * purpose of the resultMap parameter. For example, a generator for a wheel\n     * graph would designate a hub vertex. Role names used as keys in resultMap\n     * should be declared as public static final Strings by implementation\n     * classes.\n     *\n     * @param target receives the generated edges and vertices; if this is\n     * non-empty on entry, the result will be a disconnected graph since\n     * generated elements will not be connected to existing elements\n     * @param vertexFactory called to produce new vertices\n     * @param resultMap if non-null, receives implementation-specific mappings\n     * from String roles to graph elements (or collections of graph elements)\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, T>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, T>","parameter":"Map<String, T> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.GraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generate a graph structure. The topology of the generated graph is\ndependent on the implementation. For graphs in which not all vertices\nshare the same automorphism equivalence class, the generator may produce\na labeling indicating the roles played by generated elements. This is the\npurpose of the resultMap parameter. For example, a generator for a wheel\ngraph would designate a hub vertex. Role names used as keys in resultMap\nshould be declared as public static final Strings by implementation\nclasses.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='receives the generated edges and vertices; if this is\nnon-empty on entry, the result will be a disconnected graph since\ngenerated elements will not be connected to existing elements'}]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='called to produce new vertices'}]}', name=Optional[vertexFactory]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if non-null, receives implementation-specific mappings\nfrom String roles to graph elements (or collections of graph elements)'}]}', name=Optional[resultMap]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.generate.GraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, T>)"}],"classJavadoc":"\/**\n * GraphGenerator defines an interface for generating new graph structures.\n *\n * @author John V. Sichi\n * @since Sep 16, 2003\n *\/\n","className":"GraphGenerator","fields":[]}],"sourceFileId":109,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.generate.StarGraphGenerator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of total vertices including the center vertex","javadocBlockTagName":"order","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of total vertices including the center vertex'}]}', name=Optional[order]}"}],"constructorQualifiedSignature":"org.jgrapht.generate.StarGraphGenerator.StarGraphGenerator(int)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 67,col 5)","constructorJavadocComment":"\n     * Creates a new StarGraphGenerator object.\n     *\n     * @param order number of total vertices including the center vertex\n     ","constructorDeclaration":"public StarGraphGenerator(int order)","constructorBody":"{\n    this.order = order;\n}","constructorName":"StarGraphGenerator","constructorQualifiedName":"org.jgrapht.generate.StarGraphGenerator.StarGraphGenerator","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int order","parameterName":"order"}],"literalExprs":[],"constructorTokenRange":"public StarGraphGenerator(int order)\n    {\n        this.order = order;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new StarGraphGenerator object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of total vertices including the center vertex'}]}', name=Optional[order]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void generateGraph(Graph<V, E> target, final VertexFactory<V> vertexFactory, Map<String, V> resultMap)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (order < 1) {\n        return;\n    }\n    V centerVertex = vertexFactory.createVertex();\n    target.addVertex(centerVertex);\n    if (resultMap != null) {\n        resultMap.put(CENTER_VERTEX, centerVertex);\n    }\n    for (int i = 0; i < (order - 1); i++) {\n        V newVertex = vertexFactory.createVertex();\n        target.addVertex(newVertex);\n    }\n    Iterator<V> iter = target.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if (v != centerVertex) {\n            target.addEdge(v, centerVertex);\n        }\n    }\n}","methodRange":"(line 72,col 5)-(line 102,col 5)","methodTokenRange":"@Override public void generateGraph(\n        Graph<V, E> target,\n        final VertexFactory<V> vertexFactory,\n        Map<String, V> resultMap)\n    {\n        if (order < 1) {\n            return;\n        }\n\n        \/\/Create center vertex\n        V centerVertex = vertexFactory.createVertex();\n        target.addVertex(centerVertex);\n        if (resultMap != null) {\n            resultMap.put(CENTER_VERTEX, centerVertex);\n        }\n\n        \/\/Create other vertices\n        for (int i = 0; i < (order - 1); i++) {\n            V newVertex = vertexFactory.createVertex();\n            target.addVertex(newVertex);\n        }\n\n        \/\/Add one edge between the center vertex and every other vertex\n        Iterator<V> iter = target.vertexSet().iterator();\n        while (iter.hasNext()) {\n            V v = iter.next();\n            if (v != centerVertex) {\n                target.addEdge(v, centerVertex);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Generates a star graph with the designated order from the constructor\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> target","parameterName":"target"},{"parameterType":"VertexFactory<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.VertexFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.VertexFactory.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.VertexFactory<V>","parameter":"final VertexFactory<V> vertexFactory","parameterName":"vertexFactory"},{"parameterType":"Map<String, V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<java.lang.String, V>","parameter":"Map<String, V> resultMap","parameterName":"resultMap"}],"methodName":"generateGraph","methodQualifiedSignature":"org.jgrapht.generate.StarGraphGenerator.generateGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generates a star graph with the designated order from the constructor'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 77,col 21)-(line 77,col 21)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 84,col 26)-(line 84,col 29)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 89,col 22)-(line 89,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 89,col 38)-(line 89,col 38)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.generate.StarGraphGenerator.generateGraph(org.jgrapht.Graph<V, E>, org.jgrapht.VertexFactory<V>, java.util.Map<java.lang.String, V>)"}],"classJavadoc":"\/**\n * Generates a <a href=\"http:\/\/mathworld.wolfram.com\/StarGraph.html\">star\n * graph<\/a> of any size. This is a graph where every vertex has exactly one\n * edge with a center vertex.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n *\/\n","className":"StarGraphGenerator","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 63)","fieldName":"CENTER_VERTEX","fieldJavadocComment":"","fieldTokenRange":"public static final String CENTER_VERTEX = \"Center Vertex\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 55,col 48)-(line 55,col 62)","literalExprId":1,"literalExpr":"\"Center Vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"Center Vertex\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 57,col 5)-(line 57,col 22)","fieldName":"order","fieldJavadocComment":"","fieldTokenRange":"private int order;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":110,"packageName":"org.jgrapht.generate"},{"sourceFileName":"org.jgrapht.UndirectedGraph","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex whose degree is to be calculated.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose degree is to be calculated.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the degree of the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the degree of the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int degreeOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 62,col 5)-(line 62,col 34)","methodTokenRange":"public int degreeOf(V vertex);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the degree of the specified vertex. A degree of a vertex in an\n     * undirected graph is the number of edges touching that vertex.\n     *\n     * @param vertex vertex whose degree is to be calculated.\n     *\n     * @return the degree of the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"degreeOf","methodQualifiedSignature":"org.jgrapht.UndirectedGraph.degreeOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the degree of the specified vertex. A degree of a vertex in an\nundirected graph is the number of edges touching that vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex whose degree is to be calculated.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the degree of the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.UndirectedGraph.degreeOf(V)"}],"classJavadoc":"\/**\n * A graph whose all edges are undirected. This is the root interface of all\n * undirected graphs.\n *\n * <p>See <a href=\"http:\/\/mathworld.wolfram.com\/Graph.html\">\n * http:\/\/mathworld.wolfram.com\/Graph.html<\/a> for more on undirected and on\n * directed graphs.<\/p>\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n *\/\n","className":"UndirectedGraph","fields":[]}],"sourceFileId":111,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.traverse.TopologicalOrderIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the directed graph to be iterated.","javadocBlockTagName":"dg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph to be iterated.'}]}', name=Optional[dg]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 89,col 5)-(line 92,col 5)","constructorJavadocComment":"\n     * Creates a new topological order iterator over the directed graph\n     * specified, with arbitrary tie-breaking in case of partial order.\n     * Traversal will start at one of the graph's <i>sources<\/i>. See the\n     * definition of source at <a\n     * href=\"http:\/\/mathworld.wolfram.com\/Source.html\">\n     * http:\/\/mathworld.wolfram.com\/Source.html<\/a>.\n     *\n     * @param dg the directed graph to be iterated.\n     ","constructorDeclaration":"public TopologicalOrderIterator(DirectedGraph<V, E> dg)","constructorBody":"{\n    this(dg, new LinkedListQueue<V>());\n}","constructorName":"TopologicalOrderIterator","constructorQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> dg","parameterName":"dg"}],"literalExprs":[],"constructorTokenRange":"public TopologicalOrderIterator(DirectedGraph<V, E> dg)\n    {\n        this(dg, new LinkedListQueue<V>());\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new topological order iterator over the directed graph\nspecified, with arbitrary tie-breaking in case of partial order.\nTraversal will start at one of the graph's <i>sources<\/i>. See the\ndefinition of source at <a\nhref=\"http:\/\/mathworld.wolfram.com\/Source.html\">\nhttp:\/\/mathworld.wolfram.com\/Source.html<\/a>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph to be iterated.'}]}', name=Optional[dg]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the directed graph to be iterated.","javadocBlockTagName":"dg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph to be iterated.'}]}', name=Optional[dg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"queue to use for tie-break in case of partial order (e.g. a\nPriorityQueue can be used to break ties according to vertex priority);\nmust be initially empty","javadocBlockTagName":"queue","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='queue to use for tie-break in case of partial order (e.g. a\nPriorityQueue can be used to break ties according to vertex priority);\nmust be initially empty'}]}', name=Optional[queue]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator(org.jgrapht.DirectedGraph<V, E>, java.util.Queue<V>)","variableDeclarationExprs":[],"constructorRange":"(line 107,col 5)-(line 110,col 5)","constructorJavadocComment":"\n     * Creates a new topological order iterator over the directed graph\n     * specified, with a user-supplied queue implementation to allow customized\n     * control over tie-breaking in case of partial order. Traversal will start\n     * at one of the graph's <i>sources<\/i>. See the definition of source at <a\n     * href=\"http:\/\/mathworld.wolfram.com\/Source.html\">\n     * http:\/\/mathworld.wolfram.com\/Source.html<\/a>.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue queue to use for tie-break in case of partial order (e.g. a\n     * PriorityQueue can be used to break ties according to vertex priority);\n     * must be initially empty\n     ","constructorDeclaration":"public TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue)","constructorBody":"{\n    this(dg, queue, new HashMap<V, ModifiableInteger>());\n}","constructorName":"TopologicalOrderIterator","constructorQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> dg","parameterName":"dg"},{"parameterType":"Queue<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Queue, typeParametersMap=TypeParametersMap{nameToValue={java.util.Queue.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Queue<V>","parameter":"Queue<V> queue","parameterName":"queue"}],"literalExprs":[],"constructorTokenRange":"public TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue)\n    {\n        this(dg, queue, new HashMap<V, ModifiableInteger>());\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new topological order iterator over the directed graph\nspecified, with a user-supplied queue implementation to allow customized\ncontrol over tie-breaking in case of partial order. Traversal will start\nat one of the graph's <i>sources<\/i>. See the definition of source at <a\nhref=\"http:\/\/mathworld.wolfram.com\/Source.html\">\nhttp:\/\/mathworld.wolfram.com\/Source.html<\/a>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph to be iterated.'}]}', name=Optional[dg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='queue to use for tie-break in case of partial order (e.g. a\nPriorityQueue can be used to break ties according to vertex priority);\nmust be initially empty'}]}', name=Optional[queue]}]}"},{"constructorName":"TopologicalOrderIterator","constructorQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator","constructorQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator(org.jgrapht.DirectedGraph<V, E>, java.util.Queue<V>, java.util.Map<V, org.jgrapht.util.ModifiableInteger>)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> dg","parameterName":"dg"},{"parameterType":"Queue<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Queue, typeParametersMap=TypeParametersMap{nameToValue={java.util.Queue.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Queue<V>","parameter":"Queue<V> queue","parameterName":"queue"},{"parameterType":"Map<V, ModifiableInteger>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.util.ModifiableInteger, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.util.ModifiableInteger>","parameter":"Map<V, ModifiableInteger> inDegreeMap","parameterName":"inDegreeMap"}],"literalExprs":[],"constructorTokenRange":"private TopologicalOrderIterator(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        this(dg, initialize(dg, queue, inDegreeMap));\n        this.queue = queue;\n        this.inDegreeMap = inDegreeMap;\n\n        \/\/ empty queue for non-empty graph would indicate presence of\n        \/\/ cycles (no roots found)\n        assert dg.vertexSet().isEmpty() || !queue.isEmpty();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 114,col 5)-(line 126,col 5)","constructorJavadocComment":" needs to know the start vertex in its constructor","constructorDeclaration":"private TopologicalOrderIterator(DirectedGraph<V, E> dg, Queue<V> queue, Map<V, ModifiableInteger> inDegreeMap)","constructorBody":"{\n    this(dg, initialize(dg, queue, inDegreeMap));\n    this.queue = queue;\n    this.inDegreeMap = inDegreeMap;\n    assert dg.vertexSet().isEmpty() || !queue.isEmpty();\n}","constructorJavadoc":""},{"constructorName":"TopologicalOrderIterator","constructorQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator","constructorQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.TopologicalOrderIterator(org.jgrapht.DirectedGraph<V, E>, V)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> dg","parameterName":"dg"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V start","parameterName":"start"}],"literalExprs":[],"constructorTokenRange":"private TopologicalOrderIterator(DirectedGraph<V, E> dg, V start)\n    {\n        super(dg, start);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 130,col 5)-(line 133,col 5)","constructorJavadocComment":" middle\" doesn't make sense.","constructorDeclaration":"private TopologicalOrderIterator(DirectedGraph<V, E> dg, V start)","constructorBody":"{\n    super(dg, start);\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 228,col 5)-(line 264,col 5)","classOrInterfaceTokenRange":"private static class LinkedListQueue<T>\n        extends LinkedList<T>\n        implements Queue<T>\n    {\n        private static final long serialVersionUID = 4217659843476891334L;\n\n        @Override public T element()\n        {\n            return getFirst();\n        }\n\n        @Override public boolean offer(T o)\n        {\n            return add(o);\n        }\n\n        @Override public T peek()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return getFirst();\n        }\n\n        @Override public T poll()\n        {\n            if (isEmpty()) {\n                return null;\n            }\n            return removeFirst();\n        }\n\n        @Override public T remove()\n        {\n            return removeFirst();\n        }\n    }","classOrInterfaceJavadocComment":" top-level in org.jgrapht.util if anyone else needs it.","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#isConnectedComponentExhausted()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean isConnectedComponentExhausted()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return queue.isEmpty();\n}","methodRange":"(line 138,col 5)-(line 145,col 5)","methodTokenRange":"@Override protected boolean isConnectedComponentExhausted()\n    {\n        \/\/ FIXME jvs 25-Apr-2005: This isn't correct for a graph with more than\n        \/\/ one component.  We will actually exhaust a connected component\n        \/\/ before the queue is empty, because initialize adds roots from all\n        \/\/ components to the queue.\n        return queue.isEmpty();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     ","methodParameters":[],"methodName":"isConnectedComponentExhausted","methodQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.isConnectedComponentExhausted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.isConnectedComponentExhausted()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertex(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertex(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    putSeenData(vertex, null);\n    decrementInDegree(vertex);\n}","methodRange":"(line 150,col 5)-(line 154,col 5)","methodTokenRange":"@Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, null);\n        decrementInDegree(vertex);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertex","methodQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.encounterVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 152,col 29)-(line 152,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.encounterVertex(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertexAgain(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertexAgain(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertexAgain(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    decrementInDegree(vertex);\n}","methodRange":"(line 159,col 5)-(line 162,col 5)","methodTokenRange":"@Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        decrementInDegree(vertex);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertexAgain","methodQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.encounterVertexAgain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertexAgain(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.encounterVertexAgain(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#provideNextVertex()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected V provideNextVertex()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return queue.remove();\n}","methodRange":"(line 167,col 5)-(line 170,col 5)","methodTokenRange":"@Override protected V provideNextVertex()\n    {\n        return queue.remove();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see CrossComponentIterator#provideNextVertex()\n     ","methodParameters":[],"methodName":"provideNextVertex","methodQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.provideNextVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.provideNextVertex()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose in-degree will be decremented.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose in-degree will be decremented.'}]}', name=Optional[vertex]}"}],"methodDeclaration":"private void decrementInDegree(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    ModifiableInteger inDegree = inDegreeMap.get(vertex);\n    if (inDegree.value > 0) {\n        inDegree.value--;\n        if (inDegree.value == 0) {\n            queue.offer(vertex);\n        }\n    }\n}","methodRange":"(line 177,col 5)-(line 188,col 5)","methodTokenRange":"private void decrementInDegree(V vertex)\n    {\n        ModifiableInteger inDegree = inDegreeMap.get(vertex);\n\n        if (inDegree.value > 0) {\n            inDegree.value--;\n\n            if (inDegree.value == 0) {\n                queue.offer(vertex);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Decrements the in-degree of a vertex.\n     *\n     * @param vertex the vertex whose in-degree will be decremented.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"decrementInDegree","methodQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.decrementInDegree","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Decrements the in-degree of a vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose in-degree will be decremented.'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 181,col 30)-(line 181,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 184,col 35)-(line 184,col 35)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.decrementInDegree(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the directed graph to be iterated.","javadocBlockTagName":"dg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph to be iterated.'}]}', name=Optional[dg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"initializer for queue","javadocBlockTagName":"queue","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initializer for queue'}]}', name=Optional[queue]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"initializer for inDegreeMap","javadocBlockTagName":"inDegreeMap","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initializer for inDegreeMap'}]}', name=Optional[inDegreeMap]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"start vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"private static V initialize(DirectedGraph<V, E> dg, Queue<V> queue, Map<V, ModifiableInteger> inDegreeMap)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (Iterator<V> i = dg.vertexSet().iterator(); i.hasNext(); ) {\n        V vertex = i.next();\n        int inDegree = dg.inDegreeOf(vertex);\n        inDegreeMap.put(vertex, new ModifiableInteger(inDegree));\n        if (inDegree == 0) {\n            queue.offer(vertex);\n        }\n    }\n    if (queue.isEmpty()) {\n        return null;\n    } else {\n        return queue.peek();\n    }\n}","methodRange":"(line 201,col 5)-(line 222,col 5)","methodTokenRange":"private static <V, E> V initialize(\n        DirectedGraph<V, E> dg,\n        Queue<V> queue,\n        Map<V, ModifiableInteger> inDegreeMap)\n    {\n        for (Iterator<V> i = dg.vertexSet().iterator(); i.hasNext();) {\n            V vertex = i.next();\n\n            int inDegree = dg.inDegreeOf(vertex);\n            inDegreeMap.put(vertex, new ModifiableInteger(inDegree));\n\n            if (inDegree == 0) {\n                queue.offer(vertex);\n            }\n        }\n\n        if (queue.isEmpty()) {\n            return null;\n        } else {\n            return queue.peek();\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Initializes the internal traversal object structure. Sets up the internal\n     * queue with the directed graph vertices and creates the control structure\n     * for the in-degrees.\n     *\n     * @param dg the directed graph to be iterated.\n     * @param queue initializer for queue\n     * @param inDegreeMap initializer for inDegreeMap\n     *\n     * @return start vertex\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> dg","parameterName":"dg"},{"parameterType":"Queue<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Queue, typeParametersMap=TypeParametersMap{nameToValue={java.util.Queue.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Queue<V>","parameter":"Queue<V> queue","parameterName":"queue"},{"parameterType":"Map<V, ModifiableInteger>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.util.ModifiableInteger, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.util.ModifiableInteger>","parameter":"Map<V, ModifiableInteger> inDegreeMap","parameterName":"inDegreeMap"}],"methodName":"initialize","methodQualifiedSignature":"org.jgrapht.traverse.TopologicalOrderIterator.initialize","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the internal traversal object structure. Sets up the internal\nqueue with the directed graph vertices and creates the control structure\nfor the in-degrees.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph to be iterated.'}]}', name=Optional[dg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initializer for queue'}]}', name=Optional[queue]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initializer for inDegreeMap'}]}', name=Optional[inDegreeMap]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 212,col 29)-(line 212,col 29)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 218,col 20)-(line 218,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.TopologicalOrderIterator.initialize(org.jgrapht.DirectedGraph<V, E>, java.util.Queue<V>, java.util.Map<V, org.jgrapht.util.ModifiableInteger>)"}],"classJavadoc":"\/**\n * Implements topological order traversal for a directed acyclic graph. A\n * topological sort is a permutation <tt>p<\/tt> of the vertices of a graph such\n * that an edge <tt>(i,j)<\/tt> implies that <tt>i<\/tt> appears before <tt>j<\/tt>\n * in <tt>p<\/tt> (Skiena 1990, p. 208). See also <a\n * href=\"http:\/\/mathworld.wolfram.com\/TopologicalSort.html\">\n * http:\/\/mathworld.wolfram.com\/TopologicalSort.html<\/a>.\n *\n * <p>See \"Algorithms in Java, Third Edition, Part 5: Graph Algorithms\" by\n * Robert Sedgewick and \"Data Structures and Algorithms with Object-Oriented\n * Design Patterns in Java\" by Bruno R. Preiss for implementation alternatives.\n * The latter can be found online at <a\n * href=\"http:\/\/www.brpreiss.com\/books\/opus5\/\">\n * http:\/\/www.brpreiss.com\/books\/opus5\/<\/a><\/p>\n *\n * <p>For this iterator to work correctly the graph must be acyclic, and must\n * not be modified during iteration. Currently there are no means to ensure\n * that, nor to fail-fast; the results with cyclic input (including self-loops)\n * or concurrent modifications are undefined. To precheck a graph for cycles,\n * consider using {@link org.jgrapht.alg.CycleDetector} or {@link\n * KosarajuStrongConnectivityInspector}.<\/p>\n *\n * @author Marden Neubert\n * @since Dec 18, 2004\n *\/\n","className":"TopologicalOrderIterator","fields":[{"fieldRange":"(line 76,col 5)-(line 76,col 27)","fieldName":"queue","fieldJavadocComment":"","fieldTokenRange":"private Queue<V> queue;","fieldTypeResolved":"ReferenceType{java.util.Queue, typeParametersMap=TypeParametersMap{nameToValue={java.util.Queue.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Queue<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Queue<V>"},{"fieldRange":"(line 77,col 5)-(line 77,col 50)","fieldName":"inDegreeMap","fieldJavadocComment":"","fieldTokenRange":"private Map<V, ModifiableInteger> inDegreeMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.util.ModifiableInteger, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, ModifiableInteger>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.util.ModifiableInteger>"}]}],"sourceFileId":112,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.traverse.CrossComponentIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.event.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex iteration to be started.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if <code>g==null<\/code> or does not\ncontain <code>startVertex<\/code>","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>g==null<\/code> or does not\ncontain <code>startVertex<\/code>'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.CrossComponentIterator(org.jgrapht.Graph<V, E>, V)","variableDeclarationExprs":[],"constructorRange":"(line 133,col 5)-(line 162,col 5)","constructorJavadocComment":"\n     * Creates a new iterator for the specified graph. Iteration will start at\n     * the specified start vertex. If the specified start vertex is <code>\n     * null<\/code>, Iteration will start at an arbitrary graph vertex.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     *\n     * @throws IllegalArgumentException if <code>g==null<\/code> or does not\n     * contain <code>startVertex<\/code>\n     ","constructorDeclaration":"public CrossComponentIterator(Graph<V, E> g, V startVertex)","constructorBody":"{\n    super();\n    if (g == null) {\n        throw new IllegalArgumentException(\"graph must not be null\");\n    }\n    graph = g;\n    specifics = createGraphSpecifics(g);\n    vertexIterator = g.vertexSet().iterator();\n    setCrossComponentTraversal(startVertex == null);\n    reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n    reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n    if (startVertex == null) {\n        if (vertexIterator.hasNext()) {\n            this.startVertex = vertexIterator.next();\n        } else {\n            this.startVertex = null;\n        }\n    } else if (g.containsVertex(startVertex)) {\n        this.startVertex = startVertex;\n    } else {\n        throw new IllegalArgumentException(\"graph must contain the start vertex\");\n    }\n}","constructorName":"CrossComponentIterator","constructorQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.CrossComponentIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"literalExprs":[{"literalExprRange":"(line 137,col 18)-(line 137,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 138,col 48)-(line 138,col 71)","literalExprId":2,"literalExpr":"\"graph must not be null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 144,col 51)-(line 144,col 54)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 146,col 64)-(line 146,col 67)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 147,col 65)-(line 147,col 68)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 149,col 28)-(line 149,col 31)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 154,col 36)-(line 154,col 39)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 160,col 17)-(line 160,col 53)","literalExprId":8,"literalExpr":"\"graph must contain the start vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public CrossComponentIterator(Graph<V, E> g, V startVertex)\n    {\n        super();\n\n        if (g == null) {\n            throw new IllegalArgumentException(\"graph must not be null\");\n        }\n        graph = g;\n\n        specifics = createGraphSpecifics(g);\n        vertexIterator = g.vertexSet().iterator();\n        setCrossComponentTraversal(startVertex == null);\n\n        reusableEdgeEvent = new FlyweightEdgeEvent<V, E>(this, null);\n        reusableVertexEvent = new FlyweightVertexEvent<V>(this, null);\n\n        if (startVertex == null) {\n            \/\/ pick a start vertex if graph not empty\n            if (vertexIterator.hasNext()) {\n                this.startVertex = vertexIterator.next();\n            } else {\n                this.startVertex = null;\n            }\n        } else if (g.containsVertex(startVertex)) {\n            this.startVertex = startVertex;\n        } else {\n            throw new IllegalArgumentException(\n                \"graph must contain the start vertex\");\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new iterator for the specified graph. Iteration will start at\nthe specified start vertex. If the specified start vertex is <code>\nnull<\/code>, Iteration will start at an arbitrary graph vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>g==null<\/code> or does not\ncontain <code>startVertex<\/code>'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 393,col 5)-(line 415,col 5)","classOrInterfaceTokenRange":"static interface SimpleContainer<T>\n    {\n        \/**\n         * Tests if this container is empty.\n         *\n         * @return <code>true<\/code> if empty, otherwise <code>false<\/code>.\n         *\/\n        public boolean isEmpty();\n\n        \/**\n         * Adds the specified object to this container.\n         *\n         * @param o the object to be added.\n         *\/\n        public void add(T o);\n\n        \/**\n         * Remove an object from this container and return it.\n         *\n         * @return the object removed from this container.\n         *\/\n        public T remove();\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 421,col 5)-(line 435,col 5)","classOrInterfaceTokenRange":"abstract static class Specifics<VV, EE>\n    {\n        \/**\n         * Returns the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         *\n         * @param vertex the vertex whose outgoing edges are to be returned.\n         *\n         * @return the edges outgoing from the specified vertex in case of\n         * directed graph, and the edge touching the specified vertex in case of\n         * undirected graph.\n         *\/\n        public abstract Set<? extends EE> edgesOf(VV vertex);\n    }","classOrInterfaceJavadocComment":"\n     * Provides unified interface for operations that are different in directed\n     * graphs and in undirected graphs.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Provides unified interface for operations that are different in directed\ngraphs and in undirected graphs.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 443,col 5)-(line 465,col 5)","classOrInterfaceTokenRange":"static class FlyweightEdgeEvent<VV, localE>\n        extends EdgeTraversalEvent<VV, localE>\n    {\n        private static final long serialVersionUID = 4051327833765000755L;\n\n        \/**\n         * @see EdgeTraversalEvent#EdgeTraversalEvent(Object, Edge)\n         *\/\n        public FlyweightEdgeEvent(Object eventSource, localE edge)\n        {\n            super(eventSource, edge);\n        }\n\n        \/**\n         * Sets the edge of this event.\n         *\n         * @param edge the edge to be set.\n         *\/\n        protected void setEdge(localE edge)\n        {\n            this.edge = edge;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A reusable edge event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A reusable edge event.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 11, 2003'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 473,col 5)-(line 495,col 5)","classOrInterfaceTokenRange":"static class FlyweightVertexEvent<VV>\n        extends VertexTraversalEvent<VV>\n    {\n        private static final long serialVersionUID = 3834024753848399924L;\n\n        \/**\n         * @see VertexTraversalEvent#VertexTraversalEvent(Object, Object)\n         *\/\n        public FlyweightVertexEvent(Object eventSource, VV vertex)\n        {\n            super(eventSource, vertex);\n        }\n\n        \/**\n         * Sets the vertex of this event.\n         *\n         * @param vertex the vertex to be set.\n         *\/\n        protected void setVertex(VV vertex)\n        {\n            this.vertex = vertex;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A reusable vertex event.\n     *\n     * @author Barak Naveh\n     * @since Aug 11, 2003\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A reusable vertex event.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 11, 2003'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 500,col 5)-(line 522,col 5)","classOrInterfaceTokenRange":"private static class DirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private DirectedGraph<VV, EE> graph;\n\n        \/**\n         * Creates a new DirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         *\/\n        public DirectedSpecifics(DirectedGraph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        \/**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         *\/\n        @Override public Set<? extends EE> edgesOf(VV vertex)\n        {\n            return graph.outgoingEdgesOf(vertex);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * An implementation of {@link Specifics} for a directed graph.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An implementation of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Specifics'}, JavadocSnippet{text=' for a directed graph.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 528,col 5)-(line 550,col 5)","classOrInterfaceTokenRange":"private static class UndirectedSpecifics<VV, EE>\n        extends Specifics<VV, EE>\n    {\n        private Graph<VV, EE> graph;\n\n        \/**\n         * Creates a new UndirectedSpecifics object.\n         *\n         * @param g the graph for which this specifics object to be created.\n         *\/\n        public UndirectedSpecifics(Graph<VV, EE> g)\n        {\n            graph = g;\n        }\n\n        \/**\n         * @see CrossComponentIterator.Specifics#edgesOf(Object)\n         *\/\n        @Override public Set<EE> edgesOf(VV vertex)\n        {\n            return graph.edgesOf(vertex);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * An implementation of {@link Specifics} in which edge direction (if any)\n     * is ignored.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An implementation of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Specifics'}, JavadocSnippet{text=' in which edge direction (if any)\nis ignored.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the graph being traversed","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph being traversed'}]}', name=Optional.empty}"}],"methodDeclaration":"public Graph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 167,col 5)-(line 170,col 5)","methodTokenRange":"public Graph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @return the graph being traversed\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph being traversed'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"Graph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Iterator#hasNext()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#hasNext()'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (startVertex != null) {\n        encounterStartVertex();\n    }\n    if (isConnectedComponentExhausted()) {\n        if (state == CCS_WITHIN_COMPONENT) {\n            state = CCS_AFTER_COMPONENT;\n            if (nListeners != 0) {\n                fireConnectedComponentFinished(ccFinishedEvent);\n            }\n        }\n        if (isCrossComponentTraversal()) {\n            while (vertexIterator.hasNext()) {\n                V v = vertexIterator.next();\n                if (!isSeenVertex(v)) {\n                    encounterVertex(v, null);\n                    state = CCS_BEFORE_COMPONENT;\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}","methodRange":"(line 175,col 5)-(line 208,col 5)","methodTokenRange":"@Override public boolean hasNext()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (isConnectedComponentExhausted()) {\n            if (state == CCS_WITHIN_COMPONENT) {\n                state = CCS_AFTER_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentFinished(ccFinishedEvent);\n                }\n            }\n\n            if (isCrossComponentTraversal()) {\n                while (vertexIterator.hasNext()) {\n                    V v = vertexIterator.next();\n\n                    if (!isSeenVertex(v)) {\n                        encounterVertex(v, null);\n                        state = CCS_BEFORE_COMPONENT;\n\n                        return true;\n                    }\n                }\n\n                return false;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see java.util.Iterator#hasNext()\n     ","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.hasNext","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#hasNext()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 177,col 28)-(line 177,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 184,col 35)-(line 184,col 35)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 44)-(line 194,col 47)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 197,col 32)-(line 197,col 35)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 201,col 24)-(line 201,col 28)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 203,col 24)-(line 203,col 28)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 206,col 20)-(line 206,col 23)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.hasNext()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Iterator#next()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#next()'}]}', name=Optional.empty}"}],"methodDeclaration":"public V next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (startVertex != null) {\n        encounterStartVertex();\n    }\n    if (hasNext()) {\n        if (state == CCS_BEFORE_COMPONENT) {\n            state = CCS_WITHIN_COMPONENT;\n            if (nListeners != 0) {\n                fireConnectedComponentStarted(ccStartedEvent);\n            }\n        }\n        V nextVertex = provideNextVertex();\n        if (nListeners != 0) {\n            fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n        }\n        addUnseenChildrenOf(nextVertex);\n        return nextVertex;\n    } else {\n        throw new NoSuchElementException();\n    }\n}","methodRange":"(line 213,col 5)-(line 238,col 5)","methodTokenRange":"@Override public V next()\n    {\n        if (startVertex != null) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            if (state == CCS_BEFORE_COMPONENT) {\n                state = CCS_WITHIN_COMPONENT;\n                if (nListeners != 0) {\n                    fireConnectedComponentStarted(ccStartedEvent);\n                }\n            }\n\n            V nextVertex = provideNextVertex();\n            if (nListeners != 0) {\n                fireVertexTraversed(createVertexTraversalEvent(nextVertex));\n            }\n\n            addUnseenChildrenOf(nextVertex);\n\n            return nextVertex;\n        } else {\n            throw new NoSuchElementException();\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see java.util.Iterator#next()\n     ","methodParameters":[],"methodName":"next","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.next","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#next()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 215,col 28)-(line 215,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 222,col 35)-(line 222,col 35)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 228,col 31)-(line 228,col 31)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.next()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if there are no more uniterated vertices in the\ncurrently iterated connected component; <tt>false<\/tt> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if there are no more uniterated vertices in the\ncurrently iterated connected component; <tt>false<\/tt> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected abstract boolean isConnectedComponentExhausted()","methodAccessSpecifier":"PROTECTED","methodBody":"","methodRange":"(line 247,col 5)-(line 247,col 63)","methodTokenRange":"protected abstract boolean isConnectedComponentExhausted();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <tt>true<\/tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false<\/tt> otherwise.\n     *\n     * @return <tt>true<\/tt> if there are no more uniterated vertices in the\n     * currently iterated connected component; <tt>false<\/tt> otherwise.\n     ","methodParameters":[],"methodName":"isConnectedComponentExhausted","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.isConnectedComponentExhausted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <tt>true<\/tt> if there are no more uniterated vertices in the\ncurrently iterated connected component; <tt>false<\/tt> otherwise.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if there are no more uniterated vertices in the\ncurrently iterated connected component; <tt>false<\/tt> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.isConnectedComponentExhausted()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex encountered","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex encountered'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered, or null if the\nvertex is a starting point","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered, or null if the\nvertex is a starting point'}]}', name=Optional[edge]}"}],"methodDeclaration":"protected abstract void encounterVertex(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"","methodRange":"(line 256,col 5)-(line 256,col 62)","methodTokenRange":"protected abstract void encounterVertex(V vertex, E edge);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Update data structures the first time we see a vertex.\n     *\n     * @param vertex the vertex encountered\n     * @param edge the edge via which the vertex was encountered, or null if the\n     * vertex is a starting point\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertex","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.encounterVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Update data structures the first time we see a vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex encountered'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered, or null if the\nvertex is a starting point'}]}', name=Optional[edge]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.encounterVertex(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the next vertex to be returned by this iterator.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next vertex to be returned by this iterator.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected abstract V provideNextVertex()","methodAccessSpecifier":"PROTECTED","methodBody":"","methodRange":"(line 264,col 5)-(line 264,col 45)","methodTokenRange":"protected abstract V provideNextVertex();","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the vertex to be returned in the following call to the iterator\n     * <code>next<\/code> method.\n     *\n     * @return the next vertex to be returned by this iterator.\n     ","methodParameters":[],"methodName":"provideNextVertex","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.provideNextVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the vertex to be returned in the following call to the iterator\n<code>next<\/code> method.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next vertex to be returned by this iterator.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.provideNextVertex()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has already been seen.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has already been seen.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex. A <code>null<\/code> return can also\nindicate that the vertex was explicitly associated with <code>\nnull<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex. A <code>null<\/code> return can also\nindicate that the vertex was explicitly associated with <code>\nnull<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected D getSeenData(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return seen.get(vertex);\n}","methodRange":"(line 276,col 5)-(line 279,col 5)","methodTokenRange":"protected D getSeenData(V vertex)\n    {\n        return seen.get(vertex);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(D, bounds=[])}","methodJavadocComment":"\n     * Access the data stored for a seen vertex.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null<\/code> if no\n     * data was associated with the vertex. A <code>null<\/code> return can also\n     * indicate that the vertex was explicitly associated with <code>\n     * null<\/code>.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getSeenData","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.getSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Access the data stored for a seen vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has already been seen.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex. A <code>null<\/code> return can also\nindicate that the vertex was explicitly associated with <code>\nnull<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"D","methodType":"D","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.getSeenData(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in question","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in question'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if vertex has already been seen","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if vertex has already been seen'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean isSeenVertex(Object vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return seen.containsKey(vertex);\n}","methodRange":"(line 288,col 5)-(line 291,col 5)","methodTokenRange":"protected boolean isSeenVertex(Object vertex)\n    {\n        return seen.containsKey(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question\n     *\n     * @return <tt>true<\/tt> if vertex has already been seen\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object vertex","parameterName":"vertex"}],"methodName":"isSeenVertex","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.isSeenVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determines whether a vertex has been seen yet by this traversal.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in question'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if vertex has already been seen'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.isSeenVertex(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex re-encountered","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex re-encountered'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was re-encountered","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was re-encountered'}]}', name=Optional[edge]}"}],"methodDeclaration":"protected abstract void encounterVertexAgain(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"","methodRange":"(line 300,col 5)-(line 300,col 67)","methodTokenRange":"protected abstract void encounterVertexAgain(V vertex, E edge);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called whenever we re-encounter a vertex. The default implementation does\n     * nothing.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertexAgain","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.encounterVertexAgain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called whenever we re-encounter a vertex. The default implementation does\nnothing.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex re-encountered'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was re-encountered'}]}', name=Optional[edge]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.encounterVertexAgain(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has been seen.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has been seen.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"data to be associated with the seen vertex.","javadocBlockTagName":"data","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='data to be associated with the seen vertex.'}]}', name=Optional[data]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"previous value associated with specified vertex or <code>\nnull<\/code> if no data was associated with the vertex. A <code>\nnull<\/code> return can also indicate that the vertex was explicitly\nassociated with <code>null<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified vertex or <code>\nnull<\/code> if no data was associated with the vertex. A <code>\nnull<\/code> return can also indicate that the vertex was explicitly\nassociated with <code>null<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected D putSeenData(V vertex, D data)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return seen.put(vertex, data);\n}","methodRange":"(line 313,col 5)-(line 316,col 5)","methodTokenRange":"protected D putSeenData(V vertex, D data)\n    {\n        return seen.put(vertex, data);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(D, bounds=[])}","methodJavadocComment":"\n     * Stores iterator-dependent data for a vertex that has been seen.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null<\/code> if no data was associated with the vertex. A <code>\n     * null<\/code> return can also indicate that the vertex was explicitly\n     * associated with <code>null<\/code>.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"D","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(D, bounds=[])}","parameterTypeResolvedDescribed":"D","parameter":"D data","parameterName":"data"}],"methodName":"putSeenData","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.putSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Stores iterator-dependent data for a vertex that has been seen.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has been seen.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='data to be associated with the seen vertex.'}]}', name=Optional[data]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified vertex or <code>\nnull<\/code> if no data was associated with the vertex. A <code>\nnull<\/code> return can also indicate that the vertex was explicitly\nassociated with <code>null<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"D","methodType":"D","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.putSeenData(V, D)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex which has been finished","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex which has been finished'}]}', name=Optional[vertex]}"}],"methodDeclaration":"protected void finishVertex(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (nListeners != 0) {\n        fireVertexFinished(createVertexTraversalEvent(vertex));\n    }\n}","methodRange":"(line 324,col 5)-(line 329,col 5)","methodTokenRange":"protected void finishVertex(V vertex)\n    {\n        if (nListeners != 0) {\n            fireVertexFinished(createVertexTraversalEvent(vertex));\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called when a vertex has been finished (meaning is dependent on traversal\n     * represented by subclass).\n     *\n     * @param vertex vertex which has been finished\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"finishVertex","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.finishVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called when a vertex has been finished (meaning is dependent on traversal\nrepresented by subclass).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex which has been finished'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 326,col 27)-(line 326,col 27)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.finishVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"<V>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<V>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"<E>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<E>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"TODO Document me","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='TODO Document me'}]}', name=Optional.empty}"}],"methodDeclaration":" static Specifics<V, E> createGraphSpecifics(Graph<V, E> g)","methodAccessSpecifier":"NONE","methodBody":"{\n    if (g instanceof DirectedGraph<?, ?>) {\n        return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n    } else {\n        return new UndirectedSpecifics<V, E>(g);\n    }\n}","methodRange":"(line 339,col 5)-(line 346,col 5)","methodTokenRange":"static <V, E> Specifics<V, E> createGraphSpecifics(Graph<V, E> g)\n    {\n        if (g instanceof DirectedGraph<?, ?>) {\n            return new DirectedSpecifics<V, E>((DirectedGraph<V, E>) g);\n        } else {\n            return new UndirectedSpecifics<V, E>(g);\n        }\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.traverse.CrossComponentIterator.Specifics, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.CrossComponentIterator.Specifics.VV=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.traverse.CrossComponentIterator.Specifics.EE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @param <V>\n     * @param <E>\n     * @param g\n     *\n     * @return TODO Document me\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"createGraphSpecifics","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.createGraphSpecifics","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<V>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<E>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='TODO Document me'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.traverse.CrossComponentIterator.Specifics<V, E>","methodType":"Specifics<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.createGraphSpecifics(org.jgrapht.Graph<V, E>)"},{"methodDeclaration":"private void addUnseenChildrenOf(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (E edge : specifics.edgesOf(vertex)) {\n        if (nListeners != 0) {\n            fireEdgeTraversed(createEdgeTraversalEvent(edge));\n        }\n        V oppositeV = Graphs.getOppositeVertex(graph, edge, vertex);\n        if (isSeenVertex(oppositeV)) {\n            encounterVertexAgain(oppositeV, edge);\n        } else {\n            encounterVertex(oppositeV, edge);\n        }\n    }\n}","methodRange":"(line 348,col 5)-(line 363,col 5)","methodTokenRange":"private void addUnseenChildrenOf(V vertex)\n    {\n        for (E edge : specifics.edgesOf(vertex)) {\n            if (nListeners != 0) {\n                fireEdgeTraversed(createEdgeTraversalEvent(edge));\n            }\n\n            V oppositeV = Graphs.getOppositeVertex(graph, edge, vertex);\n\n            if (isSeenVertex(oppositeV)) {\n                encounterVertexAgain(oppositeV, edge);\n            } else {\n                encounterVertex(oppositeV, edge);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"addUnseenChildrenOf","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.addUnseenChildrenOf","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 351,col 31)-(line 351,col 31)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.addUnseenChildrenOf(V)"},{"methodDeclaration":"private EdgeTraversalEvent<V, E> createEdgeTraversalEvent(E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (isReuseEvents()) {\n        reusableEdgeEvent.setEdge(edge);\n        return reusableEdgeEvent;\n    } else {\n        return new EdgeTraversalEvent<V, E>(this, edge);\n    }\n}","methodRange":"(line 365,col 5)-(line 374,col 5)","methodTokenRange":"private EdgeTraversalEvent<V, E> createEdgeTraversalEvent(E edge)\n    {\n        if (isReuseEvents()) {\n            reusableEdgeEvent.setEdge(edge);\n\n            return reusableEdgeEvent;\n        } else {\n            return new EdgeTraversalEvent<V, E>(this, edge);\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"createEdgeTraversalEvent","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.createEdgeTraversalEvent","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"EdgeTraversalEvent<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.createEdgeTraversalEvent(E)"},{"methodDeclaration":"private VertexTraversalEvent<V> createVertexTraversalEvent(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (isReuseEvents()) {\n        reusableVertexEvent.setVertex(vertex);\n        return reusableVertexEvent;\n    } else {\n        return new VertexTraversalEvent<V>(this, vertex);\n    }\n}","methodRange":"(line 376,col 5)-(line 385,col 5)","methodTokenRange":"private VertexTraversalEvent<V> createVertexTraversalEvent(V vertex)\n    {\n        if (isReuseEvents()) {\n            reusableVertexEvent.setVertex(vertex);\n\n            return reusableVertexEvent;\n        } else {\n            return new VertexTraversalEvent<V>(this, vertex);\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"createVertexTraversalEvent","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.createVertexTraversalEvent","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"VertexTraversalEvent<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.createVertexTraversalEvent(V)"},{"methodDeclaration":"private void encounterStartVertex()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    encounterVertex(startVertex, null);\n    startVertex = null;\n}","methodRange":"(line 387,col 5)-(line 391,col 5)","methodTokenRange":"private void encounterStartVertex()\n    {\n        encounterVertex(startVertex, null);\n        startVertex = null;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"encounterStartVertex","methodQualifiedSignature":"org.jgrapht.traverse.CrossComponentIterator.encounterStartVertex","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 389,col 38)-(line 389,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 390,col 23)-(line 390,col 26)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.CrossComponentIterator.encounterStartVertex()"}],"classJavadoc":"\/**\n * Provides a cross-connected-component traversal functionality for iterator\n * subclasses.\n *\n * @param <V> vertex type\n * @param <E> edge type\n * @param <D> type of data associated to seen vertices\n *\n * @author Barak Naveh\n * @since Jan 31, 2004\n *\/\n","className":"CrossComponentIterator","fields":[{"fieldRange":"(line 64,col 5)-(line 64,col 54)","fieldName":"CCS_BEFORE_COMPONENT","fieldJavadocComment":"","fieldTokenRange":"private static final int CCS_BEFORE_COMPONENT = 1;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 64,col 53)-(line 64,col 53)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[1]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 65,col 5)-(line 65,col 54)","fieldName":"CCS_WITHIN_COMPONENT","fieldJavadocComment":"","fieldTokenRange":"private static final int CCS_WITHIN_COMPONENT = 2;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 65,col 53)-(line 65,col 53)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[2]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 66,col 5)-(line 66,col 53)","fieldName":"CCS_AFTER_COMPONENT","fieldJavadocComment":"","fieldTokenRange":"private static final int CCS_AFTER_COMPONENT = 3;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 66,col 52)-(line 66,col 52)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[3]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 92,col 5)-(line 95,col 75)","fieldName":"ccFinishedEvent","fieldJavadocComment":"","fieldTokenRange":"private final ConnectedComponentTraversalEvent ccFinishedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_FINISHED);","fieldTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ConnectedComponentTraversalEvent(this, ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_FINISHED)]","fieldType":"ConnectedComponentTraversalEvent","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent"},{"fieldRange":"(line 96,col 5)-(line 99,col 74)","fieldName":"ccStartedEvent","fieldJavadocComment":"","fieldTokenRange":"private final ConnectedComponentTraversalEvent ccStartedEvent =\n        new ConnectedComponentTraversalEvent(\n            this,\n            ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_STARTED);","fieldTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ConnectedComponentTraversalEvent(this, ConnectedComponentTraversalEvent.CONNECTED_COMPONENT_STARTED)]","fieldType":"ConnectedComponentTraversalEvent","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent"},{"fieldRange":"(line 103,col 5)-(line 103,col 55)","fieldName":"reusableEdgeEvent","fieldJavadocComment":" during iteration.","fieldTokenRange":"private FlyweightEdgeEvent<V, E> reusableEdgeEvent;","fieldTypeResolved":"ReferenceType{org.jgrapht.traverse.CrossComponentIterator.FlyweightEdgeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.CrossComponentIterator.FlyweightEdgeEvent.VV=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.traverse.CrossComponentIterator.FlyweightEdgeEvent.localE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"FlyweightEdgeEvent<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.traverse.CrossComponentIterator.FlyweightEdgeEvent<V, E>"},{"fieldRange":"(line 104,col 5)-(line 104,col 56)","fieldName":"reusableVertexEvent","fieldJavadocComment":"","fieldTokenRange":"private FlyweightVertexEvent<V> reusableVertexEvent;","fieldTypeResolved":"ReferenceType{org.jgrapht.traverse.CrossComponentIterator.FlyweightVertexEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.CrossComponentIterator.FlyweightVertexEvent.VV=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"FlyweightVertexEvent<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.traverse.CrossComponentIterator.FlyweightVertexEvent<V>"},{"fieldRange":"(line 105,col 5)-(line 105,col 46)","fieldName":"vertexIterator","fieldJavadocComment":"","fieldTokenRange":"private Iterator<V> vertexIterator = null;","fieldTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 105,col 42)-(line 105,col 45)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Iterator<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Iterator<V>"},{"fieldRange":"(line 111,col 5)-(line 111,col 49)","fieldName":"seen","fieldJavadocComment":"\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     ","fieldTokenRange":"private Map<V, D> seen = new HashMap<V, D>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(D, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, D>()]","fieldType":"Map<V, D>","fieldJavadoc":"Stores the vertices that have been seen during iteration and (optionally)\nsome additional traversal info regarding each vertex.\n","fieldTypeResolvedDescribed":"java.util.Map<V, D>"},{"fieldRange":"(line 112,col 5)-(line 112,col 26)","fieldName":"startVertex","fieldJavadocComment":"","fieldTokenRange":"private V startVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 113,col 5)-(line 113,col 38)","fieldName":"specifics","fieldJavadocComment":"","fieldTokenRange":"private Specifics<V, E> specifics;","fieldTypeResolved":"ReferenceType{org.jgrapht.traverse.CrossComponentIterator.Specifics, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.CrossComponentIterator.Specifics.VV=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.traverse.CrossComponentIterator.Specifics.EE=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Specifics<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.traverse.CrossComponentIterator.Specifics<V, E>"},{"fieldRange":"(line 115,col 5)-(line 115,col 36)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 120,col 5)-(line 120,col 45)","fieldName":"state","fieldJavadocComment":"\n     * The connected component state\n     ","fieldTokenRange":"private int state = CCS_BEFORE_COMPONENT;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[CCS_BEFORE_COMPONENT]","fieldType":"int","fieldJavadoc":"The connected component state\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":113,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.traverse.AbstractGraphIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.event.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"if <code>true<\/code> traverses across\nconnected components.","javadocBlockTagName":"crossComponentTraversal","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>true<\/code> traverses across\nconnected components.'}]}', name=Optional[crossComponentTraversal]}"}],"methodDeclaration":"public void setCrossComponentTraversal(boolean crossComponentTraversal)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.crossComponentTraversal = crossComponentTraversal;\n}","methodRange":"(line 73,col 5)-(line 76,col 5)","methodTokenRange":"public void setCrossComponentTraversal(boolean crossComponentTraversal)\n    {\n        this.crossComponentTraversal = crossComponentTraversal;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Sets the cross component traversal flag - indicates whether to traverse\n     * the graph across connected components.\n     *\n     * @param crossComponentTraversal if <code>true<\/code> traverses across\n     * connected components.\n     ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean crossComponentTraversal","parameterName":"crossComponentTraversal"}],"methodName":"setCrossComponentTraversal","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.setCrossComponentTraversal","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the cross component traversal flag - indicates whether to traverse\nthe graph across connected components.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>true<\/code> traverses across\nconnected components.'}]}', name=Optional[crossComponentTraversal]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.setCrossComponentTraversal(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if traverses across connected components,\notherwise <code>false<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if traverses across connected components,\notherwise <code>false<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isCrossComponentTraversal()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return crossComponentTraversal;\n}","methodRange":"(line 85,col 5)-(line 88,col 5)","methodTokenRange":"@Override public boolean isCrossComponentTraversal()\n    {\n        return crossComponentTraversal;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Test whether this iterator is set to traverse the graph across connected\n     * components.\n     *\n     * @return <code>true<\/code> if traverses across connected components,\n     * otherwise <code>false<\/code>.\n     ","methodParameters":[],"methodName":"isCrossComponentTraversal","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.isCrossComponentTraversal","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test whether this iterator is set to traverse the graph across connected\ncomponents.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if traverses across connected components,\notherwise <code>false<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.isCrossComponentTraversal()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphIterator#setReuseEvents(boolean)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphIterator#setReuseEvents(boolean)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void setReuseEvents(boolean reuseEvents)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.reuseEvents = reuseEvents;\n}","methodRange":"(line 93,col 5)-(line 96,col 5)","methodTokenRange":"@Override public void setReuseEvents(boolean reuseEvents)\n    {\n        this.reuseEvents = reuseEvents;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphIterator#setReuseEvents(boolean)\n     ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean reuseEvents","parameterName":"reuseEvents"}],"methodName":"setReuseEvents","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.setReuseEvents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphIterator#setReuseEvents(boolean)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.setReuseEvents(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphIterator#isReuseEvents()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphIterator#isReuseEvents()'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isReuseEvents()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return reuseEvents;\n}","methodRange":"(line 101,col 5)-(line 104,col 5)","methodTokenRange":"@Override public boolean isReuseEvents()\n    {\n        return reuseEvents;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see GraphIterator#isReuseEvents()\n     ","methodParameters":[],"methodName":"isReuseEvents","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.isReuseEvents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphIterator#isReuseEvents()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.isReuseEvents()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversal listener to be added.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be added.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void addTraversalListener(TraversalListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!traversalListeners.contains(l)) {\n        traversalListeners.add(l);\n        nListeners = traversalListeners.size();\n    }\n}","methodRange":"(line 111,col 5)-(line 117,col 5)","methodTokenRange":"@Override public void addTraversalListener(TraversalListener<V, E> l)\n    {\n        if (!traversalListeners.contains(l)) {\n            traversalListeners.add(l);\n            nListeners = traversalListeners.size();\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds the specified traversal listener to this iterator.\n     *\n     * @param l the traversal listener to be added.\n     ","methodParameters":[{"parameterType":"TraversalListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.TraversalListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.TraversalListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.TraversalListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.TraversalListener<V, E>","parameter":"TraversalListener<V, E> l","parameterName":"l"}],"methodName":"addTraversalListener","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.addTraversalListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified traversal listener to this iterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be added.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.addTraversalListener(org.jgrapht.event.TraversalListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"UnsupportedOperationException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[UnsupportedOperationException]}"}],"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException();\n}","methodRange":"(line 124,col 5)-(line 127,col 5)","methodTokenRange":"@Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Unsupported.\n     *\n     * @throws UnsupportedOperationException\n     ","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Unsupported.'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[UnsupportedOperationException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.remove()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversal listener to be removed.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be removed.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void removeTraversalListener(TraversalListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    traversalListeners.remove(l);\n    nListeners = traversalListeners.size();\n}","methodRange":"(line 134,col 5)-(line 138,col 5)","methodTokenRange":"@Override public void removeTraversalListener(TraversalListener<V, E> l)\n    {\n        traversalListeners.remove(l);\n        nListeners = traversalListeners.size();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes the specified traversal listener from this iterator.\n     *\n     * @param l the traversal listener to be removed.\n     ","methodParameters":[{"parameterType":"TraversalListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.TraversalListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.TraversalListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.TraversalListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.TraversalListener<V, E>","parameter":"TraversalListener<V, E> l","parameterName":"l"}],"methodName":"removeTraversalListener","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.removeTraversalListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the specified traversal listener from this iterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be removed.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.removeTraversalListener(org.jgrapht.event.TraversalListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the connected component finished event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the connected component finished event.'}]}', name=Optional[e]}"}],"methodDeclaration":"protected void fireConnectedComponentFinished(ConnectedComponentTraversalEvent e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    for (int i = 0; i < nListeners; i++) {\n        TraversalListener<V, E> l = traversalListeners.get(i);\n        l.connectedComponentFinished(e);\n    }\n}","methodRange":"(line 146,col 5)-(line 153,col 5)","methodTokenRange":"protected void fireConnectedComponentFinished(\n        ConnectedComponentTraversalEvent e)\n    {\n        for (int i = 0; i < nListeners; i++) {\n            TraversalListener<V, E> l = traversalListeners.get(i);\n            l.connectedComponentFinished(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Informs all listeners that the traversal of the current connected\n     * component finished.\n     *\n     * @param e the connected component finished event.\n     ","methodParameters":[{"parameterType":"ConnectedComponentTraversalEvent","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent","parameter":"ConnectedComponentTraversalEvent e","parameterName":"e"}],"methodName":"fireConnectedComponentFinished","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.fireConnectedComponentFinished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Informs all listeners that the traversal of the current connected\ncomponent finished.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the connected component finished event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 149,col 22)-(line 149,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.fireConnectedComponentFinished(org.jgrapht.event.ConnectedComponentTraversalEvent)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the connected component started event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the connected component started event.'}]}', name=Optional[e]}"}],"methodDeclaration":"protected void fireConnectedComponentStarted(ConnectedComponentTraversalEvent e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    for (int i = 0; i < nListeners; i++) {\n        TraversalListener<V, E> l = traversalListeners.get(i);\n        l.connectedComponentStarted(e);\n    }\n}","methodRange":"(line 161,col 5)-(line 168,col 5)","methodTokenRange":"protected void fireConnectedComponentStarted(\n        ConnectedComponentTraversalEvent e)\n    {\n        for (int i = 0; i < nListeners; i++) {\n            TraversalListener<V, E> l = traversalListeners.get(i);\n            l.connectedComponentStarted(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Informs all listeners that a traversal of a new connected component has\n     * started.\n     *\n     * @param e the connected component started event.\n     ","methodParameters":[{"parameterType":"ConnectedComponentTraversalEvent","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent","parameter":"ConnectedComponentTraversalEvent e","parameterName":"e"}],"methodName":"fireConnectedComponentStarted","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.fireConnectedComponentStarted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Informs all listeners that a traversal of a new connected component has\nstarted.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the connected component started event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 164,col 22)-(line 164,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.fireConnectedComponentStarted(org.jgrapht.event.ConnectedComponentTraversalEvent)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"protected void fireEdgeTraversed(EdgeTraversalEvent<V, E> e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    for (int i = 0; i < nListeners; i++) {\n        TraversalListener<V, E> l = traversalListeners.get(i);\n        l.edgeTraversed(e);\n    }\n}","methodRange":"(line 175,col 5)-(line 181,col 5)","methodTokenRange":"protected void fireEdgeTraversed(EdgeTraversalEvent<V, E> e)\n    {\n        for (int i = 0; i < nListeners; i++) {\n            TraversalListener<V, E> l = traversalListeners.get(i);\n            l.edgeTraversed(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Informs all listeners that a the specified edge was visited.\n     *\n     * @param e the edge traversal event.\n     ","methodParameters":[{"parameterType":"EdgeTraversalEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.EdgeTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.EdgeTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.EdgeTraversalEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.EdgeTraversalEvent<V, E>","parameter":"EdgeTraversalEvent<V, E> e","parameterName":"e"}],"methodName":"fireEdgeTraversed","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.fireEdgeTraversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Informs all listeners that a the specified edge was visited.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 177,col 22)-(line 177,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.fireEdgeTraversed(org.jgrapht.event.EdgeTraversalEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"protected void fireVertexTraversed(VertexTraversalEvent<V> e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    for (int i = 0; i < nListeners; i++) {\n        TraversalListener<V, E> l = traversalListeners.get(i);\n        l.vertexTraversed(e);\n    }\n}","methodRange":"(line 188,col 5)-(line 194,col 5)","methodTokenRange":"protected void fireVertexTraversed(VertexTraversalEvent<V> e)\n    {\n        for (int i = 0; i < nListeners; i++) {\n            TraversalListener<V, E> l = traversalListeners.get(i);\n            l.vertexTraversed(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Informs all listeners that a the specified vertex was visited.\n     *\n     * @param e the vertex traversal event.\n     ","methodParameters":[{"parameterType":"VertexTraversalEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexTraversalEvent<V>","parameter":"VertexTraversalEvent<V> e","parameterName":"e"}],"methodName":"fireVertexTraversed","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.fireVertexTraversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Informs all listeners that a the specified vertex was visited.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 190,col 22)-(line 190,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.fireVertexTraversed(org.jgrapht.event.VertexTraversalEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"protected void fireVertexFinished(VertexTraversalEvent<V> e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    for (int i = 0; i < nListeners; i++) {\n        TraversalListener<V, E> l = traversalListeners.get(i);\n        l.vertexFinished(e);\n    }\n}","methodRange":"(line 201,col 5)-(line 207,col 5)","methodTokenRange":"protected void fireVertexFinished(VertexTraversalEvent<V> e)\n    {\n        for (int i = 0; i < nListeners; i++) {\n            TraversalListener<V, E> l = traversalListeners.get(i);\n            l.vertexFinished(e);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Informs all listeners that a the specified vertex was finished.\n     *\n     * @param e the vertex traversal event.\n     ","methodParameters":[{"parameterType":"VertexTraversalEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexTraversalEvent<V>","parameter":"VertexTraversalEvent<V> e","parameterName":"e"}],"methodName":"fireVertexFinished","methodQualifiedSignature":"org.jgrapht.traverse.AbstractGraphIterator.fireVertexFinished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Informs all listeners that a the specified vertex was finished.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 203,col 22)-(line 203,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.AbstractGraphIterator.fireVertexFinished(org.jgrapht.event.VertexTraversalEvent<V>)"}],"classJavadoc":"\/**\n * An empty implementation of a graph iterator to minimize the effort required\n * to implement graph iterators.\n *\n * @author Barak Naveh\n * @since Jul 19, 2003\n *\/\n","className":"AbstractGraphIterator","fields":[{"fieldRange":"(line 56,col 5)-(line 57,col 49)","fieldName":"traversalListeners","fieldJavadocComment":"","fieldTokenRange":"private List<TraversalListener<V, E>> traversalListeners =\n        new ArrayList<TraversalListener<V, E>>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.event.TraversalListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.TraversalListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.TraversalListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<TraversalListener<V, E>>()]","fieldType":"List<TraversalListener<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<org.jgrapht.event.TraversalListener<V, E>>"},{"fieldRange":"(line 58,col 5)-(line 58,col 51)","fieldName":"crossComponentTraversal","fieldJavadocComment":"","fieldTokenRange":"private boolean crossComponentTraversal = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 58,col 47)-(line 58,col 50)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 59,col 5)-(line 59,col 40)","fieldName":"reuseEvents","fieldJavadocComment":"","fieldTokenRange":"private boolean reuseEvents = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 59,col 35)-(line 59,col 39)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 64,col 5)-(line 64,col 33)","fieldName":"nListeners","fieldJavadocComment":" event firing calls can be skipped.","fieldTokenRange":"protected int nListeners = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[{"literalExprRange":"(line 64,col 32)-(line 64,col 32)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":114,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.traverse.ClosestFirstIterator","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"},{"importId":2,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.ClosestFirstIterator(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 82,col 5)-(line 85,col 5)","constructorJavadocComment":"\n     * Creates a new closest-first iterator for the specified graph.\n     *\n     * @param g the graph to be iterated.\n     ","constructorDeclaration":"public ClosestFirstIterator(Graph<V, E> g)","constructorBody":"{\n    this(g, null);\n}","constructorName":"ClosestFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.ClosestFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 84,col 17)-(line 84,col 20)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public ClosestFirstIterator(Graph<V, E> g)\n    {\n        this(g, null);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new closest-first iterator for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex iteration to be started.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.ClosestFirstIterator(org.jgrapht.Graph<V, E>, V)","variableDeclarationExprs":[],"constructorRange":"(line 97,col 5)-(line 100,col 5)","constructorJavadocComment":"\n     * Creates a new closest-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null<\/code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     ","constructorDeclaration":"public ClosestFirstIterator(Graph<V, E> g, V startVertex)","constructorBody":"{\n    this(g, startVertex, Double.POSITIVE_INFINITY);\n}","constructorName":"ClosestFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.ClosestFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"literalExprs":[],"constructorTokenRange":"public ClosestFirstIterator(Graph<V, E> g, V startVertex)\n    {\n        this(g, startVertex, Double.POSITIVE_INFINITY);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new closest-first iterator for the specified graph. Iteration\nwill start at the specified start vertex and will be limited to the\nconnected component that includes that vertex. If the specified start\nvertex is <code>null<\/code>, iteration will start at an arbitrary vertex\nand will not be limited, that is, will be able to traverse all the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex iteration to be started.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search.","javadocBlockTagName":"radius","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search.'}]}', name=Optional[radius]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.ClosestFirstIterator(org.jgrapht.Graph<V, E>, V, double)","variableDeclarationExprs":[],"constructorRange":"(line 115,col 5)-(line 121,col 5)","constructorJavadocComment":"\n     * Creates a new radius-bounded closest-first iterator for the specified\n     * graph. Iteration will start at the specified start vertex and will be\n     * limited to the subset of the connected component which includes that\n     * vertex and is reachable via paths of weighted length less than or equal\n     * to the specified radius. The specified start vertex may not be <code>\n     * null<\/code>.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search.\n     ","constructorDeclaration":"public ClosestFirstIterator(Graph<V, E> g, V startVertex, double radius)","constructorBody":"{\n    super(g, startVertex);\n    this.radius = radius;\n    checkRadiusTraversal(isCrossComponentTraversal());\n    initialized = true;\n}","constructorName":"ClosestFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.ClosestFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double radius","parameterName":"radius"}],"literalExprs":[{"literalExprRange":"(line 120,col 23)-(line 120,col 26)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public ClosestFirstIterator(Graph<V, E> g, V startVertex, double radius)\n    {\n        super(g, startVertex);\n        this.radius = radius;\n        checkRadiusTraversal(isCrossComponentTraversal());\n        initialized = true;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new radius-bounded closest-first iterator for the specified\ngraph. Iteration will start at the specified start vertex and will be\nlimited to the subset of the connected component which includes that\nvertex and is reachable via paths of weighted length less than or equal\nto the specified radius. The specified start vertex may not be <code>\nnull<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search.'}]}', name=Optional[radius]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 305,col 5)-(line 325,col 5)","classOrInterfaceTokenRange":"static class QueueEntry<V, E>\n    {\n        \/**\n         * Best spanning tree edge to vertex seen so far.\n         *\/\n        E spanningTreeEdge;\n\n        \/**\n         * The vertex reached.\n         *\/\n        V vertex;\n\n        \/**\n         * True once spanningTreeEdge is guaranteed to be the true minimum.\n         *\/\n        boolean frozen;\n\n        QueueEntry()\n        {\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Private data to associate with each entry in the priority queue.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private data to associate with each entry in the priority queue.'}]}, blockTags=[]}]"}],"methods":[{"methodDeclaration":"public void setCrossComponentTraversal(boolean crossComponentTraversal)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (initialized) {\n        checkRadiusTraversal(crossComponentTraversal);\n    }\n    super.setCrossComponentTraversal(crossComponentTraversal);\n}","methodRange":"(line 124,col 5)-(line 131,col 5)","methodTokenRange":"@Override public void setCrossComponentTraversal(\n        boolean crossComponentTraversal)\n    {\n        if (initialized) {\n            checkRadiusTraversal(crossComponentTraversal);\n        }\n        super.setCrossComponentTraversal(crossComponentTraversal);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" override AbstractGraphIterator","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean crossComponentTraversal","parameterName":"crossComponentTraversal"}],"methodName":"setCrossComponentTraversal","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.setCrossComponentTraversal","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.setCrossComponentTraversal(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex being sought from start vertex","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex being sought from start vertex'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"weighted length of shortest path known, or\nDouble.POSITIVE_INFINITY if no path found yet","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='weighted length of shortest path known, or\nDouble.POSITIVE_INFINITY if no path found yet'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getShortestPathLength(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return node.getKey();\n}","methodRange":"(line 143,col 5)-(line 152,col 5)","methodTokenRange":"public double getShortestPathLength(V vertex)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        return node.getKey();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Get the weighted length of the shortest path known to the given vertex.\n     * If the vertex has already been visited, then it is truly the shortest\n     * path length; otherwise, it is the best known upper bound.\n     *\n     * @param vertex vertex being sought from start vertex\n     *\n     * @return weighted length of shortest path known, or\n     * Double.POSITIVE_INFINITY if no path found yet\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getShortestPathLength","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.getShortestPathLength","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the weighted length of the shortest path known to the given vertex.\nIf the vertex has already been visited, then it is truly the shortest\npath length; otherwise, it is the best known upper bound.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex being sought from start vertex'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='weighted length of shortest path known, or\nDouble.POSITIVE_INFINITY if no path found yet'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 147,col 21)-(line 147,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.getShortestPathLength(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the spanned vertex.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the spanned vertex.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the spanning tree edge, or null if the vertex either has not been\nseen yet or is the start vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the spanning tree edge, or null if the vertex either has not been\nseen yet or is the start vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getSpanningTreeEdge(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node == null) {\n        return null;\n    }\n    return node.getData().spanningTreeEdge;\n}","methodRange":"(line 166,col 5)-(line 175,col 5)","methodTokenRange":"public E getSpanningTreeEdge(V vertex)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node == null) {\n            return null;\n        }\n\n        return node.getData().spanningTreeEdge;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Get the spanning tree edge reaching a vertex which has been seen already\n     * in this traversal. This edge is the last link in the shortest known path\n     * between the start vertex and the requested vertex. If the vertex has\n     * already been visited, then it is truly the minimum spanning tree edge;\n     * otherwise, it is the best candidate seen so far.\n     *\n     * @param vertex the spanned vertex.\n     *\n     * @return the spanning tree edge, or null if the vertex either has not been\n     * seen yet or is the start vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getSpanningTreeEdge","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.getSpanningTreeEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the spanning tree edge reaching a vertex which has been seen already\nin this traversal. This edge is the last link in the shortest known path\nbetween the start vertex and the requested vertex. If the vertex has\nalready been visited, then it is truly the minimum spanning tree edge;\notherwise, it is the best candidate seen so far.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the spanned vertex.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the spanning tree edge, or null if the vertex either has not been\nseen yet or is the start vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 170,col 21)-(line 170,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 171,col 20)-(line 171,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.getSpanningTreeEdge(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#isConnectedComponentExhausted()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean isConnectedComponentExhausted()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (heap.size() == 0) {\n        return true;\n    } else {\n        if (heap.min().getKey() > radius) {\n            heap.clear();\n            return true;\n        } else {\n            return false;\n        }\n    }\n}","methodRange":"(line 180,col 5)-(line 193,col 5)","methodTokenRange":"@Override protected boolean isConnectedComponentExhausted()\n    {\n        if (heap.size() == 0) {\n            return true;\n        } else {\n            if (heap.min().getKey() > radius) {\n                heap.clear();\n\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     ","methodParameters":[],"methodName":"isConnectedComponentExhausted","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.isConnectedComponentExhausted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 182,col 28)-(line 182,col 28)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 183,col 20)-(line 183,col 23)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 188,col 24)-(line 188,col 27)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 190,col 24)-(line 190,col 28)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.isConnectedComponentExhausted()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertex(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertex(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    double shortestPathLength;\n    if (edge == null) {\n        shortestPathLength = 0;\n    } else {\n        shortestPathLength = calculatePathLength(vertex, edge);\n    }\n    FibonacciHeapNode<QueueEntry<V, E>> node = createSeenData(vertex, edge);\n    putSeenData(vertex, node);\n    heap.insert(node, shortestPathLength);\n}","methodRange":"(line 198,col 5)-(line 209,col 5)","methodTokenRange":"@Override protected void encounterVertex(V vertex, E edge)\n    {\n        double shortestPathLength;\n        if (edge == null) {\n            shortestPathLength = 0;\n        } else {\n            shortestPathLength = calculatePathLength(vertex, edge);\n        }\n        FibonacciHeapNode<QueueEntry<V, E>> node = createSeenData(vertex, edge);\n        putSeenData(vertex, node);\n        heap.insert(node, shortestPathLength);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertex","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.encounterVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 201,col 21)-(line 201,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 202,col 34)-(line 202,col 34)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.encounterVertex(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex re-encountered","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex re-encountered'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was re-encountered","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was re-encountered'}]}', name=Optional[edge]}"}],"methodDeclaration":"protected void encounterVertexAgain(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n    if (node.getData().frozen) {\n        return;\n    }\n    double candidatePathLength = calculatePathLength(vertex, edge);\n    if (candidatePathLength < node.getKey()) {\n        node.getData().spanningTreeEdge = edge;\n        heap.decreaseKey(node, candidatePathLength);\n    }\n}","methodRange":"(line 218,col 5)-(line 233,col 5)","methodTokenRange":"@Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = getSeenData(vertex);\n\n        if (node.getData().frozen) {\n            \/\/ no improvement for this vertex possible\n            return;\n        }\n\n        double candidatePathLength = calculatePathLength(vertex, edge);\n\n        if (candidatePathLength < node.getKey()) {\n            node.getData().spanningTreeEdge = edge;\n            heap.decreaseKey(node, candidatePathLength);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Override superclass. When we see a vertex again, we need to see if the\n     * new edge provides a shorter path than the old edge.\n     *\n     * @param vertex the vertex re-encountered\n     * @param edge the edge via which the vertex was re-encountered\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertexAgain","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.encounterVertexAgain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Override superclass. When we see a vertex again, we need to see if the\nnew edge provides a shorter path than the old edge.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex re-encountered'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was re-encountered'}]}', name=Optional[edge]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.encounterVertexAgain(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#provideNextVertex()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected V provideNextVertex()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    FibonacciHeapNode<QueueEntry<V, E>> node = heap.removeMin();\n    node.getData().frozen = true;\n    return node.getData().vertex;\n}","methodRange":"(line 238,col 5)-(line 244,col 5)","methodTokenRange":"@Override protected V provideNextVertex()\n    {\n        FibonacciHeapNode<QueueEntry<V, E>> node = heap.removeMin();\n        node.getData().frozen = true;\n\n        return node.getData().vertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see CrossComponentIterator#provideNextVertex()\n     ","methodParameters":[],"methodName":"provideNextVertex","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.provideNextVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 241,col 33)-(line 241,col 36)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.provideNextVertex()"},{"methodDeclaration":"private void assertNonNegativeEdge(E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (getGraph().getEdgeWeight(edge) < 0) {\n        throw new IllegalArgumentException(\"negative edge weights not allowed\");\n    }\n}","methodRange":"(line 246,col 5)-(line 252,col 5)","methodTokenRange":"private void assertNonNegativeEdge(E edge)\n    {\n        if (getGraph().getEdgeWeight(edge) < 0) {\n            throw new IllegalArgumentException(\n                \"negative edge weights not allowed\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"assertNonNegativeEdge","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.assertNonNegativeEdge","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 248,col 46)-(line 248,col 46)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 250,col 17)-(line 250,col 51)","literalExprId":2,"literalExpr":"\"negative edge weights not allowed\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.assertNonNegativeEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex for which to calculate the path length.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which to calculate the path length.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the path is being extended.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the path is being extended.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"calculated path length.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='calculated path length.'}]}', name=Optional.empty}"}],"methodDeclaration":"private double calculatePathLength(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    assertNonNegativeEdge(edge);\n    V otherVertex = Graphs.getOppositeVertex(getGraph(), edge, vertex);\n    FibonacciHeapNode<QueueEntry<V, E>> otherEntry = getSeenData(otherVertex);\n    return otherEntry.getKey() + getGraph().getEdgeWeight(edge);\n}","methodRange":"(line 263,col 5)-(line 273,col 5)","methodTokenRange":"private double calculatePathLength(V vertex, E edge)\n    {\n        assertNonNegativeEdge(edge);\n\n        V otherVertex = Graphs.getOppositeVertex(getGraph(), edge, vertex);\n        FibonacciHeapNode<QueueEntry<V, E>> otherEntry =\n            getSeenData(otherVertex);\n\n        return otherEntry.getKey()\n            + getGraph().getEdgeWeight(edge);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Determine weighted path length to a vertex via an edge, using the path\n     * length for the opposite vertex.\n     *\n     * @param vertex the vertex for which to calculate the path length.\n     * @param edge the edge via which the path is being extended.\n     *\n     * @return calculated path length.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"calculatePathLength","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.calculatePathLength","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determine weighted path length to a vertex via an edge, using the path\nlength for the opposite vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which to calculate the path length.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the path is being extended.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='calculated path length.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.calculatePathLength(V, E)"},{"methodDeclaration":"private void checkRadiusTraversal(boolean crossComponentTraversal)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (crossComponentTraversal && (radius != Double.POSITIVE_INFINITY)) {\n        throw new IllegalArgumentException(\"radius may not be specified for cross-component traversal\");\n    }\n}","methodRange":"(line 275,col 5)-(line 281,col 5)","methodTokenRange":"private void checkRadiusTraversal(boolean crossComponentTraversal)\n    {\n        if (crossComponentTraversal && (radius != Double.POSITIVE_INFINITY)) {\n            throw new IllegalArgumentException(\n                \"radius may not be specified for cross-component traversal\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean crossComponentTraversal","parameterName":"crossComponentTraversal"}],"methodName":"checkRadiusTraversal","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.checkRadiusTraversal","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 279,col 17)-(line 279,col 75)","literalExprId":1,"literalExpr":"\"radius may not be specified for cross-component traversal\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.checkRadiusTraversal(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the new heap node.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new heap node.'}]}', name=Optional.empty}"}],"methodDeclaration":"private FibonacciHeapNode<QueueEntry<V, E>> createSeenData(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    QueueEntry<V, E> entry = new QueueEntry<V, E>();\n    entry.vertex = vertex;\n    entry.spanningTreeEdge = edge;\n    return new FibonacciHeapNode<QueueEntry<V, E>>(entry);\n}","methodRange":"(line 291,col 5)-(line 300,col 5)","methodTokenRange":"private FibonacciHeapNode<QueueEntry<V, E>> createSeenData(\n        V vertex,\n        E edge)\n    {\n        QueueEntry<V, E> entry = new QueueEntry<V, E>();\n        entry.vertex = vertex;\n        entry.spanningTreeEdge = edge;\n\n        return new FibonacciHeapNode<QueueEntry<V, E>>(entry);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * The first time we see a vertex, make up a new heap node for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the new heap node.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"createSeenData","methodQualifiedSignature":"org.jgrapht.traverse.ClosestFirstIterator.createSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The first time we see a vertex, make up a new heap node for it.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new heap node.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"FibonacciHeapNode<QueueEntry<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.ClosestFirstIterator.createSeenData(V, E)"}],"classJavadoc":"\/**\n * A closest-first iterator for a directed or undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * <p>The metric for <i>closest<\/i> here is the weighted path length from a\n * start vertex, i.e. Graph.getEdgeWeight(Edge) is summed to calculate path\n * length. Negative edge weights will result in an IllegalArgumentException.\n * Optionally, path length may be bounded by a finite radius.<\/p>\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n *\/\n","className":"ClosestFirstIterator","fields":[{"fieldRange":"(line 67,col 5)-(line 68,col 46)","fieldName":"heap","fieldJavadocComment":"\n     * Priority queue of fringe vertices.\n     ","fieldTokenRange":"private FibonacciHeap<QueueEntry<V, E>> heap =\n        new FibonacciHeap<QueueEntry<V, E>>();","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeap, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeap.T=ReferenceType{org.jgrapht.traverse.ClosestFirstIterator.QueueEntry, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.ClosestFirstIterator.QueueEntry.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.traverse.ClosestFirstIterator.QueueEntry.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new FibonacciHeap<QueueEntry<V, E>>()]","fieldType":"FibonacciHeap<QueueEntry<V, E>>","fieldJavadoc":"Priority queue of fringe vertices.\n","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeap<org.jgrapht.traverse.ClosestFirstIterator.QueueEntry<V, E>>"},{"fieldRange":"(line 73,col 5)-(line 73,col 53)","fieldName":"radius","fieldJavadocComment":"\n     * Maximum distance to search.\n     ","fieldTokenRange":"private double radius = Double.POSITIVE_INFINITY;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Double.POSITIVE_INFINITY]","fieldType":"double","fieldJavadoc":"Maximum distance to search.\n","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 75,col 5)-(line 75,col 40)","fieldName":"initialized","fieldJavadocComment":"","fieldTokenRange":"private boolean initialized = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 75,col 35)-(line 75,col 39)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":115,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.traverse.BreadthFirstIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.BreadthFirstIterator.BreadthFirstIterator(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 68,col 5)-(line 71,col 5)","constructorJavadocComment":"\n     * Creates a new breadth-first iterator for the specified graph.\n     *\n     * @param g the graph to be iterated.\n     ","constructorDeclaration":"public BreadthFirstIterator(Graph<V, E> g)","constructorBody":"{\n    this(g, null);\n}","constructorName":"BreadthFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.BreadthFirstIterator.BreadthFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 70,col 17)-(line 70,col 20)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public BreadthFirstIterator(Graph<V, E> g)\n    {\n        this(g, null);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new breadth-first iterator for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex iteration to be started.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.BreadthFirstIterator.BreadthFirstIterator(org.jgrapht.Graph<V, E>, V)","variableDeclarationExprs":[],"constructorRange":"(line 83,col 5)-(line 86,col 5)","constructorJavadocComment":"\n     * Creates a new breadth-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null<\/code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     ","constructorDeclaration":"public BreadthFirstIterator(Graph<V, E> g, V startVertex)","constructorBody":"{\n    super(g, startVertex);\n}","constructorName":"BreadthFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.BreadthFirstIterator.BreadthFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"literalExprs":[],"constructorTokenRange":"public BreadthFirstIterator(Graph<V, E> g, V startVertex)\n    {\n        super(g, startVertex);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new breadth-first iterator for the specified graph. Iteration\nwill start at the specified start vertex and will be limited to the\nconnected component that includes that vertex. If the specified start\nvertex is <code>null<\/code>, iteration will start at an arbitrary vertex\nand will not be limited, that is, will be able to traverse all the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#isConnectedComponentExhausted()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean isConnectedComponentExhausted()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return queue.isEmpty();\n}","methodRange":"(line 91,col 5)-(line 94,col 5)","methodTokenRange":"@Override protected boolean isConnectedComponentExhausted()\n    {\n        return queue.isEmpty();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     ","methodParameters":[],"methodName":"isConnectedComponentExhausted","methodQualifiedSignature":"org.jgrapht.traverse.BreadthFirstIterator.isConnectedComponentExhausted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.BreadthFirstIterator.isConnectedComponentExhausted()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertex(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertex(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    putSeenData(vertex, null);\n    queue.add(vertex);\n}","methodRange":"(line 99,col 5)-(line 103,col 5)","methodTokenRange":"@Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, null);\n        queue.add(vertex);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertex","methodQualifiedSignature":"org.jgrapht.traverse.BreadthFirstIterator.encounterVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 101,col 29)-(line 101,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.BreadthFirstIterator.encounterVertex(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertexAgain(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertexAgain(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertexAgain(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n}","methodRange":"(line 108,col 5)-(line 110,col 5)","methodTokenRange":"@Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertexAgain","methodQualifiedSignature":"org.jgrapht.traverse.BreadthFirstIterator.encounterVertexAgain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertexAgain(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.BreadthFirstIterator.encounterVertexAgain(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#provideNextVertex()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected V provideNextVertex()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return queue.removeFirst();\n}","methodRange":"(line 115,col 5)-(line 118,col 5)","methodTokenRange":"@Override protected V provideNextVertex()\n    {\n        return queue.removeFirst();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see CrossComponentIterator#provideNextVertex()\n     ","methodParameters":[],"methodName":"provideNextVertex","methodQualifiedSignature":"org.jgrapht.traverse.BreadthFirstIterator.provideNextVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.BreadthFirstIterator.provideNextVertex()"}],"classJavadoc":"\/**\n * A breadth-first iterator for a directed and an undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * @author Barak Naveh\n * @since Jul 19, 2003\n *\/\n","className":"BreadthFirstIterator","fields":[{"fieldRange":"(line 61,col 5)-(line 61,col 49)","fieldName":"queue","fieldJavadocComment":"","fieldTokenRange":"private Deque<V> queue = new ArrayDeque<V>();","fieldTypeResolved":"ReferenceType{java.util.Deque, typeParametersMap=TypeParametersMap{nameToValue={java.util.Deque.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayDeque<V>()]","fieldType":"Deque<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Deque<V>"}]}],"sourceFileId":116,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.traverse.DepthFirstIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.DepthFirstIterator(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 89,col 5)","constructorJavadocComment":"\n     * Creates a new depth-first iterator for the specified graph.\n     *\n     * @param g the graph to be iterated.\n     ","constructorDeclaration":"public DepthFirstIterator(Graph<V, E> g)","constructorBody":"{\n    this(g, null);\n}","constructorName":"DepthFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.DepthFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 88,col 17)-(line 88,col 20)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public DepthFirstIterator(Graph<V, E> g)\n    {\n        this(g, null);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new depth-first iterator for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be iterated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex iteration to be started.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}"}],"constructorQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.DepthFirstIterator(org.jgrapht.Graph<V, E>, V)","variableDeclarationExprs":[],"constructorRange":"(line 101,col 5)-(line 104,col 5)","constructorJavadocComment":"\n     * Creates a new depth-first iterator for the specified graph. Iteration\n     * will start at the specified start vertex and will be limited to the\n     * connected component that includes that vertex. If the specified start\n     * vertex is <code>null<\/code>, iteration will start at an arbitrary vertex\n     * and will not be limited, that is, will be able to traverse all the graph.\n     *\n     * @param g the graph to be iterated.\n     * @param startVertex the vertex iteration to be started.\n     ","constructorDeclaration":"public DepthFirstIterator(Graph<V, E> g, V startVertex)","constructorBody":"{\n    super(g, startVertex);\n}","constructorName":"DepthFirstIterator","constructorQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.DepthFirstIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"literalExprs":[],"constructorTokenRange":"public DepthFirstIterator(Graph<V, E> g, V startVertex)\n    {\n        super(g, startVertex);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new depth-first iterator for the specified graph. Iteration\nwill start at the specified start vertex and will be limited to the\nconnected component that includes that vertex. If the specified start\nvertex is <code>null<\/code>, iteration will start at an arbitrary vertex\nand will not be limited, that is, will be able to traverse all the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be iterated.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex iteration to be started.'}]}', name=Optional[startVertex]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#isConnectedComponentExhausted()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean isConnectedComponentExhausted()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    for (; ; ) {\n        if (stack.isEmpty()) {\n            return true;\n        }\n        if (stack.getLast() != SENTINEL) {\n            return false;\n        }\n        stack.removeLast();\n        recordFinish();\n    }\n}","methodRange":"(line 109,col 5)-(line 129,col 5)","methodTokenRange":"@Override protected boolean isConnectedComponentExhausted()\n    {\n        for (;;) {\n            if (stack.isEmpty()) {\n                return true;\n            }\n            if (stack.getLast() != SENTINEL) {\n                \/\/ Found a non-sentinel.\n                return false;\n            }\n\n            \/\/ Found a sentinel:  pop it, record the finish time,\n            \/\/ and then loop to check the rest of the stack.\n\n            \/\/ Pop null we peeked at above.\n            stack.removeLast();\n\n            \/\/ This will pop corresponding vertex to be recorded as finished.\n            recordFinish();\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @see CrossComponentIterator#isConnectedComponentExhausted()\n     ","methodParameters":[],"methodName":"isConnectedComponentExhausted","methodQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.isConnectedComponentExhausted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#isConnectedComponentExhausted()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 113,col 24)-(line 113,col 27)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 117,col 24)-(line 117,col 28)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.isConnectedComponentExhausted()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertex(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertex(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    putSeenData(vertex, VisitColor.WHITE);\n    stack.addLast(vertex);\n}","methodRange":"(line 134,col 5)-(line 138,col 5)","methodTokenRange":"@Override protected void encounterVertex(V vertex, E edge)\n    {\n        putSeenData(vertex, VisitColor.WHITE);\n        stack.addLast(vertex);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertex(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertex","methodQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.encounterVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertex(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.encounterVertex(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#encounterVertexAgain(Object, Object)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertexAgain(Object, Object)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected void encounterVertexAgain(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    VisitColor color = getSeenData(vertex);\n    if (color != VisitColor.WHITE) {\n        return;\n    }\n    boolean found = stack.removeLastOccurrence(vertex);\n    assert (found);\n    stack.addLast(vertex);\n}","methodRange":"(line 143,col 5)-(line 161,col 5)","methodTokenRange":"@Override protected void encounterVertexAgain(V vertex, E edge)\n    {\n        VisitColor color = getSeenData(vertex);\n        if (color != VisitColor.WHITE) {\n            \/\/ We've already visited this vertex; no need to mess with the\n            \/\/ stack (either it's BLACK and not there at all, or it's GRAY\n            \/\/ and therefore just a sentinel).\n            return;\n        }\n\n        \/\/ Since we've encountered it before, and it's still WHITE, it\n        \/\/ *must* be on the stack.  Use removeLastOccurrence on the\n        \/\/ assumption that for typical topologies and traversals,\n        \/\/ it's likely to be nearer the top of the stack than\n        \/\/ the bottom of the stack.\n        boolean found = stack.removeLastOccurrence(vertex);\n        assert (found);\n        stack.addLast(vertex);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see CrossComponentIterator#encounterVertexAgain(Object, Object)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"encounterVertexAgain","methodQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.encounterVertexAgain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#encounterVertexAgain(Object, Object)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.encounterVertexAgain(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"CrossComponentIterator#provideNextVertex()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}"}],"methodDeclaration":"protected V provideNextVertex()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    V v;\n    for (; ; ) {\n        Object o = stack.removeLast();\n        if (o == SENTINEL) {\n            recordFinish();\n        } else {\n            v = TypeUtil.uncheckedCast(o, vertexTypeDecl);\n            break;\n        }\n    }\n    stack.addLast(v);\n    stack.addLast(SENTINEL);\n    putSeenData(v, VisitColor.GRAY);\n    return v;\n}","methodRange":"(line 166,col 5)-(line 188,col 5)","methodTokenRange":"@Override protected V provideNextVertex()\n    {\n        V v;\n        for (;;) {\n            Object o = stack.removeLast();\n            if (o == SENTINEL) {\n                \/\/ This is a finish-time sentinel we previously pushed.\n                recordFinish();\n                \/\/ Now carry on with another pop until we find a non-sentinel\n            } else {\n                \/\/ Got a real vertex to start working on\n                v = TypeUtil.uncheckedCast(o, vertexTypeDecl);\n                break;\n            }\n        }\n\n        \/\/ Push a sentinel for v onto the stack so that we'll know\n        \/\/ when we're done with it.\n        stack.addLast(v);\n        stack.addLast(SENTINEL);\n        putSeenData(v, VisitColor.GRAY);\n        return v;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * @see CrossComponentIterator#provideNextVertex()\n     ","methodParameters":[],"methodName":"provideNextVertex","methodQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.provideNextVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='CrossComponentIterator#provideNextVertex()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.provideNextVertex()"},{"methodDeclaration":"private void recordFinish()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V v = TypeUtil.uncheckedCast(stack.removeLast(), vertexTypeDecl);\n    putSeenData(v, VisitColor.BLACK);\n    finishVertex(v);\n}","methodRange":"(line 190,col 5)-(line 195,col 5)","methodTokenRange":"private void recordFinish()\n    {\n        V v = TypeUtil.uncheckedCast(stack.removeLast(), vertexTypeDecl);\n        putSeenData(v, VisitColor.BLACK);\n        finishVertex(v);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"recordFinish","methodQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.recordFinish","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.recordFinish()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"stack","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='stack'}]}', name=Optional.empty}"}],"methodDeclaration":"public Deque<Object> getStack()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return stack;\n}","methodRange":"(line 206,col 5)-(line 209,col 5)","methodTokenRange":"public Deque<Object> getStack()\n    {\n        return stack;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Deque, typeParametersMap=TypeParametersMap{nameToValue={java.util.Deque.E=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n     * Retrieves the LIFO stack of vertices which have been encountered but not\n     * yet visited (WHITE). This stack also contains <em>sentinel<\/em> entries\n     * representing vertices which have been visited but are still GRAY. A\n     * sentinel entry is a sequence (v, SENTINEL), whereas a non-sentinel entry\n     * is just (v).\n     *\n     * @return stack\n     ","methodParameters":[],"methodName":"getStack","methodQualifiedSignature":"org.jgrapht.traverse.DepthFirstIterator.getStack","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Retrieves the LIFO stack of vertices which have been encountered but not\nyet visited (WHITE). This stack also contains <em>sentinel<\/em> entries\nrepresenting vertices which have been visited but are still GRAY. A\nsentinel entry is a sequence (v, SENTINEL), whereas a non-sentinel entry\nis just (v).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='stack'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Deque<java.lang.Object>","methodType":"Deque<Object>","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.DepthFirstIterator.getStack()"}],"classJavadoc":"\/**\n * A depth-first iterator for a directed and an undirected graph. For this\n * iterator to work correctly the graph must not be modified during iteration.\n * Currently there are no means to ensure that, nor to fail-fast. The results of\n * such modifications are undefined.\n *\n * @author Liviu Rau\n * @author Barak Naveh\n * @since Jul 29, 2003\n *\/\n","className":"DepthFirstIterator","fields":[{"fieldRange":"(line 72,col 5)-(line 72,col 55)","fieldName":"SENTINEL","fieldJavadocComment":"\n     * Sentinel object. Unfortunately, we can't use null, because ArrayDeque\n     * won't accept those. And we don't want to rely on the caller to provide a\n     * sentinel object for us. So we have to play typecasting games.\n     ","fieldTokenRange":"public static final Object SENTINEL = new Object();","fieldTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new Object()]","fieldType":"Object","fieldJavadoc":"Sentinel object. Unfortunately, we can't use null, because ArrayDeque\nwon't accept those. And we don't want to rely on the caller to provide a\nsentinel object for us. So we have to play typecasting games.\n","fieldTypeResolvedDescribed":"java.lang.Object"},{"fieldRange":"(line 77,col 5)-(line 77,col 59)","fieldName":"stack","fieldJavadocComment":"\n     * @see #getStack\n     ","fieldTokenRange":"private Deque<Object> stack = new ArrayDeque<Object>();","fieldTypeResolved":"ReferenceType{java.util.Deque, typeParametersMap=TypeParametersMap{nameToValue={java.util.Deque.E=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayDeque<Object>()]","fieldType":"Deque<Object>","fieldJavadoc":"\n@see #getStack\n","fieldTypeResolvedDescribed":"java.util.Deque<java.lang.Object>"},{"fieldRange":"(line 79,col 5)-(line 79,col 56)","fieldName":"vertexTypeDecl","fieldJavadocComment":"","fieldTokenRange":"private transient TypeUtil<V> vertexTypeDecl = null;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.TypeUtil, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.TypeUtil.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 79,col 52)-(line 79,col 55)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"TypeUtil<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.TypeUtil<V>"}]}],"sourceFileId":117,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.traverse.GraphIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.event.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if traverses across connected components,\notherwise <code>false<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if traverses across connected components,\notherwise <code>false<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isCrossComponentTraversal()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 62,col 5)-(line 62,col 47)","methodTokenRange":"public boolean isCrossComponentTraversal();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Test whether this iterator is set to traverse the grpah across connected\n     * components.\n     *\n     * @return <code>true<\/code> if traverses across connected components,\n     * otherwise <code>false<\/code>.\n     ","methodParameters":[],"methodName":"isCrossComponentTraversal","methodQualifiedSignature":"org.jgrapht.traverse.GraphIterator.isCrossComponentTraversal","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test whether this iterator is set to traverse the grpah across connected\ncomponents.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if traverses across connected components,\notherwise <code>false<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.GraphIterator.isCrossComponentTraversal()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to reuse previously fired event objects\ninstead of creating a new event object for each event.","javadocBlockTagName":"reuseEvents","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to reuse previously fired event objects\ninstead of creating a new event object for each event.'}]}', name=Optional[reuseEvents]}"}],"methodDeclaration":"public void setReuseEvents(boolean reuseEvents)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 74,col 5)-(line 74,col 52)","methodTokenRange":"public void setReuseEvents(boolean reuseEvents);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Sets a value the <code>reuseEvents<\/code> flag. If the <code>\n     * reuseEvents<\/code> flag is set to <code>true<\/code> this class will reuse\n     * previously fired events and will not create a new object for each event.\n     * This option increases performance but should be used with care,\n     * especially in multithreaded environment.\n     *\n     * @param reuseEvents whether to reuse previously fired event objects\n     * instead of creating a new event object for each event.\n     ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean reuseEvents","parameterName":"reuseEvents"}],"methodName":"setReuseEvents","methodQualifiedSignature":"org.jgrapht.traverse.GraphIterator.setReuseEvents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets a value the <code>reuseEvents<\/code> flag. If the <code>\nreuseEvents<\/code> flag is set to <code>true<\/code> this class will reuse\npreviously fired events and will not create a new object for each event.\nThis option increases performance but should be used with care,\nespecially in multithreaded environment.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to reuse previously fired event objects\ninstead of creating a new event object for each event.'}]}', name=Optional[reuseEvents]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.GraphIterator.setReuseEvents(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the value of the <code>reuseEvents<\/code> flag.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value of the <code>reuseEvents<\/code> flag.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isReuseEvents()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 85,col 5)-(line 85,col 35)","methodTokenRange":"public boolean isReuseEvents();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Tests whether the <code>reuseEvents<\/code> flag is set. If the flag is\n     * set to <code>true<\/code> this class will reuse previously fired events\n     * and will not create a new object for each event. This option increases\n     * performance but should be used with care, especially in multithreaded\n     * environment.\n     *\n     * @return the value of the <code>reuseEvents<\/code> flag.\n     ","methodParameters":[],"methodName":"isReuseEvents","methodQualifiedSignature":"org.jgrapht.traverse.GraphIterator.isReuseEvents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests whether the <code>reuseEvents<\/code> flag is set. If the flag is\nset to <code>true<\/code> this class will reuse previously fired events\nand will not create a new object for each event. This option increases\nperformance but should be used with care, especially in multithreaded\nenvironment.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value of the <code>reuseEvents<\/code> flag.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.GraphIterator.isReuseEvents()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversal listener to be added.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be added.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void addTraversalListener(TraversalListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 92,col 5)-(line 92,col 64)","methodTokenRange":"public void addTraversalListener(TraversalListener<V, E> l);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds the specified traversal listener to this iterator.\n     *\n     * @param l the traversal listener to be added.\n     ","methodParameters":[{"parameterType":"TraversalListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.TraversalListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.TraversalListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.TraversalListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.TraversalListener<V, E>","parameter":"TraversalListener<V, E> l","parameterName":"l"}],"methodName":"addTraversalListener","methodQualifiedSignature":"org.jgrapht.traverse.GraphIterator.addTraversalListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified traversal listener to this iterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be added.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.GraphIterator.addTraversalListener(org.jgrapht.event.TraversalListener<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"UnsupportedOperationException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[UnsupportedOperationException]}"}],"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 99,col 5)-(line 99,col 35)","methodTokenRange":"@Override public void remove();","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Unsupported.\n     *\n     * @throws UnsupportedOperationException\n     ","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"org.jgrapht.traverse.GraphIterator.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Unsupported.'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[UnsupportedOperationException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.GraphIterator.remove()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversal listener to be removed.","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be removed.'}]}', name=Optional[l]}"}],"methodDeclaration":"public void removeTraversalListener(TraversalListener<V, E> l)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 106,col 5)-(line 106,col 67)","methodTokenRange":"public void removeTraversalListener(TraversalListener<V, E> l);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes the specified traversal listener from this iterator.\n     *\n     * @param l the traversal listener to be removed.\n     ","methodParameters":[{"parameterType":"TraversalListener<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.TraversalListener, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.TraversalListener.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.TraversalListener.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.TraversalListener<V, E>","parameter":"TraversalListener<V, E> l","parameterName":"l"}],"methodName":"removeTraversalListener","methodQualifiedSignature":"org.jgrapht.traverse.GraphIterator.removeTraversalListener","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the specified traversal listener from this iterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal listener to be removed.'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.traverse.GraphIterator.removeTraversalListener(org.jgrapht.event.TraversalListener<V, E>)"}],"classJavadoc":"\/**\n * A graph iterator.\n *\n * @author Barak Naveh\n * @since Jul 31, 2003\n *\/\n","className":"GraphIterator","fields":[]}],"sourceFileId":118,"packageName":"org.jgrapht.traverse"},{"sourceFileName":"org.jgrapht.EdgeFactory","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source vertex.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertex.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the target vertex.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertex.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a new edge whose endpoints are the specified source and target\nvertices.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a new edge whose endpoints are the specified source and target\nvertices.'}]}', name=Optional.empty}"}],"methodDeclaration":"public E createEdge(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 58,col 5)-(line 58,col 56)","methodTokenRange":"public E createEdge(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Creates a new edge whose endpoints are the specified source and target\n     * vertices.\n     *\n     * @param sourceVertex the source vertex.\n     * @param targetVertex the target vertex.\n     *\n     * @return a new edge whose endpoints are the specified source and target\n     * vertices.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"createEdge","methodQualifiedSignature":"org.jgrapht.EdgeFactory.createEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new edge whose endpoints are the specified source and target\nvertices.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertex.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertex.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a new edge whose endpoints are the specified source and target\nvertices.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.EdgeFactory.createEdge(V, V)"}],"classJavadoc":"\/**\n * An edge factory used by graphs for creating new edges.\n *\n * @author Barak Naveh\n * @since Jul 14, 2003\n *\/\n","className":"EdgeFactory","fields":[]}],"sourceFileId":119,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.GraphMapping","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in one of the graphs","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in one of the graphs'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1","javadocBlockTagName":"forward","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1'}]}', name=Optional[forward]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"corresponding vertex in other graph, or null if none","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='corresponding vertex in other graph, or null if none'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getVertexCorrespondence(V vertex, boolean forward)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 56,col 5)-(line 56,col 64)","methodTokenRange":"public V getVertexCorrespondence(V vertex, boolean forward);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Gets the mapped value where the key is <code>vertex<\/code>\n     *\n     * @param vertex vertex in one of the graphs\n     * @param forward if true, uses mapping from graph1 to graph2; if false, use\n     * mapping from graph2 to graph1\n     *\n     * @return corresponding vertex in other graph, or null if none\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean forward","parameterName":"forward"}],"methodName":"getVertexCorrespondence","methodQualifiedSignature":"org.jgrapht.GraphMapping.getVertexCorrespondence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the mapped value where the key is <code>vertex<\/code>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in one of the graphs'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1'}]}', name=Optional[forward]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='corresponding vertex in other graph, or null if none'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphMapping.getVertexCorrespondence(V, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge in one of the graphs","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge in one of the graphs'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1","javadocBlockTagName":"forward","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1'}]}', name=Optional[forward]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"corresponding edge in other graph, or null if none","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='corresponding edge in other graph, or null if none'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdgeCorrespondence(E edge, boolean forward)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 67,col 5)-(line 67,col 60)","methodTokenRange":"public E getEdgeCorrespondence(E edge, boolean forward);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Gets the mapped value where the key is <code>edge<\/code>\n     *\n     * @param edge edge in one of the graphs\n     * @param forward if true, uses mapping from graph1 to graph2; if false, use\n     * mapping from graph2 to graph1\n     *\n     * @return corresponding edge in other graph, or null if none\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean forward","parameterName":"forward"}],"methodName":"getEdgeCorrespondence","methodQualifiedSignature":"org.jgrapht.GraphMapping.getEdgeCorrespondence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the mapped value where the key is <code>edge<\/code>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge in one of the graphs'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, uses mapping from graph1 to graph2; if false, use\nmapping from graph2 to graph1'}]}', name=Optional[forward]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='corresponding edge in other graph, or null if none'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.GraphMapping.getEdgeCorrespondence(E, boolean)"}],"classJavadoc":"\/**\n * GraphMapping represents a bidirectional mapping between two graphs (called\n * graph1 and graph2), which allows the caller to obtain the matching vertex or\n * edge in either direction, from graph1 to graph2, or from graph2 to graph1. It\n * does not have to always be a complete bidirectional mapping (it could return\n * null for some lookups).\n *\n * @author Assaf Lehr\n * @since Jul 30, 2005\n *\/\n","className":"GraphMapping","fields":[]}],"sourceFileId":120,"packageName":"org.jgrapht"},{"sourceFileName":"org.jgrapht.event.VertexSetListener","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void vertexAdded(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 62,col 5)-(line 62,col 57)","methodTokenRange":"public void vertexAdded(GraphVertexChangeEvent<V> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notifies that a vertex has been added to the graph.\n     *\n     * @param e the vertex event.\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexAdded","methodQualifiedSignature":"org.jgrapht.event.VertexSetListener.vertexAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notifies that a vertex has been added to the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.VertexSetListener.vertexAdded(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void vertexRemoved(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 69,col 5)-(line 69,col 59)","methodTokenRange":"public void vertexRemoved(GraphVertexChangeEvent<V> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notifies that a vertex has been removed from the graph.\n     *\n     * @param e the vertex event.\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexRemoved","methodQualifiedSignature":"org.jgrapht.event.VertexSetListener.vertexRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notifies that a vertex has been removed from the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.VertexSetListener.vertexRemoved(org.jgrapht.event.GraphVertexChangeEvent<V>)"}],"classJavadoc":"\/**\n * A listener that is notified when the graph's vertex set changes. It should be\n * used when <i>only<\/i> notifications on vertex-set changes are of interest. If\n * all graph notifications are of interest better use <code>\n * GraphListener<\/code>.\n *\n * @author Barak Naveh\n * @see GraphListener\n * @since Jul 18, 2003\n *\/\n","className":"VertexSetListener","fields":[]}],"sourceFileId":121,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.EdgeTraversalEvent","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of the event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversed edge.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed edge.'}]}', name=Optional[edge]}"}],"constructorQualifiedSignature":"org.jgrapht.event.EdgeTraversalEvent.EdgeTraversalEvent(java.lang.Object, E)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 69,col 5)","constructorJavadocComment":"\n     * Creates a new EdgeTraversalEvent.\n     *\n     * @param eventSource the source of the event.\n     * @param edge the traversed edge.\n     ","constructorDeclaration":"public EdgeTraversalEvent(Object eventSource, E edge)","constructorBody":"{\n    super(eventSource);\n    this.edge = edge;\n}","constructorName":"EdgeTraversalEvent","constructorQualifiedName":"org.jgrapht.event.EdgeTraversalEvent.EdgeTraversalEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"literalExprs":[],"constructorTokenRange":"public EdgeTraversalEvent(Object eventSource, E edge)\n    {\n        super(eventSource);\n        this.edge = edge;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new EdgeTraversalEvent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed edge.'}]}', name=Optional[edge]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the traversed edge.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed edge.'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edge;\n}","methodRange":"(line 76,col 5)-(line 79,col 5)","methodTokenRange":"public E getEdge()\n    {\n        return edge;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Returns the traversed edge.\n     *\n     * @return the traversed edge.\n     ","methodParameters":[],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.event.EdgeTraversalEvent.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the traversed edge.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed edge.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.EdgeTraversalEvent.getEdge()"}],"classJavadoc":"\/**\n * A traversal event for a graph edge.\n *\n * @author Barak Naveh\n * @since Aug 11, 2003\n *\/\n","className":"EdgeTraversalEvent","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 4050768173789820979L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 69)","literalExprId":1,"literalExpr":"4050768173789820979L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[4050768173789820979L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 57,col 5)-(line 57,col 21)","fieldName":"edge","fieldJavadocComment":"\n     * The traversed edge.\n     ","fieldTokenRange":"protected E edge;","fieldTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"E","fieldJavadoc":"The traversed edge.\n","fieldTypeResolvedDescribed":"E"}]}],"sourceFileId":122,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.TraversalListener","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void connectedComponentFinished(ConnectedComponentTraversalEvent e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 55,col 5)-(line 56,col 44)","methodTokenRange":"public void connectedComponentFinished(\n        ConnectedComponentTraversalEvent e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called to inform listeners that the traversal of the current connected\n     * component has finished.\n     *\n     * @param e the traversal event.\n     ","methodParameters":[{"parameterType":"ConnectedComponentTraversalEvent","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent","parameter":"ConnectedComponentTraversalEvent e","parameterName":"e"}],"methodName":"connectedComponentFinished","methodQualifiedSignature":"org.jgrapht.event.TraversalListener.connectedComponentFinished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called to inform listeners that the traversal of the current connected\ncomponent has finished.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListener.connectedComponentFinished(org.jgrapht.event.ConnectedComponentTraversalEvent)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void connectedComponentStarted(ConnectedComponentTraversalEvent e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 64,col 5)-(line 64,col 78)","methodTokenRange":"public void connectedComponentStarted(ConnectedComponentTraversalEvent e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called to inform listeners that a traversal of a new connected component\n     * has started.\n     *\n     * @param e the traversal event.\n     ","methodParameters":[{"parameterType":"ConnectedComponentTraversalEvent","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent","parameter":"ConnectedComponentTraversalEvent e","parameterName":"e"}],"methodName":"connectedComponentStarted","methodQualifiedSignature":"org.jgrapht.event.TraversalListener.connectedComponentStarted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called to inform listeners that a traversal of a new connected component\nhas started.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListener.connectedComponentStarted(org.jgrapht.event.ConnectedComponentTraversalEvent)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void edgeTraversed(EdgeTraversalEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 73,col 5)-(line 73,col 58)","methodTokenRange":"public void edgeTraversed(EdgeTraversalEvent<V, E> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called to inform the listener that the specified edge have been visited\n     * during the graph traversal. Depending on the traversal algorithm, edge\n     * might be visited more than once.\n     *\n     * @param e the edge traversal event.\n     ","methodParameters":[{"parameterType":"EdgeTraversalEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.EdgeTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.EdgeTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.EdgeTraversalEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.EdgeTraversalEvent<V, E>","parameter":"EdgeTraversalEvent<V, E> e","parameterName":"e"}],"methodName":"edgeTraversed","methodQualifiedSignature":"org.jgrapht.event.TraversalListener.edgeTraversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called to inform the listener that the specified edge have been visited\nduring the graph traversal. Depending on the traversal algorithm, edge\nmight be visited more than once.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListener.edgeTraversed(org.jgrapht.event.EdgeTraversalEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void vertexTraversed(VertexTraversalEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 82,col 5)-(line 82,col 59)","methodTokenRange":"public void vertexTraversed(VertexTraversalEvent<V> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called to inform the listener that the specified vertex have been visited\n     * during the graph traversal. Depending on the traversal algorithm, vertex\n     * might be visited more than once.\n     *\n     * @param e the vertex traversal event.\n     ","methodParameters":[{"parameterType":"VertexTraversalEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexTraversalEvent<V>","parameter":"VertexTraversalEvent<V> e","parameterName":"e"}],"methodName":"vertexTraversed","methodQualifiedSignature":"org.jgrapht.event.TraversalListener.vertexTraversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called to inform the listener that the specified vertex have been visited\nduring the graph traversal. Depending on the traversal algorithm, vertex\nmight be visited more than once.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListener.vertexTraversed(org.jgrapht.event.VertexTraversalEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex traversal event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void vertexFinished(VertexTraversalEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 92,col 5)-(line 92,col 58)","methodTokenRange":"public void vertexFinished(VertexTraversalEvent<V> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Called to inform the listener that the specified vertex have been\n     * finished during the graph traversal. Exact meaning of \"finish\" is\n     * algorithm-dependent; e.g. for DFS, it means that all vertices reachable\n     * via the vertex have been visited as well.\n     *\n     * @param e the vertex traversal event.\n     ","methodParameters":[{"parameterType":"VertexTraversalEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexTraversalEvent<V>","parameter":"VertexTraversalEvent<V> e","parameterName":"e"}],"methodName":"vertexFinished","methodQualifiedSignature":"org.jgrapht.event.TraversalListener.vertexFinished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Called to inform the listener that the specified vertex have been\nfinished during the graph traversal. Exact meaning of \"finish\" is\nalgorithm-dependent; e.g. for DFS, it means that all vertices reachable\nvia the vertex have been visited as well.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex traversal event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListener.vertexFinished(org.jgrapht.event.VertexTraversalEvent<V>)"}],"classJavadoc":"\/**\n * A listener on graph iterator or on a graph traverser.\n *\n * @author Barak Naveh\n * @since Jul 19, 2003\n *\/\n","className":"TraversalListener","fields":[]}],"sourceFileId":123,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.GraphEdgeChangeEvent","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of this event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of this event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the event type of this event.","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the event type of this event.'}]}', name=Optional[type]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge that this event is related to.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that this event is related to.'}]}', name=Optional[edge]}"},{"javadocBlockType":"DEPRECATED","javadocBlockTagContent":"Use new constructor which takes vertex parameters.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='Use new constructor which takes vertex parameters.'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"org.jgrapht.event.GraphEdgeChangeEvent.GraphEdgeChangeEvent(java.lang.Object, int, E)","variableDeclarationExprs":[],"constructorRange":"(line 102,col 5)-(line 108,col 5)","constructorJavadocComment":"\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     *\n     * @deprecated Use new constructor which takes vertex parameters.\n     ","constructorDeclaration":"public GraphEdgeChangeEvent(Object eventSource, int type, E edge)","constructorBody":"{\n    this(eventSource, type, edge, null, null);\n}","constructorName":"GraphEdgeChangeEvent","constructorQualifiedName":"org.jgrapht.event.GraphEdgeChangeEvent.GraphEdgeChangeEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int type","parameterName":"type"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"literalExprs":[{"literalExprRange":"(line 107,col 39)-(line 107,col 42)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 107,col 45)-(line 107,col 48)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"@Deprecated public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge)\n    {\n        this(eventSource, type, edge, null, null);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for GraphEdgeChangeEvent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of this event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the event type of this event.'}]}', name=Optional[type]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that this event is related to.'}]}', name=Optional[edge]}, JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='Use new constructor which takes vertex parameters.'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of this event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of this event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the event type of this event.","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the event type of this event.'}]}', name=Optional[type]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge that this event is related to.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that this event is related to.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge source vertex","javadocBlockTagName":"edgeSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge source vertex'}]}', name=Optional[edgeSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge target vertex","javadocBlockTagName":"edgeTarget","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge target vertex'}]}', name=Optional[edgeTarget]}"}],"constructorQualifiedSignature":"org.jgrapht.event.GraphEdgeChangeEvent.GraphEdgeChangeEvent(java.lang.Object, int, E, V, V)","variableDeclarationExprs":[],"constructorRange":"(line 119,col 5)-(line 130,col 5)","constructorJavadocComment":"\n     * Constructor for GraphEdgeChangeEvent.\n     *\n     * @param eventSource the source of this event.\n     * @param type the event type of this event.\n     * @param edge the edge that this event is related to.\n     * @param edgeSource edge source vertex\n     * @param edgeTarget edge target vertex\n     ","constructorDeclaration":"public GraphEdgeChangeEvent(Object eventSource, int type, E edge, V edgeSource, V edgeTarget)","constructorBody":"{\n    super(eventSource, type);\n    this.edge = edge;\n    this.edgeSource = edgeSource;\n    this.edgeTarget = edgeTarget;\n}","constructorName":"GraphEdgeChangeEvent","constructorQualifiedName":"org.jgrapht.event.GraphEdgeChangeEvent.GraphEdgeChangeEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int type","parameterName":"type"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"V","parameterId":4,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V edgeSource","parameterName":"edgeSource"},{"parameterType":"V","parameterId":5,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V edgeTarget","parameterName":"edgeTarget"}],"literalExprs":[],"constructorTokenRange":"public GraphEdgeChangeEvent(\n        Object eventSource,\n        int type,\n        E edge,\n        V edgeSource,\n        V edgeTarget)\n    {\n        super(eventSource, type);\n        this.edge = edge;\n        this.edgeSource = edgeSource;\n        this.edgeTarget = edgeTarget;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructor for GraphEdgeChangeEvent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of this event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the event type of this event.'}]}', name=Optional[type]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge that this event is related to.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge source vertex'}]}', name=Optional[edgeSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge target vertex'}]}', name=Optional[edgeTarget]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"event edge","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='event edge'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edge;\n}","methodRange":"(line 137,col 5)-(line 140,col 5)","methodTokenRange":"public E getEdge()\n    {\n        return edge;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Returns the edge that this event is related to.\n     *\n     * @return event edge\n     ","methodParameters":[],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.event.GraphEdgeChangeEvent.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the edge that this event is related to.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='event edge'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphEdgeChangeEvent.getEdge()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"event source vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='event source vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeSource()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeSource;\n}","methodRange":"(line 147,col 5)-(line 150,col 5)","methodTokenRange":"public V getEdgeSource()\n    {\n        return edgeSource;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the source vertex that this event is related to.\n     *\n     * @return event source vertex\n     ","methodParameters":[],"methodName":"getEdgeSource","methodQualifiedSignature":"org.jgrapht.event.GraphEdgeChangeEvent.getEdgeSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the source vertex that this event is related to.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='event source vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphEdgeChangeEvent.getEdgeSource()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"event target vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='event target vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getEdgeTarget()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeTarget;\n}","methodRange":"(line 157,col 5)-(line 160,col 5)","methodTokenRange":"public V getEdgeTarget()\n    {\n        return edgeTarget;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the target vertex that this event is related to.\n     *\n     * @return event target vertex\n     ","methodParameters":[],"methodName":"getEdgeTarget","methodQualifiedSignature":"org.jgrapht.event.GraphEdgeChangeEvent.getEdgeTarget","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the target vertex that this event is related to.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='event target vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphEdgeChangeEvent.getEdgeTarget()"}],"classJavadoc":"\/**\n * An event which indicates that a graph edge has changed, or is about to\n * change. The event can be used either as an indication <i>after<\/i> the edge\n * has been added or removed, or <i>before<\/i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n *\/\n","className":"GraphEdgeChangeEvent","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3618134563335844662L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3618134563335844662L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3618134563335844662L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 59,col 5)-(line 59,col 51)","fieldName":"BEFORE_EDGE_ADDED","fieldJavadocComment":"\n     * Before edge added event. This event is fired before an edge is added to a\n     * graph.\n     ","fieldTokenRange":"public static final int BEFORE_EDGE_ADDED = 21;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 59,col 49)-(line 59,col 50)","literalExprId":1,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[21]","fieldType":"int","fieldJavadoc":"Before edge added event. This event is fired before an edge is added to a\ngraph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 65,col 5)-(line 65,col 53)","fieldName":"BEFORE_EDGE_REMOVED","fieldJavadocComment":"\n     * Before edge removed event. This event is fired before an edge is removed\n     * from a graph.\n     ","fieldTokenRange":"public static final int BEFORE_EDGE_REMOVED = 22;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 65,col 51)-(line 65,col 52)","literalExprId":1,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[22]","fieldType":"int","fieldJavadoc":"Before edge removed event. This event is fired before an edge is removed\nfrom a graph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 70,col 5)-(line 70,col 44)","fieldName":"EDGE_ADDED","fieldJavadocComment":"\n     * Edge added event. This event is fired after an edge is added to a graph.\n     ","fieldTokenRange":"public static final int EDGE_ADDED = 23;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 70,col 42)-(line 70,col 43)","literalExprId":1,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[23]","fieldType":"int","fieldJavadoc":"Edge added event. This event is fired after an edge is added to a graph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 76,col 5)-(line 76,col 46)","fieldName":"EDGE_REMOVED","fieldJavadocComment":"\n     * Edge removed event. This event is fired after an edge is removed from a\n     * graph.\n     ","fieldTokenRange":"public static final int EDGE_REMOVED = 24;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 76,col 44)-(line 76,col 45)","literalExprId":1,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[24]","fieldType":"int","fieldJavadoc":"Edge removed event. This event is fired after an edge is removed from a\ngraph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 81,col 5)-(line 81,col 21)","fieldName":"edge","fieldJavadocComment":"\n     * The edge that this event is related to.\n     ","fieldTokenRange":"protected E edge;","fieldTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"E","fieldJavadoc":"The edge that this event is related to.\n","fieldTypeResolvedDescribed":"E"},{"fieldRange":"(line 86,col 5)-(line 86,col 27)","fieldName":"edgeSource","fieldJavadocComment":"\n     * The source vertex of the edge that this event is related to.\n     ","fieldTokenRange":"protected V edgeSource;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"The source vertex of the edge that this event is related to.\n","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 91,col 5)-(line 91,col 27)","fieldName":"edgeTarget","fieldJavadocComment":"\n     * The target vertex of the edge that this event is related to.\n     ","fieldTokenRange":"protected V edgeTarget;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"The target vertex of the edge that this event is related to.\n","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":124,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.VertexTraversalEvent","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of the event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the traversed vertex.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed vertex.'}]}', name=Optional[vertex]}"}],"constructorQualifiedSignature":"org.jgrapht.event.VertexTraversalEvent.VertexTraversalEvent(java.lang.Object, V)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 69,col 5)","constructorJavadocComment":"\n     * Creates a new VertexTraversalEvent.\n     *\n     * @param eventSource the source of the event.\n     * @param vertex the traversed vertex.\n     ","constructorDeclaration":"public VertexTraversalEvent(Object eventSource, V vertex)","constructorBody":"{\n    super(eventSource);\n    this.vertex = vertex;\n}","constructorName":"VertexTraversalEvent","constructorQualifiedName":"org.jgrapht.event.VertexTraversalEvent.VertexTraversalEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"literalExprs":[],"constructorTokenRange":"public VertexTraversalEvent(Object eventSource, V vertex)\n    {\n        super(eventSource);\n        this.vertex = vertex;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new VertexTraversalEvent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed vertex.'}]}', name=Optional[vertex]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the traversed vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return vertex;\n}","methodRange":"(line 76,col 5)-(line 79,col 5)","methodTokenRange":"public V getVertex()\n    {\n        return vertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the traversed vertex.\n     *\n     * @return the traversed vertex.\n     ","methodParameters":[],"methodName":"getVertex","methodQualifiedSignature":"org.jgrapht.event.VertexTraversalEvent.getVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the traversed vertex.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the traversed vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.VertexTraversalEvent.getVertex()"}],"classJavadoc":"\/**\n * A traversal event for a graph vertex.\n *\n * @author Barak Naveh\n * @since Aug 11, 2003\n *\/\n","className":"VertexTraversalEvent","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3688790267213918768L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 69)","literalExprId":1,"literalExpr":"3688790267213918768L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3688790267213918768L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 57,col 5)-(line 57,col 23)","fieldName":"vertex","fieldJavadocComment":"\n     * The traversed vertex.\n     ","fieldTokenRange":"protected V vertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"The traversed vertex.\n","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":125,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.GraphChangeEvent","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of the event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of event.","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of event.'}]}', name=Optional[type]}"}],"constructorQualifiedSignature":"org.jgrapht.event.GraphChangeEvent.GraphChangeEvent(java.lang.Object, int)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 69,col 5)","constructorJavadocComment":"\n     * Creates a new graph change event.\n     *\n     * @param eventSource the source of the event.\n     * @param type the type of event.\n     ","constructorDeclaration":"public GraphChangeEvent(Object eventSource, int type)","constructorBody":"{\n    super(eventSource);\n    this.type = type;\n}","constructorName":"GraphChangeEvent","constructorQualifiedName":"org.jgrapht.event.GraphChangeEvent.GraphChangeEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int type","parameterName":"type"}],"literalExprs":[],"constructorTokenRange":"public GraphChangeEvent(Object eventSource, int type)\n    {\n        super(eventSource);\n        this.type = type;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new graph change event.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of event.'}]}', name=Optional[type]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the event type.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the event type.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getType()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return type;\n}","methodRange":"(line 76,col 5)-(line 79,col 5)","methodTokenRange":"public int getType()\n    {\n        return type;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the event type.\n     *\n     * @return the event type.\n     ","methodParameters":[],"methodName":"getType","methodQualifiedSignature":"org.jgrapht.event.GraphChangeEvent.getType","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the event type.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the event type.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphChangeEvent.getType()"}],"classJavadoc":"\/**\n * An event which indicates that a graph has changed. This class is a root for\n * graph change events.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n *\/\n","className":"GraphChangeEvent","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3834592106026382391L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 69)","literalExprId":1,"literalExpr":"3834592106026382391L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3834592106026382391L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 57,col 5)-(line 57,col 23)","fieldName":"type","fieldJavadocComment":"\n     * The type of graph change this event indicates.\n     ","fieldTokenRange":"protected int type;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The type of graph change this event indicates.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":126,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.GraphListener","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void edgeAdded(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 59,col 5)-(line 59,col 56)","methodTokenRange":"public void edgeAdded(GraphEdgeChangeEvent<V, E> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notifies that an edge has been added to the graph.\n     *\n     * @param e the edge event.\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeAdded","methodQualifiedSignature":"org.jgrapht.event.GraphListener.edgeAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notifies that an edge has been added to the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphListener.edgeAdded(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge event.","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge event.'}]}', name=Optional[e]}"}],"methodDeclaration":"public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 66,col 5)-(line 66,col 58)","methodTokenRange":"public void edgeRemoved(GraphEdgeChangeEvent<V, E> e);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Notifies that an edge has been removed from the graph.\n     *\n     * @param e the edge event.\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeRemoved","methodQualifiedSignature":"org.jgrapht.event.GraphListener.edgeRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Notifies that an edge has been removed from the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge event.'}]}', name=Optional[e]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphListener.edgeRemoved(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"}],"classJavadoc":"\/**\n * A listener that is notified when the graph changes.\n *\n * <p>If only notifications on vertex set changes are required it is more\n * efficient to use the VertexSetListener.<\/p>\n *\n * @author Barak Naveh\n * @see VertexSetListener\n * @since Jul 18, 2003\n *\/\n","className":"GraphListener","fields":[]}],"sourceFileId":127,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.TraversalListenerAdapter","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"TraversalListener#connectedComponentFinished(ConnectedComponentTraversalEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#connectedComponentFinished(ConnectedComponentTraversalEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void connectedComponentFinished(ConnectedComponentTraversalEvent e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 54,col 5)-(line 57,col 5)","methodTokenRange":"@Override public void connectedComponentFinished(\n        ConnectedComponentTraversalEvent e)\n    {\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see TraversalListener#connectedComponentFinished(ConnectedComponentTraversalEvent)\n     ","methodParameters":[{"parameterType":"ConnectedComponentTraversalEvent","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent","parameter":"ConnectedComponentTraversalEvent e","parameterName":"e"}],"methodName":"connectedComponentFinished","methodQualifiedSignature":"org.jgrapht.event.TraversalListenerAdapter.connectedComponentFinished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#connectedComponentFinished(ConnectedComponentTraversalEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListenerAdapter.connectedComponentFinished(org.jgrapht.event.ConnectedComponentTraversalEvent)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"TraversalListener#connectedComponentStarted(ConnectedComponentTraversalEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#connectedComponentStarted(ConnectedComponentTraversalEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void connectedComponentStarted(ConnectedComponentTraversalEvent e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 62,col 5)-(line 65,col 5)","methodTokenRange":"@Override public void connectedComponentStarted(\n        ConnectedComponentTraversalEvent e)\n    {\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see TraversalListener#connectedComponentStarted(ConnectedComponentTraversalEvent)\n     ","methodParameters":[{"parameterType":"ConnectedComponentTraversalEvent","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.ConnectedComponentTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.ConnectedComponentTraversalEvent","parameter":"ConnectedComponentTraversalEvent e","parameterName":"e"}],"methodName":"connectedComponentStarted","methodQualifiedSignature":"org.jgrapht.event.TraversalListenerAdapter.connectedComponentStarted","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#connectedComponentStarted(ConnectedComponentTraversalEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListenerAdapter.connectedComponentStarted(org.jgrapht.event.ConnectedComponentTraversalEvent)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"TraversalListener#edgeTraversed(EdgeTraversalEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#edgeTraversed(EdgeTraversalEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeTraversed(EdgeTraversalEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 70,col 5)-(line 72,col 5)","methodTokenRange":"@Override public void edgeTraversed(EdgeTraversalEvent<V, E> e)\n    {\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see TraversalListener#edgeTraversed(EdgeTraversalEvent)\n     ","methodParameters":[{"parameterType":"EdgeTraversalEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.EdgeTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.EdgeTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.event.EdgeTraversalEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.EdgeTraversalEvent<V, E>","parameter":"EdgeTraversalEvent<V, E> e","parameterName":"e"}],"methodName":"edgeTraversed","methodQualifiedSignature":"org.jgrapht.event.TraversalListenerAdapter.edgeTraversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#edgeTraversed(EdgeTraversalEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListenerAdapter.edgeTraversed(org.jgrapht.event.EdgeTraversalEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"TraversalListener#vertexTraversed(VertexTraversalEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#vertexTraversed(VertexTraversalEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexTraversed(VertexTraversalEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 77,col 5)-(line 79,col 5)","methodTokenRange":"@Override public void vertexTraversed(VertexTraversalEvent<V> e)\n    {\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see TraversalListener#vertexTraversed(VertexTraversalEvent)\n     ","methodParameters":[{"parameterType":"VertexTraversalEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexTraversalEvent<V>","parameter":"VertexTraversalEvent<V> e","parameterName":"e"}],"methodName":"vertexTraversed","methodQualifiedSignature":"org.jgrapht.event.TraversalListenerAdapter.vertexTraversed","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#vertexTraversed(VertexTraversalEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListenerAdapter.vertexTraversed(org.jgrapht.event.VertexTraversalEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"TraversalListener#vertexFinished(VertexTraversalEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#vertexFinished(VertexTraversalEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexFinished(VertexTraversalEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 84,col 5)-(line 86,col 5)","methodTokenRange":"@Override public void vertexFinished(VertexTraversalEvent<V> e)\n    {\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see TraversalListener#vertexFinished(VertexTraversalEvent)\n     ","methodParameters":[{"parameterType":"VertexTraversalEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.VertexTraversalEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.VertexTraversalEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.VertexTraversalEvent<V>","parameter":"VertexTraversalEvent<V> e","parameterName":"e"}],"methodName":"vertexFinished","methodQualifiedSignature":"org.jgrapht.event.TraversalListenerAdapter.vertexFinished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='TraversalListener#vertexFinished(VertexTraversalEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.TraversalListenerAdapter.vertexFinished(org.jgrapht.event.VertexTraversalEvent<V>)"}],"classJavadoc":"\/**\n * An empty do-nothing implementation of the {@link TraversalListener} interface\n * used for subclasses.\n *\n * @author Barak Naveh\n * @since Aug 6, 2003\n *\/\n","className":"TraversalListenerAdapter","fields":[]}],"sourceFileId":128,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.ConnectedComponentTraversalEvent","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of the event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of event.","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of event.'}]}', name=Optional[type]}"}],"constructorQualifiedSignature":"org.jgrapht.event.ConnectedComponentTraversalEvent.ConnectedComponentTraversalEvent(java.lang.Object, int)","variableDeclarationExprs":[],"constructorRange":"(line 75,col 5)-(line 79,col 5)","constructorJavadocComment":"\n     * Creates a new ConnectedComponentTraversalEvent.\n     *\n     * @param eventSource the source of the event.\n     * @param type the type of event.\n     ","constructorDeclaration":"public ConnectedComponentTraversalEvent(Object eventSource, int type)","constructorBody":"{\n    super(eventSource);\n    this.type = type;\n}","constructorName":"ConnectedComponentTraversalEvent","constructorQualifiedName":"org.jgrapht.event.ConnectedComponentTraversalEvent.ConnectedComponentTraversalEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int type","parameterName":"type"}],"literalExprs":[],"constructorTokenRange":"public ConnectedComponentTraversalEvent(Object eventSource, int type)\n    {\n        super(eventSource);\n        this.type = type;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new ConnectedComponentTraversalEvent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of event.'}]}', name=Optional[type]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the event type.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the event type.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getType()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return type;\n}","methodRange":"(line 86,col 5)-(line 89,col 5)","methodTokenRange":"public int getType()\n    {\n        return type;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the event type.\n     *\n     * @return the event type.\n     ","methodParameters":[],"methodName":"getType","methodQualifiedSignature":"org.jgrapht.event.ConnectedComponentTraversalEvent.getType","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the event type.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the event type.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.ConnectedComponentTraversalEvent.getType()"}],"classJavadoc":"\/**\n * A traversal event with respect to a connected component.\n *\n * @author Barak Naveh\n * @since Aug 11, 2003\n *\/\n","className":"ConnectedComponentTraversalEvent","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3834311717709822262L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 69)","literalExprId":1,"literalExpr":"3834311717709822262L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3834311717709822262L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 57,col 5)-(line 57,col 61)","fieldName":"CONNECTED_COMPONENT_STARTED","fieldJavadocComment":"\n     * Connected component traversal started event.\n     ","fieldTokenRange":"public static final int CONNECTED_COMPONENT_STARTED = 31;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 57,col 59)-(line 57,col 60)","literalExprId":1,"literalExpr":"31","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[31]","fieldType":"int","fieldJavadoc":"Connected component traversal started event.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 62,col 5)-(line 62,col 62)","fieldName":"CONNECTED_COMPONENT_FINISHED","fieldJavadocComment":"\n     * Connected component traversal finished event.\n     ","fieldTokenRange":"public static final int CONNECTED_COMPONENT_FINISHED = 32;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 62,col 60)-(line 62,col 61)","literalExprId":1,"literalExpr":"32","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[32]","fieldType":"int","fieldJavadoc":"Connected component traversal finished event.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 67,col 5)-(line 67,col 21)","fieldName":"type","fieldJavadocComment":"\n     * The type of this event.\n     ","fieldTokenRange":"private int type;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The type of this event.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":129,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.event.GraphVertexChangeEvent","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source of the event.","javadocBlockTagName":"eventSource","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of the event.","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the event.'}]}', name=Optional[type]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex that the event is related to.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that the event is related to.'}]}', name=Optional[vertex]}"}],"constructorQualifiedSignature":"org.jgrapht.event.GraphVertexChangeEvent.GraphVertexChangeEvent(java.lang.Object, int, V)","variableDeclarationExprs":[],"constructorRange":"(line 91,col 5)-(line 95,col 5)","constructorJavadocComment":"\n     * Creates a new GraphVertexChangeEvent object.\n     *\n     * @param eventSource the source of the event.\n     * @param type the type of the event.\n     * @param vertex the vertex that the event is related to.\n     ","constructorDeclaration":"public GraphVertexChangeEvent(Object eventSource, int type, V vertex)","constructorBody":"{\n    super(eventSource, type);\n    this.vertex = vertex;\n}","constructorName":"GraphVertexChangeEvent","constructorQualifiedName":"org.jgrapht.event.GraphVertexChangeEvent.GraphVertexChangeEvent","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object eventSource","parameterName":"eventSource"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int type","parameterName":"type"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"literalExprs":[],"constructorTokenRange":"public GraphVertexChangeEvent(Object eventSource, int type, V vertex)\n    {\n        super(eventSource, type);\n        this.vertex = vertex;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new GraphVertexChangeEvent object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source of the event.'}]}', name=Optional[eventSource]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the event.'}]}', name=Optional[type]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that the event is related to.'}]}', name=Optional[vertex]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the vertex that this event is related to.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that this event is related to.'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return vertex;\n}","methodRange":"(line 102,col 5)-(line 105,col 5)","methodTokenRange":"public V getVertex()\n    {\n        return vertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the vertex that this event is related to.\n     *\n     * @return the vertex that this event is related to.\n     ","methodParameters":[],"methodName":"getVertex","methodQualifiedSignature":"org.jgrapht.event.GraphVertexChangeEvent.getVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the vertex that this event is related to.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex that this event is related to.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.event.GraphVertexChangeEvent.getVertex()"}],"classJavadoc":"\/**\n * An event which indicates that a graph vertex has changed, or is about to\n * change. The event can be used either as an indication <i>after<\/i> the vertex\n * has been added or removed, or <i>before<\/i> it is added. The type of the\n * event can be tested using the {@link\n * org.jgrapht.event.GraphChangeEvent#getType()} method.\n *\n * @author Barak Naveh\n * @since Aug 10, 2003\n *\/\n","className":"GraphVertexChangeEvent","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 70)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"private static final long serialVersionUID = 3690189962679104053L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 53,col 50)-(line 53,col 69)","literalExprId":1,"literalExpr":"3690189962679104053L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[3690189962679104053L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 59,col 5)-(line 59,col 53)","fieldName":"BEFORE_VERTEX_ADDED","fieldJavadocComment":"\n     * Before vertex added event. This event is fired before a vertex is added\n     * to a graph.\n     ","fieldTokenRange":"public static final int BEFORE_VERTEX_ADDED = 11;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 59,col 51)-(line 59,col 52)","literalExprId":1,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[11]","fieldType":"int","fieldJavadoc":"Before vertex added event. This event is fired before a vertex is added\nto a graph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 65,col 5)-(line 65,col 55)","fieldName":"BEFORE_VERTEX_REMOVED","fieldJavadocComment":"\n     * Before vertex removed event. This event is fired before a vertex is\n     * removed from a graph.\n     ","fieldTokenRange":"public static final int BEFORE_VERTEX_REMOVED = 12;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 65,col 53)-(line 65,col 54)","literalExprId":1,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[12]","fieldType":"int","fieldJavadoc":"Before vertex removed event. This event is fired before a vertex is\nremoved from a graph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 71,col 5)-(line 71,col 46)","fieldName":"VERTEX_ADDED","fieldJavadocComment":"\n     * Vertex added event. This event is fired after a vertex is added to a\n     * graph.\n     ","fieldTokenRange":"public static final int VERTEX_ADDED = 13;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 71,col 44)-(line 71,col 45)","literalExprId":1,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[13]","fieldType":"int","fieldJavadoc":"Vertex added event. This event is fired after a vertex is added to a\ngraph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 77,col 5)-(line 77,col 48)","fieldName":"VERTEX_REMOVED","fieldJavadocComment":"\n     * Vertex removed event. This event is fired after a vertex is removed from\n     * a graph.\n     ","fieldTokenRange":"public static final int VERTEX_REMOVED = 14;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 77,col 46)-(line 77,col 47)","literalExprId":1,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[14]","fieldType":"int","fieldJavadoc":"Vertex removed event. This event is fired after a vertex is removed from\na graph.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 82,col 5)-(line 82,col 23)","fieldName":"vertex","fieldJavadocComment":"\n     * The vertex that this event is related to.\n     ","fieldTokenRange":"protected V vertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"The vertex that this event is related to.\n","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":130,"packageName":"org.jgrapht.event"},{"sourceFileName":"org.jgrapht.alg.TarjanLowestCommonAncestor","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.TarjanLowestCommonAncestor.TarjanLowestCommonAncestor(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 35,col 5)-(line 38,col 5)","constructorJavadocComment":"\n     * Create an instance with a reference to the graph that we will find LCAs\n     * for\n     ","constructorDeclaration":"public TarjanLowestCommonAncestor(Graph<V, E> g)","constructorBody":"{\n    this.g = g;\n}","constructorName":"TarjanLowestCommonAncestor","constructorQualifiedName":"org.jgrapht.alg.TarjanLowestCommonAncestor.TarjanLowestCommonAncestor","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public TarjanLowestCommonAncestor(Graph<V, E> g)\n    {\n        this.g = g;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create an instance with a reference to the graph that we will find LCAs\nfor'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 63,col 5)-(line 145,col 5)","classOrInterfaceTokenRange":"private class Worker\n    {\n        \/\/ The implementation of makeFind as referred to by <block>It uses the\n        \/\/ MakeSet, Find, and Union functions of a disjoint-set forest.\n        \/\/ MakeSet(u) removes u to a singleton set, Find(u) returns the standard\n        \/\/ representative of the set containing u, and Union(u,v) merges the set\n        \/\/ containing u with the set containing v. <\/block>\n        \/\/ (http:\/\/en.wikipedia.org\/wiki\/Tarjan's_off-line_lowest_common_ancestors_algorithm)\n        private UnionFind<V> uf = new UnionFind<V>(Collections.<V>emptySet());\n\n        \/\/ the ancestors. instead of <code>u.ancestor = x<\/code> we do\n        \/\/ <code>ancestors.put(u,x)<\/code>\n        private Map<V, V> ancestors = new HashMap<V, V>();\n\n        \/\/ instead of u.colour = black we do black.add(u)\n        private Set<V> black = new HashSet<V>();\n\n        \/\/ the two vertex that we want to find the LCA for\n        private List<LcaRequestResponse<V>> lrr;\n        private MultiMap<V> lrrMap;\n\n        private Worker(List<LcaRequestResponse<V>> lrr)\n        {\n            this.lrr = lrr;\n            this.lrrMap = new MultiMap<V>();\n\n            \/\/ put in the reverse links from a and b entries back to the\n            \/\/ LcaRequestReponse they're contained in\n            for (LcaRequestResponse<V> r : lrr) {\n                lrrMap.getOrCreate(r.getA()).add(r);\n                lrrMap.getOrCreate(r.getB()).add(r);\n            }\n        }\n\n        \/**\n         * Calculates the LCM as described by\n         * http:\/\/en.wikipedia.org\/wiki\/Tarjan's_off-line_lowest_common_ancestors_algorithm\n         * <code>function TarjanOLCA(u) MakeSet(u); u.ancestor := u; for each v\n         * in u.children do TarjanOLCA(v); Union(u,v); Find(u).ancestor := u;\n         * u.colour := black; for each v such that {u,v} in P do if v.colour ==\n         * black print \"Tarjan's Lowest Common Ancestor of \" + u + \" and \" + v +\n         * \" is \" + Find(v).ancestor + \".\";<\/code>\n         *\n         * @param u the starting node (called recursively)\n         *\n         * @return the LCM if found, if not null\n         *\/\n        private List<V> calculate(final V u)\n        {\n            uf.addElement(u);\n            ancestors.put(u, u);\n            for (E vEdge : g.edgesOf(u)) {\n                if (g.getEdgeSource(vEdge).equals(u)) {\n                    V v = g.getEdgeTarget(vEdge);\n                    calculate(v);\n                    uf.union(u, v);\n                    ancestors.put(uf.find(u), u);\n                }\n            }\n            black.add(u);\n\n            Set<LcaRequestResponse<V>> requestsForNodeU = lrrMap.get(u);\n            if (requestsForNodeU != null) {\n                for (LcaRequestResponse<V> rr : requestsForNodeU) {\n                    if (black.contains(rr.getB()) && rr.getA().equals(u)) {\n                        rr.setLca(ancestors.get(uf.find(rr.getB())));\n                    }\n                    if (black.contains(rr.getA()) && rr.getB().equals(u)) {\n                        rr.setLca(ancestors.get(uf.find(rr.getA())));\n                    }\n                }\n\n                \/\/ once we've dealt with it - remove it (to save memory?)\n                lrrMap.remove(u);\n            }\n\n            List<V> result = new LinkedList<V>();\n            for (LcaRequestResponse<V> current : lrr) {\n                result.add(current.getLca());\n            }\n            return result;\n        }\n    }","classOrInterfaceJavadocComment":" The worker class keeps the state whilst doing calculations. ","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 147,col 5)-(line 176,col 5)","classOrInterfaceTokenRange":"public static class LcaRequestResponse<V>\n    {\n        private V a, b, lca;\n\n        public LcaRequestResponse(V a, V b)\n        {\n            this.a = a;\n            this.b = b;\n        }\n\n        public V getA()\n        {\n            return a;\n        }\n\n        public V getB()\n        {\n            return b;\n        }\n\n        public V getLca()\n        {\n            return lca;\n        }\n\n        void setLca(V lca)\n        {\n            this.lca = lca;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 178,col 5)-(line 189,col 5)","classOrInterfaceTokenRange":"@SuppressWarnings(\"serial\")\n    private static final class MultiMap<V>\n        extends HashMap<V, Set<LcaRequestResponse<V>>>\n    {\n        public Set<LcaRequestResponse<V>> getOrCreate(V key)\n        {\n            if (!containsKey(key)) {\n                put(key, new HashSet<LcaRequestResponse<V>>());\n            }\n            return get(key);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public V calculate(V start, V a, V b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<LcaRequestResponse<V>> list = new LinkedList<LcaRequestResponse<V>>();\n    list.add(new LcaRequestResponse<V>(a, b));\n    return calculate(start, list).get(0);\n}","methodRange":"(line 44,col 5)-(line 50,col 5)","methodTokenRange":"public V calculate(V start, V a, V b)\n    {\n        List<LcaRequestResponse<V>> list =\n            new LinkedList<LcaRequestResponse<V>>();\n        list.add(new LcaRequestResponse<V>(a, b));\n        return calculate(start, list).get(0);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Calculate the LCM between <code>a<\/code> and <code>b<\/code> treating\n     * <code>start<\/code> as the root we want to search from.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V start","parameterName":"start"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"calculate","methodQualifiedSignature":"org.jgrapht.alg.TarjanLowestCommonAncestor.calculate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculate the LCM between <code>a<\/code> and <code>b<\/code> treating\n<code>start<\/code> as the root we want to search from.'}]}, blockTags=[]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 49,col 43)-(line 49,col 43)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.TarjanLowestCommonAncestor.calculate(V, V, V)"},{"javadocBlockTags":[],"methodDeclaration":"public List<V> calculate(V start, List<LcaRequestResponse<V>> lrr)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new Worker(lrr).calculate(start);\n}","methodRange":"(line 57,col 5)-(line 60,col 5)","methodTokenRange":"public List<V> calculate(V start, List<LcaRequestResponse<V>> lrr)\n    {\n        return new Worker(lrr).calculate(start);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Calculate the LCMs between a set of pairs (<code>a<\/code> and <code>\n     * b<\/code>) treating <code>start<\/code> as the root we want to search from,\n     * and setting the LCA of each pair in its LCA field\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V start","parameterName":"start"},{"parameterType":"List<LcaRequestResponse<V>>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.alg.TarjanLowestCommonAncestor.LcaRequestResponse, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.TarjanLowestCommonAncestor.LcaRequestResponse.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","parameterTypeResolvedDescribed":"java.util.List<org.jgrapht.alg.TarjanLowestCommonAncestor.LcaRequestResponse<V>>","parameter":"List<LcaRequestResponse<V>> lrr","parameterName":"lrr"}],"methodName":"calculate","methodQualifiedSignature":"org.jgrapht.alg.TarjanLowestCommonAncestor.calculate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculate the LCMs between a set of pairs (<code>a<\/code> and <code>\nb<\/code>) treating <code>start<\/code> as the root we want to search from,\nand setting the LCA of each pair in its LCA field'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.TarjanLowestCommonAncestor.calculate(V, java.util.List<org.jgrapht.alg.TarjanLowestCommonAncestor.LcaRequestResponse<V>>)"}],"classJavadoc":"","className":"TarjanLowestCommonAncestor","fields":[{"fieldRange":"(line 29,col 5)-(line 29,col 26)","fieldName":"g","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> g;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"}]}],"sourceFileId":131,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.PrimMinimumSpanningTree","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"PrimMinimumSpanningTree","constructorQualifiedName":"org.jgrapht.alg.PrimMinimumSpanningTree.PrimMinimumSpanningTree","constructorQualifiedSignature":"org.jgrapht.alg.PrimMinimumSpanningTree.PrimMinimumSpanningTree(org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 90,col 54)-(line 90,col 57)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 119,col 37)-(line 119,col 37)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public PrimMinimumSpanningTree(final Graph<V, E> g)\n    {\n        this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());\n\n        Set<V> unspanned = new HashSet<V>(g.vertexSet());\n\n        while (!unspanned.isEmpty()) {\n            Iterator<V> ri = unspanned.iterator();\n\n            V root = ri.next();\n\n            ri.remove();\n\n            \/\/ Edges crossing the cut C = (S, V \\ S), where S is set of\n            \/\/ already spanned vertices\n\n            PriorityQueue<E> dangling =\n                new PriorityQueue<E>(\n                    g.edgeSet().size(),\n                    new Comparator<E>() {\n                        @Override public int compare(E lop, E rop)\n                        {\n                            return Double.valueOf(g.getEdgeWeight(lop))\n                                .compareTo(g.getEdgeWeight(rop));\n                        }\n                    });\n\n            dangling.addAll(g.edgesOf(root));\n\n            for (E next; (next = dangling.poll()) != null;) {\n                V s,\n                    t =\n                        unspanned.contains(s = g.getEdgeSource(next)) ? s\n                        : g.getEdgeTarget(next);\n\n                \/\/ Decayed edges aren't removed from priority-queue so that\n                \/\/ having them just ignored being encountered through min-max\n                \/\/ traversal\n                if (!unspanned.contains(t)) {\n                    continue;\n                }\n\n                this.minimumSpanningTreeEdgeSet.add(next);\n\n                unspanned.remove(t);\n\n                for (E e : g.edgesOf(t)) {\n                    if (unspanned.contains(\n                            g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(\n                                e)\n                            : g.getEdgeSource(e)))\n                    {\n                        dangling.add(e);\n                    }\n                }\n            }\n        }\n\n        double spanningTreeWeight = 0;\n        for (E e : minimumSpanningTreeEdgeSet) {\n            spanningTreeWeight += g.getEdgeWeight(e);\n        }\n\n        this.minimumSpanningTreeTotalWeight = spanningTreeWeight;\n    }","variableDeclarationExprs":[{"variableType":"Set<V>","variableName":"unspanned","variableDeclarationExprId":1,"variableDeclarationExpr":"Set<V> unspanned = new HashSet<V>(g.vertexSet())","variableDeclarationExprRange":"(line 65,col 9)-(line 65,col 56)","variableTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 65,col 16)-(line 65,col 56)"},{"variableType":"Iterator<V>","variableName":"ri","variableDeclarationExprId":2,"variableDeclarationExpr":"Iterator<V> ri = unspanned.iterator()","variableDeclarationExprRange":"(line 68,col 13)-(line 68,col 49)","variableTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 68,col 25)-(line 68,col 49)"},{"variableType":"V","variableName":"root","variableDeclarationExprId":3,"variableDeclarationExpr":"V root = ri.next()","variableDeclarationExprRange":"(line 70,col 13)-(line 70,col 30)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 70,col 15)-(line 70,col 30)"},{"variableType":"PriorityQueue<E>","variableName":"dangling","variableDeclarationExprId":4,"variableDeclarationExpr":"PriorityQueue<E> dangling = new PriorityQueue<E>(g.edgeSet().size(), new Comparator<E>() {\n\n    @Override\n    public int compare(E lop, E rop) {\n        return Double.valueOf(g.getEdgeWeight(lop)).compareTo(g.getEdgeWeight(rop));\n    }\n})","variableDeclarationExprRange":"(line 77,col 13)-(line 86,col 22)","variableTypeResolved":"ReferenceType{java.util.PriorityQueue, typeParametersMap=TypeParametersMap{nameToValue={java.util.PriorityQueue.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","variableRange":"(line 77,col 30)-(line 86,col 22)"},{"variableType":"E","variableName":"next","variableDeclarationExprId":5,"variableDeclarationExpr":"E next","variableDeclarationExprRange":"(line 90,col 18)-(line 90,col 23)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 90,col 20)-(line 90,col 23)"},{"variableType":"V","variableName":"t","variableDeclarationExprId":6,"variableDeclarationExpr":"V s, t = unspanned.contains(s = g.getEdgeSource(next)) ? s : g.getEdgeTarget(next)","variableDeclarationExprRange":"(line 91,col 17)-(line 94,col 47)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 92,col 21)-(line 94,col 47)"},{"variableType":"E","variableName":"e","variableDeclarationExprId":7,"variableDeclarationExpr":"E e","variableDeclarationExprRange":"(line 107,col 22)-(line 107,col 24)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 107,col 24)-(line 107,col 24)"},{"variableType":"double","variableName":"spanningTreeWeight","variableDeclarationExprId":8,"variableDeclarationExpr":"double spanningTreeWeight = 0","variableDeclarationExprRange":"(line 119,col 9)-(line 119,col 37)","variableTypeResolved":"PrimitiveTypeUsage{name='double'}","variableRange":"(line 119,col 16)-(line 119,col 37)"},{"variableType":"E","variableName":"e","variableDeclarationExprId":9,"variableDeclarationExpr":"E e","variableDeclarationExprRange":"(line 120,col 14)-(line 120,col 16)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 120,col 16)-(line 120,col 16)"}],"constructorRange":"(line 61,col 5)-(line 125,col 5)","constructorJavadocComment":"","constructorDeclaration":"public PrimMinimumSpanningTree(final Graph<V, E> g)","constructorBody":"{\n    this.minimumSpanningTreeEdgeSet = new HashSet<E>(g.vertexSet().size());\n    Set<V> unspanned = new HashSet<V>(g.vertexSet());\n    while (!unspanned.isEmpty()) {\n        Iterator<V> ri = unspanned.iterator();\n        V root = ri.next();\n        ri.remove();\n        PriorityQueue<E> dangling = new PriorityQueue<E>(g.edgeSet().size(), new Comparator<E>() {\n\n            @Override\n            public int compare(E lop, E rop) {\n                return Double.valueOf(g.getEdgeWeight(lop)).compareTo(g.getEdgeWeight(rop));\n            }\n        });\n        dangling.addAll(g.edgesOf(root));\n        for (E next; (next = dangling.poll()) != null; ) {\n            V s, t = unspanned.contains(s = g.getEdgeSource(next)) ? s : g.getEdgeTarget(next);\n            if (!unspanned.contains(t)) {\n                continue;\n            }\n            this.minimumSpanningTreeEdgeSet.add(next);\n            unspanned.remove(t);\n            for (E e : g.edgesOf(t)) {\n                if (unspanned.contains(g.getEdgeSource(e).equals(t) ? g.getEdgeTarget(e) : g.getEdgeSource(e))) {\n                    dangling.add(e);\n                }\n            }\n        }\n    }\n    double spanningTreeWeight = 0;\n    for (E e : minimumSpanningTreeEdgeSet) {\n        spanningTreeWeight += g.getEdgeWeight(e);\n    }\n    this.minimumSpanningTreeTotalWeight = spanningTreeWeight;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public Set<E> getMinimumSpanningTreeEdgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return Collections.unmodifiableSet(minimumSpanningTreeEdgeSet);\n}","methodRange":"(line 127,col 5)-(line 130,col 5)","methodTokenRange":"@Override public Set<E> getMinimumSpanningTreeEdgeSet()\n    {\n        return Collections.unmodifiableSet(minimumSpanningTreeEdgeSet);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getMinimumSpanningTreeEdgeSet","methodQualifiedSignature":"org.jgrapht.alg.PrimMinimumSpanningTree.getMinimumSpanningTreeEdgeSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.PrimMinimumSpanningTree.getMinimumSpanningTreeEdgeSet()"},{"methodDeclaration":"public double getMinimumSpanningTreeTotalWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return minimumSpanningTreeTotalWeight;\n}","methodRange":"(line 132,col 5)-(line 135,col 5)","methodTokenRange":"@Override public double getMinimumSpanningTreeTotalWeight()\n    {\n        return minimumSpanningTreeTotalWeight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[],"methodName":"getMinimumSpanningTreeTotalWeight","methodQualifiedSignature":"org.jgrapht.alg.PrimMinimumSpanningTree.getMinimumSpanningTreeTotalWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.PrimMinimumSpanningTree.getMinimumSpanningTreeTotalWeight()"}],"classJavadoc":"\/**\n * An implementation of <a href=\"http:\/\/en.wikipedia.org\/wiki\/Prim's_algorithm\">\n * Prim's algorithm<\/a> that finds a minimum spanning tree\/forest subject to\n * connectivity of the supplied weighted undirected graph. The algorithm was\n * developed by Czech mathematician V. Jarnk and later independently by\n * computer scientist Robert C. Prim and rediscovered by E. Dijkstra.\n *\n * @author Alexey Kudinkin\n * @since Mar 5, 2013\n *\/\n","className":"PrimMinimumSpanningTree","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 52)","fieldName":"minimumSpanningTreeEdgeSet","fieldJavadocComment":"\n     * Minimum Spanning-Tree\/Forest edge set\n     ","fieldTokenRange":"private final Set<E> minimumSpanningTreeEdgeSet;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"Minimum Spanning-Tree\/Forest edge set\n","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 59,col 5)-(line 59,col 56)","fieldName":"minimumSpanningTreeTotalWeight","fieldJavadocComment":"\n     * Minimum Spanning-Tree\/Forest edge set overall weight\n     ","fieldTokenRange":"private final double minimumSpanningTreeTotalWeight;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"Minimum Spanning-Tree\/Forest edge set overall weight\n","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":132,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.BlockCutpointGraph","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.BlockCutpointGraph(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[{"variableType":"V","variableName":"s","variableDeclarationExprId":1,"variableDeclarationExpr":"V s = graph.vertexSet().iterator().next()","variableDeclarationExprRange":"(line 108,col 9)-(line 108,col 49)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 108,col 11)-(line 108,col 49)"},{"variableType":"Iterator<V>","variableName":"iter","variableDeclarationExprId":2,"variableDeclarationExpr":"Iterator<V> iter = this.cutpoints.iterator()","variableDeclarationExprRange":"(line 118,col 14)-(line 118,col 57)","variableTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 118,col 26)-(line 118,col 57)"},{"variableType":"V","variableName":"cutpoint","variableDeclarationExprId":3,"variableDeclarationExpr":"V cutpoint = iter.next()","variableDeclarationExprRange":"(line 119,col 13)-(line 119,col 36)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 119,col 15)-(line 119,col 36)"},{"variableType":"UndirectedGraph<V, E>","variableName":"subgraph","variableDeclarationExprId":4,"variableDeclarationExpr":"UndirectedGraph<V, E> subgraph = new SimpleGraph<V, E>(this.graph.getEdgeFactory())","variableDeclarationExprRange":"(line 120,col 13)-(line 121,col 66)","variableTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 120,col 35)-(line 121,col 66)"},{"variableType":"Set<UndirectedGraph<V, E>>","variableName":"biconnectedSubgraphs","variableDeclarationExprId":5,"variableDeclarationExpr":"Set<UndirectedGraph<V, E>> biconnectedSubgraphs = getBiconnectedSubgraphs(cutpoint)","variableDeclarationExprRange":"(line 125,col 13)-(line 126,col 49)","variableTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","variableRange":"(line 125,col 40)-(line 126,col 49)"},{"variableType":"Iterator<UndirectedGraph<V, E>>","variableName":"iterator","variableDeclarationExprId":6,"variableDeclarationExpr":"Iterator<UndirectedGraph<V, E>> iterator = biconnectedSubgraphs.iterator()","variableDeclarationExprRange":"(line 128,col 17)-(line 129,col 51)","variableTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","variableRange":"(line 128,col 49)-(line 129,col 51)"},{"variableType":"UndirectedGraph<V, E>","variableName":"biconnectedSubgraph","variableDeclarationExprId":7,"variableDeclarationExpr":"UndirectedGraph<V, E> biconnectedSubgraph = iterator.next()","variableDeclarationExprRange":"(line 132,col 17)-(line 132,col 75)","variableTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 132,col 39)-(line 132,col 75)"}],"constructorRange":"(line 100,col 5)-(line 137,col 5)","constructorJavadocComment":"\n     * Running time = O(m) where m is the number of edges.\n     ","constructorDeclaration":"public BlockCutpointGraph(UndirectedGraph<V, E> graph)","constructorBody":"{\n    super(DefaultEdge.class);\n    this.graph = graph;\n    this.dfsTree = new SimpleDirectedGraph<V, DefaultEdge>(DefaultEdge.class);\n    V s = graph.vertexSet().iterator().next();\n    this.dfsTree.addVertex(s);\n    dfsVisit(s, s);\n    if (this.dfsTree.edgesOf(s).size() > 1) {\n        this.cutpoints.add(s);\n    } else {\n        this.cutpoints.remove(s);\n    }\n    for (Iterator<V> iter = this.cutpoints.iterator(); iter.hasNext(); ) {\n        V cutpoint = iter.next();\n        UndirectedGraph<V, E> subgraph = new SimpleGraph<V, E>(this.graph.getEdgeFactory());\n        subgraph.addVertex(cutpoint);\n        this.vertex2block.put(cutpoint, subgraph);\n        addVertex(subgraph);\n        Set<UndirectedGraph<V, E>> biconnectedSubgraphs = getBiconnectedSubgraphs(cutpoint);\n        for (Iterator<UndirectedGraph<V, E>> iterator = biconnectedSubgraphs.iterator(); iterator.hasNext(); ) {\n            UndirectedGraph<V, E> biconnectedSubgraph = iterator.next();\n            assert (vertexSet().contains(biconnectedSubgraph));\n            addEdge(subgraph, biconnectedSubgraph);\n        }\n    }\n}","constructorName":"BlockCutpointGraph","constructorQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.BlockCutpointGraph","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 112,col 46)-(line 112,col 46)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public BlockCutpointGraph(UndirectedGraph<V, E> graph)\n    {\n        super(DefaultEdge.class);\n        this.graph = graph;\n\n        this.dfsTree =\n            new SimpleDirectedGraph<V, DefaultEdge>(\n                DefaultEdge.class);\n        V s = graph.vertexSet().iterator().next();\n        this.dfsTree.addVertex(s);\n        dfsVisit(s, s);\n\n        if (this.dfsTree.edgesOf(s).size() > 1) {\n            this.cutpoints.add(s);\n        } else {\n            this.cutpoints.remove(s);\n        }\n\n        for (Iterator<V> iter = this.cutpoints.iterator(); iter.hasNext();) {\n            V cutpoint = iter.next();\n            UndirectedGraph<V, E> subgraph =\n                new SimpleGraph<V, E>(this.graph.getEdgeFactory());\n            subgraph.addVertex(cutpoint);\n            this.vertex2block.put(cutpoint, subgraph);\n            addVertex(subgraph);\n            Set<UndirectedGraph<V, E>> biconnectedSubgraphs =\n                getBiconnectedSubgraphs(cutpoint);\n            for (\n                Iterator<UndirectedGraph<V, E>> iterator =\n                    biconnectedSubgraphs.iterator();\n                iterator.hasNext();)\n            {\n                UndirectedGraph<V, E> biconnectedSubgraph = iterator.next();\n                assert (vertexSet().contains(biconnectedSubgraph));\n                addEdge(subgraph, biconnectedSubgraph);\n            }\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Running time = O(m) where m is the number of edges.'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 296,col 5)-(line 323,col 5)","classOrInterfaceTokenRange":"private class BCGEdge\n        extends DefaultEdge\n    {\n        \/**\n         *\/\n        private static final long serialVersionUID = -5115006161815760059L;\n\n        private V source;\n\n        private V target;\n\n        public BCGEdge(V source, V target)\n        {\n            super();\n            this.source = source;\n            this.target = target;\n        }\n\n        @Override public V getSource()\n        {\n            return this.source;\n        }\n\n        @Override public V getTarget()\n        {\n            return this.target;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 325,col 5)-(line 349,col 5)","classOrInterfaceTokenRange":"private class VertexComponentForbiddenFunction\n        implements MaskFunctor<V, E>\n    {\n        private Set<V> vertexComponent;\n\n        public VertexComponentForbiddenFunction(Set<V> vertexComponent)\n        {\n            this.vertexComponent = vertexComponent;\n        }\n\n        @Override public boolean isEdgeMasked(E edge)\n        {\n            return false;\n        }\n\n        @Override public boolean isVertexMasked(V vertex)\n        {\n            if (this.vertexComponent.contains(vertex)) {\n                \/\/ vertex belongs to component then we do not mask it.\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in the initial graph.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in the initial graph.'}]}', name=Optional[vertex]}"}],"methodDeclaration":"public UndirectedGraph<V, E> getBlock(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!this.graph.vertexSet().contains(vertex)) {\n        throw new IllegalArgumentException(\"No such vertex in the graph!\");\n    }\n    return this.vertex2block.get(vertex);\n}","methodRange":"(line 145,col 5)-(line 152,col 5)","methodTokenRange":"public UndirectedGraph<V, E> getBlock(V vertex)\n    {\n        if (!this.graph.vertexSet().contains(vertex)) {\n            throw new IllegalArgumentException(\"No such vertex in the graph!\");\n        }\n\n        return this.vertex2block.get(vertex);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the vertex if vertex is a cutpoint, and otherwise returns the\n     * block (biconnected component) containing the vertex.\n     *\n     * @param vertex vertex in the initial graph.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getBlock","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.getBlock","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the vertex if vertex is a cutpoint, and otherwise returns the\nblock (biconnected component) containing the vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in the initial graph.'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[{"literalExprRange":"(line 148,col 48)-(line 148,col 77)","literalExprId":1,"literalExpr":"\"No such vertex in the graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.getBlock(V)"},{"javadocBlockTags":[],"methodDeclaration":"public Set<V> getCutpoints()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.cutpoints;\n}","methodRange":"(line 157,col 5)-(line 160,col 5)","methodTokenRange":"public Set<V> getCutpoints()\n    {\n        return this.cutpoints;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the cutpoints of the initial graph.\n     ","methodParameters":[],"methodName":"getCutpoints","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.getCutpoints","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the cutpoints of the initial graph.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.getCutpoints()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in the initial graph.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in the initial graph.'}]}', name=Optional[vertex]}"}],"methodDeclaration":"public boolean isCutpoint(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!this.graph.vertexSet().contains(vertex)) {\n        throw new IllegalArgumentException(\"No such vertex in the graph!\");\n    }\n    return this.cutpoints.contains(vertex);\n}","methodRange":"(line 168,col 5)-(line 175,col 5)","methodTokenRange":"public boolean isCutpoint(V vertex)\n    {\n        if (!this.graph.vertexSet().contains(vertex)) {\n            throw new IllegalArgumentException(\"No such vertex in the graph!\");\n        }\n\n        return this.cutpoints.contains(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if the vertex is a cutpoint, <code>false<\/code>\n     * otherwise.\n     *\n     * @param vertex vertex in the initial graph.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"isCutpoint","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.isCutpoint","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if the vertex is a cutpoint, <code>false<\/code>\notherwise.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in the initial graph.'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 171,col 48)-(line 171,col 77)","literalExprId":1,"literalExpr":"\"No such vertex in the graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.isCutpoint(V)"},{"methodDeclaration":"private void biconnectedComponentFinished(V s, V n)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    this.cutpoints.add(s);\n    Set<V> vertexComponent = new HashSet<V>();\n    Set<BCGEdge> edgeComponent = new HashSet<BCGEdge>();\n    BCGEdge edge = this.stack.removeLast();\n    while ((getNumOrder(edge.getSource()) >= getNumOrder(n)) && !this.stack.isEmpty()) {\n        edgeComponent.add(edge);\n        vertexComponent.add(edge.getSource());\n        vertexComponent.add(edge.getTarget());\n        edge = this.stack.removeLast();\n    }\n    edgeComponent.add(edge);\n    vertexComponent.add(edge.getSource());\n    vertexComponent.add(edge.getTarget());\n    VertexComponentForbiddenFunction mask = new VertexComponentForbiddenFunction(vertexComponent);\n    UndirectedGraph<V, E> biconnectedSubgraph = new UndirectedMaskSubgraph<V, E>(this.graph, mask);\n    for (Iterator<V> iter = vertexComponent.iterator(); iter.hasNext(); ) {\n        V vertex = iter.next();\n        this.vertex2block.put(vertex, biconnectedSubgraph);\n        getBiconnectedSubgraphs(vertex).add(biconnectedSubgraph);\n    }\n    addVertex(biconnectedSubgraph);\n}","methodRange":"(line 177,col 5)-(line 214,col 5)","methodTokenRange":"private void biconnectedComponentFinished(V s, V n)\n    {\n        this.cutpoints.add(s);\n\n        Set<V> vertexComponent = new HashSet<V>();\n        Set<BCGEdge> edgeComponent = new HashSet<BCGEdge>();\n        BCGEdge edge = this.stack.removeLast();\n        while (\n            (getNumOrder(edge.getSource()) >= getNumOrder(n))\n            && !this.stack.isEmpty())\n        {\n            edgeComponent.add(edge);\n\n            vertexComponent.add(edge.getSource());\n            vertexComponent.add(edge.getTarget());\n\n            edge = this.stack.removeLast();\n        }\n        edgeComponent.add(edge);\n        \/\/ edgeComponent is an equivalence class.\n\n        vertexComponent.add(edge.getSource());\n        vertexComponent.add(edge.getTarget());\n\n        VertexComponentForbiddenFunction mask =\n            new VertexComponentForbiddenFunction(\n                vertexComponent);\n        UndirectedGraph<V, E> biconnectedSubgraph =\n            new UndirectedMaskSubgraph<V, E>(\n                this.graph,\n                mask);\n        for (Iterator<V> iter = vertexComponent.iterator(); iter.hasNext();) {\n            V vertex = iter.next();\n            this.vertex2block.put(vertex, biconnectedSubgraph);\n            getBiconnectedSubgraphs(vertex).add(biconnectedSubgraph);\n        }\n        addVertex(biconnectedSubgraph);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V s","parameterName":"s"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V n","parameterName":"n"}],"methodName":"biconnectedComponentFinished","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.biconnectedComponentFinished","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.biconnectedComponentFinished(V, V)"},{"methodDeclaration":"private int dfsVisit(V s, V father)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    this.numOrder++;\n    int minS = this.numOrder;\n    setNumOrder(s, this.numOrder);\n    for (Iterator<E> iter = this.graph.edgesOf(s).iterator(); iter.hasNext(); ) {\n        E edge = iter.next();\n        V n = Graphs.getOppositeVertex(this.graph, edge, s);\n        if (getNumOrder(n) == 0) {\n            this.dfsTree.addVertex(n);\n            BCGEdge dfsEdge = new BCGEdge(s, n);\n            this.dfsTree.addEdge(s, n, dfsEdge);\n            this.stack.add(dfsEdge);\n            int minN = dfsVisit(n, s);\n            minS = Math.min(minN, minS);\n            if (minN >= getNumOrder(s)) {\n                biconnectedComponentFinished(s, n);\n            }\n        } else if ((getNumOrder(n) < getNumOrder(s)) && !n.equals(father)) {\n            BCGEdge backwardEdge = new BCGEdge(s, n);\n            this.stack.add(backwardEdge);\n            minS = Math.min(getNumOrder(n), minS);\n        }\n    }\n    return minS;\n}","methodRange":"(line 216,col 5)-(line 256,col 5)","methodTokenRange":"private int dfsVisit(V s, V father)\n    {\n        this.numOrder++;\n        int minS = this.numOrder;\n        setNumOrder(s, this.numOrder);\n\n        for (\n            Iterator<E> iter = this.graph.edgesOf(s).iterator();\n            iter.hasNext();)\n        {\n            E edge = iter.next();\n            V n = Graphs.getOppositeVertex(this.graph, edge, s);\n            if (getNumOrder(n) == 0) {\n                this.dfsTree.addVertex(n);\n                BCGEdge dfsEdge = new BCGEdge(s, n);\n                this.dfsTree.addEdge(s, n, dfsEdge);\n\n                this.stack.add(dfsEdge);\n\n                \/\/ minimum of the traverse orders of the \"attach points\" of\n                \/\/ the vertex n.\n                int minN = dfsVisit(n, s);\n                minS = Math.min(minN, minS);\n                if (minN >= getNumOrder(s)) {\n                    \/\/ s is a cutpoint.\n                    \/\/ it has a son whose \"attach depth\" is greater or equal.\n                    biconnectedComponentFinished(s, n);\n                }\n            } else if ((getNumOrder(n) < getNumOrder(s)) && !n.equals(father)) {\n                BCGEdge backwardEdge = new BCGEdge(s, n);\n                this.stack.add(backwardEdge);\n\n                \/\/ n is an \"attach point\" of s. {s->n} is a backward edge.\n                minS = Math.min(getNumOrder(n), minS);\n            }\n        }\n\n        \/\/ minimum of the traverse orders of the \"attach points\" of\n        \/\/ the vertex s.\n        return minS;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V s","parameterName":"s"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V father","parameterName":"father"}],"methodName":"dfsVisit","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.dfsVisit","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 228,col 35)-(line 228,col 35)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.dfsVisit(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in the initial graph.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in the initial graph.'}]}', name=Optional[vertex]}"}],"methodDeclaration":"private Set<UndirectedGraph<V, E>> getBiconnectedSubgraphs(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<UndirectedGraph<V, E>> biconnectedSubgraphs = this.vertex2biconnectedSubgraphs.get(vertex);\n    if (biconnectedSubgraphs == null) {\n        biconnectedSubgraphs = new HashSet<UndirectedGraph<V, E>>();\n        this.vertex2biconnectedSubgraphs.put(vertex, biconnectedSubgraphs);\n    }\n    return biconnectedSubgraphs;\n}","methodRange":"(line 265,col 5)-(line 274,col 5)","methodTokenRange":"private Set<UndirectedGraph<V, E>> getBiconnectedSubgraphs(V vertex)\n    {\n        Set<UndirectedGraph<V, E>> biconnectedSubgraphs =\n            this.vertex2biconnectedSubgraphs.get(vertex);\n        if (biconnectedSubgraphs == null) {\n            biconnectedSubgraphs = new HashSet<UndirectedGraph<V, E>>();\n            this.vertex2biconnectedSubgraphs.put(vertex, biconnectedSubgraphs);\n        }\n        return biconnectedSubgraphs;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the biconnected components containing the vertex. A vertex which\n     * is not a cutpoint is contained in exactly one component. A cutpoint is\n     * contained is at least 2 components.\n     *\n     * @param vertex vertex in the initial graph.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getBiconnectedSubgraphs","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.getBiconnectedSubgraphs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the biconnected components containing the vertex. A vertex which\nis not a cutpoint is contained in exactly one component. A cutpoint is\ncontained is at least 2 components.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in the initial graph.'}]}', name=Optional[vertex]}]}","methodReturnTypeDescribed":"","methodType":"Set<UndirectedGraph<V, E>>","literalExprs":[{"literalExprRange":"(line 269,col 37)-(line 269,col 40)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.getBiconnectedSubgraphs(V)"},{"javadocBlockTags":[],"methodDeclaration":"private int getNumOrder(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    assert (vertex != null);\n    Integer numOrder = this.vertex2numOrder.get(vertex);\n    if (numOrder == null) {\n        return 0;\n    } else {\n        return numOrder.intValue();\n    }\n}","methodRange":"(line 279,col 5)-(line 289,col 5)","methodTokenRange":"private int getNumOrder(V vertex)\n    {\n        assert (vertex != null);\n\n        Integer numOrder = this.vertex2numOrder.get(vertex);\n        if (numOrder == null) {\n            return 0;\n        } else {\n            return numOrder.intValue();\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the traverse order of the vertex in the DFS.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getNumOrder","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.getNumOrder","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the traverse order of the vertex in the DFS.'}]}, blockTags=[]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 281,col 27)-(line 281,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 284,col 25)-(line 284,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 285,col 20)-(line 285,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.getNumOrder(V)"},{"methodDeclaration":"private void setNumOrder(V vertex, int numOrder)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    this.vertex2numOrder.put(vertex, Integer.valueOf(numOrder));\n}","methodRange":"(line 291,col 5)-(line 294,col 5)","methodTokenRange":"private void setNumOrder(V vertex, int numOrder)\n    {\n        this.vertex2numOrder.put(vertex, Integer.valueOf(numOrder));\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int numOrder","parameterName":"numOrder"}],"methodName":"setNumOrder","methodQualifiedSignature":"org.jgrapht.alg.BlockCutpointGraph.setNumOrder","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BlockCutpointGraph.setNumOrder(V, int)"}],"classJavadoc":"\/**\n * Definition of a <a href=\"http:\/\/mathworld.wolfram.com\/Block.html\">block of a\n * graph<\/a> in MathWorld.<br>\n * Definition and lemma taken from the article <a\n * href=\"http:\/\/www.albany.edu\/~goel\/publications\/rosencrantz2005.pdf\">\n * Structure-Based Resilience Metrics for Service-Oriented Networks<\/a>:\n *\n * <ul>\n * <li><b>Definition 4.5<\/b> Let G(V; E) be a connected undirected graph. The\n * block-cut point graph (BC graph) of G, denoted by GB(VB; EB), is the\n * bipartite graph defined as follows. (a) VB has one node corresponding to each\n * block and one node corresponding to each cut point of G. (b) Each edge fx; yg\n * in EB joins a block node x to a cut point y if the block corresponding to x\n * contains the cut point node corresponding to y.<\/li>\n * <li><b>Lemma 4.4<\/b> Let G(V; E) be a connected undirected graph. (a) Each\n * pair of blocks of G share at most one node, and that node is a cutpoint. (b)\n * The BC graph of G is a tree in which each leaf node corresponds to a block of\n * G.<\/li>\n * <\/ul>\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"BlockCutpointGraph","fields":[{"fieldRange":"(line 74,col 5)-(line 74,col 71)","fieldName":"serialVersionUID","fieldJavadocComment":"\n     ","fieldTokenRange":"private static final long serialVersionUID = -9101341117013163934L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 74,col 51)-(line 74,col 70)","literalExprId":1,"literalExpr":"9101341117013163934L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[-9101341117013163934L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 76,col 5)-(line 76,col 48)","fieldName":"cutpoints","fieldJavadocComment":"","fieldTokenRange":"private Set<V> cutpoints = new HashSet<V>();","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashSet<V>()]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 81,col 5)-(line 81,col 50)","fieldName":"dfsTree","fieldJavadocComment":"\n     * DFS (Depth-First-Search) tree.\n     ","fieldTokenRange":"private DirectedGraph<V, DefaultEdge> dfsTree;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=ReferenceType{org.jgrapht.graph.DefaultEdge, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, DefaultEdge>","fieldJavadoc":"DFS (Depth-First-Search) tree.\n","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, org.jgrapht.graph.DefaultEdge>"},{"fieldRange":"(line 83,col 5)-(line 83,col 40)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private UndirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 85,col 5)-(line 85,col 25)","fieldName":"numOrder","fieldJavadocComment":"","fieldTokenRange":"private int numOrder;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 87,col 5)-(line 87,col 61)","fieldName":"stack","fieldJavadocComment":"","fieldTokenRange":"private Deque<BCGEdge> stack = new ArrayDeque<BCGEdge>();","fieldTypeResolved":"ReferenceType{java.util.Deque, typeParametersMap=TypeParametersMap{nameToValue={java.util.Deque.E=ReferenceType{org.jgrapht.alg.BlockCutpointGraph.BCGEdge, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayDeque<BCGEdge>()]","fieldType":"Deque<BCGEdge>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Deque<org.jgrapht.alg.BlockCutpointGraph.BCGEdge>"},{"fieldRange":"(line 89,col 5)-(line 90,col 53)","fieldName":"vertex2biconnectedSubgraphs","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Set<UndirectedGraph<V, E>>> vertex2biconnectedSubgraphs =\n        new HashMap<V, Set<UndirectedGraph<V, E>>>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, Set<UndirectedGraph<V, E>>>()]","fieldType":"Map<V, Set<UndirectedGraph<V, E>>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.Set<org.jgrapht.UndirectedGraph<V, E>>>"},{"fieldRange":"(line 92,col 5)-(line 93,col 48)","fieldName":"vertex2block","fieldJavadocComment":"","fieldTokenRange":"private Map<V, UndirectedGraph<V, E>> vertex2block =\n        new HashMap<V, UndirectedGraph<V, E>>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, UndirectedGraph<V, E>>()]","fieldType":"Map<V, UndirectedGraph<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.UndirectedGraph<V, E>>"},{"fieldRange":"(line 95,col 5)-(line 95,col 72)","fieldName":"vertex2numOrder","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vertex2numOrder = new HashMap<V, Integer>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, Integer>()]","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"}]}],"sourceFileId":133,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.AllDirectedPaths","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"AllDirectedPaths","constructorQualifiedName":"org.jgrapht.alg.AllDirectedPaths.AllDirectedPaths","constructorQualifiedSignature":"org.jgrapht.alg.AllDirectedPaths.AllDirectedPaths(org.jgrapht.DirectedGraph<V, E>)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 59,col 22)-(line 59,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 60,col 48)-(line 60,col 70)","literalExprId":2,"literalExpr":"\"Graph cannot be null!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public AllDirectedPaths(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Graph cannot be null!\");\n        }\n\n        this.graph = graph;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 57,col 5)-(line 64,col 5)","constructorJavadocComment":"","constructorDeclaration":"public AllDirectedPaths(DirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Graph cannot be null!\");\n    }\n    this.graph = graph;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source vertex","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertex'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the target vertex","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertex'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, only search simple\n(non-self-intersecting) paths","javadocBlockTagName":"simplePathsOnly","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, only search simple\n(non-self-intersecting) paths'}]}', name=Optional[simplePathsOnly]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)","javadocBlockTagName":"maxPathLength","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)'}]}', name=Optional[maxPathLength]}"}],"methodDeclaration":"public List<GraphPath<V, E>> getAllPaths(V sourceVertex, V targetVertex, boolean simplePathsOnly, Integer maxPathLength)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getAllPaths(Collections.singleton(sourceVertex), Collections.singleton(targetVertex), simplePathsOnly, maxPathLength);\n}","methodRange":"(line 78,col 5)-(line 89,col 5)","methodTokenRange":"public List<GraphPath<V, E>> getAllPaths(\n        V sourceVertex,\n        V targetVertex,\n        boolean simplePathsOnly,\n        Integer maxPathLength)\n    {\n        return getAllPaths(\n            Collections.singleton(sourceVertex),\n            Collections.singleton(targetVertex),\n            simplePathsOnly,\n            maxPathLength);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Calculate (and return) all paths from the source vertex to the target\n     * vertex.\n     *\n     * @param sourceVertex the source vertex\n     * @param targetVertex the target vertex\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean simplePathsOnly","parameterName":"simplePathsOnly"},{"parameterType":"Integer","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer maxPathLength","parameterName":"maxPathLength"}],"methodName":"getAllPaths","methodQualifiedSignature":"org.jgrapht.alg.AllDirectedPaths.getAllPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculate (and return) all paths from the source vertex to the target\nvertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertex'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertex'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, only search simple\n(non-self-intersecting) paths'}]}', name=Optional[simplePathsOnly]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)'}]}', name=Optional[maxPathLength]}]}","methodReturnTypeDescribed":"","methodType":"List<GraphPath<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AllDirectedPaths.getAllPaths(V, V, boolean, java.lang.Integer)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source vertices","javadocBlockTagName":"sourceVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertices'}]}', name=Optional[sourceVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the target vertices","javadocBlockTagName":"targetVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertices'}]}', name=Optional[targetVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, only search simple\n(non-self-intersecting) paths","javadocBlockTagName":"simplePathsOnly","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, only search simple\n(non-self-intersecting) paths'}]}', name=Optional[simplePathsOnly]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)","javadocBlockTagName":"maxPathLength","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)'}]}', name=Optional[maxPathLength]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of all paths from the sources to the targets containing no\nmore than maxPathLength edges","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of all paths from the sources to the targets containing no\nmore than maxPathLength edges'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<GraphPath<V, E>> getAllPaths(Set<V> sourceVertices, Set<V> targetVertices, boolean simplePathsOnly, Integer maxPathLength)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if ((maxPathLength != null) && (maxPathLength < 0)) {\n        throw new IllegalArgumentException(\"maxPathLength must be non-negative if defined\");\n    }\n    if (!simplePathsOnly && (maxPathLength == null)) {\n        throw new IllegalArgumentException(\"If search is not restricted to simple paths, a maximum path length must be set to avoid infinite cycles\");\n    }\n    if ((sourceVertices.isEmpty()) || (targetVertices.isEmpty())) {\n        return new ArrayList();\n    }\n    Map<E, Integer> edgeMinDistancesFromTargets = edgeMinDistancesBackwards(targetVertices, maxPathLength);\n    List<GraphPath<V, E>> allPaths = generatePaths(sourceVertices, targetVertices, simplePathsOnly, maxPathLength, edgeMinDistancesFromTargets);\n    return allPaths;\n}","methodRange":"(line 106,col 5)-(line 140,col 5)","methodTokenRange":"public List<GraphPath<V, E>> getAllPaths(\n        Set<V> sourceVertices,\n        Set<V> targetVertices,\n        boolean simplePathsOnly,\n        Integer maxPathLength)\n    {\n        if ((maxPathLength != null) && (maxPathLength < 0)) {\n            throw new IllegalArgumentException(\n                \"maxPathLength must be non-negative if defined\");\n        }\n\n        if (!simplePathsOnly && (maxPathLength == null)) {\n            throw new IllegalArgumentException(\n                \"If search is not restricted to simple paths, a maximum path length must be set to avoid infinite cycles\");\n        }\n\n        if ((sourceVertices.isEmpty()) || (targetVertices.isEmpty())) {\n            return new ArrayList();\n        }\n\n        \/\/ Decorate the edges with the minimum path lengths through them\n        Map<E, Integer> edgeMinDistancesFromTargets =\n            edgeMinDistancesBackwards(targetVertices, maxPathLength);\n\n        \/\/ Generate all the paths\n        List<GraphPath<V, E>> allPaths =\n            generatePaths(\n                sourceVertices,\n                targetVertices,\n                simplePathsOnly,\n                maxPathLength,\n                edgeMinDistancesFromTargets);\n\n        return allPaths;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Calculate (and return) all paths from the source vertices to the target\n     * vertices.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all paths are considered, which may be very slow due to potentially huge\n     * output)\n     *\n     * @return list of all paths from the sources to the targets containing no\n     * more than maxPathLength edges\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> sourceVertices","parameterName":"sourceVertices"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> targetVertices","parameterName":"targetVertices"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean simplePathsOnly","parameterName":"simplePathsOnly"},{"parameterType":"Integer","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer maxPathLength","parameterName":"maxPathLength"}],"methodName":"getAllPaths","methodQualifiedSignature":"org.jgrapht.alg.AllDirectedPaths.getAllPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculate (and return) all paths from the source vertices to the target\nvertices.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertices'}]}', name=Optional[sourceVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertices'}]}', name=Optional[targetVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, only search simple\n(non-self-intersecting) paths'}]}', name=Optional[simplePathsOnly]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path (if null,\nall paths are considered, which may be very slow due to potentially huge\noutput)'}]}', name=Optional[maxPathLength]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of all paths from the sources to the targets containing no\nmore than maxPathLength edges'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<GraphPath<V, E>>","literalExprs":[{"literalExprRange":"(line 112,col 31)-(line 112,col 34)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 112,col 57)-(line 112,col 57)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 114,col 17)-(line 114,col 63)","literalExprId":3,"literalExpr":"\"maxPathLength must be non-negative if defined\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 117,col 51)-(line 117,col 54)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 119,col 17)-(line 119,col 121)","literalExprId":5,"literalExpr":"\"If search is not restricted to simple paths, a maximum path length must be set to avoid infinite cycles\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AllDirectedPaths.getAllPaths(java.util.Set<V>, java.util.Set<V>, boolean, java.lang.Integer)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the target vertices","javadocBlockTagName":"targetVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertices'}]}', name=Optional[targetVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges to allow in a path (if null,\nall edges will be considered, which may be expensive)","javadocBlockTagName":"maxPathLength","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path (if null,\nall edges will be considered, which may be expensive)'}]}', name=Optional[maxPathLength]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the minimum number of edges in a path from each edge to the\ntargets, encoded in a Map","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the minimum number of edges in a path from each edge to the\ntargets, encoded in a Map'}]}', name=Optional.empty}"}],"methodDeclaration":"private Map<E, Integer> edgeMinDistancesBackwards(Set<V> targetVertices, Integer maxPathLength)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Map<E, Integer> edgeMinDistances = new HashMap();\n    Map<V, Integer> vertexMinDistances = new HashMap();\n    Queue<V> verticesToProcess = new LinkedList();\n    if (maxPathLength != null) {\n        if (maxPathLength < 0) {\n            throw new IllegalArgumentException(\"maxPathLength must be non-negative if defined\");\n        }\n        if (maxPathLength == 0) {\n            return edgeMinDistances;\n        }\n    }\n    for (V target : targetVertices) {\n        vertexMinDistances.put(target, 0);\n        verticesToProcess.add(target);\n    }\n    for (V vertex; (vertex = verticesToProcess.poll()) != null; ) {\n        assert vertexMinDistances.containsKey(vertex);\n        Integer childDistance = vertexMinDistances.get(vertex) + 1;\n        for (E edge : graph.incomingEdgesOf(vertex)) {\n            if (!edgeMinDistances.containsKey(edge) || (edgeMinDistances.get(edge) > childDistance)) {\n                edgeMinDistances.put(edge, childDistance);\n            }\n            V edgeSource = graph.getEdgeSource(edge);\n            if (!vertexMinDistances.containsKey(edgeSource) || (vertexMinDistances.get(edgeSource) > childDistance)) {\n                vertexMinDistances.put(edgeSource, childDistance);\n                if ((maxPathLength == null) || (childDistance < maxPathLength)) {\n                    verticesToProcess.add(edgeSource);\n                }\n            }\n        }\n    }\n    assert verticesToProcess.isEmpty();\n    return edgeMinDistances;\n}","methodRange":"(line 153,col 5)-(line 217,col 5)","methodTokenRange":"private Map<E, Integer> edgeMinDistancesBackwards(\n        Set<V> targetVertices,\n        Integer maxPathLength)\n    {\n        \/*\n         * We walk backwards through the network from the target\n         * vertices, marking edges and vertices with their minimum\n         * distances as we go.\n         *\/\n        Map<E, Integer> edgeMinDistances = new HashMap();\n        Map<V, Integer> vertexMinDistances = new HashMap();\n        Queue<V> verticesToProcess = new LinkedList();\n\n        \/\/ Input sanity checking\n        if (maxPathLength != null) {\n            if (maxPathLength < 0) {\n                throw new IllegalArgumentException(\n                    \"maxPathLength must be non-negative if defined\");\n            }\n            if (maxPathLength == 0) {\n                return edgeMinDistances;\n            }\n        }\n\n        \/\/ Bootstrap the process with the target vertices\n        for (V target : targetVertices) {\n            vertexMinDistances.put(target, 0);\n            verticesToProcess.add(target);\n        }\n\n        \/\/ Work through the node queue. When it's empty, we're done!\n        for (V vertex; (vertex = verticesToProcess.poll()) != null;) {\n            assert vertexMinDistances.containsKey(vertex);\n\n            Integer childDistance = vertexMinDistances.get(vertex) + 1;\n\n            \/\/ Check whether the incoming edges of this node are correctly\n            \/\/ decorated\n            for (E edge : graph.incomingEdgesOf(vertex)) {\n                \/\/ Mark the edge if needed\n                if (!edgeMinDistances.containsKey(edge)\n                    || (edgeMinDistances.get(edge) > childDistance))\n                {\n                    edgeMinDistances.put(edge, childDistance);\n                }\n\n                \/\/ Mark the edge's source vertex if needed\n                V edgeSource = graph.getEdgeSource(edge);\n                if (!vertexMinDistances.containsKey(edgeSource)\n                    || (vertexMinDistances.get(edgeSource) > childDistance))\n                {\n                    vertexMinDistances.put(edgeSource, childDistance);\n\n                    if ((maxPathLength == null)\n                        || (childDistance < maxPathLength))\n                    {\n                        verticesToProcess.add(edgeSource);\n                    }\n                }\n            }\n        }\n\n        assert verticesToProcess.isEmpty();\n        return edgeMinDistances;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n     * Compute the minimum number of edges in a path to the targets through each\n     * edge, so long as it is not greater than a bound.\n     *\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path (if null,\n     * all edges will be considered, which may be expensive)\n     *\n     * @return the minimum number of edges in a path from each edge to the\n     * targets, encoded in a Map\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> targetVertices","parameterName":"targetVertices"},{"parameterType":"Integer","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer maxPathLength","parameterName":"maxPathLength"}],"methodName":"edgeMinDistancesBackwards","methodQualifiedSignature":"org.jgrapht.alg.AllDirectedPaths.edgeMinDistancesBackwards","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compute the minimum number of edges in a path to the targets through each\nedge, so long as it is not greater than a bound.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertices'}]}', name=Optional[targetVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path (if null,\nall edges will be considered, which may be expensive)'}]}', name=Optional[maxPathLength]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the minimum number of edges in a path from each edge to the\ntargets, encoded in a Map'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Map<E, java.lang.Integer>","methodType":"Map<E, Integer>","literalExprs":[{"literalExprRange":"(line 167,col 30)-(line 167,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 168,col 33)-(line 168,col 33)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 170,col 21)-(line 170,col 67)","literalExprId":3,"literalExpr":"\"maxPathLength must be non-negative if defined\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 172,col 34)-(line 172,col 34)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 44)-(line 179,col 44)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 184,col 63)-(line 184,col 66)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 187,col 70)-(line 187,col 70)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 206,col 43)-(line 206,col 46)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AllDirectedPaths.edgeMinDistancesBackwards(java.util.Set<V>, java.lang.Integer)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the source vertices","javadocBlockTagName":"sourceVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertices'}]}', name=Optional[sourceVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the target vertices","javadocBlockTagName":"targetVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertices'}]}', name=Optional[targetVertices]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges to allow in a path","javadocBlockTagName":"maxPathLength","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path'}]}', name=Optional[maxPathLength]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, only search simple\n(non-self-intersecting) paths (if null, all edges will be considered,\nwhich may be expensive)","javadocBlockTagName":"simplePathsOnly","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, only search simple\n(non-self-intersecting) paths (if null, all edges will be considered,\nwhich may be expensive)'}]}', name=Optional[simplePathsOnly]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the minimum number of edges in a path\nto a target through each edge, as computed by {@code\nedgeMinDistancesBackwards}.","javadocBlockTagName":"edgeMinDistancesFromTargets","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the minimum number of edges in a path\nto a target through each edge, as computed by '}, JavadocInlineTag{tagName='code', type=CODE, content='\nedgeMinDistancesBackwards'}, JavadocSnippet{text='.'}]}', name=Optional[edgeMinDistancesFromTargets]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a List of all GraphPaths from the sources to the targets\nsatisfying the given constraints","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a List of all GraphPaths from the sources to the targets\nsatisfying the given constraints'}]}', name=Optional.empty}"}],"methodDeclaration":"private List<GraphPath<V, E>> generatePaths(Set<V> sourceVertices, Set<V> targetVertices, boolean simplePathsOnly, Integer maxPathLength, Map<E, Integer> edgeMinDistancesFromTargets)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<GraphPath<V, E>> completePaths = new ArrayList();\n    Deque<List<E>> incompletePaths = new LinkedList();\n    if (maxPathLength != null) {\n        if (maxPathLength < 0) {\n            throw new IllegalArgumentException(\"maxPathLength must be non-negative if defined\");\n        }\n        if (maxPathLength == 0) {\n            return completePaths;\n        }\n    }\n    for (V source : sourceVertices) {\n        for (E edge : graph.outgoingEdgesOf(source)) {\n            assert graph.getEdgeSource(edge).equals(source);\n            if (edgeMinDistancesFromTargets.containsKey(edge)) {\n                List<E> path = Arrays.asList(edge);\n                incompletePaths.add(path);\n            }\n        }\n    }\n    for (List<E> incompletePath; (incompletePath = incompletePaths.poll()) != null; ) {\n        Integer lengthSoFar = incompletePath.size();\n        assert (maxPathLength == null) || (lengthSoFar < maxPathLength);\n        E leafEdge = incompletePath.get(lengthSoFar - 1);\n        V leafNode = graph.getEdgeTarget(leafEdge);\n        Set<V> pathVertices = new HashSet();\n        for (E pathEdge : incompletePath) {\n            pathVertices.add(graph.getEdgeSource(pathEdge));\n            pathVertices.add(graph.getEdgeTarget(pathEdge));\n        }\n        for (E outEdge : graph.outgoingEdgesOf(leafNode)) {\n            if (edgeMinDistancesFromTargets.containsKey(outEdge) && ((maxPathLength == null) || ((edgeMinDistancesFromTargets.get(outEdge) + lengthSoFar) <= maxPathLength))) {\n                List<E> newPath = new ArrayList(incompletePath);\n                newPath.add(outEdge);\n                if (simplePathsOnly && pathVertices.contains(graph.getEdgeTarget(outEdge))) {\n                    continue;\n                }\n                if (targetVertices.contains(graph.getEdgeTarget(outEdge))) {\n                    GraphPath<V, E> completePath = makePath(newPath);\n                    assert sourceVertices.contains(completePath.getStartVertex());\n                    assert targetVertices.contains(completePath.getEndVertex());\n                    assert (maxPathLength == null) || (completePath.getWeight() <= maxPathLength);\n                    completePaths.add(completePath);\n                }\n                if ((maxPathLength == null) || (newPath.size() < maxPathLength)) {\n                    incompletePaths.addFirst(newPath);\n                }\n            }\n        }\n    }\n    assert incompletePaths.isEmpty();\n    return completePaths;\n}","methodRange":"(line 236,col 5)-(line 338,col 5)","methodTokenRange":"private List<GraphPath<V, E>> generatePaths(\n        Set<V> sourceVertices,\n        Set<V> targetVertices,\n        boolean simplePathsOnly,\n        Integer maxPathLength,\n        Map<E, Integer> edgeMinDistancesFromTargets)\n    {\n        \/*\n         * We walk forwards through the network from the source\n         * vertices, exploring all outgoing edges whose minimum\n         * distances is small enough.\n         *\/\n        List<GraphPath<V, E>> completePaths = new ArrayList();\n        Deque<List<E>> incompletePaths = new LinkedList();\n\n        \/\/ Input sanity checking\n        if (maxPathLength != null) {\n            if (maxPathLength < 0) {\n                throw new IllegalArgumentException(\n                    \"maxPathLength must be non-negative if defined\");\n            }\n            if (maxPathLength == 0) {\n                return completePaths;\n            }\n        }\n\n        \/\/ Bootstrap the search with the source vertices\n        for (V source : sourceVertices) {\n            for (E edge : graph.outgoingEdgesOf(source)) {\n                assert graph.getEdgeSource(edge).equals(source);\n\n                if (edgeMinDistancesFromTargets.containsKey(edge)) {\n                    List<E> path = Arrays.asList(edge);\n                    incompletePaths.add(path);\n                }\n            }\n        }\n\n        \/\/ Walk through the queue of incomplete paths\n        for (\n            List<E> incompletePath;\n            (incompletePath = incompletePaths.poll()) != null;)\n        {\n            Integer lengthSoFar = incompletePath.size();\n            assert (maxPathLength == null) || (lengthSoFar < maxPathLength);\n\n            E leafEdge = incompletePath.get(lengthSoFar - 1);\n            V leafNode = graph.getEdgeTarget(leafEdge);\n\n            Set<V> pathVertices = new HashSet();\n            for (E pathEdge : incompletePath) {\n                pathVertices.add(graph.getEdgeSource(pathEdge));\n                pathVertices.add(graph.getEdgeTarget(pathEdge));\n            }\n\n            for (E outEdge : graph.outgoingEdgesOf(leafNode)) {\n                \/\/ Proceed if the outgoing edge is marked and the mark\n                \/\/ is sufficiently small\n                if (edgeMinDistancesFromTargets.containsKey(outEdge)\n                    && ((maxPathLength == null)\n                        || ((edgeMinDistancesFromTargets.get(outEdge)\n                                + lengthSoFar) <= maxPathLength)))\n                {\n                    List<E> newPath = new ArrayList(incompletePath);\n                    newPath.add(outEdge);\n\n                    \/\/ If requested, make sure this path isn't self-intersecting\n                    if (simplePathsOnly\n                        && pathVertices.contains(\n                            graph.getEdgeTarget(outEdge)))\n                    {\n                        continue;\n                    }\n\n                    \/\/ If this path reaches a target, add it to completePaths\n                    if (targetVertices.contains(graph.getEdgeTarget(outEdge))) {\n                        GraphPath<V, E> completePath = makePath(newPath);\n                        assert sourceVertices.contains(\n                            completePath.getStartVertex());\n                        assert targetVertices.contains(\n                            completePath.getEndVertex());\n                        assert (maxPathLength == null)\n                            || (completePath.getWeight() <= maxPathLength);\n                        completePaths.add(completePath);\n                    }\n\n                    \/\/ If this path is short enough, consider further\n                    \/\/ extensions of it\n                    if ((maxPathLength == null)\n                        || (newPath.size() < maxPathLength))\n                    {\n                        incompletePaths.addFirst(newPath); \/\/ We use\n                                                           \/\/ incompletePaths in\n                                                           \/\/ FIFO mode to avoid\n                                                           \/\/ memory blowup\n                    }\n                }\n            }\n        }\n\n        assert incompletePaths.isEmpty();\n        return completePaths;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Generate all paths from the sources to the targets, using pre-computed\n     * minimum distances.\n     *\n     * @param sourceVertices the source vertices\n     * @param targetVertices the target vertices\n     * @param maxPathLength maximum number of edges to allow in a path\n     * @param simplePathsOnly if true, only search simple\n     * (non-self-intersecting) paths (if null, all edges will be considered,\n     * which may be expensive)\n     * @param edgeMinDistancesFromTargets the minimum number of edges in a path\n     * to a target through each edge, as computed by {@code\n     * edgeMinDistancesBackwards}.\n     *\n     * @return a List of all GraphPaths from the sources to the targets\n     * satisfying the given constraints\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> sourceVertices","parameterName":"sourceVertices"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> targetVertices","parameterName":"targetVertices"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean simplePathsOnly","parameterName":"simplePathsOnly"},{"parameterType":"Integer","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer maxPathLength","parameterName":"maxPathLength"},{"parameterType":"Map<E, Integer>","parameterId":5,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<E, java.lang.Integer>","parameter":"Map<E, Integer> edgeMinDistancesFromTargets","parameterName":"edgeMinDistancesFromTargets"}],"methodName":"generatePaths","methodQualifiedSignature":"org.jgrapht.alg.AllDirectedPaths.generatePaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Generate all paths from the sources to the targets, using pre-computed\nminimum distances.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the source vertices'}]}', name=Optional[sourceVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the target vertices'}]}', name=Optional[targetVertices]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges to allow in a path'}]}', name=Optional[maxPathLength]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, only search simple\n(non-self-intersecting) paths (if null, all edges will be considered,\nwhich may be expensive)'}]}', name=Optional[simplePathsOnly]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the minimum number of edges in a path\nto a target through each edge, as computed by '}, JavadocInlineTag{tagName='code', type=CODE, content='\nedgeMinDistancesBackwards'}, JavadocSnippet{text='.'}]}', name=Optional[edgeMinDistancesFromTargets]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a List of all GraphPaths from the sources to the targets\nsatisfying the given constraints'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<GraphPath<V, E>>","literalExprs":[{"literalExprRange":"(line 252,col 30)-(line 252,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 253,col 33)-(line 253,col 33)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 255,col 21)-(line 255,col 67)","literalExprId":3,"literalExpr":"\"maxPathLength must be non-negative if defined\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 257,col 34)-(line 257,col 34)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 277,col 58)-(line 277,col 61)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 280,col 38)-(line 280,col 41)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 282,col 59)-(line 282,col 59)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 295,col 43)-(line 295,col 46)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 317,col 50)-(line 317,col 53)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 324,col 43)-(line 324,col 46)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AllDirectedPaths.generatePaths(java.util.Set<V>, java.util.Set<V>, boolean, java.lang.Integer, java.util.Map<E, java.lang.Integer>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edges","javadocBlockTagName":"edges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edges'}]}', name=Optional[edges]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the corresponding GraphPath","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the corresponding GraphPath'}]}', name=Optional.empty}"}],"methodDeclaration":"private GraphPath<V, E> makePath(List<E> edges)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V source = graph.getEdgeSource(edges.get(0));\n    V target = graph.getEdgeTarget(edges.get(edges.size() - 1));\n    double weight = edges.size();\n    return new GraphPathImpl<V, E>(graph, source, target, edges, weight);\n}","methodRange":"(line 347,col 5)-(line 353,col 5)","methodTokenRange":"private GraphPath<V, E> makePath(List<E> edges)\n    {\n        V source = graph.getEdgeSource(edges.get(0));\n        V target = graph.getEdgeTarget(edges.get(edges.size() - 1));\n        double weight = edges.size();\n        return new GraphPathImpl<V, E>(graph, source, target, edges, weight);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Transform an ordered list of edges into a GraphPath\n     *\n     * @param edges the edges\n     *\n     * @return the corresponding GraphPath\n     ","methodParameters":[{"parameterType":"List<E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<E>","parameter":"List<E> edges","parameterName":"edges"}],"methodName":"makePath","methodQualifiedSignature":"org.jgrapht.alg.AllDirectedPaths.makePath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Transform an ordered list of edges into a GraphPath'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edges'}]}', name=Optional[edges]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the corresponding GraphPath'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"GraphPath<V, E>","literalExprs":[{"literalExprRange":"(line 349,col 50)-(line 349,col 50)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 350,col 65)-(line 350,col 65)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AllDirectedPaths.makePath(java.util.List<E>)"}],"classJavadoc":"","className":"AllDirectedPaths","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 44)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"}]}],"sourceFileId":134,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.KShortestPathsIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph on which shortest paths are searched.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph on which shortest paths are searched.'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"start vertex of the calculated paths.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex of the calculated paths.'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex of the calculated paths.","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the calculated paths.'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of paths stored at end vertex of the graph.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of paths stored at end vertex of the graph.'}]}', name=Optional[maxSize]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.KShortestPathsIterator(org.jgrapht.Graph<V, E>, V, V, int)","variableDeclarationExprs":[],"constructorRange":"(line 106,col 5)-(line 125,col 5)","constructorJavadocComment":"\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param endVertex end vertex of the calculated paths.\n     * @param maxSize number of paths stored at end vertex of the graph.\n     ","constructorDeclaration":"public KShortestPathsIterator(Graph<V, E> graph, V startVertex, V endVertex, int maxSize)","constructorBody":"{\n    assertKShortestPathsIterator(graph, startVertex);\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.endVertex = endVertex;\n    this.k = maxSize;\n    this.seenDataContainer = new HashMap<V, RankingPathElementList<V, E>>();\n    this.prevSeenDataContainer = new HashMap<V, RankingPathElementList<V, E>>();\n    this.prevImprovedVertices = new HashSet<V>();\n}","constructorName":"KShortestPathsIterator","constructorQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.KShortestPathsIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"}],"literalExprs":[],"constructorTokenRange":"public KShortestPathsIterator(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex,\n        int maxSize)\n    {\n        assertKShortestPathsIterator(graph, startVertex);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.endVertex = endVertex;\n\n        this.k = maxSize;\n\n        this.seenDataContainer = new HashMap<V, RankingPathElementList<V, E>>();\n        this.prevSeenDataContainer =\n            new HashMap<V, RankingPathElementList<V, E>>();\n\n        this.prevImprovedVertices = new HashSet<V>();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph on which shortest paths are searched.'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex of the calculated paths.'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the calculated paths.'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of paths stored at end vertex of the graph.'}]}', name=Optional[maxSize]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if at least one path has been improved during\nthe previous pass, <code>false<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if at least one path has been improved during\nthe previous pass, <code>false<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!this.startVertexEncountered) {\n        encounterStartVertex();\n    }\n    return !(this.prevImprovedVertices.isEmpty());\n}","methodRange":"(line 131,col 5)-(line 138,col 5)","methodTokenRange":"@Override public boolean hasNext()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        return !(this.prevImprovedVertices.isEmpty());\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @return <code>true<\/code> if at least one path has been improved during\n     * the previous pass, <code>false<\/code> otherwise.\n     ","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.hasNext","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if at least one path has been improved during\nthe previous pass, <code>false<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.hasNext()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Iterator#next()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#next()'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!this.startVertexEncountered) {\n        encounterStartVertex();\n    }\n    if (hasNext()) {\n        Set<V> improvedVertices = new HashSet<V>();\n        for (Iterator<V> iter = this.prevImprovedVertices.iterator(); iter.hasNext(); ) {\n            V vertex = iter.next();\n            if (!vertex.equals(this.endVertex)) {\n                updateOutgoingVertices(vertex, improvedVertices);\n            }\n        }\n        savePassData(improvedVertices);\n        this.passNumber++;\n        return improvedVertices;\n    }\n    throw new NoSuchElementException();\n}","methodRange":"(line 152,col 5)-(line 178,col 5)","methodTokenRange":"@Override public Set<V> next()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        \/\/ at the i-th pass the shortest paths with i edges are calculated.\n        if (hasNext()) {\n            Set<V> improvedVertices = new HashSet<V>();\n\n            for (\n                Iterator<V> iter = this.prevImprovedVertices.iterator();\n                iter.hasNext();)\n            {\n                V vertex = iter.next();\n                if (!vertex.equals(this.endVertex)) {\n                    updateOutgoingVertices(vertex, improvedVertices);\n                }\n            }\n\n            savePassData(improvedVertices);\n            this.passNumber++;\n\n            return improvedVertices;\n        }\n        throw new NoSuchElementException();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the list of vertices whose path has been improved during the\n     * current pass. Complexity =\n     *\n     * <ul>\n     * <li>O(<code>m*k*(m+n)<\/code>) where <code>k<\/code> is the maximum number\n     * of shortest paths to compute, <code>m<\/code> is the number of edges of\n     * the graph and <code>n<\/code> is the number of vertices of the graph<\/li>\n     * <\/ul>\n     *\n     * @see java.util.Iterator#next()\n     ","methodParameters":[],"methodName":"next","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.next","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the list of vertices whose path has been improved during the\ncurrent pass. Complexity =\n\n<ul>\n<li>O(<code>m*k*(m+n)<\/code>) where <code>k<\/code> is the maximum number\nof shortest paths to compute, <code>m<\/code> is the number of edges of\nthe graph and <code>n<\/code> is the number of vertices of the graph<\/li>\n<\/ul>'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#next()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.next()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Iterator#remove()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#remove()'}]}', name=Optional.empty}"}],"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException();\n}","methodRange":"(line 185,col 5)-(line 188,col 5)","methodTokenRange":"@Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Unsupported.\n     *\n     * @see java.util.Iterator#remove()\n     ","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Unsupported.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#remove()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.remove()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex.","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of <code>RankingPathElement<\/code>, or <code>null<\/code> of\nno path exists between the start vertex and the end vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>RankingPathElement<\/code>, or <code>null<\/code> of\nno path exists between the start vertex and the end vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":" RankingPathElementList<V, E> getPathElements(V endVertex)","methodAccessSpecifier":"NONE","methodBody":"{\n    return this.seenDataContainer.get(endVertex);\n}","methodRange":"(line 199,col 5)-(line 202,col 5)","methodTokenRange":"RankingPathElementList<V, E> getPathElements(V endVertex)\n    {\n        return this.seenDataContainer.get(endVertex);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the path elements of the ranking shortest paths with less than\n     * <code>nMaxHops<\/code> edges between the start vertex and the end vertex.\n     *\n     * @param endVertex end vertex.\n     *\n     * @return list of <code>RankingPathElement<\/code>, or <code>null<\/code> of\n     * no path exists between the start vertex and the end vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"getPathElements","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.getPathElements","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the path elements of the ranking shortest paths with less than\n<code>nMaxHops<\/code> edges between the start vertex and the end vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>RankingPathElement<\/code>, or <code>null<\/code> of\nno path exists between the start vertex and the end vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"RankingPathElementList<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.getPathElements(V)"},{"methodDeclaration":"private void assertKShortestPathsIterator(Graph<V, E> graph, V startVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (graph == null) {\n        throw new NullPointerException(\"graph is null\");\n    }\n    if (startVertex == null) {\n        throw new NullPointerException(\"startVertex is null\");\n    }\n}","methodRange":"(line 204,col 5)-(line 212,col 5)","methodTokenRange":"private void assertKShortestPathsIterator(Graph<V, E> graph, V startVertex)\n    {\n        if (graph == null) {\n            throw new NullPointerException(\"graph is null\");\n        }\n        if (startVertex == null) {\n            throw new NullPointerException(\"startVertex is null\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"methodName":"assertKShortestPathsIterator","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.assertKShortestPathsIterator","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 206,col 22)-(line 206,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 207,col 44)-(line 207,col 58)","literalExprId":2,"literalExpr":"\"graph is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 28)-(line 209,col 31)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 210,col 44)-(line 210,col 64)","literalExprId":4,"literalExpr":"\"startVertex is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.assertKShortestPathsIterator(org.jgrapht.Graph<V, E>, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the new entry.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new entry.'}]}', name=Optional.empty}"}],"methodDeclaration":"private RankingPathElementList<V, E> createSeenData(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V oppositeVertex = Graphs.getOppositeVertex(this.graph, edge, vertex);\n    RankingPathElementList<V, E> oppositeData = this.prevSeenDataContainer.get(oppositeVertex);\n    RankingPathElementList<V, E> data = new RankingPathElementList<V, E>(this.graph, this.k, oppositeData, edge, this.endVertex);\n    return data;\n}","methodRange":"(line 222,col 5)-(line 240,col 5)","methodTokenRange":"private RankingPathElementList<V, E> createSeenData(V vertex, E edge)\n    {\n        V oppositeVertex = Graphs.getOppositeVertex(this.graph, edge, vertex);\n\n        RankingPathElementList<V, E> oppositeData =\n            this.prevSeenDataContainer.get(oppositeVertex);\n\n        \/\/ endVertex in argument to ensure that stored paths do not disconnect\n        \/\/ the end-vertex\n        RankingPathElementList<V, E> data =\n            new RankingPathElementList<V, E>(\n                this.graph,\n                this.k,\n                oppositeData,\n                edge,\n                this.endVertex);\n\n        return data;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * The first time we see a vertex, make up a new entry for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the new entry.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"createSeenData","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.createSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The first time we see a vertex, make up a new entry for it.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new entry.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"RankingPathElementList<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.createSeenData(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"private Iterator<E> edgesOfIterator(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (this.graph instanceof DirectedGraph<?, ?>) {\n        return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex).iterator();\n    } else {\n        return this.graph.edgesOf(vertex).iterator();\n    }\n}","methodRange":"(line 250,col 5)-(line 258,col 5)","methodTokenRange":"private Iterator<E> edgesOfIterator(V vertex)\n    {\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex)\n                .iterator();\n        } else {\n            return this.graph.edgesOf(vertex).iterator();\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns an iterator to loop over outgoing edges <code>Edge<\/code> of the\n     * vertex.\n     *\n     * @param vertex\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOfIterator","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.edgesOfIterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an iterator to loop over outgoing edges <code>Edge<\/code> of the\nvertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<E>","methodType":"Iterator<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.edgesOfIterator(V)"},{"javadocBlockTags":[],"methodDeclaration":"private void encounterStartVertex()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    RankingPathElementList<V, E> data = new RankingPathElementList<V, E>(this.graph, this.k, new RankingPathElement<V, E>(this.startVertex));\n    this.seenDataContainer.put(this.startVertex, data);\n    this.prevSeenDataContainer.put(this.startVertex, data);\n    this.prevImprovedVertices.add(this.startVertex);\n    this.startVertexEncountered = true;\n}","methodRange":"(line 263,col 5)-(line 280,col 5)","methodTokenRange":"private void encounterStartVertex()\n    {\n        RankingPathElementList<V, E> data =\n            new RankingPathElementList<V, E>(\n                this.graph,\n                this.k,\n                new RankingPathElement<V, E>(\n                    this.startVertex));\n\n        this.seenDataContainer.put(this.startVertex, data);\n        this.prevSeenDataContainer.put(this.startVertex, data);\n\n        \/\/ initially the only vertex whose value is considered to have changed\n        \/\/ is the start vertex\n        this.prevImprovedVertices.add(this.startVertex);\n\n        this.startVertexEncountered = true;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Initializes the list of paths at the start vertex and adds an empty path.\n     ","methodParameters":[],"methodName":"encounterStartVertex","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.encounterStartVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the list of paths at the start vertex and adds an empty path.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 279,col 39)-(line 279,col 42)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.encounterStartVertex()"},{"methodDeclaration":"private void savePassData(Set<V> improvedVertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (Iterator<V> iter = improvedVertices.iterator(); iter.hasNext(); ) {\n        V vertex = iter.next();\n        RankingPathElementList<V, E> pathElementList = this.seenDataContainer.get(vertex);\n        RankingPathElementList<V, E> improvedPaths = new RankingPathElementList<V, E>(this.graph, pathElementList.maxSize, vertex);\n        for (Iterator<RankingPathElement<V, E>> pathIter = pathElementList.iterator(); pathIter.hasNext(); ) {\n            RankingPathElement<V, E> path = pathIter.next();\n            if (path.getHopCount() == this.passNumber) {\n                improvedPaths.pathElements.add(path);\n            }\n        }\n        this.prevSeenDataContainer.put(vertex, improvedPaths);\n    }\n    this.prevImprovedVertices = improvedVertices;\n}","methodRange":"(line 282,col 5)-(line 312,col 5)","methodTokenRange":"private void savePassData(Set<V> improvedVertices)\n    {\n        for (Iterator<V> iter = improvedVertices.iterator(); iter.hasNext();) {\n            V vertex = iter.next();\n\n            RankingPathElementList<V, E> pathElementList =\n                this.seenDataContainer.get(vertex);\n\n            RankingPathElementList<V, E> improvedPaths =\n                new RankingPathElementList<V, E>(\n                    this.graph,\n                    pathElementList.maxSize,\n                    vertex);\n\n            for (\n                Iterator<RankingPathElement<V, E>> pathIter =\n                    pathElementList.iterator();\n                pathIter.hasNext();)\n            {\n                RankingPathElement<V, E> path = pathIter.next();\n                if (path.getHopCount() == this.passNumber) {\n                    \/\/ the path has just been computed.\n                    improvedPaths.pathElements.add(path);\n                }\n            }\n\n            this.prevSeenDataContainer.put(vertex, improvedPaths);\n        }\n\n        this.prevImprovedVertices = improvedVertices;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> improvedVertices","parameterName":"improvedVertices"}],"methodName":"savePassData","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.savePassData","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.savePassData(java.util.Set<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex reached by a path.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex reached by a path.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the vertex.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the vertex.'}]}', name=Optional[edge]}"}],"methodDeclaration":"private boolean tryToAddFirstPaths(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    RankingPathElementList<V, E> data = createSeenData(vertex, edge);\n    if (!data.isEmpty()) {\n        this.seenDataContainer.put(vertex, data);\n        return true;\n    }\n    return false;\n}","methodRange":"(line 323,col 5)-(line 333,col 5)","methodTokenRange":"private boolean tryToAddFirstPaths(V vertex, E edge)\n    {\n        \/\/ the vertex has not been reached yet\n        RankingPathElementList<V, E> data = createSeenData(vertex, edge);\n\n        if (!data.isEmpty()) {\n            this.seenDataContainer.put(vertex, data);\n            return true;\n        }\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Try to add the first paths to the specified vertex. These paths reached\n     * the specified vertex and ended with the specified edge. A new\n     * intermediary path is stored in the paths list of the specified vertex\n     * provided that the path can be extended to the end-vertex.\n     *\n     * @param vertex vertex reached by a path.\n     * @param edge edge reaching the vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"tryToAddFirstPaths","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.tryToAddFirstPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Try to add the first paths to the specified vertex. These paths reached\nthe specified vertex and ended with the specified edge. A new\nintermediary path is stored in the paths list of the specified vertex\nprovided that the path can be extended to the end-vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex reached by a path.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the vertex.'}]}', name=Optional[edge]}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 330,col 20)-(line 330,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 332,col 16)-(line 332,col 20)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.tryToAddFirstPaths(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"}],"methodDeclaration":"private boolean tryToAddNewPaths(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    RankingPathElementList<V, E> data = this.seenDataContainer.get(vertex);\n    V oppositeVertex = Graphs.getOppositeVertex(this.graph, edge, vertex);\n    RankingPathElementList<V, E> oppositeData = this.prevSeenDataContainer.get(oppositeVertex);\n    return data.addPathElements(oppositeData, edge);\n}","methodRange":"(line 344,col 5)-(line 353,col 5)","methodTokenRange":"private boolean tryToAddNewPaths(V vertex, E edge)\n    {\n        RankingPathElementList<V, E> data = this.seenDataContainer.get(vertex);\n\n        V oppositeVertex = Graphs.getOppositeVertex(this.graph, edge, vertex);\n        RankingPathElementList<V, E> oppositeData =\n            this.prevSeenDataContainer.get(oppositeVertex);\n\n        return data.addPathElements(oppositeData, edge);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Try to add new paths for the vertex. These new paths reached the\n     * specified vertex and ended with the specified edge. A new intermediary\n     * path is stored in the paths list of the specified vertex provided that\n     * the path can be extended to the end-vertex.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"tryToAddNewPaths","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.tryToAddNewPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Try to add new paths for the vertex. These new paths reached the\nspecified vertex and ended with the specified edge. A new intermediary\npath is stored in the paths list of the specified vertex provided that\nthe path can be extended to the end-vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.tryToAddNewPaths(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"improvedVertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[improvedVertices]}"}],"methodDeclaration":"private void updateOutgoingVertices(V vertex, Set<V> improvedVertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (Iterator<E> iter = edgesOfIterator(vertex); iter.hasNext(); ) {\n        E edge = iter.next();\n        V vertexReachedByEdge = Graphs.getOppositeVertex(this.graph, edge, vertex);\n        if (!vertexReachedByEdge.equals(this.startVertex)) {\n            if (this.seenDataContainer.containsKey(vertexReachedByEdge)) {\n                boolean relaxed = tryToAddNewPaths(vertexReachedByEdge, edge);\n                if (relaxed) {\n                    improvedVertices.add(vertexReachedByEdge);\n                }\n            } else {\n                boolean relaxed = tryToAddFirstPaths(vertexReachedByEdge, edge);\n                if (relaxed) {\n                    improvedVertices.add(vertexReachedByEdge);\n                }\n            }\n        }\n    }\n}","methodRange":"(line 375,col 5)-(line 404,col 5)","methodTokenRange":"private void updateOutgoingVertices(V vertex, Set<V> improvedVertices)\n    {\n        \/\/ try to add new paths for the target vertices of the outgoing edges\n        \/\/ of the vertex in argument.\n        for (Iterator<E> iter = edgesOfIterator(vertex); iter.hasNext();) {\n            E edge = iter.next();\n            V vertexReachedByEdge =\n                Graphs.getOppositeVertex(this.graph, edge,\n                    vertex);\n\n            \/\/ check if the path does not loop over the start vertex.\n            if (!vertexReachedByEdge.equals(this.startVertex)) {\n                if (this.seenDataContainer.containsKey(vertexReachedByEdge)) {\n                    boolean relaxed =\n                        tryToAddNewPaths(vertexReachedByEdge,\n                            edge);\n                    if (relaxed) {\n                        improvedVertices.add(vertexReachedByEdge);\n                    }\n                } else {\n                    boolean relaxed =\n                        tryToAddFirstPaths(vertexReachedByEdge,\n                            edge);\n                    if (relaxed) {\n                        improvedVertices.add(vertexReachedByEdge);\n                    }\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * <p>Updates outgoing vertices of the vertex. For each outgoing vertex, the\n     * new paths are obtained by concatenating the specified edge to the\n     * calculated paths of the specified vertex. If the weight of a new path is\n     * greater than the weight of any path stored so far at the outgoing vertex\n     * then the path is not added, otherwise it is added to the list of paths in\n     * increasing order of weight.<\/p>\n     *\n     * Complexity =\n     *\n     * <ul>\n     * <li>O(<code>d(v)*k*(m+n)<\/code>) where <code>d(v)<\/code> is the outgoing\n     * degree of the specified vertex, <code>k<\/code> is the maximum number of\n     * shortest paths to compute, <code>m<\/code> is the number of edges of the\n     * graph and <code>n<\/code> is the number of vertices of the graph<\/li>\n     * <\/ul>\n     *\n     * @param vertex\n     * @param improvedVertices\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> improvedVertices","parameterName":"improvedVertices"}],"methodName":"updateOutgoingVertices","methodQualifiedSignature":"org.jgrapht.alg.KShortestPathsIterator.updateOutgoingVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Updates outgoing vertices of the vertex. For each outgoing vertex, the\nnew paths are obtained by concatenating the specified edge to the\ncalculated paths of the specified vertex. If the weight of a new path is\ngreater than the weight of any path stored so far at the outgoing vertex\nthen the path is not added, otherwise it is added to the list of paths in\nincreasing order of weight.<\/p>\n\nComplexity =\n\n<ul>\n<li>O(<code>d(v)*k*(m+n)<\/code>) where <code>d(v)<\/code> is the outgoing\ndegree of the specified vertex, <code>k<\/code> is the maximum number of\nshortest paths to compute, <code>m<\/code> is the number of edges of the\ngraph and <code>n<\/code> is the number of vertices of the graph<\/li>\n<\/ul>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[improvedVertices]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KShortestPathsIterator.updateOutgoingVertices(V, java.util.Set<V>)"}],"classJavadoc":"\/**\n * Helper class for {@link KShortestPaths}.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"KShortestPathsIterator","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 24)","fieldName":"endVertex","fieldJavadocComment":"\n     * End vertex.\n     ","fieldTokenRange":"private V endVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"End vertex.\n","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 63,col 5)-(line 63,col 30)","fieldName":"graph","fieldJavadocComment":"\n     * Graph on which shortest paths are searched.\n     ","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"Graph on which shortest paths are searched.\n","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 68,col 5)-(line 68,col 18)","fieldName":"k","fieldJavadocComment":"\n     * Number of paths stored at each end vertex.\n     ","fieldTokenRange":"private int k;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of paths stored at each end vertex.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 74,col 5)-(line 74,col 40)","fieldName":"prevImprovedVertices","fieldJavadocComment":"\n     * Vertices whose ranking shortest paths have been modified during the\n     * previous pass.\n     ","fieldTokenRange":"private Set<V> prevImprovedVertices;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"Vertices whose ranking shortest paths have been modified during the\nprevious pass.\n","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 79,col 5)-(line 79,col 71)","fieldName":"prevSeenDataContainer","fieldJavadocComment":"\n     * Stores the paths that improved the vertex in the previous pass.\n     ","fieldTokenRange":"private Map<V, RankingPathElementList<V, E>> prevSeenDataContainer;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.RankingPathElementList, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElementList.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElementList.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, RankingPathElementList<V, E>>","fieldJavadoc":"Stores the paths that improved the vertex in the previous pass.\n","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.RankingPathElementList<V, E>>"},{"fieldRange":"(line 86,col 5)-(line 86,col 67)","fieldName":"seenDataContainer","fieldJavadocComment":"\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex. Key = vertex, value\n     * = <code>RankingPathElementList<\/code> list of calculated paths.\n     ","fieldTokenRange":"private Map<V, RankingPathElementList<V, E>> seenDataContainer;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.RankingPathElementList, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElementList.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElementList.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, RankingPathElementList<V, E>>","fieldJavadoc":"Stores the vertices that have been seen during iteration and (optionally)\nsome additional traversal info regarding each vertex. Key = vertex, value\n= <code>RankingPathElementList<\/code> list of calculated paths.\n","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.RankingPathElementList<V, E>>"},{"fieldRange":"(line 91,col 5)-(line 91,col 26)","fieldName":"startVertex","fieldJavadocComment":"\n     * Start vertex.\n     ","fieldTokenRange":"private V startVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"Start vertex.\n","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 93,col 5)-(line 93,col 43)","fieldName":"startVertexEncountered","fieldJavadocComment":"","fieldTokenRange":"private boolean startVertexEncountered;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 98,col 5)-(line 98,col 31)","fieldName":"passNumber","fieldJavadocComment":"\n     * Stores the number of the path.\n     ","fieldTokenRange":"private int passNumber = 1;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 98,col 30)-(line 98,col 30)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[1]","fieldType":"int","fieldJavadoc":"Stores the number of the path.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":135,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.KruskalMinimumSpanningTree","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.alg.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be searched","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.KruskalMinimumSpanningTree.KruskalMinimumSpanningTree(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[{"variableType":"UnionFind<V>","variableName":"forest","variableDeclarationExprId":1,"variableDeclarationExpr":"UnionFind<V> forest = new UnionFind<V>(graph.vertexSet())","variableDeclarationExprRange":"(line 70,col 9)-(line 70,col 65)","variableTypeResolved":"ReferenceType{org.jgrapht.alg.util.UnionFind, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.UnionFind.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 70,col 22)-(line 70,col 65)"},{"variableType":"ArrayList<E>","variableName":"allEdges","variableDeclarationExprId":2,"variableDeclarationExpr":"ArrayList<E> allEdges = new ArrayList<E>(graph.edgeSet())","variableDeclarationExprRange":"(line 71,col 9)-(line 71,col 65)","variableTypeResolved":"ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","variableRange":"(line 71,col 22)-(line 71,col 65)"},{"variableType":"E","variableName":"edge","variableDeclarationExprId":3,"variableDeclarationExpr":"E edge","variableDeclarationExprRange":"(line 85,col 14)-(line 85,col 19)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 85,col 16)-(line 85,col 19)"},{"variableType":"V","variableName":"source","variableDeclarationExprId":4,"variableDeclarationExpr":"V source = graph.getEdgeSource(edge)","variableDeclarationExprRange":"(line 86,col 13)-(line 86,col 48)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 86,col 15)-(line 86,col 48)"},{"variableType":"V","variableName":"target","variableDeclarationExprId":5,"variableDeclarationExpr":"V target = graph.getEdgeTarget(edge)","variableDeclarationExprRange":"(line 87,col 13)-(line 87,col 48)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 87,col 15)-(line 87,col 48)"}],"constructorRange":"(line 68,col 5)-(line 96,col 5)","constructorJavadocComment":"\n     * Creates and executes a new KruskalMinimumSpanningTree algorithm instance.\n     * An instance is only good for a single spanning tree; after construction,\n     * it can be accessed to retrieve information about the spanning tree found.\n     *\n     * @param graph the graph to be searched\n     ","constructorDeclaration":"public KruskalMinimumSpanningTree(final Graph<V, E> graph)","constructorBody":"{\n    UnionFind<V> forest = new UnionFind<V>(graph.vertexSet());\n    ArrayList<E> allEdges = new ArrayList<E>(graph.edgeSet());\n    Collections.sort(allEdges, new Comparator<E>() {\n\n        @Override\n        public int compare(E edge1, E edge2) {\n            return Double.valueOf(graph.getEdgeWeight(edge1)).compareTo(graph.getEdgeWeight(edge2));\n        }\n    });\n    spanningTreeCost = 0;\n    edgeList = new HashSet<E>();\n    for (E edge : allEdges) {\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n        if (forest.find(source).equals(forest.find(target))) {\n            continue;\n        }\n        forest.union(source, target);\n        edgeList.add(edge);\n        spanningTreeCost += graph.getEdgeWeight(edge);\n    }\n}","constructorName":"KruskalMinimumSpanningTree","constructorQualifiedName":"org.jgrapht.alg.KruskalMinimumSpanningTree.KruskalMinimumSpanningTree","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"final Graph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 82,col 28)-(line 82,col 28)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public KruskalMinimumSpanningTree(final Graph<V, E> graph)\n    {\n        UnionFind<V> forest = new UnionFind<V>(graph.vertexSet());\n        ArrayList<E> allEdges = new ArrayList<E>(graph.edgeSet());\n        Collections.sort(\n            allEdges,\n            new Comparator<E>() {\n                @Override public int compare(E edge1, E edge2)\n                {\n                    return Double.valueOf(graph.getEdgeWeight(edge1)).compareTo(\n                        graph.getEdgeWeight(edge2));\n                }\n            });\n\n        spanningTreeCost = 0;\n        edgeList = new HashSet<E>();\n\n        for (E edge : allEdges) {\n            V source = graph.getEdgeSource(edge);\n            V target = graph.getEdgeTarget(edge);\n            if (forest.find(source).equals(forest.find(target))) {\n                continue;\n            }\n\n            forest.union(source, target);\n            edgeList.add(edge);\n            spanningTreeCost += graph.getEdgeWeight(edge);\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates and executes a new KruskalMinimumSpanningTree algorithm instance.\nAn instance is only good for a single spanning tree; after construction,\nit can be accessed to retrieve information about the spanning tree found.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public Set<E> getMinimumSpanningTreeEdgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return edgeList;\n}","methodRange":"(line 98,col 5)-(line 101,col 5)","methodTokenRange":"@Override public Set<E> getMinimumSpanningTreeEdgeSet()\n    {\n        return edgeList;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getMinimumSpanningTreeEdgeSet","methodQualifiedSignature":"org.jgrapht.alg.KruskalMinimumSpanningTree.getMinimumSpanningTreeEdgeSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KruskalMinimumSpanningTree.getMinimumSpanningTreeEdgeSet()"},{"methodDeclaration":"public double getMinimumSpanningTreeTotalWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return spanningTreeCost;\n}","methodRange":"(line 103,col 5)-(line 106,col 5)","methodTokenRange":"@Override public double getMinimumSpanningTreeTotalWeight()\n    {\n        return spanningTreeCost;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[],"methodName":"getMinimumSpanningTreeTotalWeight","methodQualifiedSignature":"org.jgrapht.alg.KruskalMinimumSpanningTree.getMinimumSpanningTreeTotalWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KruskalMinimumSpanningTree.getMinimumSpanningTreeTotalWeight()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"minimum spanning-tree edges set","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree edges set'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getEdgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getMinimumSpanningTreeEdgeSet();\n}","methodRange":"(line 113,col 5)-(line 116,col 5)","methodTokenRange":"@Deprecated public Set<E> getEdgeSet()\n    {\n        return getMinimumSpanningTreeEdgeSet();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns edges set constituting the minimum spanning tree\/forest\n     *\n     * @return minimum spanning-tree edges set\n     ","methodParameters":[],"methodName":"getEdgeSet","methodQualifiedSignature":"org.jgrapht.alg.KruskalMinimumSpanningTree.getEdgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns edges set constituting the minimum spanning tree\/forest'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree edges set'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KruskalMinimumSpanningTree.getEdgeSet()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"minimum spanning-tree total weight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree total weight'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getSpanningTreeCost()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getMinimumSpanningTreeTotalWeight();\n}","methodRange":"(line 123,col 5)-(line 126,col 5)","methodTokenRange":"@Deprecated public double getSpanningTreeCost()\n    {\n        return getMinimumSpanningTreeTotalWeight();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns total weight of the minimum spanning tree\/forest.\n     *\n     * @return minimum spanning-tree total weight\n     ","methodParameters":[],"methodName":"getSpanningTreeCost","methodQualifiedSignature":"org.jgrapht.alg.KruskalMinimumSpanningTree.getSpanningTreeCost","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns total weight of the minimum spanning tree\/forest.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree total weight'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KruskalMinimumSpanningTree.getSpanningTreeCost()"}],"classJavadoc":"\/**\n * An implementation of <a\n * href=\"http:\/\/en.wikipedia.org\/wiki\/Kruskal's_algorithm\">Kruskal's minimum\n * spanning tree algorithm<\/a>. If the given graph is connected it computes the\n * minimum spanning tree, otherwise it computes the minimum spanning forest. The\n * algorithm runs in time O(E log E). This implementation uses the hashCode and\n * equals method of the vertices.\n *\n * @author Tom Conerly\n * @since Feb 10, 2010\n *\/\n","className":"KruskalMinimumSpanningTree","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 36)","fieldName":"spanningTreeCost","fieldJavadocComment":"","fieldTokenRange":"private double spanningTreeCost;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 59,col 5)-(line 59,col 28)","fieldName":"edgeList","fieldJavadocComment":"","fieldTokenRange":"private Set<E> edgeList;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"}]}],"sourceFileId":136,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.StrongConnectivityInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to inspect","javadocBlockTagName":"directedGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to inspect'}]}', name=Optional[directedGraph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.StrongConnectivityInspector(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 88,col 5)-(line 99,col 5)","constructorJavadocComment":"\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public StrongConnectivityInspector(DirectedGraph<V, E> directedGraph)","constructorBody":"{\n    if (directedGraph == null) {\n        throw new IllegalArgumentException(\"null not allowed for graph!\");\n    }\n    graph = directedGraph;\n    vertexToVertexData = null;\n    orderedVertices = null;\n    stronglyConnectedSets = null;\n    stronglyConnectedSubgraphs = null;\n}","constructorName":"StrongConnectivityInspector","constructorQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.StrongConnectivityInspector","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> directedGraph","parameterName":"directedGraph"}],"literalExprs":[{"literalExprRange":"(line 90,col 30)-(line 90,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 91,col 48)-(line 91,col 76)","literalExprId":2,"literalExpr":"\"null not allowed for graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 30)-(line 95,col 33)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 96,col 27)-(line 96,col 30)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 97,col 33)-(line 97,col 36)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 98,col 38)-(line 98,col 41)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public StrongConnectivityInspector(DirectedGraph<V, E> directedGraph)\n    {\n        if (directedGraph == null) {\n            throw new IllegalArgumentException(\"null not allowed for graph!\");\n        }\n\n        graph = directedGraph;\n        vertexToVertexData = null;\n        orderedVertices = null;\n        stronglyConnectedSets = null;\n        stronglyConnectedSubgraphs = null;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The constructor of the StrongConnectivityAlgorithm class.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to inspect'}]}', name=Optional[directedGraph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 282,col 5)-(line 326,col 5)","classOrInterfaceTokenRange":"private static abstract class VertexData<V>\n    {\n        private byte bitfield;\n\n        private VertexData(\n            boolean discovered,\n            boolean finished)\n        {\n            this.bitfield = 0;\n            setDiscovered(discovered);\n            setFinished(finished);\n        }\n\n        private boolean isDiscovered()\n        {\n            return (bitfield & 1) == 1;\n        }\n\n        private boolean isFinished()\n        {\n            return (bitfield & 2) == 2;\n        }\n\n        private void setDiscovered(boolean discovered)\n        {\n            if (discovered) {\n                bitfield |= 1;\n            } else {\n                bitfield &= ~1;\n            }\n        }\n\n        private void setFinished(boolean finished)\n        {\n            if (finished) {\n                bitfield |= 2;\n            } else {\n                bitfield &= ~2;\n            }\n        }\n\n        abstract VertexData<V> getFinishedData();\n\n        abstract V getVertex();\n    }","classOrInterfaceJavadocComment":"\n     * Lightweight class storing some data for every vertex.\n     ","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 328,col 5)-(line 351,col 5)","classOrInterfaceTokenRange":"private static final class VertexData1<V>\n        extends VertexData<V>\n    {\n        private final VertexData<V> finishedData;\n\n        private VertexData1(\n            VertexData<V> finishedData,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.finishedData = finishedData;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return finishedData;\n        }\n\n        @Override V getVertex()\n        {\n            return null;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 353,col 5)-(line 376,col 5)","classOrInterfaceTokenRange":"private static final class VertexData2<V>\n        extends VertexData<V>\n    {\n        private final V vertex;\n\n        private VertexData2(\n            V vertex,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.vertex = vertex;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return null;\n        }\n\n        @Override V getVertex()\n        {\n            return vertex;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the graph inspected by this StrongConnectivityAlgorithm","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected by this StrongConnectivityAlgorithm'}]}', name=Optional.empty}"}],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 106,col 5)-(line 109,col 5)","methodTokenRange":"public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph inspected by the StrongConnectivityAlgorithm.\n     *\n     * @return the graph inspected by this StrongConnectivityAlgorithm\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph inspected by the StrongConnectivityAlgorithm.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected by this StrongConnectivityAlgorithm'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the graph is strongly connected, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isStronglyConnected()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return stronglyConnectedSets().size() == 1;\n}","methodRange":"(line 117,col 5)-(line 120,col 5)","methodTokenRange":"public boolean isStronglyConnected()\n    {\n        return stronglyConnectedSets().size() == 1;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns true if the graph of this <code>\n     * StronglyConnectivityInspector<\/code> instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     ","methodParameters":[],"methodName":"isStronglyConnected","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.isStronglyConnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the graph of this <code>\nStronglyConnectivityInspector<\/code> instance is strongly connected.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 119,col 50)-(line 119,col 50)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.isStronglyConnected()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<Set<V>> stronglyConnectedSets()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (stronglyConnectedSets == null) {\n        orderedVertices = new LinkedList<VertexData<V>>();\n        stronglyConnectedSets = new Vector<Set<V>>();\n        createVertexData();\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            if (!data.isDiscovered()) {\n                dfsVisit(graph, data, null);\n            }\n        }\n        DirectedGraph<V, E> inverseGraph = new EdgeReversedGraph<V, E>(graph);\n        resetVertexData();\n        for (VertexData<V> data : orderedVertices) {\n            if (!data.isDiscovered()) {\n                Set<V> set = new HashSet<V>();\n                stronglyConnectedSets.add(set);\n                dfsVisit(inverseGraph, data, set);\n            }\n        }\n        orderedVertices = null;\n        vertexToVertexData = null;\n    }\n    return stronglyConnectedSets;\n}","methodRange":"(line 130,col 5)-(line 172,col 5)","methodTokenRange":"public List<Set<V>> stronglyConnectedSets()\n    {\n        if (stronglyConnectedSets == null) {\n            orderedVertices = new LinkedList<VertexData<V>>();\n            stronglyConnectedSets = new Vector<Set<V>>();\n\n            \/\/ create VertexData objects for all vertices, store them\n            createVertexData();\n\n            \/\/ perform the first round of DFS, result is an ordering\n            \/\/ of the vertices by decreasing finishing time\n            for (VertexData<V> data : vertexToVertexData.values()) {\n                if (!data.isDiscovered()) {\n                    dfsVisit(graph, data, null);\n                }\n            }\n\n            \/\/ 'create' inverse graph (i.e. every edge is reversed)\n            DirectedGraph<V, E> inverseGraph =\n                new EdgeReversedGraph<V, E>(graph);\n\n            \/\/ get ready for next dfs round\n            resetVertexData();\n\n            \/\/ second dfs round: vertices are considered in decreasing\n            \/\/ finishing time order; every tree found is a strongly\n            \/\/ connected set\n            for (VertexData<V> data : orderedVertices) {\n                if (!data.isDiscovered()) {\n                    \/\/ new strongly connected set\n                    Set<V> set = new HashSet<V>();\n                    stronglyConnectedSets.add(set);\n                    dfsVisit(inverseGraph, data, set);\n                }\n            }\n\n            \/\/ clean up for garbage collection\n            orderedVertices = null;\n            vertexToVertexData = null;\n        }\n\n        return stronglyConnectedSets;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List<\/code> of <code>Set<\/code> s containing the strongly\n     * connected components\n     ","methodParameters":[],"methodName":"stronglyConnectedSets","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.stronglyConnectedSets","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes a '}, JavadocInlineTag{tagName='link', type=LINK, content=' List'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Set'}, JavadocSnippet{text='s, where each set contains vertices\nwhich together form a strongly connected component within the given\ngraph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[{"literalExprRange":"(line 132,col 38)-(line 132,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 143,col 43)-(line 143,col 46)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 167,col 31)-(line 167,col 34)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 168,col 34)-(line 168,col 37)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.stronglyConnectedSets()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of subgraphs representing the strongly connected\ncomponents","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (stronglyConnectedSubgraphs == null) {\n        List<Set<V>> sets = stronglyConnectedSets();\n        stronglyConnectedSubgraphs = new Vector<DirectedSubgraph<V, E>>(sets.size());\n        for (Set<V> set : sets) {\n            stronglyConnectedSubgraphs.add(new DirectedSubgraph<V, E>(graph, set, null));\n        }\n    }\n    return stronglyConnectedSubgraphs;\n}","methodRange":"(line 187,col 5)-(line 204,col 5)","methodTokenRange":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()\n    {\n        if (stronglyConnectedSubgraphs == null) {\n            List<Set<V>> sets = stronglyConnectedSets();\n            stronglyConnectedSubgraphs =\n                new Vector<DirectedSubgraph<V, E>>(sets.size());\n\n            for (Set<V> set : sets) {\n                stronglyConnectedSubgraphs.add(\n                    new DirectedSubgraph<V, E>(\n                        graph,\n                        set,\n                        null));\n            }\n        }\n\n        return stronglyConnectedSubgraphs;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.<\/p>\n     *\n     * <p>NOTE: Calling this method will first execute {@link\n     * StrongConnectivityInspector#stronglyConnectedSets()}. If you don't need\n     * subgraphs, use that method.<\/p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     ","methodParameters":[],"methodName":"stronglyConnectedSubgraphs","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.stronglyConnectedSubgraphs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Computes a list of '}, JavadocInlineTag{tagName='link', type=LINK, content=' DirectedSubgraph'}, JavadocSnippet{text='s of the given graph. Each\nsubgraph will represent a strongly connected component and will contain\nall vertices of that component. The subgraph will have an edge (u,v) iff\nu and v are contained in the strongly connected component.<\/p>\n\n<p>NOTE: Calling this method will first execute '}, JavadocInlineTag{tagName='link', type=LINK, content='\nStrongConnectivityInspector#stronglyConnectedSets()'}, JavadocSnippet{text='. If you don't need\nsubgraphs, use that method.<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<DirectedSubgraph<V, E>>","literalExprs":[{"literalExprRange":"(line 189,col 43)-(line 189,col 46)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 199,col 25)-(line 199,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.stronglyConnectedSubgraphs()"},{"methodDeclaration":"private void createVertexData()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    vertexToVertexData = new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n    for (V vertex : graph.vertexSet()) {\n        vertexToVertexData.put(vertex, new VertexData2<V>(vertex, false, false));\n    }\n}","methodRange":"(line 211,col 5)-(line 221,col 5)","methodTokenRange":"private void createVertexData()\n    {\n        vertexToVertexData =\n            new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n\n        for (V vertex : graph.vertexSet()) {\n            vertexToVertexData.put(\n                vertex,\n                new VertexData2<V>(vertex, false, false));\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Creates a VertexData object for every vertex in the graph and stores\n     * them\n     * in a HashMap.\n     ","methodParameters":[],"methodName":"createVertexData","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.createVertexData","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 219,col 44)-(line 219,col 48)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 219,col 51)-(line 219,col 55)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.createVertexData()"},{"methodDeclaration":"private void dfsVisit(DirectedGraph<V, E> visitedGraph, VertexData<V> vertexData, Set<V> vertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n    stack.add(vertexData);\n    while (!stack.isEmpty()) {\n        VertexData<V> data = stack.removeLast();\n        if (!data.isDiscovered()) {\n            data.setDiscovered(true);\n            if (vertices != null) {\n                vertices.add(data.getVertex());\n            }\n            stack.add(new VertexData1<V>(data, true, true));\n            for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                VertexData<V> targetData = vertexToVertexData.get(visitedGraph.getEdgeTarget(edge));\n                if (!targetData.isDiscovered()) {\n                    stack.add(targetData);\n                }\n            }\n        } else if (data.isFinished()) {\n            if (vertices == null) {\n                orderedVertices.addFirst(data.getFinishedData());\n            }\n        }\n    }\n}","methodRange":"(line 229,col 5)-(line 266,col 5)","methodTokenRange":"private void dfsVisit(\n        DirectedGraph<V, E> visitedGraph,\n        VertexData<V> vertexData,\n        Set<V> vertices)\n    {\n        Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n        stack.add(vertexData);\n\n        while (!stack.isEmpty()) {\n            VertexData<V> data = stack.removeLast();\n\n            if (!data.isDiscovered()) {\n                data.setDiscovered(true);\n\n                if (vertices != null) {\n                    vertices.add(data.getVertex());\n                }\n\n                stack.add(new VertexData1<V>(data, true, true));\n\n                \/\/ follow all edges\n                for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                    VertexData<V> targetData =\n                        vertexToVertexData.get(\n                            visitedGraph.getEdgeTarget(edge));\n\n                    if (!targetData.isDiscovered()) {\n                        \/\/ the \"recursion\"\n                        stack.add(targetData);\n                    }\n                }\n            } else if (data.isFinished()) {\n                if (vertices == null) {\n                    orderedVertices.addFirst(data.getFinishedData());\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * The subroutine of DFS. NOTE: the set is used to distinguish between 1st\n     * and 2nd round of DFS. set == null: finished vertices are stored (1st\n     * round). set != null: all vertices found will be saved in the set (2nd\n     * round)\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> visitedGraph","parameterName":"visitedGraph"},{"parameterType":"VertexData<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.StrongConnectivityInspector.VertexData, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.StrongConnectivityInspector.VertexData.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>","parameter":"VertexData<V> vertexData","parameterName":"vertexData"},{"parameterType":"Set<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertices","parameterName":"vertices"}],"methodName":"dfsVisit","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.dfsVisit","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 241,col 36)-(line 241,col 39)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 243,col 33)-(line 243,col 36)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 247,col 52)-(line 247,col 55)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 247,col 58)-(line 247,col 61)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 261,col 33)-(line 261,col 36)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.dfsVisit(org.jgrapht.DirectedGraph<V, E>, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>, java.util.Set<V>)"},{"methodDeclaration":"private void resetVertexData()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (VertexData<V> data : vertexToVertexData.values()) {\n        data.setDiscovered(false);\n        data.setFinished(false);\n    }\n}","methodRange":"(line 271,col 5)-(line 277,col 5)","methodTokenRange":"private void resetVertexData()\n    {\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            data.setDiscovered(false);\n            data.setFinished(false);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Resets all VertexData objects.\n     ","methodParameters":[],"methodName":"resetVertexData","methodQualifiedSignature":"org.jgrapht.alg.StrongConnectivityInspector.resetVertexData","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 274,col 32)-(line 274,col 36)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 275,col 30)-(line 275,col 34)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StrongConnectivityInspector.resetVertexData()"}],"classJavadoc":"\/**\n * <p>Complements the {@link ConnectivityInspector} class with the capability to\n * compute the strongly connected components of a directed graph. The algorithm\n * is implemented after \"Cormen et al: Introduction to algorithms\", Chapter\n * 22.5. It has a running time of O(V + E).<\/p>\n *\n * <p>Unlike {@link ConnectivityInspector}, this class does not implement\n * incremental inspection. The full algorithm is executed at the first call of\n * {@link StrongConnectivityInspector#stronglyConnectedSets()} or {@link\n * StrongConnectivityInspector#isStronglyConnected()}.<\/p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n * @deprecated Use {@link KosarajuStrongConnectivityInspector} instead.\n *\/\n","className":"StrongConnectivityInspector","fields":[{"fieldRange":"(line 67,col 5)-(line 67,col 44)","fieldName":"graph","fieldJavadocComment":" the graph to compute the strongly connected sets for","fieldTokenRange":"private final DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 70,col 5)-(line 70,col 54)","fieldName":"orderedVertices","fieldJavadocComment":" stores the vertices, ordered by their finishing time in first dfs","fieldTokenRange":"private LinkedList<VertexData<V>> orderedVertices;","fieldTypeResolved":"ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=ReferenceType{org.jgrapht.alg.StrongConnectivityInspector.VertexData, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.StrongConnectivityInspector.VertexData.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"LinkedList<VertexData<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.LinkedList<org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>>"},{"fieldRange":"(line 73,col 5)-(line 73,col 47)","fieldName":"stronglyConnectedSets","fieldJavadocComment":" the result of the computation, cached for future calls","fieldTokenRange":"private List<Set<V>> stronglyConnectedSets;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.Set<V>>"},{"fieldRange":"(line 76,col 5)-(line 76,col 68)","fieldName":"stronglyConnectedSubgraphs","fieldJavadocComment":" the result of the computation, cached for future calls","fieldTokenRange":"private List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.graph.DirectedSubgraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.DirectedSubgraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.DirectedSubgraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<DirectedSubgraph<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<org.jgrapht.graph.DirectedSubgraph<V, E>>"},{"fieldRange":"(line 79,col 5)-(line 79,col 53)","fieldName":"vertexToVertexData","fieldJavadocComment":" maps vertices to their VertexData object","fieldTokenRange":"private Map<V, VertexData<V>> vertexToVertexData;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.StrongConnectivityInspector.VertexData, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.StrongConnectivityInspector.VertexData.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, VertexData<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.StrongConnectivityInspector.VertexData<V>>"}]}],"sourceFileId":137,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2State","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"GraphOrdering on first graph","javadocBlockTagName":"g1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='GraphOrdering on first graph'}]}', name=Optional[g1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"GraphOrdering on second graph (possible subgraph)","javadocBlockTagName":"g2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='GraphOrdering on second graph (possible subgraph)'}]}', name=Optional[g2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equality of vertices","javadocBlockTagName":"vertexComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equality of vertices'}]}', name=Optional[vertexComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equality of edges","javadocBlockTagName":"edgeComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equality of edges'}]}', name=Optional[edgeComparator]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.VF2State(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 99,col 5)","constructorJavadocComment":"\n     * @param g1 GraphOrdering on first graph\n     * @param g2 GraphOrdering on second graph (possible subgraph)\n     * @param vertexComparator comparator for semantic equality of vertices\n     * @param edgeComparator comparator for semantic equality of edges\n     ","constructorDeclaration":"public VF2State(GraphOrdering<V, E> g1, GraphOrdering<V, E> g2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    this.g1 = g1;\n    this.g2 = g2;\n    this.vertexComparator = vertexComparator;\n    this.edgeComparator = edgeComparator;\n    n1 = g1.getVertexCount();\n    n2 = g2.getVertexCount();\n    core1 = new int[n1];\n    in1 = new int[n1];\n    out1 = new int[n1];\n    core2 = new int[n2];\n    in2 = new int[n2];\n    out2 = new int[n2];\n    Arrays.fill(core1, NULL_NODE);\n    Arrays.fill(core2, NULL_NODE);\n    coreLen = 0;\n    addedVertex1 = addVertex1 = addVertex2 = NULL_NODE;\n    t1BothLen = t2BothLen = t1InLen = t2InLen = t1OutLen = t2OutLen = 0;\n}","constructorName":"VF2State","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.VF2State","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g1","parameterName":"g1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g2","parameterName":"g2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[{"literalExprRange":"(line 95,col 19)-(line 95,col 19)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 98,col 75)-(line 98,col 75)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public VF2State(\n        GraphOrdering<V, E> g1,\n        GraphOrdering<V, E> g2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this.g1 = g1;\n        this.g2 = g2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n\n        n1 = g1.getVertexCount();\n        n2 = g2.getVertexCount();\n\n        core1 = new int[n1];\n        in1 = new int[n1];\n        out1 = new int[n1];\n        core2 = new int[n2];\n        in2 = new int[n2];\n        out2 = new int[n2];\n        Arrays.fill(core1, NULL_NODE);\n        Arrays.fill(core2, NULL_NODE);\n\n        coreLen = 0;\n        addedVertex1 = addVertex1 = addVertex2 = NULL_NODE;\n\n        t1BothLen = t2BothLen = t1InLen = t2InLen = t1OutLen = t2OutLen = 0;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='GraphOrdering on first graph'}]}', name=Optional[g1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='GraphOrdering on second graph (possible subgraph)'}]}', name=Optional[g2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equality of vertices'}]}', name=Optional[vertexComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equality of edges'}]}', name=Optional[edgeComparator]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[s]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.VF2State(org.jgrapht.alg.isomorphism.VF2State<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 106,col 5)-(line 136,col 5)","constructorJavadocComment":"\n     * copy constructor\n     *\n     * @param s\n     ","constructorDeclaration":"public VF2State(VF2State<V, E> s)","constructorBody":"{\n    g1 = s.g1;\n    g2 = s.g2;\n    core1 = s.core1;\n    core2 = s.core2;\n    in1 = s.in1;\n    in2 = s.in2;\n    out1 = s.out1;\n    out2 = s.out2;\n    coreLen = s.coreLen;\n    n1 = s.n1;\n    n2 = s.n2;\n    t1BothLen = s.t1BothLen;\n    t2BothLen = s.t2BothLen;\n    t1InLen = s.t1InLen;\n    t2InLen = s.t2InLen;\n    t1OutLen = s.t1OutLen;\n    t2OutLen = s.t2OutLen;\n    vertexComparator = s.vertexComparator;\n    edgeComparator = s.edgeComparator;\n    addVertex1 = s.addVertex1;\n    addVertex2 = s.addVertex2;\n    addedVertex1 = s.addedVertex1;\n}","constructorName":"VF2State","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.VF2State","constructorParameters":[{"parameterType":"VF2State<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.VF2State, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.VF2State.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.VF2State.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.VF2State<V, E>","parameter":"VF2State<V, E> s","parameterName":"s"}],"literalExprs":[],"constructorTokenRange":"public VF2State(VF2State<V, E> s)\n    {\n        g1 = s.g1;\n        g2 = s.g2;\n\n        core1 = s.core1;\n        core2 = s.core2;\n        in1 = s.in1;\n        in2 = s.in2;\n        out1 = s.out1;\n        out2 = s.out2;\n\n        coreLen = s.coreLen;\n\n        n1 = s.n1;\n        n2 = s.n2;\n\n        t1BothLen = s.t1BothLen;\n        t2BothLen = s.t2BothLen;\n        t1InLen = s.t1InLen;\n        t2InLen = s.t2InLen;\n        t1OutLen = s.t1OutLen;\n        t2OutLen = s.t2OutLen;\n\n        vertexComparator = s.vertexComparator;\n        edgeComparator = s.edgeComparator;\n\n        addVertex1 = s.addVertex1;\n        addVertex2 = s.addVertex2;\n        addedVertex1 = s.addedVertex1;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='copy constructor'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[s]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"false, if there are no more pairs left","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='false, if there are no more pairs left'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean nextPair()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (addVertex2 == NULL_NODE) {\n        addVertex2 = 0;\n    }\n    if (addVertex1 == NULL_NODE) {\n        addVertex1 = 0;\n    } else {\n        addVertex1++;\n    }\n    if ((t1BothLen > coreLen) && (t2BothLen > coreLen)) {\n        while ((addVertex2 < n2) && ((core2[addVertex2] != NULL_NODE) || (out2[addVertex2] == 0) || (in2[addVertex2] == 0))) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && ((core1[addVertex1] != NULL_NODE) || (out1[addVertex1] == 0) || (in1[addVertex1] == 0))) {\n            addVertex1++;\n        }\n    } else if ((t1OutLen > coreLen) && (t2OutLen > coreLen)) {\n        while ((addVertex2 < n2) && ((core2[addVertex2] != NULL_NODE) || (out2[addVertex2] == 0))) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && ((core1[addVertex1] != NULL_NODE) || (out1[addVertex1] == 0))) {\n            addVertex1++;\n        }\n    } else if ((t1InLen > coreLen) && (t2InLen > coreLen)) {\n        while ((addVertex2 < n2) && ((core2[addVertex2] != NULL_NODE) || (in2[addVertex2] == 0))) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && ((core1[addVertex1] != NULL_NODE) || (in1[addVertex1] == 0))) {\n            addVertex1++;\n        }\n    } else {\n        while ((addVertex2 < n2) && (core2[addVertex2] != NULL_NODE)) {\n            addVertex2++;\n            addVertex1 = 0;\n        }\n        while ((addVertex1 < n1) && (core1[addVertex1] != NULL_NODE)) {\n            addVertex1++;\n        }\n    }\n    if ((addVertex1 < n1) && (addVertex2 < n2)) {\n        showLog(\"nextPair\", \"next candidate pair: (\" + g1.getVertex(addVertex1) + \", \" + g2.getVertex(addVertex2) + \")\");\n        return true;\n    }\n    showLog(\"nextPair\", \"no more candidate pairs\");\n    addVertex1 = addVertex2 = NULL_NODE;\n    return false;\n}","methodRange":"(line 144,col 5)-(line 246,col 5)","methodTokenRange":"public boolean nextPair()\n    {\n        if (addVertex2 == NULL_NODE) {\n            addVertex2 = 0;\n        }\n\n        if (addVertex1 == NULL_NODE) {\n            addVertex1 = 0;\n        } else {\n            addVertex1++;\n        }\n\n        \/\/ check incoming and outgoing edges\n        if ((t1BothLen > coreLen) && (t2BothLen > coreLen)) {\n            \/\/ find minimum for addVertex2 in core2 and t2in\/t2out\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (out2[addVertex2] == 0)\n                    || (in2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            \/\/ find first\/next vertex for addVertex1 in core1 and t1in\/t1out\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (out1[addVertex1] == 0)\n                    || (in1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        \/\/ check outgoing edges\n        else if ((t1OutLen > coreLen) && (t2OutLen > coreLen)) {\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (out2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (out1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        \/\/ check incoming edges\n        else if ((t1InLen > coreLen) && (t2InLen > coreLen)) {\n            while (\n                (addVertex2 < n2)\n                && ((core2[addVertex2] != NULL_NODE)\n                    || (in2[addVertex2] == 0)))\n            {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while (\n                (addVertex1 < n1)\n                && ((core1[addVertex1] != NULL_NODE)\n                    || (in1[addVertex1] == 0)))\n            {\n                addVertex1++;\n            }\n        }\n\n        \/\/ check new edges\n        else {\n            while ((addVertex2 < n2) && (core2[addVertex2] != NULL_NODE)) {\n                addVertex2++;\n                addVertex1 = 0;\n            }\n\n            while ((addVertex1 < n1) && (core1[addVertex1] != NULL_NODE)) {\n                addVertex1++;\n            }\n        }\n\n        if ((addVertex1 < n1) && (addVertex2 < n2)) {\n            showLog(\n                \"nextPair\",\n                \"next candidate pair: (\"\n                + g1.getVertex(addVertex1) + \", \"\n                + g2.getVertex(addVertex2) + \")\");\n            return true;\n        }\n\n        \/\/ there are no more pairs..\n        showLog(\"nextPair\", \"no more candidate pairs\");\n\n        addVertex1 = addVertex2 = NULL_NODE;\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * calculates a pair of nodes which may be added to the current matching,\n     * according to the VF2 algorithm.\n     *\n     * @return false, if there are no more pairs left\n     ","methodParameters":[],"methodName":"nextPair","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.nextPair","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='calculates a pair of nodes which may be added to the current matching,\naccording to the VF2 algorithm.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='false, if there are no more pairs left'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 147,col 26)-(line 147,col 26)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 26)-(line 151,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 162,col 45)-(line 162,col 45)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 163,col 44)-(line 163,col 44)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 166,col 30)-(line 166,col 30)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 173,col 45)-(line 173,col 45)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 174,col 44)-(line 174,col 44)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 185,col 45)-(line 185,col 45)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 188,col 30)-(line 188,col 30)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 45)-(line 194,col 45)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 205,col 44)-(line 205,col 44)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 208,col 30)-(line 208,col 30)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 214,col 44)-(line 214,col 44)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 30)-(line 224,col 30)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 234,col 17)-(line 234,col 26)","literalExprId":15,"literalExpr":"\"nextPair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 235,col 17)-(line 235,col 40)","literalExprId":16,"literalExpr":"\"next candidate pair: (\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 236,col 46)-(line 236,col 49)","literalExprId":17,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 237,col 46)-(line 237,col 48)","literalExprId":18,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 238,col 20)-(line 238,col 23)","literalExprId":19,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 242,col 17)-(line 242,col 26)","literalExprId":20,"literalExpr":"\"nextPair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 242,col 29)-(line 242,col 53)","literalExprId":21,"literalExpr":"\"no more candidate pairs\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 245,col 16)-(line 245,col 20)","literalExprId":22,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.nextPair()"},{"javadocBlockTags":[],"methodDeclaration":"public void addPair()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    showLog(\"addPair\", \"(\" + g1.getVertex(addVertex1) + \", \" + g2.getVertex(addVertex2) + \") added\");\n    coreLen++;\n    addedVertex1 = addVertex1;\n    if (in1[addVertex1] == 0) {\n        in1[addVertex1] = coreLen;\n        t1InLen++;\n        if (out1[addVertex1] > 0) {\n            t1BothLen++;\n        }\n    }\n    if (out1[addVertex1] == 0) {\n        out1[addVertex1] = coreLen;\n        t1OutLen++;\n        if (in1[addVertex1] > 0) {\n            t1BothLen++;\n        }\n    }\n    if (in2[addVertex2] == 0) {\n        in2[addVertex2] = coreLen;\n        t2InLen++;\n        if (out2[addVertex2] > 0) {\n            t2BothLen++;\n        }\n    }\n    if (out2[addVertex2] == 0) {\n        out2[addVertex2] = coreLen;\n        t2OutLen++;\n        if (in2[addVertex2] > 0) {\n            t2BothLen++;\n        }\n    }\n    core1[addVertex1] = addVertex2;\n    core2[addVertex2] = addVertex1;\n    for (int other : g1.getInEdges(addVertex1)) {\n        if (in1[other] == 0) {\n            in1[other] = coreLen;\n            t1InLen++;\n            if (out1[other] > 0) {\n                t1BothLen++;\n            }\n        }\n    }\n    for (int other : g1.getOutEdges(addVertex1)) {\n        if (out1[other] == 0) {\n            out1[other] = coreLen;\n            t1OutLen++;\n            if (in1[other] > 0) {\n                t1BothLen++;\n            }\n        }\n    }\n    for (int other : g2.getInEdges(addVertex2)) {\n        if (in2[other] == 0) {\n            in2[other] = coreLen;\n            t2InLen++;\n            if (out2[other] > 0) {\n                t2BothLen++;\n            }\n        }\n    }\n    for (int other : g2.getOutEdges(addVertex2)) {\n        if (out2[other] == 0) {\n            out2[other] = coreLen;\n            t2OutLen++;\n            if (in2[other] > 0) {\n                t2BothLen++;\n            }\n        }\n    }\n}","methodRange":"(line 251,col 5)-(line 335,col 5)","methodTokenRange":"public void addPair()\n    {\n        showLog(\n            \"addPair\",\n            \"(\" + g1.getVertex(addVertex1) + \", \"\n            + g2.getVertex(addVertex2) + \") added\");\n\n        coreLen++;\n        addedVertex1 = addVertex1;\n\n        if (in1[addVertex1] == 0) {\n            in1[addVertex1] = coreLen;\n            t1InLen++;\n            if (out1[addVertex1] > 0) {\n                t1BothLen++;\n            }\n        }\n\n        if (out1[addVertex1] == 0) {\n            out1[addVertex1] = coreLen;\n            t1OutLen++;\n            if (in1[addVertex1] > 0) {\n                t1BothLen++;\n            }\n        }\n\n        if (in2[addVertex2] == 0) {\n            in2[addVertex2] = coreLen;\n            t2InLen++;\n            if (out2[addVertex2] > 0) {\n                t2BothLen++;\n            }\n        }\n\n        if (out2[addVertex2] == 0) {\n            out2[addVertex2] = coreLen;\n            t2OutLen++;\n            if (in2[addVertex2] > 0) {\n                t2BothLen++;\n            }\n        }\n\n        core1[addVertex1] = addVertex2;\n        core2[addVertex2] = addVertex1;\n\n        for (int other : g1.getInEdges(addVertex1)) {\n            if (in1[other] == 0) {\n                in1[other] = coreLen;\n                t1InLen++;\n                if (out1[other] > 0) {\n                    t1BothLen++;\n                }\n            }\n        }\n\n        for (int other : g1.getOutEdges(addVertex1)) {\n            if (out1[other] == 0) {\n                out1[other] = coreLen;\n                t1OutLen++;\n                if (in1[other] > 0) {\n                    t1BothLen++;\n                }\n            }\n        }\n\n        for (int other : g2.getInEdges(addVertex2)) {\n            if (in2[other] == 0) {\n                in2[other] = coreLen;\n                t2InLen++;\n                if (out2[other] > 0) {\n                    t2BothLen++;\n                }\n            }\n        }\n\n        for (int other : g2.getOutEdges(addVertex2)) {\n            if (out2[other] == 0) {\n                out2[other] = coreLen;\n                t2OutLen++;\n                if (in2[other] > 0) {\n                    t2BothLen++;\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * adds the pair to the current matching.\n     ","methodParameters":[],"methodName":"addPair","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.addPair","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='adds the pair to the current matching.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 254,col 13)-(line 254,col 21)","literalExprId":1,"literalExpr":"\"addPair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 255,col 13)-(line 255,col 15)","literalExprId":2,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 255,col 46)-(line 255,col 49)","literalExprId":3,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 256,col 42)-(line 256,col 50)","literalExprId":4,"literalExpr":"\") added\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 261,col 32)-(line 261,col 32)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 264,col 36)-(line 264,col 36)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 269,col 33)-(line 269,col 33)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 272,col 35)-(line 272,col 35)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 277,col 32)-(line 277,col 32)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 280,col 36)-(line 280,col 36)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 285,col 33)-(line 285,col 33)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 288,col 35)-(line 288,col 35)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 297,col 31)-(line 297,col 31)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 300,col 35)-(line 300,col 35)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 307,col 32)-(line 307,col 32)","literalExprId":15,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 310,col 34)-(line 310,col 34)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 317,col 31)-(line 317,col 31)","literalExprId":17,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 320,col 35)-(line 320,col 35)","literalExprId":18,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 327,col 32)-(line 327,col 32)","literalExprId":19,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 330,col 34)-(line 330,col 34)","literalExprId":20,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.addPair()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"is the matching already complete?","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='is the matching already complete?'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isGoal()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return coreLen == n2;\n}","methodRange":"(line 340,col 5)-(line 343,col 5)","methodTokenRange":"public boolean isGoal()\n    {\n        return coreLen == n2;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @return is the matching already complete?\n     ","methodParameters":[],"methodName":"isGoal","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.isGoal","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='is the matching already complete?'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.isGoal()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are isomorphic to the already matched vertices of\ngraph2 and the second one vertex of nextPair.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are isomorphic to the already matched vertices of\ngraph2 and the second one vertex of nextPair.'}]}', name=Optional.empty}"}],"methodDeclaration":"public abstract boolean isFeasiblePair()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 350,col 5)-(line 350,col 45)","methodTokenRange":"public abstract boolean isFeasiblePair();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @return true, if the already matched vertices of graph1 plus the first\n     * vertex of nextPair are isomorphic to the already matched vertices of\n     * graph2 and the second one vertex of nextPair.\n     ","methodParameters":[],"methodName":"isFeasiblePair","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.isFeasiblePair","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are isomorphic to the already matched vertices of\ngraph2 and the second one vertex of nextPair.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.isFeasiblePair()"},{"javadocBlockTags":[],"methodDeclaration":"public void backtrack()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int addedVertex2 = core1[addedVertex1];\n    showLog(\"backtrack\", \"remove (\" + g1.getVertex(addedVertex1) + \", \" + g2.getVertex(addedVertex2) + \") from the matching\");\n    if (in1[addedVertex1] == coreLen) {\n        in1[addedVertex1] = 0;\n    }\n    for (int other : g1.getInEdges(addedVertex1)) {\n        if (in1[other] == coreLen) {\n            in1[other] = 0;\n        }\n    }\n    if (out1[addedVertex1] == coreLen) {\n        out1[addedVertex1] = 0;\n    }\n    for (int other : g1.getOutEdges(addedVertex1)) {\n        if (out1[other] == coreLen) {\n            out1[other] = 0;\n        }\n    }\n    if (in2[addedVertex2] == coreLen) {\n        in2[addedVertex2] = 0;\n    }\n    for (int other : g2.getInEdges(addedVertex2)) {\n        if (in2[other] == coreLen) {\n            in2[other] = 0;\n        }\n    }\n    if (out2[addedVertex2] == coreLen) {\n        out2[addedVertex2] = 0;\n    }\n    for (int other : g2.getOutEdges(addedVertex2)) {\n        if (out2[other] == coreLen) {\n            out2[other] = 0;\n        }\n    }\n    core1[addedVertex1] = core2[addedVertex2] = NULL_NODE;\n    coreLen--;\n    addedVertex1 = NULL_NODE;\n}","methodRange":"(line 355,col 5)-(line 407,col 5)","methodTokenRange":"public void backtrack()\n    {\n        int addedVertex2 = core1[addedVertex1];\n\n        showLog(\n            \"backtrack\",\n            \"remove (\" + g1.getVertex(addedVertex1) + \", \"\n            + g2.getVertex(addedVertex2) + \") from the matching\");\n\n        if (in1[addedVertex1] == coreLen) {\n            in1[addedVertex1] = 0;\n        }\n\n        for (int other : g1.getInEdges(addedVertex1)) {\n            if (in1[other] == coreLen) {\n                in1[other] = 0;\n            }\n        }\n\n        if (out1[addedVertex1] == coreLen) {\n            out1[addedVertex1] = 0;\n        }\n\n        for (int other : g1.getOutEdges(addedVertex1)) {\n            if (out1[other] == coreLen) {\n                out1[other] = 0;\n            }\n        }\n\n        if (in2[addedVertex2] == coreLen) {\n            in2[addedVertex2] = 0;\n        }\n\n        for (int other : g2.getInEdges(addedVertex2)) {\n            if (in2[other] == coreLen) {\n                in2[other] = 0;\n            }\n        }\n\n        if (out2[addedVertex2] == coreLen) {\n            out2[addedVertex2] = 0;\n        }\n\n        for (int other : g2.getOutEdges(addedVertex2)) {\n            if (out2[other] == coreLen) {\n                out2[other] = 0;\n            }\n        }\n\n        core1[addedVertex1] = core2[addedVertex2] = NULL_NODE;\n        coreLen--;\n        addedVertex1 = NULL_NODE;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * removes the last added pair from the matching\n     ","methodParameters":[],"methodName":"backtrack","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.backtrack","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='removes the last added pair from the matching'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 360,col 13)-(line 360,col 23)","literalExprId":1,"literalExpr":"\"backtrack\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 361,col 13)-(line 361,col 22)","literalExprId":2,"literalExpr":"\"remove (\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 361,col 55)-(line 361,col 58)","literalExprId":3,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 362,col 44)-(line 362,col 64)","literalExprId":4,"literalExpr":"\") from the matching\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 365,col 33)-(line 365,col 33)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 370,col 30)-(line 370,col 30)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 375,col 34)-(line 375,col 34)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 380,col 31)-(line 380,col 31)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 385,col 33)-(line 385,col 33)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 390,col 30)-(line 390,col 30)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 395,col 34)-(line 395,col 34)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 400,col 31)-(line 400,col 31)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.backtrack()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"v1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"v2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"v1 and v2 are equivalent","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='v1 and v2 are equivalent'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean areCompatibleVertexes(int v1, int v2)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return (vertexComparator == null) || (vertexComparator.compare(g1.getVertex(v1), g2.getVertex(v2)) == 0);\n}","methodRange":"(line 417,col 5)-(line 422,col 5)","methodTokenRange":"protected boolean areCompatibleVertexes(int v1, int v2)\n    {\n        return (vertexComparator == null)\n            || (vertexComparator.compare(g1.getVertex(v1), g2.getVertex(v2))\n                == 0);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * checks the vertices v1 and v2 for semantic equivalence\n     *\n     * @param v1\n     * @param v2\n     *\n     * @return v1 and v2 are equivalent\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v1","parameterName":"v1"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v2","parameterName":"v2"}],"methodName":"areCompatibleVertexes","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.areCompatibleVertexes","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='checks the vertices v1 and v2 for semantic equivalence'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='v1 and v2 are equivalent'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 419,col 37)-(line 419,col 40)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 421,col 20)-(line 421,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.areCompatibleVertexes(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"v1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"v2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"u1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[u1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"u2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[u2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"edges are equivalent","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='edges are equivalent'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean areCompatibleEdges(int v1, int v2, int u1, int u2)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return (edgeComparator == null) || (edgeComparator.compare(g1.getEdge(v1, v2), g2.getEdge(u1, u2)) == 0);\n}","methodRange":"(line 434,col 5)-(line 439,col 5)","methodTokenRange":"protected boolean areCompatibleEdges(int v1, int v2, int u1, int u2)\n    {\n        return (edgeComparator == null)\n            || (edgeComparator.compare(g1.getEdge(v1, v2), g2.getEdge(u1, u2))\n                == 0);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * checks the edges from v1 to v2 and from u1 to u2 for semantic equivalence\n     *\n     * @param v1\n     * @param v2\n     * @param u1\n     * @param u2\n     *\n     * @return edges are equivalent\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v1","parameterName":"v1"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v2","parameterName":"v2"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int u1","parameterName":"u1"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int u2","parameterName":"u2"}],"methodName":"areCompatibleEdges","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.areCompatibleEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='checks the edges from v1 to v2 and from u1 to u2 for semantic equivalence'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[v2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[u1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[u2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='edges are equivalent'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 436,col 35)-(line 436,col 38)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 438,col 20)-(line 438,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.areCompatibleEdges(int, int, int, int)"},{"methodDeclaration":"public IsomorphicGraphMapping<V, E> getCurrentMapping()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new IsomorphicGraphMapping<V, E>(g1, g2, core1, core2);\n}","methodRange":"(line 441,col 5)-(line 444,col 5)","methodTokenRange":"public IsomorphicGraphMapping<V, E> getCurrentMapping()\n    {\n        return new IsomorphicGraphMapping<V, E>(g1, g2, core1, core2);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getCurrentMapping","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.getCurrentMapping","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IsomorphicGraphMapping<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.getCurrentMapping()"},{"methodDeclaration":"public void resetAddVertexes()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    addVertex1 = addVertex2 = NULL_NODE;\n}","methodRange":"(line 446,col 5)-(line 449,col 5)","methodTokenRange":"public void resetAddVertexes()\n    {\n        addVertex1 = addVertex2 = NULL_NODE;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"resetAddVertexes","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.resetAddVertexes","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.resetAddVertexes()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"method","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[method]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"str","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[str]}"}],"methodDeclaration":"protected void showLog(String method, String str)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (!DEBUG) {\n        return;\n    }\n    char[] indent = new char[2 * coreLen];\n    Arrays.fill(indent, ' ');\n    System.out.println((new String(indent)) + method + \"> \" + str);\n}","methodRange":"(line 457,col 5)-(line 466,col 5)","methodTokenRange":"protected void showLog(String method, String str)\n    {\n        if (!DEBUG) {\n            return;\n        }\n\n        char [] indent = new char[2 * coreLen];\n        Arrays.fill(indent, ' ');\n        System.out.println((new String(indent)) + method + \"> \" + str);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * creates the debug output only if DEBUG is true.\n     *\n     * @param method\n     * @param str\n     ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String method","parameterName":"method"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String str","parameterName":"str"}],"methodName":"showLog","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2State.showLog","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='creates the debug output only if DEBUG is true.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[method]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[str]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 463,col 35)-(line 463,col 35)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 464,col 29)-(line 464,col 31)","literalExprId":2,"literalExpr":"' '","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 465,col 60)-(line 465,col 63)","literalExprId":3,"literalExpr":"\"> \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2State.showLog(java.lang.String, java.lang.String)"}],"classJavadoc":"\/**\n * controls the matching between two graphs according to the VF2 algorithm.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\n * @author Fabian Sph\n *\/\n","className":"VF2State","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 43)","fieldName":"NULL_NODE","fieldJavadocComment":"","fieldTokenRange":"public static final int NULL_NODE = -1;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 52,col 42)-(line 52,col 42)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[-1]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 54,col 5)-(line 54,col 49)","fieldName":"DEBUG","fieldJavadocComment":"","fieldTokenRange":"protected static final boolean DEBUG = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[{"literalExprRange":"(line 54,col 44)-(line 54,col 48)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 56,col 5)-(line 56,col 56)","fieldName":"core1","fieldJavadocComment":"","fieldTokenRange":"protected int [] core1, core2, in1, in2, out1, out2;","fieldTypeResolved":"","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 58,col 5)-(line 59,col 65)","fieldName":"coreLen","fieldJavadocComment":"","fieldTokenRange":"protected int coreLen, n1, n2, t1BothLen, t2BothLen, t1InLen, t2InLen,\n        t1OutLen, t2OutLen, addedVertex1, addVertex1, addVertex2;","fieldTypeResolved":"","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 61,col 5)-(line 61,col 41)","fieldName":"g1","fieldJavadocComment":"","fieldTokenRange":"protected GraphOrdering<V, E> g1, g2;","fieldTypeResolved":"","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"GraphOrdering<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 63,col 5)-(line 63,col 45)","fieldName":"vertexComparator","fieldJavadocComment":"","fieldTokenRange":"protected Comparator<V> vertexComparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<V>"},{"fieldRange":"(line 64,col 5)-(line 64,col 43)","fieldName":"edgeComparator","fieldJavadocComment":"","fieldTokenRange":"protected Comparator<E> edgeComparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<E>"}]}],"sourceFileId":138,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"VF2GraphIsomorphismState","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState.VF2GraphIsomorphismState","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState.VF2GraphIsomorphismState(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g1","parameterName":"g1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g2","parameterName":"g2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[],"constructorTokenRange":"public VF2GraphIsomorphismState(\n        GraphOrdering<V, E> g1,\n        GraphOrdering<V, E> g2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        super(g1, g2, vertexComparator, edgeComparator);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 45,col 5)-(line 52,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2GraphIsomorphismState(GraphOrdering<V, E> g1, GraphOrdering<V, E> g2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    super(g1, g2, vertexComparator, edgeComparator);\n}","constructorJavadoc":""},{"constructorName":"VF2GraphIsomorphismState","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState.VF2GraphIsomorphismState","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState.VF2GraphIsomorphismState(org.jgrapht.alg.isomorphism.VF2State<V, E>)","constructorParameters":[{"parameterType":"VF2State<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.VF2State, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.VF2State.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.VF2State.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.VF2State<V, E>","parameter":"VF2State<V, E> s","parameterName":"s"}],"literalExprs":[],"constructorTokenRange":"public VF2GraphIsomorphismState(VF2State<V, E> s)\n    {\n        super(s);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 54,col 5)-(line 57,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2GraphIsomorphismState(VF2State<V, E> s)","constructorBody":"{\n    super(s);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are graph isomorphic to the already matched vertices\nof graph2 and the second one vertex of nextPair.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are graph isomorphic to the already matched vertices\nof graph2 and the second one vertex of nextPair.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isFeasiblePair()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String pairstr = \"(\" + g1.getVertex(addVertex1) + \", \" + g2.getVertex(addVertex2) + \")\", abortmsg = pairstr + \" does not fit in the current matching\";\n    if (!areCompatibleVertexes(addVertex1, addVertex2)) {\n        return false;\n    }\n    int termOutPred1 = 0, termOutPred2 = 0, termInPred1 = 0, termInPred2 = 0, newPred1 = 0, newPred2 = 0, termOutSucc1 = 0, termOutSucc2 = 0, termInSucc1 = 0, termInSucc2 = 0, newSucc1 = 0, newSucc2 = 0;\n    for (int other1 : g1.getOutEdges(addVertex1)) {\n        if (core1[other1] != NULL_NODE) {\n            int other2 = core1[other1];\n            if (!g2.hasEdge(addVertex2, other2) || !areCompatibleEdges(addVertex1, other1, addVertex2, other2)) {\n                showLog(\"isFeasiblePair\", abortmsg + \": edge from \" + g2.getVertex(addVertex2) + \" to \" + g2.getVertex(other2) + \" is missing in the 2nd graph\");\n                return false;\n            }\n        } else {\n            if (in1[other1] > 0) {\n                termInSucc1++;\n            }\n            if (out1[other1] > 0) {\n                termOutSucc1++;\n            }\n            if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                newSucc1++;\n            }\n        }\n    }\n    for (int other2 : g2.getOutEdges(addVertex2)) {\n        if (core2[other2] != NULL_NODE) {\n            int other1 = core2[other2];\n            if (!g1.hasEdge(addVertex1, other1)) {\n                showLog(\"isFeasbilePair\", abortmsg + \": edge from \" + g1.getVertex(addVertex1) + \" to \" + g1.getVertex(other1) + \" is missing in the 1st graph\");\n                return false;\n            }\n        } else {\n            if (in2[other2] > 0) {\n                termInSucc2++;\n            }\n            if (out2[other2] > 0) {\n                termOutSucc2++;\n            }\n            if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                newSucc2++;\n            }\n        }\n    }\n    if ((termInSucc1 != termInSucc2) || (termOutSucc1 != termOutSucc2) || (newSucc1 != newSucc2)) {\n        if (DEBUG) {\n            String cause = \"\", v1 = g1.getVertex(addVertex1).toString(), v2 = g2.getVertex(addVertex2).toString();\n            if (termInSucc2 > termInSucc1) {\n                cause = \"|Tin2  Succ(Graph2, \" + v2 + \")| != |Tin1  Succ(Graph1, \" + v1 + \")|\";\n            } else if (termOutSucc2 > termOutSucc1) {\n                cause = \"|Tout2  Succ(Graph2, \" + v2 + \")| != |Tout1  Succ(Graph1, \" + v1 + \")|\";\n            } else if (newSucc2 > newSucc1) {\n                cause = \"|N\u203E  Succ(Graph2, \" + v2 + \")| != |N\u203E  Succ(Graph1, \" + v1 + \")|\";\n            }\n            showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n        }\n        return false;\n    }\n    for (int other1 : g1.getInEdges(addVertex1)) {\n        if (core1[other1] != NULL_NODE) {\n            int other2 = core1[other1];\n            if (!g2.hasEdge(other2, addVertex2) || !areCompatibleEdges(other1, addVertex1, other2, addVertex2)) {\n                showLog(\"isFeasbilePair\", abortmsg + \": edge from \" + g2.getVertex(other2) + \" to \" + g2.getVertex(addVertex2) + \" is missing in the 2nd graph\");\n                return false;\n            }\n        } else {\n            if (in1[other1] > 0) {\n                termInPred1++;\n            }\n            if (out1[other1] > 0) {\n                termOutPred1++;\n            }\n            if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                newPred1++;\n            }\n        }\n    }\n    for (int other2 : g2.getInEdges(addVertex2)) {\n        if (core2[other2] != NULL_NODE) {\n            int other1 = core2[other2];\n            if (!g1.hasEdge(other1, addVertex1)) {\n                showLog(\"isFeasiblePair\", abortmsg + \": edge from \" + g1.getVertex(other1) + \" to \" + g1.getVertex(addVertex1) + \" is missing in the 1st graph\");\n                return false;\n            }\n        } else {\n            if (in2[other2] > 0) {\n                termInPred2++;\n            }\n            if (out2[other2] > 0) {\n                termOutPred2++;\n            }\n            if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                newPred2++;\n            }\n        }\n    }\n    if ((termInPred1 == termInPred2) && (termOutPred1 == termOutPred2) && (newPred1 == newPred2)) {\n        showLog(\"isFeasiblePair\", pairstr + \" fits\");\n        return true;\n    } else {\n        if (DEBUG) {\n            String cause = \"\", v1 = g1.getVertex(addVertex1).toString(), v2 = g2.getVertex(addVertex2).toString();\n            if (termInPred2 > termInPred1) {\n                cause = \"|Tin2  Pred(Graph2, \" + v2 + \")| != |Tin1  Pred(Graph1, \" + v1 + \")|\";\n            } else if (termOutPred2 > termOutPred1) {\n                cause = \"|Tout2  Pred(Graph2, \" + v2 + \")| != |Tout1  Pred(Graph1, \" + v1 + \")|\";\n            } else if (newPred2 > newPred1) {\n                cause = \"|N\u203E  Pred(Graph2, \" + v2 + \")| != |N\u203E  Pred(Graph1, \" + v1 + \")|\";\n            }\n            showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n        }\n        return false;\n    }\n}","methodRange":"(line 64,col 5)-(line 255,col 5)","methodTokenRange":"@Override public boolean isFeasiblePair()\n    {\n        String pairstr =\n            \"(\" + g1.getVertex(addVertex1) + \", \"\n            + g2.getVertex(addVertex2) + \")\",\n            abortmsg = pairstr + \" does not fit in the current matching\";\n\n        \/\/ check for semantic equality of both vertexes\n        if (!areCompatibleVertexes(addVertex1, addVertex2)) {\n            return false;\n        }\n\n        int termOutPred1 = 0, termOutPred2 = 0, termInPred1 = 0,\n            termInPred2 = 0, newPred1 = 0, newPred2 = 0, termOutSucc1 = 0,\n            termOutSucc2 = 0, termInSucc1 = 0, termInSucc2 = 0, newSucc1 = 0,\n            newSucc2 = 0;\n\n        \/\/ check outgoing edges of addVertex1\n        for (int other1 : g1.getOutEdges(addVertex1)) {\n            if (core1[other1] != NULL_NODE) {\n                int other2 = core1[other1];\n                if (!g2.hasEdge(addVertex2, other2)\n                    || !areCompatibleEdges(\n                        addVertex1,\n                        other1,\n                        addVertex2,\n                        other2))\n                {\n                    showLog(\n                        \"isFeasiblePair\",\n                        abortmsg + \": edge from \"\n                        + g2.getVertex(addVertex2) + \" to \"\n                        + g2.getVertex(other2)\n                        + \" is missing in the 2nd graph\");\n                    return false;\n                }\n            } else {\n                if (in1[other1] > 0) {\n                    termInSucc1++;\n                }\n                if (out1[other1] > 0) {\n                    termOutSucc1++;\n                }\n                if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                    newSucc1++;\n                }\n            }\n        }\n\n        \/\/ check outgoing edges of addVertex2\n        for (int other2 : g2.getOutEdges(addVertex2)) {\n            if (core2[other2] != NULL_NODE) {\n                int other1 = core2[other2];\n                if (!g1.hasEdge(addVertex1, other1)) {\n                    showLog(\n                        \"isFeasbilePair\",\n                        abortmsg + \": edge from \"\n                        + g1.getVertex(addVertex1) + \" to \"\n                        + g1.getVertex(other1)\n                        + \" is missing in the 1st graph\");\n                    return false;\n                }\n            } else {\n                if (in2[other2] > 0) {\n                    termInSucc2++;\n                }\n                if (out2[other2] > 0) {\n                    termOutSucc2++;\n                }\n                if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                    newSucc2++;\n                }\n            }\n        }\n\n        if ((termInSucc1 != termInSucc2)\n            || (termOutSucc1 != termOutSucc2)\n            || (newSucc1 != newSucc2))\n        {\n            if (DEBUG) {\n                String cause = \"\", v1 = g1.getVertex(addVertex1).toString(),\n                    v2 = g2.getVertex(addVertex2).toString();\n\n                if (termInSucc2 > termInSucc1) {\n                    cause =\n                        \"|Tin2  Succ(Graph2, \" + v2\n                        + \")| != |Tin1  Succ(Graph1, \" + v1 + \")|\";\n                } else if (termOutSucc2 > termOutSucc1) {\n                    cause =\n                        \"|Tout2  Succ(Graph2, \" + v2\n                        + \")| != |Tout1  Succ(Graph1, \" + v1 + \")|\";\n                } else if (newSucc2 > newSucc1) {\n                    cause =\n                        \"|N\u203E  Succ(Graph2, \" + v2\n                        + \")| != |N\u203E  Succ(Graph1, \" + v1 + \")|\";\n                }\n\n                showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n            }\n\n            return false;\n        }\n\n        \/\/ check incoming edges of addVertex1\n        for (int other1 : g1.getInEdges(addVertex1)) {\n            if (core1[other1] != NULL_NODE) {\n                int other2 = core1[other1];\n                if (!g2.hasEdge(other2, addVertex2)\n                    || !areCompatibleEdges(\n                        other1,\n                        addVertex1,\n                        other2,\n                        addVertex2))\n                {\n                    showLog(\n                        \"isFeasbilePair\",\n                        abortmsg + \": edge from \"\n                        + g2.getVertex(other2) + \" to \"\n                        + g2.getVertex(addVertex2)\n                        + \" is missing in the 2nd graph\");\n                    return false;\n                }\n            } else {\n                if (in1[other1] > 0) {\n                    termInPred1++;\n                }\n                if (out1[other1] > 0) {\n                    termOutPred1++;\n                }\n                if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                    newPred1++;\n                }\n            }\n        }\n\n        \/\/ check incoming edges of addVertex2\n        for (int other2 : g2.getInEdges(addVertex2)) {\n            if (core2[other2] != NULL_NODE) {\n                int other1 = core2[other2];\n                if (!g1.hasEdge(other1, addVertex1)) {\n                    showLog(\n                        \"isFeasiblePair\",\n                        abortmsg + \": edge from \"\n                        + g1.getVertex(other1) + \" to \"\n                        + g1.getVertex(addVertex1)\n                        + \" is missing in the 1st graph\");\n                    return false;\n                }\n            } else {\n                if (in2[other2] > 0) {\n                    termInPred2++;\n                }\n                if (out2[other2] > 0) {\n                    termOutPred2++;\n                }\n                if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                    newPred2++;\n                }\n            }\n        }\n\n        if ((termInPred1 == termInPred2)\n            && (termOutPred1 == termOutPred2)\n            && (newPred1 == newPred2))\n        {\n            showLog(\"isFeasiblePair\", pairstr + \" fits\");\n            return true;\n        } else {\n            if (DEBUG) {\n                String cause = \"\", v1 = g1.getVertex(addVertex1).toString(),\n                    v2 = g2.getVertex(addVertex2).toString();\n\n                if (termInPred2 > termInPred1) {\n                    cause =\n                        \"|Tin2  Pred(Graph2, \" + v2\n                        + \")| != |Tin1  Pred(Graph1, \" + v1 + \")|\";\n                } else if (termOutPred2 > termOutPred1) {\n                    cause =\n                        \"|Tout2  Pred(Graph2, \" + v2\n                        + \")| != |Tout1  Pred(Graph1, \" + v1 + \")|\";\n                } else if (newPred2 > newPred1) {\n                    cause =\n                        \"|N\u203E  Pred(Graph2, \" + v2\n                        + \")| != |N\u203E  Pred(Graph1, \" + v1 + \")|\";\n                }\n\n                showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n            }\n\n            return false;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @return true, if the already matched vertices of graph1 plus the first\n     * vertex of nextPair are graph isomorphic to the already matched vertices\n     * of graph2 and the second one vertex of nextPair.\n     ","methodParameters":[],"methodName":"isFeasiblePair","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState.isFeasiblePair","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are graph isomorphic to the already matched vertices\nof graph2 and the second one vertex of nextPair.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 67,col 13)-(line 67,col 15)","literalExprId":1,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 67,col 46)-(line 67,col 49)","literalExprId":2,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 42)-(line 68,col 44)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 69,col 34)-(line 69,col 72)","literalExprId":4,"literalExpr":"\" does not fit in the current matching\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 73,col 20)-(line 73,col 24)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 76,col 28)-(line 76,col 28)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 46)-(line 76,col 46)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 63)-(line 76,col 63)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 27)-(line 77,col 27)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 41)-(line 77,col 41)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 55)-(line 77,col 55)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 73)-(line 77,col 73)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 28)-(line 78,col 28)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 45)-(line 78,col 45)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 62)-(line 78,col 62)","literalExprId":15,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 76)-(line 78,col 76)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 79,col 24)-(line 79,col 24)","literalExprId":17,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 93,col 25)-(line 93,col 40)","literalExprId":18,"literalExpr":"\"isFeasiblePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 94,col 36)-(line 94,col 49)","literalExprId":19,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 54)-(line 95,col 59)","literalExprId":20,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 97,col 27)-(line 97,col 56)","literalExprId":21,"literalExpr":"\" is missing in the 2nd graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 98,col 28)-(line 98,col 32)","literalExprId":22,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 101,col 35)-(line 101,col 35)","literalExprId":23,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 104,col 36)-(line 104,col 36)","literalExprId":24,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 107,col 37)-(line 107,col 37)","literalExprId":25,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 107,col 60)-(line 107,col 60)","literalExprId":26,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 119,col 25)-(line 119,col 40)","literalExprId":27,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 120,col 36)-(line 120,col 49)","literalExprId":28,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 121,col 54)-(line 121,col 59)","literalExprId":29,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 123,col 27)-(line 123,col 56)","literalExprId":30,"literalExpr":"\" is missing in the 1st graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 124,col 28)-(line 124,col 32)","literalExprId":31,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 127,col 35)-(line 127,col 35)","literalExprId":32,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 130,col 36)-(line 130,col 36)","literalExprId":33,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 133,col 37)-(line 133,col 37)","literalExprId":34,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 133,col 60)-(line 133,col 60)","literalExprId":35,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 144,col 32)-(line 144,col 33)","literalExprId":36,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 149,col 25)-(line 149,col 47)","literalExprId":37,"literalExpr":"\"|Tin2  Succ(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 150,col 27)-(line 150,col 55)","literalExprId":38,"literalExpr":"\")| != |Tin1  Succ(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 150,col 64)-(line 150,col 67)","literalExprId":39,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 153,col 25)-(line 153,col 48)","literalExprId":40,"literalExpr":"\"|Tout2  Succ(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 27)-(line 154,col 56)","literalExprId":41,"literalExpr":"\")| != |Tout1  Succ(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 65)-(line 154,col 68)","literalExprId":42,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 157,col 25)-(line 157,col 45)","literalExprId":43,"literalExpr":"\"|N\u203E  Succ(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 158,col 27)-(line 158,col 53)","literalExprId":44,"literalExpr":"\")| != |N\u203E  Succ(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 158,col 62)-(line 158,col 65)","literalExprId":45,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 161,col 25)-(line 161,col 40)","literalExprId":46,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 161,col 54)-(line 161,col 57)","literalExprId":47,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 164,col 20)-(line 164,col 24)","literalExprId":48,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 179,col 25)-(line 179,col 40)","literalExprId":49,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 180,col 36)-(line 180,col 49)","literalExprId":50,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 181,col 50)-(line 181,col 55)","literalExprId":51,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 183,col 27)-(line 183,col 56)","literalExprId":52,"literalExpr":"\" is missing in the 2nd graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 184,col 28)-(line 184,col 32)","literalExprId":53,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 187,col 35)-(line 187,col 35)","literalExprId":54,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 36)-(line 190,col 36)","literalExprId":55,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 37)-(line 193,col 37)","literalExprId":56,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 60)-(line 193,col 60)","literalExprId":57,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 205,col 25)-(line 205,col 40)","literalExprId":58,"literalExpr":"\"isFeasiblePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 206,col 36)-(line 206,col 49)","literalExprId":59,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 207,col 50)-(line 207,col 55)","literalExprId":60,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 27)-(line 209,col 56)","literalExprId":61,"literalExpr":"\" is missing in the 1st graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 210,col 28)-(line 210,col 32)","literalExprId":62,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 213,col 35)-(line 213,col 35)","literalExprId":63,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 216,col 36)-(line 216,col 36)","literalExprId":64,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 37)-(line 219,col 37)","literalExprId":65,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 60)-(line 219,col 60)","literalExprId":66,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 229,col 21)-(line 229,col 36)","literalExprId":67,"literalExpr":"\"isFeasiblePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 229,col 49)-(line 229,col 55)","literalExprId":68,"literalExpr":"\" fits\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 230,col 20)-(line 230,col 23)","literalExprId":69,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 233,col 32)-(line 233,col 33)","literalExprId":70,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 238,col 25)-(line 238,col 47)","literalExprId":71,"literalExpr":"\"|Tin2  Pred(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 239,col 27)-(line 239,col 55)","literalExprId":72,"literalExpr":"\")| != |Tin1  Pred(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 239,col 64)-(line 239,col 67)","literalExprId":73,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 242,col 25)-(line 242,col 48)","literalExprId":74,"literalExpr":"\"|Tout2  Pred(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 243,col 27)-(line 243,col 56)","literalExprId":75,"literalExpr":"\")| != |Tout1  Pred(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 243,col 65)-(line 243,col 68)","literalExprId":76,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 246,col 25)-(line 246,col 45)","literalExprId":77,"literalExpr":"\"|N\u203E  Pred(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 247,col 27)-(line 247,col 53)","literalExprId":78,"literalExpr":"\")| != |N\u203E  Pred(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 247,col 62)-(line 247,col 65)","literalExprId":79,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 250,col 25)-(line 250,col 40)","literalExprId":80,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 250,col 54)-(line 250,col 57)","literalExprId":81,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 253,col 20)-(line 253,col 24)","literalExprId":82,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismState.isFeasiblePair()"}],"classJavadoc":"","className":"VF2GraphIsomorphismState","fields":[]}],"sourceFileId":139,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first graph","javadocBlockTagName":"graph1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[graph1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second graph","javadocBlockTagName":"graph2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph'}]}', name=Optional[graph2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equivalence of vertices","javadocBlockTagName":"vertexComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of vertices'}]}', name=Optional[vertexComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equivalence of edges","javadocBlockTagName":"edgeComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of edges'}]}', name=Optional[edgeComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, edges get cached for faster access","javadocBlockTagName":"cacheEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, edges get cached for faster access'}]}', name=Optional[cacheEdges]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, java.util.Comparator<V>, java.util.Comparator<E>, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 104,col 5)","constructorJavadocComment":"\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     ","constructorDeclaration":"public VF2AbstractIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator, boolean cacheEdges)","constructorBody":"{\n    if ((graph1 instanceof Multigraph) || (graph2 instanceof Multigraph) || (graph1 instanceof Pseudograph) || (graph2 instanceof Pseudograph) || (graph1 instanceof DirectedMultigraph) || (graph2 instanceof DirectedMultigraph) || (graph1 instanceof DirectedPseudograph) || (graph2 instanceof DirectedPseudograph)) {\n        throw new UnsupportedOperationException(\"graphs with multiple \" + \"edges are not supported\");\n    }\n    if (((graph1 instanceof DirectedGraph) && (graph2 instanceof UndirectedGraph)) || ((graph1 instanceof UndirectedGraph) && (graph2 instanceof DirectedGraph))) {\n        throw new IllegalArgumentException(\"can not match directed with \" + \"undirected graphs\");\n    }\n    this.graph1 = graph1;\n    this.graph2 = graph2;\n    this.vertexComparator = vertexComparator;\n    this.edgeComparator = edgeComparator;\n    this.ordering1 = new GraphOrdering<V, E>(graph1, true, cacheEdges);\n    this.ordering2 = new GraphOrdering<V, E>(graph2, true, cacheEdges);\n}","constructorName":"VF2AbstractIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"},{"parameterType":"boolean","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[{"literalExprRange":"(line 82,col 17)-(line 82,col 39)","literalExprId":1,"literalExpr":"\"graphs with multiple \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 83,col 19)-(line 83,col 43)","literalExprId":2,"literalExpr":"\"edges are not supported\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 92,col 17)-(line 92,col 46)","literalExprId":3,"literalExpr":"\"can not match directed with \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 93,col 19)-(line 93,col 37)","literalExprId":4,"literalExpr":"\"undirected graphs\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 100,col 58)-(line 100,col 61)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 102,col 58)-(line 102,col 61)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator,\n        boolean cacheEdges)\n    {\n        if ((graph1 instanceof Multigraph)\n            || (graph2 instanceof Multigraph)\n            || (graph1 instanceof Pseudograph)\n            || (graph2 instanceof Pseudograph)\n            || (graph1 instanceof DirectedMultigraph)\n            || (graph2 instanceof DirectedMultigraph)\n            || (graph1 instanceof DirectedPseudograph)\n            || (graph2 instanceof DirectedPseudograph))\n        {\n            throw new UnsupportedOperationException(\n                \"graphs with multiple \"\n                + \"edges are not supported\");\n        }\n\n        if (((graph1 instanceof DirectedGraph)\n                && (graph2 instanceof UndirectedGraph))\n            || ((graph1 instanceof UndirectedGraph)\n                && (graph2 instanceof DirectedGraph)))\n        {\n            throw new IllegalArgumentException(\n                \"can not match directed with \"\n                + \"undirected graphs\");\n        }\n\n        this.graph1 = graph1;\n        this.graph2 = graph2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n        this.ordering1 = new GraphOrdering<V, E>(graph1, true,\n            cacheEdges);\n        this.ordering2 = new GraphOrdering<V, E>(graph2, true,\n            cacheEdges);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation of the VF2 algorithm does not support graphs with\nmultiple edges.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[graph1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph'}]}', name=Optional[graph2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of vertices'}]}', name=Optional[vertexComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of edges'}]}', name=Optional[edgeComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, edges get cached for faster access'}]}', name=Optional[cacheEdges]}]}"},{"constructorName":"VF2AbstractIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[{"literalExprRange":"(line 116,col 13)-(line 116,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            true);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 106,col 5)-(line 117,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2AbstractIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    this(graph1, graph2, vertexComparator, edgeComparator, true);\n}","constructorJavadoc":""},{"constructorName":"VF2AbstractIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, boolean)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[{"literalExprRange":"(line 126,col 13)-(line 126,col 16)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 127,col 13)-(line 127,col 16)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        boolean cacheEdges)\n    {\n        this(graph1,\n            graph2,\n            null,\n            null,\n            cacheEdges);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 119,col 5)-(line 129,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2AbstractIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, boolean cacheEdges)","constructorBody":"{\n    this(graph1, graph2, null, null, cacheEdges);\n}","constructorJavadoc":""},{"constructorName":"VF2AbstractIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.VF2AbstractIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"}],"literalExprs":[{"literalExprRange":"(line 137,col 13)-(line 137,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2AbstractIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2)\n    {\n        this(graph1,\n            graph2,\n            true);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 131,col 5)-(line 138,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2AbstractIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2)","constructorBody":"{\n    this(graph1, graph2, true);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public abstract Iterator<GraphMapping<V, E>> getMappings()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 140,col 5)-(line 140,col 73)","methodTokenRange":"@Override public abstract Iterator<GraphMapping<V, E>> getMappings();","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getMappings","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.getMappings","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Iterator<GraphMapping<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.getMappings()"},{"methodDeclaration":"public boolean isomorphismExists()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Iterator<GraphMapping<V, E>> iter = getMappings();\n    return iter.hasNext();\n}","methodRange":"(line 142,col 5)-(line 146,col 5)","methodTokenRange":"@Override public boolean isomorphismExists()\n    {\n        Iterator<GraphMapping<V, E>> iter = getMappings();\n        return iter.hasNext();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"isomorphismExists","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.isomorphismExists","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2AbstractIsomorphismInspector.isomorphismExists()"}],"classJavadoc":"","className":"VF2AbstractIsomorphismInspector","fields":[{"fieldRange":"(line 48,col 5)-(line 48,col 41)","fieldName":"graph1","fieldJavadocComment":"","fieldTokenRange":"protected Graph<V, E> graph1, graph2;","fieldTypeResolved":"","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 50,col 5)-(line 50,col 45)","fieldName":"vertexComparator","fieldJavadocComment":"","fieldTokenRange":"protected Comparator<V> vertexComparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<V>"},{"fieldRange":"(line 51,col 5)-(line 51,col 43)","fieldName":"edgeComparator","fieldJavadocComment":"","fieldTokenRange":"protected Comparator<E> edgeComparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<E>"},{"fieldRange":"(line 53,col 5)-(line 53,col 55)","fieldName":"ordering1","fieldJavadocComment":"","fieldTokenRange":"protected GraphOrdering<V, E> ordering1, ordering2;","fieldTypeResolved":"","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"GraphOrdering<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":""}]}],"sourceFileId":140,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"VF2SubgraphIsomorphismState","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState.VF2SubgraphIsomorphismState","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState.VF2SubgraphIsomorphismState(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g1","parameterName":"g1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g2","parameterName":"g2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[],"constructorTokenRange":"public VF2SubgraphIsomorphismState(\n        GraphOrdering<V, E> g1,\n        GraphOrdering<V, E> g2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        super(g1, g2, vertexComparator, edgeComparator);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 45,col 5)-(line 52,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2SubgraphIsomorphismState(GraphOrdering<V, E> g1, GraphOrdering<V, E> g2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    super(g1, g2, vertexComparator, edgeComparator);\n}","constructorJavadoc":""},{"constructorName":"VF2SubgraphIsomorphismState","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState.VF2SubgraphIsomorphismState","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState.VF2SubgraphIsomorphismState(org.jgrapht.alg.isomorphism.VF2State<V, E>)","constructorParameters":[{"parameterType":"VF2State<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.VF2State, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.VF2State.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.VF2State.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.VF2State<V, E>","parameter":"VF2State<V, E> s","parameterName":"s"}],"literalExprs":[],"constructorTokenRange":"public VF2SubgraphIsomorphismState(VF2State<V, E> s)\n    {\n        super(s);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 54,col 5)-(line 57,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2SubgraphIsomorphismState(VF2State<V, E> s)","constructorBody":"{\n    super(s);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are subgraph isomorphic to the already matched\nvertices of graph2 and the second one vertex of nextPair.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are subgraph isomorphic to the already matched\nvertices of graph2 and the second one vertex of nextPair.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isFeasiblePair()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String pairstr = \"(\" + g1.getVertex(addVertex1) + \", \" + g2.getVertex(addVertex2) + \")\", abortmsg = pairstr + \" does not fit in the current matching\";\n    if (!areCompatibleVertexes(addVertex1, addVertex2)) {\n        return false;\n    }\n    int termOutPred1 = 0, termOutPred2 = 0, termInPred1 = 0, termInPred2 = 0, newPred1 = 0, newPred2 = 0, termOutSucc1 = 0, termOutSucc2 = 0, termInSucc1 = 0, termInSucc2 = 0, newSucc1 = 0, newSucc2 = 0;\n    for (int other1 : g1.getOutEdges(addVertex1)) {\n        if (core1[other1] != NULL_NODE) {\n            int other2 = core1[other1];\n            if (!g2.hasEdge(addVertex2, other2) || !areCompatibleEdges(addVertex1, other1, addVertex2, other2)) {\n                showLog(\"isFeasiblePair\", abortmsg + \": edge from \" + g2.getVertex(addVertex2) + \" to \" + g2.getVertex(other2) + \" is missing in the 2nd graph\");\n                return false;\n            }\n        } else {\n            if (in1[other1] > 0) {\n                termInSucc1++;\n            }\n            if (out1[other1] > 0) {\n                termOutSucc1++;\n            }\n            if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                newSucc1++;\n            }\n        }\n    }\n    for (int other2 : g2.getOutEdges(addVertex2)) {\n        if (core2[other2] != NULL_NODE) {\n            int other1 = core2[other2];\n            if (!g1.hasEdge(addVertex1, other1)) {\n                showLog(\"isFeasbilePair\", abortmsg + \": edge from \" + g1.getVertex(addVertex1) + \" to \" + g1.getVertex(other1) + \" is missing in the 1st graph\");\n                return false;\n            }\n        } else {\n            if (in2[other2] > 0) {\n                termInSucc2++;\n            }\n            if (out2[other2] > 0) {\n                termOutSucc2++;\n            }\n            if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                newSucc2++;\n            }\n        }\n    }\n    if ((termInSucc1 < termInSucc2) || (termOutSucc1 < termOutSucc2) || (newSucc1 < newSucc2)) {\n        if (DEBUG) {\n            String cause = \"\", v1 = g1.getVertex(addVertex1).toString(), v2 = g2.getVertex(addVertex2).toString();\n            if (termInSucc2 > termInSucc1) {\n                cause = \"|Tin2  Succ(Graph2, \" + v2 + \")| > |Tin1  Succ(Graph1, \" + v1 + \")|\";\n            } else if (termOutSucc2 > termOutSucc1) {\n                cause = \"|Tout2  Succ(Graph2, \" + v2 + \")| > |Tout1  Succ(Graph1, \" + v1 + \")|\";\n            } else if (newSucc2 > newSucc1) {\n                cause = \"|N\u203E  Succ(Graph2, \" + v2 + \")| > |N\u203E  Succ(Graph1, \" + v1 + \")|\";\n            }\n            showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n        }\n        return false;\n    }\n    for (int other1 : g1.getInEdges(addVertex1)) {\n        if (core1[other1] != NULL_NODE) {\n            int other2 = core1[other1];\n            if (!g2.hasEdge(other2, addVertex2) || !areCompatibleEdges(other1, addVertex1, other2, addVertex2)) {\n                showLog(\"isFeasbilePair\", abortmsg + \": edge from \" + g2.getVertex(other2) + \" to \" + g2.getVertex(addVertex2) + \" is missing in the 2nd graph\");\n                return false;\n            }\n        } else {\n            if (in1[other1] > 0) {\n                termInPred1++;\n            }\n            if (out1[other1] > 0) {\n                termOutPred1++;\n            }\n            if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                newPred1++;\n            }\n        }\n    }\n    for (int other2 : g2.getInEdges(addVertex2)) {\n        if (core2[other2] != NULL_NODE) {\n            int other1 = core2[other2];\n            if (!g1.hasEdge(other1, addVertex1)) {\n                showLog(\"isFeasiblePair\", abortmsg + \": edge from \" + g1.getVertex(other1) + \" to \" + g1.getVertex(addVertex1) + \" is missing in the 1st graph\");\n                return false;\n            }\n        } else {\n            if (in2[other2] > 0) {\n                termInPred2++;\n            }\n            if (out2[other2] > 0) {\n                termOutPred2++;\n            }\n            if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                newPred2++;\n            }\n        }\n    }\n    if ((termInPred1 >= termInPred2) && (termOutPred1 >= termOutPred2) && (newPred1 >= newPred2)) {\n        showLog(\"isFeasiblePair\", pairstr + \" fits\");\n        return true;\n    } else {\n        if (DEBUG) {\n            String cause = \"\", v1 = g1.getVertex(addVertex1).toString(), v2 = g2.getVertex(addVertex2).toString();\n            if (termInPred2 > termInPred1) {\n                cause = \"|Tin2  Pred(Graph2, \" + v2 + \")| > |Tin1  Pred(Graph1, \" + v1 + \")|\";\n            } else if (termOutPred2 > termOutPred1) {\n                cause = \"|Tout2  Pred(Graph2, \" + v2 + \")| > |Tout1  Pred(Graph1, \" + v1 + \")|\";\n            } else if (newPred2 > newPred1) {\n                cause = \"|N\u203E  Pred(Graph2, \" + v2 + \")| > |N\u203E  Pred(Graph1, \" + v1 + \")|\";\n            }\n            showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n        }\n        return false;\n    }\n}","methodRange":"(line 64,col 5)-(line 255,col 5)","methodTokenRange":"@Override public boolean isFeasiblePair()\n    {\n        String pairstr =\n            \"(\" + g1.getVertex(addVertex1) + \", \"\n            + g2.getVertex(addVertex2) + \")\",\n            abortmsg = pairstr + \" does not fit in the current matching\";\n\n        \/\/ check for semantic equality of both vertexes\n        if (!areCompatibleVertexes(addVertex1, addVertex2)) {\n            return false;\n        }\n\n        int termOutPred1 = 0, termOutPred2 = 0, termInPred1 = 0,\n            termInPred2 = 0, newPred1 = 0, newPred2 = 0, termOutSucc1 = 0,\n            termOutSucc2 = 0, termInSucc1 = 0, termInSucc2 = 0, newSucc1 = 0,\n            newSucc2 = 0;\n\n        \/\/ check outgoing edges of addVertex1\n        for (int other1 : g1.getOutEdges(addVertex1)) {\n            if (core1[other1] != NULL_NODE) {\n                int other2 = core1[other1];\n                if (!g2.hasEdge(addVertex2, other2)\n                    || !areCompatibleEdges(\n                        addVertex1,\n                        other1,\n                        addVertex2,\n                        other2))\n                {\n                    showLog(\n                        \"isFeasiblePair\",\n                        abortmsg + \": edge from \"\n                        + g2.getVertex(addVertex2) + \" to \"\n                        + g2.getVertex(other2)\n                        + \" is missing in the 2nd graph\");\n                    return false;\n                }\n            } else {\n                if (in1[other1] > 0) {\n                    termInSucc1++;\n                }\n                if (out1[other1] > 0) {\n                    termOutSucc1++;\n                }\n                if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                    newSucc1++;\n                }\n            }\n        }\n\n        \/\/ check outgoing edges of addVertex2\n        for (int other2 : g2.getOutEdges(addVertex2)) {\n            if (core2[other2] != NULL_NODE) {\n                int other1 = core2[other2];\n                if (!g1.hasEdge(addVertex1, other1)) {\n                    showLog(\n                        \"isFeasbilePair\",\n                        abortmsg + \": edge from \"\n                        + g1.getVertex(addVertex1) + \" to \"\n                        + g1.getVertex(other1)\n                        + \" is missing in the 1st graph\");\n                    return false;\n                }\n            } else {\n                if (in2[other2] > 0) {\n                    termInSucc2++;\n                }\n                if (out2[other2] > 0) {\n                    termOutSucc2++;\n                }\n                if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                    newSucc2++;\n                }\n            }\n        }\n\n        if ((termInSucc1 < termInSucc2)\n            || (termOutSucc1 < termOutSucc2)\n            || (newSucc1 < newSucc2))\n        {\n            if (DEBUG) {\n                String cause = \"\", v1 = g1.getVertex(addVertex1).toString(),\n                    v2 = g2.getVertex(addVertex2).toString();\n\n                if (termInSucc2 > termInSucc1) {\n                    cause =\n                        \"|Tin2  Succ(Graph2, \" + v2\n                        + \")| > |Tin1  Succ(Graph1, \" + v1 + \")|\";\n                } else if (termOutSucc2 > termOutSucc1) {\n                    cause =\n                        \"|Tout2  Succ(Graph2, \" + v2\n                        + \")| > |Tout1  Succ(Graph1, \" + v1 + \")|\";\n                } else if (newSucc2 > newSucc1) {\n                    cause =\n                        \"|N\u203E  Succ(Graph2, \" + v2\n                        + \")| > |N\u203E  Succ(Graph1, \" + v1 + \")|\";\n                }\n\n                showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n            }\n\n            return false;\n        }\n\n        \/\/ check incoming edges of addVertex1\n        for (int other1 : g1.getInEdges(addVertex1)) {\n            if (core1[other1] != NULL_NODE) {\n                int other2 = core1[other1];\n                if (!g2.hasEdge(other2, addVertex2)\n                    || !areCompatibleEdges(\n                        other1,\n                        addVertex1,\n                        other2,\n                        addVertex2))\n                {\n                    showLog(\n                        \"isFeasbilePair\",\n                        abortmsg + \": edge from \"\n                        + g2.getVertex(other2) + \" to \"\n                        + g2.getVertex(addVertex2)\n                        + \" is missing in the 2nd graph\");\n                    return false;\n                }\n            } else {\n                if (in1[other1] > 0) {\n                    termInPred1++;\n                }\n                if (out1[other1] > 0) {\n                    termOutPred1++;\n                }\n                if ((in1[other1] == 0) && (out1[other1] == 0)) {\n                    newPred1++;\n                }\n            }\n        }\n\n        \/\/ check incoming edges of addVertex2\n        for (int other2 : g2.getInEdges(addVertex2)) {\n            if (core2[other2] != NULL_NODE) {\n                int other1 = core2[other2];\n                if (!g1.hasEdge(other1, addVertex1)) {\n                    showLog(\n                        \"isFeasiblePair\",\n                        abortmsg + \": edge from \"\n                        + g1.getVertex(other1) + \" to \"\n                        + g1.getVertex(addVertex1)\n                        + \" is missing in the 1st graph\");\n                    return false;\n                }\n            } else {\n                if (in2[other2] > 0) {\n                    termInPred2++;\n                }\n                if (out2[other2] > 0) {\n                    termOutPred2++;\n                }\n                if ((in2[other2] == 0) && (out2[other2] == 0)) {\n                    newPred2++;\n                }\n            }\n        }\n\n        if ((termInPred1 >= termInPred2)\n            && (termOutPred1 >= termOutPred2)\n            && (newPred1 >= newPred2))\n        {\n            showLog(\"isFeasiblePair\", pairstr + \" fits\");\n            return true;\n        } else {\n            if (DEBUG) {\n                String cause = \"\", v1 = g1.getVertex(addVertex1).toString(),\n                    v2 = g2.getVertex(addVertex2).toString();\n\n                if (termInPred2 > termInPred1) {\n                    cause =\n                        \"|Tin2  Pred(Graph2, \" + v2\n                        + \")| > |Tin1  Pred(Graph1, \" + v1 + \")|\";\n                } else if (termOutPred2 > termOutPred1) {\n                    cause =\n                        \"|Tout2  Pred(Graph2, \" + v2\n                        + \")| > |Tout1  Pred(Graph1, \" + v1 + \")|\";\n                } else if (newPred2 > newPred1) {\n                    cause =\n                        \"|N\u203E  Pred(Graph2, \" + v2\n                        + \")| > |N\u203E  Pred(Graph1, \" + v1 + \")|\";\n                }\n\n                showLog(\"isFeasbilePair\", abortmsg + \": \" + cause);\n            }\n\n            return false;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @return true, if the already matched vertices of graph1 plus the first\n     * vertex of nextPair are subgraph isomorphic to the already matched\n     * vertices of graph2 and the second one vertex of nextPair.\n     ","methodParameters":[],"methodName":"isFeasiblePair","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState.isFeasiblePair","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true, if the already matched vertices of graph1 plus the first\nvertex of nextPair are subgraph isomorphic to the already matched\nvertices of graph2 and the second one vertex of nextPair.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 67,col 13)-(line 67,col 15)","literalExprId":1,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 67,col 46)-(line 67,col 49)","literalExprId":2,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 42)-(line 68,col 44)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 69,col 34)-(line 69,col 72)","literalExprId":4,"literalExpr":"\" does not fit in the current matching\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 73,col 20)-(line 73,col 24)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 76,col 28)-(line 76,col 28)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 46)-(line 76,col 46)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 63)-(line 76,col 63)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 27)-(line 77,col 27)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 41)-(line 77,col 41)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 55)-(line 77,col 55)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 73)-(line 77,col 73)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 28)-(line 78,col 28)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 45)-(line 78,col 45)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 62)-(line 78,col 62)","literalExprId":15,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 76)-(line 78,col 76)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 79,col 24)-(line 79,col 24)","literalExprId":17,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 93,col 25)-(line 93,col 40)","literalExprId":18,"literalExpr":"\"isFeasiblePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 94,col 36)-(line 94,col 49)","literalExprId":19,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 54)-(line 95,col 59)","literalExprId":20,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 97,col 27)-(line 97,col 56)","literalExprId":21,"literalExpr":"\" is missing in the 2nd graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 98,col 28)-(line 98,col 32)","literalExprId":22,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 101,col 35)-(line 101,col 35)","literalExprId":23,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 104,col 36)-(line 104,col 36)","literalExprId":24,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 107,col 37)-(line 107,col 37)","literalExprId":25,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 107,col 60)-(line 107,col 60)","literalExprId":26,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 119,col 25)-(line 119,col 40)","literalExprId":27,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 120,col 36)-(line 120,col 49)","literalExprId":28,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 121,col 54)-(line 121,col 59)","literalExprId":29,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 123,col 27)-(line 123,col 56)","literalExprId":30,"literalExpr":"\" is missing in the 1st graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 124,col 28)-(line 124,col 32)","literalExprId":31,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 127,col 35)-(line 127,col 35)","literalExprId":32,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 130,col 36)-(line 130,col 36)","literalExprId":33,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 133,col 37)-(line 133,col 37)","literalExprId":34,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 133,col 60)-(line 133,col 60)","literalExprId":35,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 144,col 32)-(line 144,col 33)","literalExprId":36,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 149,col 25)-(line 149,col 47)","literalExprId":37,"literalExpr":"\"|Tin2  Succ(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 150,col 27)-(line 150,col 54)","literalExprId":38,"literalExpr":"\")| > |Tin1  Succ(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 150,col 63)-(line 150,col 66)","literalExprId":39,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 153,col 25)-(line 153,col 48)","literalExprId":40,"literalExpr":"\"|Tout2  Succ(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 27)-(line 154,col 55)","literalExprId":41,"literalExpr":"\")| > |Tout1  Succ(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 64)-(line 154,col 67)","literalExprId":42,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 157,col 25)-(line 157,col 45)","literalExprId":43,"literalExpr":"\"|N\u203E  Succ(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 158,col 27)-(line 158,col 52)","literalExprId":44,"literalExpr":"\")| > |N\u203E  Succ(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 158,col 61)-(line 158,col 64)","literalExprId":45,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 161,col 25)-(line 161,col 40)","literalExprId":46,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 161,col 54)-(line 161,col 57)","literalExprId":47,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 164,col 20)-(line 164,col 24)","literalExprId":48,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 179,col 25)-(line 179,col 40)","literalExprId":49,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 180,col 36)-(line 180,col 49)","literalExprId":50,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 181,col 50)-(line 181,col 55)","literalExprId":51,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 183,col 27)-(line 183,col 56)","literalExprId":52,"literalExpr":"\" is missing in the 2nd graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 184,col 28)-(line 184,col 32)","literalExprId":53,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 187,col 35)-(line 187,col 35)","literalExprId":54,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 36)-(line 190,col 36)","literalExprId":55,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 37)-(line 193,col 37)","literalExprId":56,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 60)-(line 193,col 60)","literalExprId":57,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 205,col 25)-(line 205,col 40)","literalExprId":58,"literalExpr":"\"isFeasiblePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 206,col 36)-(line 206,col 49)","literalExprId":59,"literalExpr":"\": edge from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 207,col 50)-(line 207,col 55)","literalExprId":60,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 27)-(line 209,col 56)","literalExprId":61,"literalExpr":"\" is missing in the 1st graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 210,col 28)-(line 210,col 32)","literalExprId":62,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 213,col 35)-(line 213,col 35)","literalExprId":63,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 216,col 36)-(line 216,col 36)","literalExprId":64,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 37)-(line 219,col 37)","literalExprId":65,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 60)-(line 219,col 60)","literalExprId":66,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 229,col 21)-(line 229,col 36)","literalExprId":67,"literalExpr":"\"isFeasiblePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 229,col 49)-(line 229,col 55)","literalExprId":68,"literalExpr":"\" fits\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 230,col 20)-(line 230,col 23)","literalExprId":69,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 233,col 32)-(line 233,col 33)","literalExprId":70,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 238,col 25)-(line 238,col 47)","literalExprId":71,"literalExpr":"\"|Tin2  Pred(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 239,col 27)-(line 239,col 54)","literalExprId":72,"literalExpr":"\")| > |Tin1  Pred(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 239,col 63)-(line 239,col 66)","literalExprId":73,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 242,col 25)-(line 242,col 48)","literalExprId":74,"literalExpr":"\"|Tout2  Pred(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 243,col 27)-(line 243,col 55)","literalExprId":75,"literalExpr":"\")| > |Tout1  Pred(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 243,col 64)-(line 243,col 67)","literalExprId":76,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 246,col 25)-(line 246,col 45)","literalExprId":77,"literalExpr":"\"|N\u203E  Pred(Graph2, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 247,col 27)-(line 247,col 52)","literalExprId":78,"literalExpr":"\")| > |N\u203E  Pred(Graph1, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 247,col 61)-(line 247,col 64)","literalExprId":79,"literalExpr":"\")|\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 250,col 25)-(line 250,col 40)","literalExprId":80,"literalExpr":"\"isFeasbilePair\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 250,col 54)-(line 250,col 57)","literalExprId":81,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 253,col 20)-(line 253,col 24)","literalExprId":82,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismState.isFeasiblePair()"}],"classJavadoc":"","className":"VF2SubgraphIsomorphismState","fields":[]}],"sourceFileId":141,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.IsomorphismInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public Iterator<GraphMapping<V, E>> getMappings()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 52,col 5)-(line 52,col 54)","methodTokenRange":"public Iterator<GraphMapping<V, E>> getMappings();","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getMappings","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphismInspector.getMappings","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Iterator<GraphMapping<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphismInspector.getMappings()"},{"methodDeclaration":"public boolean isomorphismExists()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 54,col 5)-(line 54,col 39)","methodTokenRange":"public boolean isomorphismExists();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"isomorphismExists","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphismInspector.isomorphismExists","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphismInspector.isomorphismExists()"}],"classJavadoc":"\/**\n * This is a general interface for graph and subgraph isomorphism.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\/\n","className":"IsomorphismInspector","fields":[]}],"sourceFileId":142,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first graph","javadocBlockTagName":"graph1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[graph1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second graph (possible subgraph of graph1)","javadocBlockTagName":"graph2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph (possible subgraph of graph1)'}]}', name=Optional[graph2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equivalence of vertices","javadocBlockTagName":"vertexComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of vertices'}]}', name=Optional[vertexComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equivalence of edges","javadocBlockTagName":"edgeComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of edges'}]}', name=Optional[edgeComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, edges get cached for faster access","javadocBlockTagName":"cacheEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, edges get cached for faster access'}]}', name=Optional[cacheEdges]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, java.util.Comparator<V>, java.util.Comparator<E>, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 81,col 5)","constructorJavadocComment":"\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph (possible subgraph of graph1)\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     ","constructorDeclaration":"public VF2SubgraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator, boolean cacheEdges)","constructorBody":"{\n    super(graph1, graph2, vertexComparator, edgeComparator, cacheEdges);\n}","constructorName":"VF2SubgraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"},{"parameterType":"boolean","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[],"constructorTokenRange":"public VF2SubgraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator,\n        boolean cacheEdges)\n    {\n        super(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            cacheEdges);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation of the VF2 algorithm does not support graphs with\nmultiple edges.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[graph1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph (possible subgraph of graph1)'}]}', name=Optional[graph2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of vertices'}]}', name=Optional[vertexComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of edges'}]}', name=Optional[edgeComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, edges get cached for faster access'}]}', name=Optional[cacheEdges]}]}"},{"constructorName":"VF2SubgraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[{"literalExprRange":"(line 93,col 13)-(line 93,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2SubgraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        super(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            true);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 83,col 5)-(line 94,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2SubgraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    super(graph1, graph2, vertexComparator, edgeComparator, true);\n}","constructorJavadoc":""},{"constructorName":"VF2SubgraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, boolean)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[{"literalExprRange":"(line 103,col 13)-(line 103,col 16)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 104,col 13)-(line 104,col 16)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public VF2SubgraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        boolean cacheEdges)\n    {\n        super(graph1,\n            graph2,\n            null,\n            null,\n            cacheEdges);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 96,col 5)-(line 106,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2SubgraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, boolean cacheEdges)","constructorBody":"{\n    super(graph1, graph2, null, null, cacheEdges);\n}","constructorJavadoc":""},{"constructorName":"VF2SubgraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.VF2SubgraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"}],"literalExprs":[{"literalExprRange":"(line 114,col 13)-(line 114,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2SubgraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2)\n    {\n        super(graph1,\n            graph2,\n            true);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 108,col 5)-(line 115,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2SubgraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2)","constructorBody":"{\n    super(graph1, graph2, true);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public VF2SubgraphMappingIterator<V, E> getMappings()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new VF2SubgraphMappingIterator<V, E>(ordering1, ordering2, vertexComparator, edgeComparator);\n}","methodRange":"(line 117,col 5)-(line 124,col 5)","methodTokenRange":"@Override public VF2SubgraphMappingIterator<V, E> getMappings()\n    {\n        return new VF2SubgraphMappingIterator<V, E>(\n            ordering1,\n            ordering2,\n            vertexComparator,\n            edgeComparator);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getMappings","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.getMappings","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"VF2SubgraphMappingIterator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphIsomorphismInspector.getMappings()"}],"classJavadoc":"\/**\n * This is an implementation of the VF2 algorithm using its feature of detecting\n * <a href=\"http:\/\/mathworld.wolfram.com\/Vertex-InducedSubgraph.html\">subgraph\n * isomorphism between two graphs<\/a> as described in Cordella et al. A\n * (sub)graph isomorphism algorithm for matching large graphs (2004),\n * DOI:10.1109\/TPAMI.2004.75, <a\n * href=\"http:\/\/ieeexplore.ieee.org\/xpl\/articleDetails.jsp?arnumber=1323804\">\n * http:\/\/ieeexplore.ieee.org\/xpl\/articleDetails.jsp?arnumber=1323804<\/a>\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\/\n","className":"VF2SubgraphIsomorphismInspector","fields":[]}],"sourceFileId":143,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.GraphOrdering","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be ordered","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be ordered'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"should the vertices be ordered by their degree. This\nspeeds up the VF2 algorithm.","javadocBlockTagName":"orderByDegree","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='should the vertices be ordered by their degree. This\nspeeds up the VF2 algorithm.'}]}', name=Optional[orderByDegree]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, the class creates a adjacency matrix and two\narrays for incoming and outgoing edges for fast access.","javadocBlockTagName":"cacheEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the class creates a adjacency matrix and two\narrays for incoming and outgoing edges for fast access.'}]}', name=Optional[cacheEdges]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.GraphOrdering(org.jgrapht.Graph<V, E>, boolean, boolean)","variableDeclarationExprs":[{"variableType":"List<V>","variableName":"vertexSet","variableDeclarationExprId":1,"variableDeclarationExpr":"List<V> vertexSet = new ArrayList<V>(graph.vertexSet())","variableDeclarationExprRange":"(line 81,col 9)-(line 81,col 63)","variableTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 81,col 17)-(line 81,col 63)"},{"variableType":"Integer","variableName":"i","variableDeclarationExprId":2,"variableDeclarationExpr":"Integer i = 0","variableDeclarationExprRange":"(line 98,col 9)-(line 98,col 21)","variableTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 98,col 17)-(line 98,col 21)"},{"variableType":"V","variableName":"vertex","variableDeclarationExprId":3,"variableDeclarationExpr":"V vertex","variableDeclarationExprRange":"(line 99,col 14)-(line 99,col 21)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 99,col 16)-(line 99,col 21)"}],"constructorRange":"(line 73,col 5)-(line 103,col 5)","constructorJavadocComment":"\n     * @param graph the graph to be ordered\n     * @param orderByDegree should the vertices be ordered by their degree. This\n     * speeds up the VF2 algorithm.\n     * @param cacheEdges if true, the class creates a adjacency matrix and two\n     * arrays for incoming and outgoing edges for fast access.\n     ","constructorDeclaration":"public GraphOrdering(Graph<V, E> graph, boolean orderByDegree, boolean cacheEdges)","constructorBody":"{\n    this.graph = graph;\n    this.cacheEdges = cacheEdges;\n    List<V> vertexSet = new ArrayList<V>(graph.vertexSet());\n    if (orderByDegree) {\n        java.util.Collections.sort(vertexSet, new GeneralVertexDegreeComparator<V>(graph));\n    }\n    vertexCount = vertexSet.size();\n    mapVertexToOrder = new HashMap<V, Integer>();\n    mapOrderToVertex = new ArrayList<V>(vertexCount);\n    if (cacheEdges) {\n        outgoingEdges = new int[vertexCount][];\n        incomingEdges = new int[vertexCount][];\n        adjMatrix = new Boolean[vertexCount][vertexCount];\n    }\n    Integer i = 0;\n    for (V vertex : vertexSet) {\n        mapVertexToOrder.put(vertex, i++);\n        mapOrderToVertex.add(vertex);\n    }\n}","constructorName":"GraphOrdering","constructorQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.GraphOrdering","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean orderByDegree","parameterName":"orderByDegree"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[{"literalExprRange":"(line 98,col 21)-(line 98,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public GraphOrdering(\n        Graph<V, E> graph,\n        boolean orderByDegree,\n        boolean cacheEdges)\n    {\n        this.graph = graph;\n        this.cacheEdges = cacheEdges;\n\n        List<V> vertexSet = new ArrayList<V>(graph.vertexSet());\n        if (orderByDegree) {\n            java.util.Collections.sort(\n                vertexSet,\n                new GeneralVertexDegreeComparator<V>(graph));\n        }\n\n        vertexCount = vertexSet.size();\n        mapVertexToOrder = new HashMap<V, Integer>();\n        mapOrderToVertex = new ArrayList<V>(vertexCount);\n\n        if (cacheEdges) {\n            outgoingEdges = new int[vertexCount][];\n            incomingEdges = new int[vertexCount][];\n            adjMatrix = new Boolean[vertexCount][vertexCount];\n        }\n\n        Integer i = 0;\n        for (V vertex : vertexSet) {\n            mapVertexToOrder.put(vertex, i++);\n            mapOrderToVertex.add(vertex);\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be ordered'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='should the vertices be ordered by their degree. This\nspeeds up the VF2 algorithm.'}]}', name=Optional[orderByDegree]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the class creates a adjacency matrix and two\narrays for incoming and outgoing edges for fast access.'}]}', name=Optional[cacheEdges]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be ordered","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be ordered'}]}', name=Optional[graph]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.GraphOrdering(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 108,col 5)-(line 111,col 5)","constructorJavadocComment":"\n     * @param graph the graph to be ordered\n     ","constructorDeclaration":"public GraphOrdering(Graph<V, E> graph)","constructorBody":"{\n    this(graph, false, true);\n}","constructorName":"GraphOrdering","constructorQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.GraphOrdering","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 110,col 21)-(line 110,col 25)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 110,col 28)-(line 110,col 31)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public GraphOrdering(Graph<V, E> graph)\n    {\n        this(graph, false, true);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be ordered'}]}', name=Optional[graph]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 273,col 5)-(line 287,col 5)","classOrInterfaceTokenRange":"private static class GeneralVertexDegreeComparator<V2>\n        implements Comparator<V2>\n    {\n        private Graph<V2, ?> graph;\n\n        GeneralVertexDegreeComparator(Graph<V2, ?> graph)\n        {\n            this.graph = graph;\n        }\n\n        @Override public int compare(V2 v1, V2 v2)\n        {\n            return graph.edgesOf(v1).size() - graph.edgesOf(v2).size();\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"returns the number of vertices in the graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='returns the number of vertices in the graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getVertexCount()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.vertexCount;\n}","methodRange":"(line 116,col 5)-(line 119,col 5)","methodTokenRange":"public int getVertexCount()\n    {\n        return this.vertexCount;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @return returns the number of vertices in the graph.\n     ","methodParameters":[],"methodName":"getVertexCount","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getVertexCount","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='returns the number of vertices in the graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getVertexCount()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number which identifies the vertex v in this\norder.","javadocBlockTagName":"vertexNumber","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number which identifies the vertex v in this\norder.'}]}', name=Optional[vertexNumber]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the identifying numbers of all vertices which are connected to v\nby an edge outgoing from v.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the identifying numbers of all vertices which are connected to v\nby an edge outgoing from v.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int[] getOutEdges(int vertexNumber)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (cacheEdges && (outgoingEdges[vertexNumber] != null)) {\n        return outgoingEdges[vertexNumber];\n    }\n    V v = getVertex(vertexNumber);\n    Set<E> edgeSet = null;\n    if (graph instanceof DirectedGraph<?, ?>) {\n        edgeSet = ((DirectedGraph<V, E>) graph).outgoingEdgesOf(v);\n    } else {\n        edgeSet = graph.edgesOf(v);\n    }\n    int[] vertexArray = new int[edgeSet.size()];\n    int i = 0;\n    for (E edge : edgeSet) {\n        V source = graph.getEdgeSource(edge), target = graph.getEdgeTarget(edge);\n        vertexArray[i++] = mapVertexToOrder.get(source.equals(v) ? target : source);\n    }\n    if (cacheEdges) {\n        outgoingEdges[vertexNumber] = vertexArray;\n    }\n    return vertexArray;\n}","methodRange":"(line 128,col 5)-(line 158,col 5)","methodTokenRange":"public int [] getOutEdges(int vertexNumber)\n    {\n        if (cacheEdges && (outgoingEdges[vertexNumber] != null)) {\n            return outgoingEdges[vertexNumber];\n        }\n\n        V v = getVertex(vertexNumber);\n        Set<E> edgeSet = null;\n\n        if (graph instanceof DirectedGraph<?, ?>) {\n            edgeSet = ((DirectedGraph<V, E>) graph).outgoingEdgesOf(v);\n        } else {\n            edgeSet = graph.edgesOf(v);\n        }\n\n        int [] vertexArray = new int[edgeSet.size()];\n        int i = 0;\n\n        for (E edge : edgeSet) {\n            V source = graph.getEdgeSource(edge),\n                target = graph.getEdgeTarget(edge);\n            vertexArray[i++] =\n                mapVertexToOrder.get(source.equals(v) ? target : source);\n        }\n\n        if (cacheEdges) {\n            outgoingEdges[vertexNumber] = vertexArray;\n        }\n\n        return vertexArray;\n    }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n     * @param vertexNumber the number which identifies the vertex v in this\n     * order.\n     *\n     * @return the identifying numbers of all vertices which are connected to v\n     * by an edge outgoing from v.\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int vertexNumber","parameterName":"vertexNumber"}],"methodName":"getOutEdges","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getOutEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number which identifies the vertex v in this\norder.'}]}', name=Optional[vertexNumber]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the identifying numbers of all vertices which are connected to v\nby an edge outgoing from v.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 130,col 59)-(line 130,col 62)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 135,col 26)-(line 135,col 29)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 144,col 17)-(line 144,col 17)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getOutEdges(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number which identifies the vertex v in this\norder.","javadocBlockTagName":"vertexNumber","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number which identifies the vertex v in this\norder.'}]}', name=Optional[vertexNumber]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the identifying numbers of all vertices which are connected to v\nby an edge incoming to v.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the identifying numbers of all vertices which are connected to v\nby an edge incoming to v.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int[] getInEdges(int vertexNumber)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (cacheEdges && (incomingEdges[vertexNumber] != null)) {\n        return incomingEdges[vertexNumber];\n    }\n    V v = getVertex(vertexNumber);\n    Set<E> edgeSet = null;\n    if (graph instanceof DirectedGraph<?, ?>) {\n        edgeSet = ((DirectedGraph<V, E>) graph).incomingEdgesOf(v);\n    } else {\n        edgeSet = graph.edgesOf(v);\n    }\n    int[] vertexArray = new int[edgeSet.size()];\n    int i = 0;\n    for (E edge : edgeSet) {\n        V source = graph.getEdgeSource(edge), target = graph.getEdgeTarget(edge);\n        vertexArray[i++] = mapVertexToOrder.get(source.equals(v) ? target : source);\n    }\n    if (cacheEdges) {\n        incomingEdges[vertexNumber] = vertexArray;\n    }\n    return vertexArray;\n}","methodRange":"(line 167,col 5)-(line 197,col 5)","methodTokenRange":"public int [] getInEdges(int vertexNumber)\n    {\n        if (cacheEdges && (incomingEdges[vertexNumber] != null)) {\n            return incomingEdges[vertexNumber];\n        }\n\n        V v = getVertex(vertexNumber);\n        Set<E> edgeSet = null;\n\n        if (graph instanceof DirectedGraph<?, ?>) {\n            edgeSet = ((DirectedGraph<V, E>) graph).incomingEdgesOf(v);\n        } else {\n            edgeSet = graph.edgesOf(v);\n        }\n\n        int [] vertexArray = new int[edgeSet.size()];\n        int i = 0;\n\n        for (E edge : edgeSet) {\n            V source = graph.getEdgeSource(edge),\n                target = graph.getEdgeTarget(edge);\n            vertexArray[i++] =\n                mapVertexToOrder.get(source.equals(v) ? target : source);\n        }\n\n        if (cacheEdges) {\n            incomingEdges[vertexNumber] = vertexArray;\n        }\n\n        return vertexArray;\n    }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n     * @param vertexNumber the number which identifies the vertex v in this\n     * order.\n     *\n     * @return the identifying numbers of all vertices which are connected to v\n     * by an edge incoming to v.\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int vertexNumber","parameterName":"vertexNumber"}],"methodName":"getInEdges","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getInEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number which identifies the vertex v in this\norder.'}]}', name=Optional[vertexNumber]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the identifying numbers of all vertices which are connected to v\nby an edge incoming to v.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 169,col 59)-(line 169,col 62)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 174,col 26)-(line 174,col 29)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 183,col 17)-(line 183,col 17)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getInEdges(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of the first vertex v1","javadocBlockTagName":"v1Number","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of the first vertex v1'}]}', name=Optional[v1Number]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of the second vertex v2","javadocBlockTagName":"v2Number","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of the second vertex v2'}]}', name=Optional[v2Number]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"exists the edge from v1 to v2","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='exists the edge from v1 to v2'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasEdge(int v1Number, int v2Number)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V v1, v2;\n    Boolean containsEdge = null;\n    if (cacheEdges) {\n        containsEdge = adjMatrix[v1Number][v2Number];\n    }\n    if (!cacheEdges || (containsEdge == null)) {\n        v1 = getVertex(v1Number);\n        v2 = getVertex(v2Number);\n        containsEdge = graph.containsEdge(v1, v2);\n    }\n    if (cacheEdges && (adjMatrix[v1Number][v2Number] == null)) {\n        adjMatrix[v1Number][v2Number] = containsEdge;\n    }\n    return containsEdge;\n}","methodRange":"(line 205,col 5)-(line 225,col 5)","methodTokenRange":"public boolean hasEdge(int v1Number, int v2Number)\n    {\n        V v1, v2;\n        Boolean containsEdge = null;\n\n        if (cacheEdges) {\n            containsEdge = adjMatrix[v1Number][v2Number];\n        }\n\n        if (!cacheEdges || (containsEdge == null)) {\n            v1 = getVertex(v1Number);\n            v2 = getVertex(v2Number);\n            containsEdge = graph.containsEdge(v1, v2);\n        }\n\n        if (cacheEdges && (adjMatrix[v1Number][v2Number] == null)) {\n            adjMatrix[v1Number][v2Number] = containsEdge;\n        }\n\n        return containsEdge;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @param v1Number the number of the first vertex v1\n     * @param v2Number the number of the second vertex v2\n     *\n     * @return exists the edge from v1 to v2\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v1Number","parameterName":"v1Number"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v2Number","parameterName":"v2Number"}],"methodName":"hasEdge","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.hasEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of the first vertex v1'}]}', name=Optional[v1Number]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of the second vertex v2'}]}', name=Optional[v2Number]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='exists the edge from v1 to v2'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 208,col 32)-(line 208,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 214,col 45)-(line 214,col 48)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 220,col 61)-(line 220,col 64)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.hasEdge(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number identifying the vertex v","javadocBlockTagName":"vertexNumber","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number identifying the vertex v'}]}', name=Optional[vertexNumber]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"v","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='v'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getVertex(int vertexNumber)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return mapOrderToVertex.get(vertexNumber);\n}","methodRange":"(line 234,col 5)-(line 237,col 5)","methodTokenRange":"public V getVertex(int vertexNumber)\n    {\n        return mapOrderToVertex.get(vertexNumber);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * be careful: there's no check against an invalid vertexNumber\n     *\n     * @param vertexNumber the number identifying the vertex v\n     *\n     * @return v\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int vertexNumber","parameterName":"vertexNumber"}],"methodName":"getVertex","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='be careful: there's no check against an invalid vertexNumber'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number identifying the vertex v'}]}', name=Optional[vertexNumber]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='v'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getVertex(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number identifying the vertex v1","javadocBlockTagName":"v1Number","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number identifying the vertex v1'}]}', name=Optional[v1Number]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number identifying the vertex v2","javadocBlockTagName":"v2Number","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number identifying the vertex v2'}]}', name=Optional[v2Number]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the edge from v1 to v2","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the edge from v1 to v2'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getEdge(int v1Number, int v2Number)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V v1 = getVertex(v1Number), v2 = getVertex(v2Number);\n    return graph.getEdge(v1, v2);\n}","methodRange":"(line 245,col 5)-(line 250,col 5)","methodTokenRange":"public E getEdge(int v1Number, int v2Number)\n    {\n        V v1 = getVertex(v1Number), v2 = getVertex(v2Number);\n\n        return graph.getEdge(v1, v2);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * @param v1Number the number identifying the vertex v1\n     * @param v2Number the number identifying the vertex v2\n     *\n     * @return the edge from v1 to v2\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v1Number","parameterName":"v1Number"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v2Number","parameterName":"v2Number"}],"methodName":"getEdge","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number identifying the vertex v1'}]}', name=Optional[v1Number]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number identifying the vertex v2'}]}', name=Optional[v2Number]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the edge from v1 to v2'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getEdge(int, int)"},{"methodDeclaration":"public int getVertexNumber(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return mapVertexToOrder.get(v).intValue();\n}","methodRange":"(line 252,col 5)-(line 255,col 5)","methodTokenRange":"public int getVertexNumber(V v)\n    {\n        return mapVertexToOrder.get(v).intValue();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getVertexNumber","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getVertexNumber","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getVertexNumber(V)"},{"methodDeclaration":"public int[] getEdgeNumbers(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    V v1 = graph.getEdgeSource(e), v2 = graph.getEdgeTarget(e);\n    int[] edge = new int[2];\n    edge[0] = mapVertexToOrder.get(v1);\n    edge[1] = mapVertexToOrder.get(v2);\n    return edge;\n}","methodRange":"(line 257,col 5)-(line 266,col 5)","methodTokenRange":"public int [] getEdgeNumbers(E e)\n    {\n        V v1 = graph.getEdgeSource(e), v2 = graph.getEdgeTarget(e);\n\n        int [] edge = new int[2];\n        edge[0] = mapVertexToOrder.get(v1);\n        edge[1] = mapVertexToOrder.get(v2);\n\n        return edge;\n    }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"getEdgeNumbers","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getEdgeNumbers","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 261,col 31)-(line 261,col 31)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 262,col 14)-(line 262,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 263,col 14)-(line 263,col 14)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getEdgeNumbers(E)"},{"methodDeclaration":"public Graph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 268,col 5)-(line 271,col 5)","methodTokenRange":"public Graph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.GraphOrdering.getGraph","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Graph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.GraphOrdering.getGraph()"}],"classJavadoc":"","className":"GraphOrdering","fields":[{"fieldRange":"(line 54,col 5)-(line 54,col 30)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 56,col 5)-(line 56,col 45)","fieldName":"mapVertexToOrder","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> mapVertexToOrder;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 57,col 5)-(line 57,col 42)","fieldName":"mapOrderToVertex","fieldJavadocComment":"","fieldTokenRange":"private ArrayList<V> mapOrderToVertex;","fieldTypeResolved":"ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ArrayList<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayList<V>"},{"fieldRange":"(line 58,col 5)-(line 58,col 28)","fieldName":"vertexCount","fieldJavadocComment":"","fieldTokenRange":"private int vertexCount;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 60,col 5)-(line 60,col 35)","fieldName":"outgoingEdges","fieldJavadocComment":"","fieldTokenRange":"private int [][] outgoingEdges;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[][]"},{"fieldRange":"(line 61,col 5)-(line 61,col 35)","fieldName":"incomingEdges","fieldJavadocComment":"","fieldTokenRange":"private int [][] incomingEdges;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[][]"},{"fieldRange":"(line 62,col 5)-(line 62,col 35)","fieldName":"adjMatrix","fieldJavadocComment":"","fieldTokenRange":"private Boolean [][] adjMatrix;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{ReferenceType{java.lang.Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Boolean[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Boolean[][]"},{"fieldRange":"(line 64,col 5)-(line 64,col 31)","fieldName":"cacheEdges","fieldJavadocComment":"","fieldTokenRange":"private boolean cacheEdges;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":144,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2GraphMappingIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"ordering1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[ordering1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"ordering2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[ordering2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertexComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"edgeComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[edgeComparator]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphMappingIterator.VF2GraphMappingIterator(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 67,col 5)","constructorJavadocComment":"\n     * @param ordering1\n     * @param ordering2\n     * @param vertexComparator\n     * @param edgeComparator\n     ","constructorDeclaration":"public VF2GraphMappingIterator(GraphOrdering<V, E> ordering1, GraphOrdering<V, E> ordering2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    super(ordering1, ordering2, vertexComparator, edgeComparator);\n}","constructorName":"VF2GraphMappingIterator","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphMappingIterator.VF2GraphMappingIterator","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> ordering1","parameterName":"ordering1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> ordering2","parameterName":"ordering2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[],"constructorTokenRange":"public VF2GraphMappingIterator(\n        GraphOrdering<V, E> ordering1,\n        GraphOrdering<V, E> ordering2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        super(ordering1, ordering2, vertexComparator, edgeComparator);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[ordering1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[ordering2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[edgeComparator]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"protected IsomorphicGraphMapping<V, E> match()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    VF2State<V, E> s;\n    if (stateStack.isEmpty()) {\n        Graph<V, E> g1 = ordering1.getGraph(), g2 = ordering2.getGraph();\n        if ((g1.vertexSet().size() != g2.vertexSet().size()) || (g1.edgeSet().size() != g2.edgeSet().size())) {\n            return null;\n        }\n        s = new VF2GraphIsomorphismState<V, E>(ordering1, ordering2, vertexComparator, edgeComparator);\n        if (g2.vertexSet().isEmpty()) {\n            return (hadOneMapping != null) ? null : s.getCurrentMapping();\n        }\n    } else {\n        stateStack.pop().backtrack();\n        s = stateStack.pop();\n    }\n    while (true) {\n        while (s.nextPair()) {\n            if (s.isFeasiblePair()) {\n                stateStack.push(s);\n                s = new VF2GraphIsomorphismState<V, E>(s);\n                s.addPair();\n                if (s.isGoal()) {\n                    stateStack.push(s);\n                    return s.getCurrentMapping();\n                }\n                s.resetAddVertexes();\n            }\n        }\n        if (stateStack.isEmpty()) {\n            return null;\n        }\n        s.backtrack();\n        s = stateStack.pop();\n    }\n}","methodRange":"(line 69,col 5)-(line 119,col 5)","methodTokenRange":"@Override protected IsomorphicGraphMapping<V, E> match()\n    {\n        VF2State<V, E> s;\n\n        if (stateStack.isEmpty()) {\n            Graph<V, E> g1 = ordering1.getGraph(), g2 = ordering2.getGraph();\n\n            if ((g1.vertexSet().size() != g2.vertexSet().size())\n                || (g1.edgeSet().size() != g2.edgeSet().size()))\n            {\n                return null;\n            }\n\n            s = new VF2GraphIsomorphismState<V, E>(\n                ordering1,\n                ordering2,\n                vertexComparator,\n                edgeComparator);\n\n            if (g2.vertexSet().isEmpty()) {\n                return (hadOneMapping != null) ? null : s.getCurrentMapping();\n            }\n        } else {\n            stateStack.pop().backtrack();\n            s = stateStack.pop();\n        }\n\n        while (true) {\n            while (s.nextPair()) {\n                if (s.isFeasiblePair()) {\n                    stateStack.push(s);\n                    s = new VF2GraphIsomorphismState<V, E>(s);\n                    s.addPair();\n\n                    if (s.isGoal()) {\n                        stateStack.push(s);\n                        return s.getCurrentMapping();\n                    }\n\n                    s.resetAddVertexes();\n                }\n            }\n\n            if (stateStack.isEmpty()) {\n                return null;\n            }\n\n            s.backtrack();\n            s = stateStack.pop();\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"match","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphMappingIterator.match","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IsomorphicGraphMapping<V, E>","literalExprs":[{"literalExprRange":"(line 79,col 24)-(line 79,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 89,col 42)-(line 89,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 89,col 50)-(line 89,col 53)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 96,col 16)-(line 96,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 113,col 24)-(line 113,col 27)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphMappingIterator.match()"}],"classJavadoc":"\/**\n * This class is used to iterate over all existing (isomorphic) mappings between\n * to graphs. It is used by the {@link VF2GraphIsomorphismInspector}.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\/\n","className":"VF2GraphMappingIterator","fields":[]}],"sourceFileId":145,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first graph","javadocBlockTagName":"g1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[g1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second graph which is a possible subgraph of g1","javadocBlockTagName":"g2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph which is a possible subgraph of g1'}]}', name=Optional[g2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the mapping as array (forwards)","javadocBlockTagName":"core1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the mapping as array (forwards)'}]}', name=Optional[core1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the mapping as array (backwards)","javadocBlockTagName":"core2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the mapping as array (backwards)'}]}', name=Optional[core2]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.IsomorphicGraphMapping(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, int[], int[])","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * @param g1 the first graph\n     * @param g2 the second graph which is a possible subgraph of g1\n     * @param core1 the mapping as array (forwards)\n     * @param core2 the mapping as array (backwards)\n     ","constructorDeclaration":"public IsomorphicGraphMapping(GraphOrdering<V, E> g1, GraphOrdering<V, E> g2, int[] core1, int[] core2)","constructorBody":"{\n    this.g1 = g1;\n    this.g2 = g2;\n    this.core1 = core1.clone();\n    this.core2 = core2.clone();\n}","constructorName":"IsomorphicGraphMapping","constructorQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.IsomorphicGraphMapping","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g1","parameterName":"g1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> g2","parameterName":"g2"},{"parameterType":"int[]","parameterId":3,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] core1","parameterName":"core1"},{"parameterType":"int[]","parameterId":4,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] core2","parameterName":"core2"}],"literalExprs":[],"constructorTokenRange":"public IsomorphicGraphMapping(\n        GraphOrdering<V, E> g1,\n        GraphOrdering<V, E> g2,\n        int [] core1,\n        int [] core2)\n    {\n        this.g1 = g1;\n        this.g2 = g2;\n        this.core1 = core1.clone();\n        this.core2 = core2.clone();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[g1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph which is a possible subgraph of g1'}]}', name=Optional[g2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the mapping as array (forwards)'}]}', name=Optional[core1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the mapping as array (backwards)'}]}', name=Optional[core2]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public V getVertexCorrespondence(V v, boolean forward)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    GraphOrdering<V, E> firstGraph, secondGraph;\n    int[] core;\n    if (forward) {\n        firstGraph = g1;\n        secondGraph = g2;\n        core = core1;\n    } else {\n        firstGraph = g2;\n        secondGraph = g1;\n        core = core2;\n    }\n    int vNumber = firstGraph.getVertexNumber(v), uNumber = core[vNumber];\n    if (uNumber == VF2State.NULL_NODE) {\n        return null;\n    }\n    return secondGraph.getVertex(uNumber);\n}","methodRange":"(line 77,col 5)-(line 99,col 5)","methodTokenRange":"@Override public V getVertexCorrespondence(V v, boolean forward)\n    {\n        GraphOrdering<V, E> firstGraph, secondGraph;\n        int [] core;\n\n        if (forward) {\n            firstGraph = g1;\n            secondGraph = g2;\n            core = core1;\n        } else {\n            firstGraph = g2;\n            secondGraph = g1;\n            core = core2;\n        }\n\n        int vNumber = firstGraph.getVertexNumber(v), uNumber = core[vNumber];\n\n        if (uNumber == VF2State.NULL_NODE) {\n            return null;\n        }\n\n        return secondGraph.getVertex(uNumber);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean forward","parameterName":"forward"}],"methodName":"getVertexCorrespondence","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.getVertexCorrespondence","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 95,col 20)-(line 95,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.getVertexCorrespondence(V, boolean)"},{"methodDeclaration":"public E getEdgeCorrespondence(E e, boolean forward)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    GraphOrdering<V, E> firstGraph, secondGraph;\n    int[] core;\n    if (forward) {\n        firstGraph = g1;\n        secondGraph = g2;\n        core = core1;\n    } else {\n        firstGraph = g2;\n        secondGraph = g1;\n        core = core2;\n    }\n    int[] eNumbers = firstGraph.getEdgeNumbers(e);\n    if ((core[eNumbers[0]] == VF2State.NULL_NODE) || (core[eNumbers[1]] == VF2State.NULL_NODE)) {\n        return null;\n    }\n    return secondGraph.getEdge(core[eNumbers[0]], core[eNumbers[1]]);\n}","methodRange":"(line 101,col 5)-(line 124,col 5)","methodTokenRange":"@Override public E getEdgeCorrespondence(E e, boolean forward)\n    {\n        GraphOrdering<V, E> firstGraph, secondGraph;\n        int [] core;\n\n        if (forward) {\n            firstGraph = g1;\n            secondGraph = g2;\n            core = core1;\n        } else {\n            firstGraph = g2;\n            secondGraph = g1;\n            core = core2;\n        }\n\n        int [] eNumbers = firstGraph.getEdgeNumbers(e);\n        if ((core[eNumbers[0]] == VF2State.NULL_NODE)\n            || (core[eNumbers[1]] == VF2State.NULL_NODE))\n        {\n            return null;\n        }\n\n        return secondGraph.getEdge(core[eNumbers[0]], core[eNumbers[1]]);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean forward","parameterName":"forward"}],"methodName":"getEdgeCorrespondence","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.getEdgeCorrespondence","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[{"literalExprRange":"(line 117,col 28)-(line 117,col 28)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 118,col 31)-(line 118,col 31)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 120,col 20)-(line 120,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 123,col 50)-(line 123,col 50)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 69)-(line 123,col 69)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.getEdgeCorrespondence(E, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"is there a corresponding vertex to v in the subgraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='is there a corresponding vertex to v in the subgraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasVertexCorrespondence(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getVertexCorrespondence(v, true) != null;\n}","methodRange":"(line 132,col 5)-(line 135,col 5)","methodTokenRange":"public boolean hasVertexCorrespondence(V v)\n    {\n        return getVertexCorrespondence(v, true) != null;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Checks if a vertex v from the first graph has a corresponding vertex in\n     * the second graph\n     *\n     * @return is there a corresponding vertex to v in the subgraph\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"hasVertexCorrespondence","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.hasVertexCorrespondence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a vertex v from the first graph has a corresponding vertex in\nthe second graph'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='is there a corresponding vertex to v in the subgraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 134,col 43)-(line 134,col 46)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 134,col 52)-(line 134,col 55)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.hasVertexCorrespondence(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"is there a corresponding edge to e in the subgraph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='is there a corresponding edge to e in the subgraph'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasEdgeCorrespondence(E e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getEdgeCorrespondence(e, true) != null;\n}","methodRange":"(line 143,col 5)-(line 146,col 5)","methodTokenRange":"public boolean hasEdgeCorrespondence(E e)\n    {\n        return getEdgeCorrespondence(e, true) != null;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Checks if a edge e from the first graph has a corresponding edge in the\n     * second graph\n     *\n     * @return is there a corresponding edge to e in the subgraph\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"hasEdgeCorrespondence","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.hasEdgeCorrespondence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks if a edge e from the first graph has a corresponding edge in the\nsecond graph'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='is there a corresponding edge to e in the subgraph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 145,col 41)-(line 145,col 44)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 145,col 50)-(line 145,col 53)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.hasEdgeCorrespondence(E)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String str = \"[\";\n    Set<V> vertexSet = g1.getGraph().vertexSet();\n    Map<String, V> vertexMap = new TreeMap<String, V>();\n    for (V v : vertexSet) {\n        vertexMap.put(v.toString(), v);\n    }\n    int i = 0;\n    for (Map.Entry<String, V> entry : vertexMap.entrySet()) {\n        V u = getVertexCorrespondence(entry.getValue(), true);\n        str += ((i++ == 0) ? \"\" : \" \") + entry.getKey() + \"=\" + ((u == null) ? \"~~\" : u);\n    }\n    return str + \"]\";\n}","methodRange":"(line 148,col 5)-(line 167,col 5)","methodTokenRange":"@Override public String toString()\n    {\n        String str = \"[\";\n        Set<V> vertexSet = g1.getGraph().vertexSet();\n        Map<String, V> vertexMap = new TreeMap<String, V>();\n\n        for (V v : vertexSet) {\n            vertexMap.put(v.toString(), v);\n        }\n\n        int i = 0;\n        for (Map.Entry<String, V> entry : vertexMap.entrySet()) {\n            V u = getVertexCorrespondence(entry.getValue(), true);\n            str +=\n                ((i++ == 0) ? \"\" : \" \") + entry.getKey() + \"=\"\n                + ((u == null) ? \"~~\" : u);\n        }\n\n        return str + \"]\";\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 150,col 22)-(line 150,col 24)","literalExprId":1,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 158,col 17)-(line 158,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 160,col 61)-(line 160,col 64)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 162,col 26)-(line 162,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 162,col 31)-(line 162,col 32)","literalExprId":5,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 162,col 36)-(line 162,col 38)","literalExprId":6,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 162,col 60)-(line 162,col 62)","literalExprId":7,"literalExpr":"\"=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 163,col 26)-(line 163,col 29)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 163,col 34)-(line 163,col 37)","literalExprId":9,"literalExpr":"\"~~\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 166,col 22)-(line 166,col 24)","literalExprId":10,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.toString()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the corresponding mapping","javadocBlockTagName":"rel","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the corresponding mapping'}]}', name=Optional[rel]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"do both relations map to the same vertices","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='do both relations map to the same vertices'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isEqualMapping(GraphMapping<V, E> rel)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (V v : g2.getGraph().vertexSet()) {\n        if (!getVertexCorrespondence(v, false).equals(rel.getVertexCorrespondence(v, false))) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 176,col 5)-(line 187,col 5)","methodTokenRange":"public boolean isEqualMapping(GraphMapping<V, E> rel)\n    {\n        for (V v : g2.getGraph().vertexSet()) {\n            if (!getVertexCorrespondence(v, false).equals(\n                    rel.getVertexCorrespondence(v, false)))\n            {\n                return false;\n            }\n        }\n\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Checks for equality. Assuming both are mappings on the same graphs.\n     *\n     * @param rel the corresponding mapping\n     *\n     * @return do both relations map to the same vertices\n     ","methodParameters":[{"parameterType":"GraphMapping<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.GraphMapping, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.GraphMapping.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.GraphMapping.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.GraphMapping<V, E>","parameter":"GraphMapping<V, E> rel","parameterName":"rel"}],"methodName":"isEqualMapping","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.isEqualMapping","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks for equality. Assuming both are mappings on the same graphs.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the corresponding mapping'}]}', name=Optional[rel]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='do both relations map to the same vertices'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 179,col 45)-(line 179,col 49)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 180,col 52)-(line 180,col 56)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 182,col 24)-(line 182,col 28)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 186,col 16)-(line 186,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.isEqualMapping(org.jgrapht.GraphMapping<V, E>)"}],"classJavadoc":"\/**\n * This class represents a GraphMapping between two (subgraph)isomorphic graphs.\n * In the subgraph isomorphic case, the second one is assumed to be a subgraph\n * of the first one.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\/\n","className":"IsomorphicGraphMapping","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 31)","fieldName":"g1","fieldJavadocComment":"","fieldTokenRange":"GraphOrdering<V, E> g1, g2;","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"GraphOrdering<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 57,col 5)-(line 57,col 24)","fieldName":"core1","fieldJavadocComment":"","fieldTokenRange":"int [] core1, core2;","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":""}]}],"sourceFileId":146,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first graph","javadocBlockTagName":"graph1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[graph1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second graph","javadocBlockTagName":"graph2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph'}]}', name=Optional[graph2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equivalence of vertices","javadocBlockTagName":"vertexComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of vertices'}]}', name=Optional[vertexComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"comparator for semantic equivalence of edges","javadocBlockTagName":"edgeComparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of edges'}]}', name=Optional[edgeComparator]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, edges get cached for faster access","javadocBlockTagName":"cacheEdges","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, edges get cached for faster access'}]}', name=Optional[cacheEdges]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, java.util.Comparator<V>, java.util.Comparator<E>, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 81,col 5)","constructorJavadocComment":"\n     * This implementation of the VF2 algorithm does not support graphs with\n     * multiple edges.\n     *\n     * @param graph1 the first graph\n     * @param graph2 the second graph\n     * @param vertexComparator comparator for semantic equivalence of vertices\n     * @param edgeComparator comparator for semantic equivalence of edges\n     * @param cacheEdges if true, edges get cached for faster access\n     ","constructorDeclaration":"public VF2GraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator, boolean cacheEdges)","constructorBody":"{\n    super(graph1, graph2, vertexComparator, edgeComparator, cacheEdges);\n}","constructorName":"VF2GraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"},{"parameterType":"boolean","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[],"constructorTokenRange":"public VF2GraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator,\n        boolean cacheEdges)\n    {\n        super(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            cacheEdges);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This implementation of the VF2 algorithm does not support graphs with\nmultiple edges.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first graph'}]}', name=Optional[graph1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second graph'}]}', name=Optional[graph2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of vertices'}]}', name=Optional[vertexComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='comparator for semantic equivalence of edges'}]}', name=Optional[edgeComparator]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, edges get cached for faster access'}]}', name=Optional[cacheEdges]}]}"},{"constructorName":"VF2GraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[{"literalExprRange":"(line 93,col 13)-(line 93,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2GraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        super(graph1,\n            graph2,\n            vertexComparator,\n            edgeComparator,\n            true);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 83,col 5)-(line 94,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2GraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    super(graph1, graph2, vertexComparator, edgeComparator, true);\n}","constructorJavadoc":""},{"constructorName":"VF2GraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>, boolean)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheEdges","parameterName":"cacheEdges"}],"literalExprs":[{"literalExprRange":"(line 103,col 13)-(line 103,col 16)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 104,col 13)-(line 104,col 16)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public VF2GraphIsomorphismInspector(\n        Graph<V, E> graph1,\n        Graph<V, E> graph2,\n        boolean cacheEdges)\n    {\n        super(graph1,\n            graph2,\n            null,\n            null,\n            cacheEdges);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 96,col 5)-(line 106,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2GraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2, boolean cacheEdges)","constructorBody":"{\n    super(graph1, graph2, null, null, cacheEdges);\n}","constructorJavadoc":""},{"constructorName":"VF2GraphIsomorphismInspector","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.VF2GraphIsomorphismInspector(org.jgrapht.Graph<V, E>, org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph1","parameterName":"graph1"},{"parameterType":"Graph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph2","parameterName":"graph2"}],"literalExprs":[{"literalExprRange":"(line 112,col 13)-(line 112,col 16)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VF2GraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2)\n    {\n        super(graph1,\n            graph2,\n            true);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 108,col 5)-(line 113,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2GraphIsomorphismInspector(Graph<V, E> graph1, Graph<V, E> graph2)","constructorBody":"{\n    super(graph1, graph2, true);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public VF2GraphMappingIterator<V, E> getMappings()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new VF2GraphMappingIterator<V, E>(ordering1, ordering2, vertexComparator, edgeComparator);\n}","methodRange":"(line 115,col 5)-(line 122,col 5)","methodTokenRange":"@Override public VF2GraphMappingIterator<V, E> getMappings()\n    {\n        return new VF2GraphMappingIterator<V, E>(\n            ordering1,\n            ordering2,\n            vertexComparator,\n            edgeComparator);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getMappings","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.getMappings","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"VF2GraphMappingIterator<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2GraphIsomorphismInspector.getMappings()"}],"classJavadoc":"\/**\n * This is an implementation of the VF2 algorithm using its feature of detecting\n * <a href=\"http:\/\/mathworld.wolfram.com\/GraphIsomorphism.html\">isomorphism\n * between two graphs<\/a> as described in Cordella et al. A (sub)graph\n * isomorphism algorithm for matching large graphs (2004),\n * DOI:10.1109\/TPAMI.2004.75, <a\n * href=\"http:\/\/ieeexplore.ieee.org\/xpl\/articleDetails.jsp?arnumber=1323804\">\n * http:\/\/ieeexplore.ieee.org\/xpl\/articleDetails.jsp?arnumber=1323804<\/a>\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\/\n","className":"VF2GraphIsomorphismInspector","fields":[]}],"sourceFileId":147,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2SubgraphMappingIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"VF2SubgraphMappingIterator","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphMappingIterator.VF2SubgraphMappingIterator","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphMappingIterator.VF2SubgraphMappingIterator(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> ordering1","parameterName":"ordering1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> ordering2","parameterName":"ordering2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[],"constructorTokenRange":"public VF2SubgraphMappingIterator(\n        GraphOrdering<V, E> ordering1,\n        GraphOrdering<V, E> ordering2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        super(ordering1, ordering2, vertexComparator, edgeComparator);\n    }","variableDeclarationExprs":[],"constructorRange":"(line 55,col 5)-(line 62,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2SubgraphMappingIterator(GraphOrdering<V, E> ordering1, GraphOrdering<V, E> ordering2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    super(ordering1, ordering2, vertexComparator, edgeComparator);\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"protected IsomorphicGraphMapping<V, E> match()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    VF2State<V, E> s;\n    if (stateStack.isEmpty()) {\n        Graph<V, E> g1 = ordering1.getGraph(), g2 = ordering2.getGraph();\n        if ((g1.vertexSet().size() < g2.vertexSet().size()) || (g1.edgeSet().size() < g2.edgeSet().size())) {\n            return null;\n        }\n        s = new VF2SubgraphIsomorphismState<V, E>(ordering1, ordering2, vertexComparator, edgeComparator);\n        if (g2.vertexSet().isEmpty()) {\n            return (hadOneMapping != null) ? null : s.getCurrentMapping();\n        }\n    } else {\n        stateStack.pop().backtrack();\n        s = stateStack.pop();\n    }\n    while (true) {\n        while (s.nextPair()) {\n            if (s.isFeasiblePair()) {\n                stateStack.push(s);\n                s = new VF2SubgraphIsomorphismState<V, E>(s);\n                s.addPair();\n                if (s.isGoal()) {\n                    stateStack.push(s);\n                    return s.getCurrentMapping();\n                }\n                s.resetAddVertexes();\n            }\n        }\n        if (stateStack.isEmpty()) {\n            return null;\n        }\n        s.backtrack();\n        s = stateStack.pop();\n    }\n}","methodRange":"(line 64,col 5)-(line 114,col 5)","methodTokenRange":"@Override protected IsomorphicGraphMapping<V, E> match()\n    {\n        VF2State<V, E> s;\n\n        if (stateStack.isEmpty()) {\n            Graph<V, E> g1 = ordering1.getGraph(), g2 = ordering2.getGraph();\n\n            if ((g1.vertexSet().size() < g2.vertexSet().size())\n                || (g1.edgeSet().size() < g2.edgeSet().size()))\n            {\n                return null;\n            }\n\n            s = new VF2SubgraphIsomorphismState<V, E>(\n                ordering1,\n                ordering2,\n                vertexComparator,\n                edgeComparator);\n\n            if (g2.vertexSet().isEmpty()) {\n                return (hadOneMapping != null) ? null : s.getCurrentMapping();\n            }\n        } else {\n            stateStack.pop().backtrack();\n            s = stateStack.pop();\n        }\n\n        while (true) {\n            while (s.nextPair()) {\n                if (s.isFeasiblePair()) {\n                    stateStack.push(s);\n                    s = new VF2SubgraphIsomorphismState<V, E>(s);\n                    s.addPair();\n\n                    if (s.isGoal()) {\n                        stateStack.push(s);\n                        return s.getCurrentMapping();\n                    }\n\n                    s.resetAddVertexes();\n                }\n            }\n\n            if (stateStack.isEmpty()) {\n                return null;\n            }\n\n            s.backtrack();\n            s = stateStack.pop();\n        }\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"match","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2SubgraphMappingIterator.match","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IsomorphicGraphMapping<V, E>","literalExprs":[{"literalExprRange":"(line 74,col 24)-(line 74,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 84,col 42)-(line 84,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 84,col 50)-(line 84,col 53)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 91,col 16)-(line 91,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 108,col 24)-(line 108,col 27)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2SubgraphMappingIterator.match()"}],"classJavadoc":"\/**\n * This class is used to iterate over all existing (subgraph isomorphic)\n * mappings between two graphs. It is used by the {@link\n * VF2SubgraphIsomorphismInspector}.\n *\n * @param <V> the type of the vertices\n * @param <E> the type of the edges\n *\/\n","className":"VF2SubgraphMappingIterator","fields":[]}],"sourceFileId":148,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.isomorphism.VF2MappingIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"VF2MappingIterator","constructorQualifiedName":"org.jgrapht.alg.isomorphism.VF2MappingIterator.VF2MappingIterator","constructorQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2MappingIterator.VF2MappingIterator(org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, org.jgrapht.alg.isomorphism.GraphOrdering<V, E>, java.util.Comparator<V>, java.util.Comparator<E>)","constructorParameters":[{"parameterType":"GraphOrdering<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> ordering1","parameterName":"ordering1"},{"parameterType":"GraphOrdering<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.GraphOrdering, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.GraphOrdering.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.GraphOrdering.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.GraphOrdering<V, E>","parameter":"GraphOrdering<V, E> ordering2","parameterName":"ordering2"},{"parameterType":"Comparator<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<V>","parameter":"Comparator<V> vertexComparator","parameterName":"vertexComparator"},{"parameterType":"Comparator<E>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<E>","parameter":"Comparator<E> edgeComparator","parameterName":"edgeComparator"}],"literalExprs":[],"constructorTokenRange":"public VF2MappingIterator(\n        GraphOrdering<V, E> ordering1,\n        GraphOrdering<V, E> ordering2,\n        Comparator<V> vertexComparator,\n        Comparator<E> edgeComparator)\n    {\n        this.ordering1 = ordering1;\n        this.ordering2 = ordering2;\n        this.vertexComparator = vertexComparator;\n        this.edgeComparator = edgeComparator;\n        this.stateStack = new ArrayDeque<VF2State<V, E>>();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 57,col 5)-(line 68,col 5)","constructorJavadocComment":"","constructorDeclaration":"public VF2MappingIterator(GraphOrdering<V, E> ordering1, GraphOrdering<V, E> ordering2, Comparator<V> vertexComparator, Comparator<E> edgeComparator)","constructorBody":"{\n    this.ordering1 = ordering1;\n    this.ordering2 = ordering2;\n    this.vertexComparator = vertexComparator;\n    this.edgeComparator = edgeComparator;\n    this.stateStack = new ArrayDeque<VF2State<V, E>>();\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"null or one matching between graph1 and graph2","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null or one matching between graph1 and graph2'}]}', name=Optional.empty}"}],"methodDeclaration":"protected abstract IsomorphicGraphMapping<V, E> match()","methodAccessSpecifier":"PROTECTED","methodBody":"","methodRange":"(line 76,col 5)-(line 76,col 60)","methodTokenRange":"protected abstract IsomorphicGraphMapping<V, E> match();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * This function moves over all mappings between graph1 and graph2. It\n     * changes the state of the whole iterator.\n     *\n     * @return null or one matching between graph1 and graph2\n     ","methodParameters":[],"methodName":"match","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2MappingIterator.match","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This function moves over all mappings between graph1 and graph2. It\nchanges the state of the whole iterator.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null or one matching between graph1 and graph2'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"IsomorphicGraphMapping<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2MappingIterator.match()"},{"methodDeclaration":"protected IsomorphicGraphMapping<V, E> matchAndCheck()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    IsomorphicGraphMapping<V, E> rel = match();\n    if (rel != null) {\n        hadOneMapping = true;\n    }\n    return rel;\n}","methodRange":"(line 78,col 5)-(line 85,col 5)","methodTokenRange":"protected IsomorphicGraphMapping<V, E> matchAndCheck()\n    {\n        IsomorphicGraphMapping<V, E> rel = match();\n        if (rel != null) {\n            hadOneMapping = true;\n        }\n        return rel;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"matchAndCheck","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2MappingIterator.matchAndCheck","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IsomorphicGraphMapping<V, E>","literalExprs":[{"literalExprRange":"(line 81,col 20)-(line 81,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 82,col 29)-(line 82,col 32)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2MappingIterator.matchAndCheck()"},{"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nextMapping != null) {\n        return true;\n    }\n    return (nextMapping = matchAndCheck()) != null;\n}","methodRange":"(line 87,col 5)-(line 94,col 5)","methodTokenRange":"@Override public boolean hasNext()\n    {\n        if (nextMapping != null) {\n            return true;\n        }\n\n        return (nextMapping = matchAndCheck()) != null;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2MappingIterator.hasNext","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 89,col 28)-(line 89,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 90,col 20)-(line 90,col 23)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 93,col 51)-(line 93,col 54)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2MappingIterator.hasNext()"},{"methodDeclaration":"public IsomorphicGraphMapping<V, E> next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nextMapping != null) {\n        IsomorphicGraphMapping<V, E> tmp = nextMapping;\n        nextMapping = null;\n        return tmp;\n    }\n    IsomorphicGraphMapping<V, E> rel = matchAndCheck();\n    if (rel == null) {\n        throw new NoSuchElementException();\n    }\n    return rel;\n}","methodRange":"(line 96,col 5)-(line 109,col 5)","methodTokenRange":"@Override public IsomorphicGraphMapping<V, E> next()\n    {\n        if (nextMapping != null) {\n            IsomorphicGraphMapping<V, E> tmp = nextMapping;\n            nextMapping = null;\n            return tmp;\n        }\n\n        IsomorphicGraphMapping<V, E> rel = matchAndCheck();\n        if (rel == null) {\n            throw new NoSuchElementException();\n        }\n        return rel;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"next","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2MappingIterator.next","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"IsomorphicGraphMapping<V, E>","literalExprs":[{"literalExprRange":"(line 98,col 28)-(line 98,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 100,col 27)-(line 100,col 30)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 105,col 20)-(line 105,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2MappingIterator.next()"},{"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException();\n}","methodRange":"(line 111,col 5)-(line 114,col 5)","methodTokenRange":"@Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"org.jgrapht.alg.isomorphism.VF2MappingIterator.remove","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.isomorphism.VF2MappingIterator.remove()"}],"classJavadoc":"","className":"VF2MappingIterator","fields":[{"fieldRange":"(line 47,col 5)-(line 47,col 45)","fieldName":"vertexComparator","fieldJavadocComment":"","fieldTokenRange":"protected Comparator<V> vertexComparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<V>"},{"fieldRange":"(line 48,col 5)-(line 48,col 43)","fieldName":"edgeComparator","fieldJavadocComment":"","fieldTokenRange":"protected Comparator<E> edgeComparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<E>"},{"fieldRange":"(line 50,col 5)-(line 50,col 55)","fieldName":"nextMapping","fieldJavadocComment":"","fieldTokenRange":"protected IsomorphicGraphMapping<V, E> nextMapping;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.isomorphism.IsomorphicGraphMapping, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.IsomorphicGraphMapping.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"IsomorphicGraphMapping<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.isomorphism.IsomorphicGraphMapping<V, E>"},{"fieldRange":"(line 51,col 5)-(line 51,col 36)","fieldName":"hadOneMapping","fieldJavadocComment":"","fieldTokenRange":"protected Boolean hadOneMapping;","fieldTypeResolved":"ReferenceType{java.lang.Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Boolean"},{"fieldRange":"(line 53,col 5)-(line 53,col 55)","fieldName":"ordering1","fieldJavadocComment":"","fieldTokenRange":"protected GraphOrdering<V, E> ordering1, ordering2;","fieldTypeResolved":"","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"GraphOrdering<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 55,col 5)-(line 55,col 52)","fieldName":"stateStack","fieldJavadocComment":"","fieldTokenRange":"protected ArrayDeque<VF2State<V, E>> stateStack;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=ReferenceType{org.jgrapht.alg.isomorphism.VF2State, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.isomorphism.VF2State.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.isomorphism.VF2State.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"ArrayDeque<VF2State<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<org.jgrapht.alg.isomorphism.VF2State<V, E>>"}]}],"sourceFileId":149,"packageName":"org.jgrapht.alg.isomorphism"},{"sourceFileName":"org.jgrapht.alg.BronKerboschCliqueFinder","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph in which cliques are to be found; graph must be\nsimple","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph in which cliques are to be found; graph must be\nsimple'}]}', name=Optional[graph]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BronKerboschCliqueFinder.BronKerboschCliqueFinder(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 65,col 5)-(line 68,col 5)","constructorJavadocComment":"\n     * Creates a new clique finder.\n     *\n     * @param graph the graph in which cliques are to be found; graph must be\n     * simple\n     ","constructorDeclaration":"public BronKerboschCliqueFinder(Graph<V, E> graph)","constructorBody":"{\n    this.graph = graph;\n}","constructorName":"BronKerboschCliqueFinder","constructorQualifiedName":"org.jgrapht.alg.BronKerboschCliqueFinder.BronKerboschCliqueFinder","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"}],"literalExprs":[],"constructorTokenRange":"public BronKerboschCliqueFinder(Graph<V, E> graph)\n    {\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new clique finder.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph in which cliques are to be found; graph must be\nsimple'}]}', name=Optional[graph]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Collection of cliques (each of which is represented as a Set of\nvertices)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Collection of cliques (each of which is represented as a Set of\nvertices)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Collection<Set<V>> getAllMaximalCliques()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    cliques = new ArrayList<Set<V>>();\n    List<V> potential_clique = new ArrayList<V>();\n    List<V> candidates = new ArrayList<V>();\n    List<V> already_found = new ArrayList<V>();\n    candidates.addAll(graph.vertexSet());\n    findCliques(potential_clique, candidates, already_found);\n    return cliques;\n}","methodRange":"(line 78,col 5)-(line 89,col 5)","methodTokenRange":"public Collection<Set<V>> getAllMaximalCliques()\n    {\n        \/\/ TODO jvs 26-July-2005:  assert that graph is simple\n\n        cliques = new ArrayList<Set<V>>();\n        List<V> potential_clique = new ArrayList<V>();\n        List<V> candidates = new ArrayList<V>();\n        List<V> already_found = new ArrayList<V>();\n        candidates.addAll(graph.vertexSet());\n        findCliques(potential_clique, candidates, already_found);\n        return cliques;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Finds all maximal cliques of the graph. A clique is maximal if it is\n     * impossible to enlarge it by adding another vertex from the graph. Note\n     * that a maximal clique is not necessarily the biggest clique in the graph.\n     *\n     * @return Collection of cliques (each of which is represented as a Set of\n     * vertices)\n     ","methodParameters":[],"methodName":"getAllMaximalCliques","methodQualifiedSignature":"org.jgrapht.alg.BronKerboschCliqueFinder.getAllMaximalCliques","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds all maximal cliques of the graph. A clique is maximal if it is\nimpossible to enlarge it by adding another vertex from the graph. Note\nthat a maximal clique is not necessarily the biggest clique in the graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Collection of cliques (each of which is represented as a Set of\nvertices)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Collection<java.util.Set<V>>","methodType":"Collection<Set<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BronKerboschCliqueFinder.getAllMaximalCliques()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Collection of cliques (each of which is represented as a Set of\nvertices)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Collection of cliques (each of which is represented as a Set of\nvertices)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Collection<Set<V>> getBiggestMaximalCliques()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    getAllMaximalCliques();\n    int maximum = 0;\n    Collection<Set<V>> biggest_cliques = new ArrayList<Set<V>>();\n    for (Set<V> clique : cliques) {\n        if (maximum < clique.size()) {\n            maximum = clique.size();\n        }\n    }\n    for (Set<V> clique : cliques) {\n        if (maximum == clique.size()) {\n            biggest_cliques.add(clique);\n        }\n    }\n    return biggest_cliques;\n}","methodRange":"(line 97,col 5)-(line 115,col 5)","methodTokenRange":"public Collection<Set<V>> getBiggestMaximalCliques()\n    {\n        \/\/ first, find all cliques\n        getAllMaximalCliques();\n\n        int maximum = 0;\n        Collection<Set<V>> biggest_cliques = new ArrayList<Set<V>>();\n        for (Set<V> clique : cliques) {\n            if (maximum < clique.size()) {\n                maximum = clique.size();\n            }\n        }\n        for (Set<V> clique : cliques) {\n            if (maximum == clique.size()) {\n                biggest_cliques.add(clique);\n            }\n        }\n        return biggest_cliques;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Finds the biggest maximal cliques of the graph.\n     *\n     * @return Collection of cliques (each of which is represented as a Set of\n     * vertices)\n     ","methodParameters":[],"methodName":"getBiggestMaximalCliques","methodQualifiedSignature":"org.jgrapht.alg.BronKerboschCliqueFinder.getBiggestMaximalCliques","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds the biggest maximal cliques of the graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Collection of cliques (each of which is represented as a Set of\nvertices)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Collection<java.util.Set<V>>","methodType":"Collection<Set<V>>","literalExprs":[{"literalExprRange":"(line 102,col 23)-(line 102,col 23)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BronKerboschCliqueFinder.getBiggestMaximalCliques()"},{"methodDeclaration":"private void findCliques(List<V> potential_clique, List<V> candidates, List<V> already_found)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<V> candidates_array = new ArrayList<V>(candidates);\n    if (!end(candidates, already_found)) {\n        for (V candidate : candidates_array) {\n            List<V> new_candidates = new ArrayList<V>();\n            List<V> new_already_found = new ArrayList<V>();\n            potential_clique.add(candidate);\n            candidates.remove(candidate);\n            for (V new_candidate : candidates) {\n                if (graph.containsEdge(candidate, new_candidate)) {\n                    new_candidates.add(new_candidate);\n                }\n            }\n            for (V new_found : already_found) {\n                if (graph.containsEdge(candidate, new_found)) {\n                    new_already_found.add(new_found);\n                }\n            }\n            if (new_candidates.isEmpty() && new_already_found.isEmpty()) {\n                cliques.add(new HashSet<V>(potential_clique));\n            } else {\n                findCliques(potential_clique, new_candidates, new_already_found);\n            }\n            already_found.add(candidate);\n            potential_clique.remove(candidate);\n        }\n    }\n}","methodRange":"(line 117,col 5)-(line 167,col 5)","methodTokenRange":"private void findCliques(\n        List<V> potential_clique,\n        List<V> candidates,\n        List<V> already_found)\n    {\n        List<V> candidates_array = new ArrayList<V>(candidates);\n        if (!end(candidates, already_found)) {\n            \/\/ for each candidate_node in candidates do\n            for (V candidate : candidates_array) {\n                List<V> new_candidates = new ArrayList<V>();\n                List<V> new_already_found = new ArrayList<V>();\n\n                \/\/ move candidate node to potential_clique\n                potential_clique.add(candidate);\n                candidates.remove(candidate);\n\n                \/\/ create new_candidates by removing nodes in candidates not\n                \/\/ connected to candidate node\n                for (V new_candidate : candidates) {\n                    if (graph.containsEdge(candidate, new_candidate)) {\n                        new_candidates.add(new_candidate);\n                    } \/\/ of if\n                } \/\/ of for\n\n                \/\/ create new_already_found by removing nodes in already_found\n                \/\/ not connected to candidate node\n                for (V new_found : already_found) {\n                    if (graph.containsEdge(candidate, new_found)) {\n                        new_already_found.add(new_found);\n                    } \/\/ of if\n                } \/\/ of for\n\n                \/\/ if new_candidates and new_already_found are empty\n                if (new_candidates.isEmpty() && new_already_found.isEmpty()) {\n                    \/\/ potential_clique is maximal_clique\n                    cliques.add(new HashSet<V>(potential_clique));\n                } \/\/ of if\n                else {\n                    \/\/ recursive call\n                    findCliques(\n                        potential_clique,\n                        new_candidates,\n                        new_already_found);\n                } \/\/ of else\n\n                \/\/ move candidate_node from potential_clique to already_found;\n                already_found.add(candidate);\n                potential_clique.remove(candidate);\n            } \/\/ of for\n        } \/\/ of if\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"List<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> potential_clique","parameterName":"potential_clique"},{"parameterType":"List<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> candidates","parameterName":"candidates"},{"parameterType":"List<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> already_found","parameterName":"already_found"}],"methodName":"findCliques","methodQualifiedSignature":"org.jgrapht.alg.BronKerboschCliqueFinder.findCliques","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BronKerboschCliqueFinder.findCliques(java.util.List<V>, java.util.List<V>, java.util.List<V>)"},{"methodDeclaration":"private boolean end(List<V> candidates, List<V> already_found)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    boolean end = false;\n    int edgecounter;\n    for (V found : already_found) {\n        edgecounter = 0;\n        for (V candidate : candidates) {\n            if (graph.containsEdge(found, candidate)) {\n                edgecounter++;\n            }\n        }\n        if (edgecounter == candidates.size()) {\n            end = true;\n        }\n    }\n    return end;\n}","methodRange":"(line 169,col 5)-(line 186,col 5)","methodTokenRange":"private boolean end(List<V> candidates, List<V> already_found)\n    {\n        \/\/ if a node in already_found is connected to all nodes in candidates\n        boolean end = false;\n        int edgecounter;\n        for (V found : already_found) {\n            edgecounter = 0;\n            for (V candidate : candidates) {\n                if (graph.containsEdge(found, candidate)) {\n                    edgecounter++;\n                } \/\/ of if\n            } \/\/ of for\n            if (edgecounter == candidates.size()) {\n                end = true;\n            }\n        } \/\/ of for\n        return end;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"List<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> candidates","parameterName":"candidates"},{"parameterType":"List<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> already_found","parameterName":"already_found"}],"methodName":"end","methodQualifiedSignature":"org.jgrapht.alg.BronKerboschCliqueFinder.end","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 172,col 23)-(line 172,col 27)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 175,col 27)-(line 175,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 182,col 23)-(line 182,col 26)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BronKerboschCliqueFinder.end(java.util.List<V>, java.util.List<V>)"}],"classJavadoc":"\/**\n * This class implements Bron-Kerbosch clique detection algorithm as it is\n * described in [Samudrala R.,Moult J.:A Graph-theoretic Algorithm for\n * comparative Modeling of Protein Structure; J.Mol. Biol. (1998); vol 279; pp.\n * 287-302]\n *\n * @author Ewgenij Proschak\n *\/\n","className":"BronKerboschCliqueFinder","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 36)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 57,col 5)-(line 57,col 39)","fieldName":"cliques","fieldJavadocComment":"","fieldTokenRange":"private Collection<Set<V>> cliques;","fieldTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Collection<Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Collection<java.util.Set<V>>"}]}],"sourceFileId":150,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.ChromaticNumber","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.util.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an undirected graph to find the chromatic number of","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an undirected graph to find the chromatic number of'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"integer the approximate chromatic number from the greedy\nalgorithm","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='integer the approximate chromatic number from the greedy\nalgorithm'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int findGreedyChromaticNumber(UndirectedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n    return coloredGroups.keySet().size();\n}","methodRange":"(line 67,col 5)-(line 71,col 5)","methodTokenRange":"public static <V, E> int findGreedyChromaticNumber(UndirectedGraph<V, E> g)\n    {\n        Map<Integer, Set<V>> coloredGroups = findGreedyColoredGroups(g);\n        return coloredGroups.keySet().size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Finds the number of colors required for a greedy coloring of the graph.\n     *\n     * @param g an undirected graph to find the chromatic number of\n     *\n     * @return integer the approximate chromatic number from the greedy\n     * algorithm\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"methodName":"findGreedyChromaticNumber","methodQualifiedSignature":"org.jgrapht.alg.ChromaticNumber.findGreedyChromaticNumber","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds the number of colors required for a greedy coloring of the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an undirected graph to find the chromatic number of'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='integer the approximate chromatic number from the greedy\nalgorithm'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ChromaticNumber.findGreedyChromaticNumber(org.jgrapht.UndirectedGraph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an undirected graph for which to find the coloring","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an undirected graph for which to find the coloring'}]}', name=Optional[g]}"}],"methodDeclaration":"public static Map<Integer, Set<V>> findGreedyColoredGroups(UndirectedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n    Collections.sort(sortedVertices, comp);\n    Collections.reverse(sortedVertices);\n    int color;\n    Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n    for (color = 0; sg.vertexSet().size() > 0; color++) {\n        Set<V> currentColor = new HashSet<V>();\n        for (Iterator<V> iter = sortedVertices.iterator(); iter.hasNext(); ) {\n            V v = iter.next();\n            boolean flag = true;\n            for (Iterator<V> innerIter = currentColor.iterator(); innerIter.hasNext(); ) {\n                V temp = innerIter.next();\n                if (sg.containsEdge(temp, v)) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                currentColor.add(v);\n                iter.remove();\n            }\n        }\n        coloredGroups.put(color, currentColor);\n        sg.removeAllVertices(currentColor);\n    }\n    return coloredGroups;\n}","methodRange":"(line 78,col 5)-(line 139,col 5)","methodTokenRange":"public static <V, E> Map<Integer, Set<V>> findGreedyColoredGroups(\n        UndirectedGraph<V, E> g)\n    {\n        \/\/ A copy of the graph is made, so that elements of the graph may be\n        \/\/ removed to carry out the algorithm\n        UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n\n        \/\/ The Vertices will be sorted in decreasing order by degree, so that\n        \/\/ higher degree vertices have priority to be colored first\n        VertexDegreeComparator<V, E> comp =\n            new VertexDegreeComparator<V, E>(sg);\n        List<V> sortedVertices = new LinkedList<V>(sg.vertexSet());\n        Collections.sort(sortedVertices, comp);\n        Collections.reverse(sortedVertices);\n\n        int color;\n\n        \/\/ create a map which will hold color as key and Set<V> as value\n        Map<Integer, Set<V>> coloredGroups = new HashMap<Integer, Set<V>>();\n\n        \/\/ We'll attempt to color each vertex with a single color each\n        \/\/ iteration, and these vertices will be removed from the graph at the\n        \/\/ end of each iteration\n        for (color = 0; sg.vertexSet().size() > 0; color++) {\n            \/\/ This set will contain vertices that are colored with the\n            \/\/ current color of this iteration\n            Set<V> currentColor = new HashSet<V>();\n            for (\n                Iterator<V> iter = sortedVertices.iterator();\n                iter.hasNext();)\n            {\n                V v = iter.next();\n\n                \/\/ Add new vertices to be colored as long as they are not\n                \/\/ adjacent with any other vertex that has already been colored\n                \/\/ with the current color\n                boolean flag = true;\n                for (\n                    Iterator<V> innerIter = currentColor.iterator();\n                    innerIter.hasNext();)\n                {\n                    V temp = innerIter.next();\n                    if (sg.containsEdge(temp, v)) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    currentColor.add(v);\n                    iter.remove();\n                }\n            }\n\n            \/\/ Add all these vertices as a group for this color\n            coloredGroups.put(color, currentColor);\n\n            \/\/ Remove vertices from the graph and then repeat the process for\n            \/\/ the next iteration\n            sg.removeAllVertices(currentColor);\n        }\n        return coloredGroups;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Finds a greedy coloring of the graph.\n     *\n     * @param g an undirected graph for which to find the coloring\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"methodName":"findGreedyColoredGroups","methodQualifiedSignature":"org.jgrapht.alg.ChromaticNumber.findGreedyColoredGroups","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a greedy coloring of the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an undirected graph for which to find the coloring'}]}', name=Optional[g]}]}","methodReturnTypeDescribed":"java.util.Map<java.lang.Integer, java.util.Set<V>>","methodType":"Map<Integer, Set<V>>","literalExprs":[{"literalExprRange":"(line 83,col 68)-(line 83,col 71)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 83,col 74)-(line 83,col 77)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 101,col 22)-(line 101,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 101,col 49)-(line 101,col 49)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 114,col 32)-(line 114,col 35)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 121,col 32)-(line 121,col 36)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.ChromaticNumber.findGreedyColoredGroups(org.jgrapht.UndirectedGraph<V, E>)"}],"classJavadoc":"\/**\n * Allows the <a href=\"http:\/\/mathworld.wolfram.com\/ChromaticNumber.html\">\n * chromatic number<\/a> of a graph to be calculated. This is the minimal number\n * of colors needed to color each vertex such that no two adjacent vertices\n * share the same color. This algorithm will not find the true chromatic number,\n * since this is an NP-complete problem. So, a greedy algorithm will find an\n * approximate chromatic number.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n *\/\n","className":"ChromaticNumber","fields":[]}],"sourceFileId":151,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to inspect","javadocBlockTagName":"directedGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to inspect'}]}', name=Optional[directedGraph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.KosarajuStrongConnectivityInspector(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 87,col 5)-(line 99,col 5)","constructorJavadocComment":"\n     * The constructor of the StrongConnectivityAlgorithm class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public KosarajuStrongConnectivityInspector(DirectedGraph<V, E> directedGraph)","constructorBody":"{\n    if (directedGraph == null) {\n        throw new IllegalArgumentException(\"null not allowed for graph!\");\n    }\n    graph = directedGraph;\n    vertexToVertexData = null;\n    orderedVertices = null;\n    stronglyConnectedSets = null;\n    stronglyConnectedSubgraphs = null;\n}","constructorName":"KosarajuStrongConnectivityInspector","constructorQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.KosarajuStrongConnectivityInspector","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> directedGraph","parameterName":"directedGraph"}],"literalExprs":[{"literalExprRange":"(line 90,col 30)-(line 90,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 91,col 48)-(line 91,col 76)","literalExprId":2,"literalExpr":"\"null not allowed for graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 30)-(line 95,col 33)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 96,col 27)-(line 96,col 30)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 97,col 33)-(line 97,col 36)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 98,col 38)-(line 98,col 41)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public KosarajuStrongConnectivityInspector(\n        DirectedGraph<V, E> directedGraph)\n    {\n        if (directedGraph == null) {\n            throw new IllegalArgumentException(\"null not allowed for graph!\");\n        }\n\n        graph = directedGraph;\n        vertexToVertexData = null;\n        orderedVertices = null;\n        stronglyConnectedSets = null;\n        stronglyConnectedSubgraphs = null;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The constructor of the StrongConnectivityAlgorithm class.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to inspect'}]}', name=Optional[directedGraph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 282,col 5)-(line 326,col 5)","classOrInterfaceTokenRange":"private static abstract class VertexData<V>\n    {\n        private byte bitfield;\n\n        private VertexData(\n            boolean discovered,\n            boolean finished)\n        {\n            this.bitfield = 0;\n            setDiscovered(discovered);\n            setFinished(finished);\n        }\n\n        private boolean isDiscovered()\n        {\n            return (bitfield & 1) == 1;\n        }\n\n        private boolean isFinished()\n        {\n            return (bitfield & 2) == 2;\n        }\n\n        private void setDiscovered(boolean discovered)\n        {\n            if (discovered) {\n                bitfield |= 1;\n            } else {\n                bitfield &= ~1;\n            }\n        }\n\n        private void setFinished(boolean finished)\n        {\n            if (finished) {\n                bitfield |= 2;\n            } else {\n                bitfield &= ~2;\n            }\n        }\n\n        abstract VertexData<V> getFinishedData();\n\n        abstract V getVertex();\n    }","classOrInterfaceJavadocComment":"\n     * Lightweight class storing some data for every vertex.\n     ","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 328,col 5)-(line 351,col 5)","classOrInterfaceTokenRange":"private static final class VertexData1<V>\n        extends VertexData<V>\n    {\n        private final VertexData<V> finishedData;\n\n        private VertexData1(\n            VertexData<V> finishedData,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.finishedData = finishedData;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return finishedData;\n        }\n\n        @Override V getVertex()\n        {\n            return null;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 353,col 5)-(line 376,col 5)","classOrInterfaceTokenRange":"private static final class VertexData2<V>\n        extends VertexData<V>\n    {\n        private final V vertex;\n\n        private VertexData2(\n            V vertex,\n            boolean discovered,\n            boolean finished)\n        {\n            super(discovered, finished);\n            this.vertex = vertex;\n        }\n\n        @Override VertexData<V> getFinishedData()\n        {\n            return null;\n        }\n\n        @Override V getVertex()\n        {\n            return vertex;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the graph inspected by this StrongConnectivityAlgorithm","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected by this StrongConnectivityAlgorithm'}]}', name=Optional.empty}"}],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 106,col 5)-(line 109,col 5)","methodTokenRange":"public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph inspected by the StrongConnectivityAlgorithm.\n     *\n     * @return the graph inspected by this StrongConnectivityAlgorithm\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph inspected by the StrongConnectivityAlgorithm.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected by this StrongConnectivityAlgorithm'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the graph is strongly connected, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isStronglyConnected()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return stronglyConnectedSets().size() == 1;\n}","methodRange":"(line 117,col 5)-(line 120,col 5)","methodTokenRange":"public boolean isStronglyConnected()\n    {\n        return stronglyConnectedSets().size() == 1;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns true if the graph of this <code>\n     * StronglyConnectivityInspector<\/code> instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     ","methodParameters":[],"methodName":"isStronglyConnected","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.isStronglyConnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the graph of this <code>\nStronglyConnectivityInspector<\/code> instance is strongly connected.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 119,col 50)-(line 119,col 50)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.isStronglyConnected()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<Set<V>> stronglyConnectedSets()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (stronglyConnectedSets == null) {\n        orderedVertices = new LinkedList<VertexData<V>>();\n        stronglyConnectedSets = new Vector<Set<V>>();\n        createVertexData();\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            if (!data.isDiscovered()) {\n                dfsVisit(graph, data, null);\n            }\n        }\n        DirectedGraph<V, E> inverseGraph = new EdgeReversedGraph<V, E>(graph);\n        resetVertexData();\n        for (VertexData<V> data : orderedVertices) {\n            if (!data.isDiscovered()) {\n                Set<V> set = new HashSet<V>();\n                stronglyConnectedSets.add(set);\n                dfsVisit(inverseGraph, data, set);\n            }\n        }\n        orderedVertices = null;\n        vertexToVertexData = null;\n    }\n    return stronglyConnectedSets;\n}","methodRange":"(line 130,col 5)-(line 172,col 5)","methodTokenRange":"public List<Set<V>> stronglyConnectedSets()\n    {\n        if (stronglyConnectedSets == null) {\n            orderedVertices = new LinkedList<VertexData<V>>();\n            stronglyConnectedSets = new Vector<Set<V>>();\n\n            \/\/ create VertexData objects for all vertices, store them\n            createVertexData();\n\n            \/\/ perform the first round of DFS, result is an ordering\n            \/\/ of the vertices by decreasing finishing time\n            for (VertexData<V> data : vertexToVertexData.values()) {\n                if (!data.isDiscovered()) {\n                    dfsVisit(graph, data, null);\n                }\n            }\n\n            \/\/ 'create' inverse graph (i.e. every edge is reversed)\n            DirectedGraph<V, E> inverseGraph =\n                new EdgeReversedGraph<V, E>(graph);\n\n            \/\/ get ready for next dfs round\n            resetVertexData();\n\n            \/\/ second dfs round: vertices are considered in decreasing\n            \/\/ finishing time order; every tree found is a strongly\n            \/\/ connected set\n            for (VertexData<V> data : orderedVertices) {\n                if (!data.isDiscovered()) {\n                    \/\/ new strongly connected set\n                    Set<V> set = new HashSet<V>();\n                    stronglyConnectedSets.add(set);\n                    dfsVisit(inverseGraph, data, set);\n                }\n            }\n\n            \/\/ clean up for garbage collection\n            orderedVertices = null;\n            vertexToVertexData = null;\n        }\n\n        return stronglyConnectedSets;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List<\/code> of <code>Set<\/code> s containing the strongly\n     * connected components\n     ","methodParameters":[],"methodName":"stronglyConnectedSets","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.stronglyConnectedSets","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes a '}, JavadocInlineTag{tagName='link', type=LINK, content=' List'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Set'}, JavadocSnippet{text='s, where each set contains vertices\nwhich together form a strongly connected component within the given\ngraph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[{"literalExprRange":"(line 132,col 38)-(line 132,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 143,col 43)-(line 143,col 46)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 167,col 31)-(line 167,col 34)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 168,col 34)-(line 168,col 37)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.stronglyConnectedSets()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of subgraphs representing the strongly connected\ncomponents","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (stronglyConnectedSubgraphs == null) {\n        List<Set<V>> sets = stronglyConnectedSets();\n        stronglyConnectedSubgraphs = new Vector<DirectedSubgraph<V, E>>(sets.size());\n        for (Set<V> set : sets) {\n            stronglyConnectedSubgraphs.add(new DirectedSubgraph<V, E>(graph, set, null));\n        }\n    }\n    return stronglyConnectedSubgraphs;\n}","methodRange":"(line 187,col 5)-(line 204,col 5)","methodTokenRange":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()\n    {\n        if (stronglyConnectedSubgraphs == null) {\n            List<Set<V>> sets = stronglyConnectedSets();\n            stronglyConnectedSubgraphs =\n                new Vector<DirectedSubgraph<V, E>>(sets.size());\n\n            for (Set<V> set : sets) {\n                stronglyConnectedSubgraphs.add(\n                    new DirectedSubgraph<V, E>(\n                        graph,\n                        set,\n                        null));\n            }\n        }\n\n        return stronglyConnectedSubgraphs;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.<\/p>\n     *\n     * <p>NOTE: Calling this method will first execute {@link\n     * KosarajuStrongConnectivityInspector#stronglyConnectedSets()}. If you\n     * don't need subgraphs, use that method.<\/p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     ","methodParameters":[],"methodName":"stronglyConnectedSubgraphs","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.stronglyConnectedSubgraphs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Computes a list of '}, JavadocInlineTag{tagName='link', type=LINK, content=' DirectedSubgraph'}, JavadocSnippet{text='s of the given graph. Each\nsubgraph will represent a strongly connected component and will contain\nall vertices of that component. The subgraph will have an edge (u,v) iff\nu and v are contained in the strongly connected component.<\/p>\n\n<p>NOTE: Calling this method will first execute '}, JavadocInlineTag{tagName='link', type=LINK, content='\nKosarajuStrongConnectivityInspector#stronglyConnectedSets()'}, JavadocSnippet{text='. If you\ndon't need subgraphs, use that method.<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<DirectedSubgraph<V, E>>","literalExprs":[{"literalExprRange":"(line 189,col 43)-(line 189,col 46)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 199,col 25)-(line 199,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.stronglyConnectedSubgraphs()"},{"methodDeclaration":"private void createVertexData()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    vertexToVertexData = new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n    for (V vertex : graph.vertexSet()) {\n        vertexToVertexData.put(vertex, new VertexData2<V>(vertex, false, false));\n    }\n}","methodRange":"(line 211,col 5)-(line 221,col 5)","methodTokenRange":"private void createVertexData()\n    {\n        vertexToVertexData =\n            new HashMap<V, VertexData<V>>(graph.vertexSet().size());\n\n        for (V vertex : graph.vertexSet()) {\n            vertexToVertexData.put(\n                vertex,\n                new VertexData2<V>(vertex, false, false));\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Creates a VertexData object for every vertex in the graph and stores\n     * them\n     * in a HashMap.\n     ","methodParameters":[],"methodName":"createVertexData","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.createVertexData","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 219,col 44)-(line 219,col 48)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 219,col 51)-(line 219,col 55)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.createVertexData()"},{"methodDeclaration":"private void dfsVisit(DirectedGraph<V, E> visitedGraph, VertexData<V> vertexData, Set<V> vertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n    stack.add(vertexData);\n    while (!stack.isEmpty()) {\n        VertexData<V> data = stack.removeLast();\n        if (!data.isDiscovered()) {\n            data.setDiscovered(true);\n            if (vertices != null) {\n                vertices.add(data.getVertex());\n            }\n            stack.add(new VertexData1<V>(data, true, true));\n            for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                VertexData<V> targetData = vertexToVertexData.get(visitedGraph.getEdgeTarget(edge));\n                if (!targetData.isDiscovered()) {\n                    stack.add(targetData);\n                }\n            }\n        } else if (data.isFinished()) {\n            if (vertices == null) {\n                orderedVertices.addFirst(data.getFinishedData());\n            }\n        }\n    }\n}","methodRange":"(line 229,col 5)-(line 266,col 5)","methodTokenRange":"private void dfsVisit(\n        DirectedGraph<V, E> visitedGraph,\n        VertexData<V> vertexData,\n        Set<V> vertices)\n    {\n        Deque<VertexData<V>> stack = new ArrayDeque<VertexData<V>>();\n        stack.add(vertexData);\n\n        while (!stack.isEmpty()) {\n            VertexData<V> data = stack.removeLast();\n\n            if (!data.isDiscovered()) {\n                data.setDiscovered(true);\n\n                if (vertices != null) {\n                    vertices.add(data.getVertex());\n                }\n\n                stack.add(new VertexData1<V>(data, true, true));\n\n                \/\/ follow all edges\n                for (E edge : visitedGraph.outgoingEdgesOf(data.getVertex())) {\n                    VertexData<V> targetData =\n                        vertexToVertexData.get(\n                            visitedGraph.getEdgeTarget(edge));\n\n                    if (!targetData.isDiscovered()) {\n                        \/\/ the \"recursion\"\n                        stack.add(targetData);\n                    }\n                }\n            } else if (data.isFinished()) {\n                if (vertices == null) {\n                    orderedVertices.addFirst(data.getFinishedData());\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * The subroutine of DFS. NOTE: the set is used to distinguish between 1st\n     * and 2nd round of DFS. set == null: finished vertices are stored (1st\n     * round). set != null: all vertices found will be saved in the set (2nd\n     * round)\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> visitedGraph","parameterName":"visitedGraph"},{"parameterType":"VertexData<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData<V>","parameter":"VertexData<V> vertexData","parameterName":"vertexData"},{"parameterType":"Set<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertices","parameterName":"vertices"}],"methodName":"dfsVisit","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.dfsVisit","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 241,col 36)-(line 241,col 39)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 243,col 33)-(line 243,col 36)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 247,col 52)-(line 247,col 55)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 247,col 58)-(line 247,col 61)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 261,col 33)-(line 261,col 36)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.dfsVisit(org.jgrapht.DirectedGraph<V, E>, org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData<V>, java.util.Set<V>)"},{"methodDeclaration":"private void resetVertexData()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (VertexData<V> data : vertexToVertexData.values()) {\n        data.setDiscovered(false);\n        data.setFinished(false);\n    }\n}","methodRange":"(line 271,col 5)-(line 277,col 5)","methodTokenRange":"private void resetVertexData()\n    {\n        for (VertexData<V> data : vertexToVertexData.values()) {\n            data.setDiscovered(false);\n            data.setFinished(false);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Resets all VertexData objects.\n     ","methodParameters":[],"methodName":"resetVertexData","methodQualifiedSignature":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.resetVertexData","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 274,col 32)-(line 274,col 36)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 275,col 30)-(line 275,col 34)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KosarajuStrongConnectivityInspector.resetVertexData()"}],"classJavadoc":"\/**\n * <p>Complements the {@link org.jgrapht.alg.ConnectivityInspector} class with\n * the capability to compute the strongly connected components of a directed\n * graph. The algorithm is implemented after \"Cormen et al: Introduction to\n * agorithms\", Chapter 22.5. It has a running time of O(V + E).<\/p>\n *\n * <p>Unlike {@link org.jgrapht.alg.ConnectivityInspector}, this class does not\n * implement incremental inspection. The full algorithm is executed at the first\n * call of {@link KosarajuStrongConnectivityInspector#stronglyConnectedSets()}\n * or {@link KosarajuStrongConnectivityInspector#isStronglyConnected()}.<\/p>\n *\n * @author Christian Soltenborn\n * @author Christian Hammer\n * @since Feb 2, 2005\n *\/\n","className":"KosarajuStrongConnectivityInspector","fields":[{"fieldRange":"(line 66,col 5)-(line 66,col 44)","fieldName":"graph","fieldJavadocComment":" the graph to compute the strongly connected sets for","fieldTokenRange":"private final DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 69,col 5)-(line 69,col 54)","fieldName":"orderedVertices","fieldJavadocComment":" stores the vertices, ordered by their finishing time in first dfs","fieldTokenRange":"private LinkedList<VertexData<V>> orderedVertices;","fieldTypeResolved":"ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=ReferenceType{org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"LinkedList<VertexData<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.LinkedList<org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData<V>>"},{"fieldRange":"(line 72,col 5)-(line 72,col 47)","fieldName":"stronglyConnectedSets","fieldJavadocComment":" the result of the computation, cached for future calls","fieldTokenRange":"private List<Set<V>> stronglyConnectedSets;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.Set<V>>"},{"fieldRange":"(line 75,col 5)-(line 75,col 68)","fieldName":"stronglyConnectedSubgraphs","fieldJavadocComment":" the result of the computation, cached for future calls","fieldTokenRange":"private List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.graph.DirectedSubgraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.DirectedSubgraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.DirectedSubgraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<DirectedSubgraph<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<org.jgrapht.graph.DirectedSubgraph<V, E>>"},{"fieldRange":"(line 78,col 5)-(line 78,col 53)","fieldName":"vertexToVertexData","fieldJavadocComment":" maps vertices to their VertexData object","fieldTokenRange":"private Map<V, VertexData<V>> vertexToVertexData;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, VertexData<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.KosarajuStrongConnectivityInspector.VertexData<V>>"}]}],"sourceFileId":152,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.BellmanFordShortestPath","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.BellmanFordShortestPath(org.jgrapht.Graph<V, E>, V)","variableDeclarationExprs":[],"constructorRange":"(line 82,col 5)-(line 85,col 5)","constructorJavadocComment":"\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     ","constructorDeclaration":"public BellmanFordShortestPath(Graph<V, E> graph, V startVertex)","constructorBody":"{\n    this(graph, startVertex, graph.vertexSet().size() - 1);\n}","constructorName":"BellmanFordShortestPath","constructorQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.BellmanFordShortestPath","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"literalExprs":[{"literalExprRange":"(line 84,col 61)-(line 84,col 61)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public BellmanFordShortestPath(Graph<V, E> graph, V startVertex)\n    {\n        this(graph, startVertex, graph.vertexSet().size() - 1);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an object to calculate shortest paths between the start vertex\nand others vertices using the Bellman-Ford algorithm.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges of the calculated paths.","javadocBlockTagName":"nMaxHops","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges of the calculated paths.'}]}', name=Optional[nMaxHops]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.BellmanFordShortestPath(org.jgrapht.Graph<V, E>, V, int)","variableDeclarationExprs":[],"constructorRange":"(line 95,col 5)-(line 101,col 5)","constructorJavadocComment":"\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     ","constructorDeclaration":"public BellmanFordShortestPath(Graph<V, E> graph, V startVertex, int nMaxHops)","constructorBody":"{\n    this(graph, startVertex, nMaxHops, DEFAULT_EPSILON);\n}","constructorName":"BellmanFordShortestPath","constructorQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.BellmanFordShortestPath","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int nMaxHops","parameterName":"nMaxHops"}],"literalExprs":[],"constructorTokenRange":"public BellmanFordShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        int nMaxHops)\n    {\n        this(graph, startVertex, nMaxHops, DEFAULT_EPSILON);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an object to calculate shortest paths between the start vertex\nand others vertices using the Bellman-Ford algorithm.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges of the calculated paths.'}]}', name=Optional[nMaxHops]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges of the calculated paths.","javadocBlockTagName":"nMaxHops","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges of the calculated paths.'}]}', name=Optional[nMaxHops]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"tolerance factor.","javadocBlockTagName":"epsilon","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.BellmanFordShortestPath(org.jgrapht.Graph<V, E>, V, int, double)","variableDeclarationExprs":[],"constructorRange":"(line 112,col 5)-(line 123,col 5)","constructorJavadocComment":"\n     * Creates an object to calculate shortest paths between the start vertex\n     * and others vertices using the Bellman-Ford algorithm.\n     *\n     * @param graph\n     * @param startVertex\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     * @param epsilon tolerance factor.\n     ","constructorDeclaration":"public BellmanFordShortestPath(Graph<V, E> graph, V startVertex, int nMaxHops, double epsilon)","constructorBody":"{\n    this.startVertex = startVertex;\n    this.nMaxHops = nMaxHops;\n    this.graph = graph;\n    this.passNumber = 1;\n    this.epsilon = epsilon;\n}","constructorName":"BellmanFordShortestPath","constructorQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.BellmanFordShortestPath","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int nMaxHops","parameterName":"nMaxHops"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[{"literalExprRange":"(line 121,col 27)-(line 121,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public BellmanFordShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        int nMaxHops,\n        double epsilon)\n    {\n        this.startVertex = startVertex;\n        this.nMaxHops = nMaxHops;\n        this.graph = graph;\n        this.passNumber = 1;\n        this.epsilon = epsilon;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an object to calculate shortest paths between the start vertex\nand others vertices using the Bellman-Ford algorithm.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges of the calculated paths.'}]}', name=Optional[nMaxHops]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex.","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the cost of the shortest path between the start vertex and the\nend vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the cost of the shortest path between the start vertex and the\nend vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getCost(V endVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertGetPath(endVertex);\n    lazyCalculate();\n    BellmanFordPathElement<V, E> pathElement = this.iter.getPathElement(endVertex);\n    if (pathElement == null) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return pathElement.getCost();\n}","methodRange":"(line 131,col 5)-(line 145,col 5)","methodTokenRange":"public double getCost(V endVertex)\n    {\n        assertGetPath(endVertex);\n\n        lazyCalculate();\n\n        BellmanFordPathElement<V, E> pathElement =\n            this.iter.getPathElement(endVertex);\n\n        if (pathElement == null) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        return pathElement.getCost();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @param endVertex end vertex.\n     *\n     * @return the cost of the shortest path between the start vertex and the\n     * end vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"getCost","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.getCost","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the cost of the shortest path between the start vertex and the\nend vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 140,col 28)-(line 140,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.getCost(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex.","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of <code>Edge<\/code>, or null if no path exists between the\nstart vertex and the end vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>Edge<\/code>, or null if no path exists between the\nstart vertex and the end vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<E> getPathEdgeList(V endVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertGetPath(endVertex);\n    lazyCalculate();\n    BellmanFordPathElement<V, E> pathElement = this.iter.getPathElement(endVertex);\n    if (pathElement == null) {\n        return null;\n    }\n    return pathElement.createEdgeListPath();\n}","methodRange":"(line 153,col 5)-(line 167,col 5)","methodTokenRange":"public List<E> getPathEdgeList(V endVertex)\n    {\n        assertGetPath(endVertex);\n\n        lazyCalculate();\n\n        BellmanFordPathElement<V, E> pathElement =\n            this.iter.getPathElement(endVertex);\n\n        if (pathElement == null) {\n            return null;\n        }\n\n        return pathElement.createEdgeListPath();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * @param endVertex end vertex.\n     *\n     * @return list of <code>Edge<\/code>, or null if no path exists between the\n     * start vertex and the end vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"getPathEdgeList","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.getPathEdgeList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>Edge<\/code>, or null if no path exists between the\nstart vertex and the end vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[{"literalExprRange":"(line 162,col 28)-(line 162,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 163,col 20)-(line 163,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.getPathEdgeList(V)"},{"methodDeclaration":"private void assertGetPath(V endVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (endVertex.equals(this.startVertex)) {\n        throw new IllegalArgumentException(\"The end vertex is the same as the start vertex!\");\n    }\n    if (!this.graph.containsVertex(endVertex)) {\n        throw new IllegalArgumentException(\"Graph must contain the end vertex!\");\n    }\n}","methodRange":"(line 169,col 5)-(line 180,col 5)","methodTokenRange":"private void assertGetPath(V endVertex)\n    {\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n\n        if (!this.graph.containsVertex(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"assertGetPath","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.assertGetPath","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 173,col 17)-(line 173,col 65)","literalExprId":1,"literalExpr":"\"The end vertex is the same as the start vertex!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 178,col 17)-(line 178,col 52)","literalExprId":2,"literalExpr":"\"Graph must contain the end vertex!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.assertGetPath(V)"},{"methodDeclaration":"private void lazyCalculate()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (this.iter == null) {\n        this.iter = new BellmanFordIterator<V, E>(this.graph, this.startVertex, epsilon);\n    }\n    for (; (this.passNumber <= this.nMaxHops) && this.iter.hasNext(); this.passNumber++) {\n        this.iter.next();\n    }\n}","methodRange":"(line 182,col 5)-(line 201,col 5)","methodTokenRange":"private void lazyCalculate()\n    {\n        if (this.iter == null) {\n            this.iter =\n                new BellmanFordIterator<V, E>(\n                    this.graph,\n                    this.startVertex,\n                    epsilon);\n        }\n\n        \/\/ at the i-th pass the shortest paths with less (or equal) than i edges\n        \/\/ are calculated.\n        for (\n            ;\n            (this.passNumber <= this.nMaxHops) && this.iter.hasNext();\n            this.passNumber++)\n        {\n            this.iter.next();\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"lazyCalculate","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.lazyCalculate","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 184,col 26)-(line 184,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.lazyCalculate()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be searched","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should start","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should end","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of Edges, or null if no path exists","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of Edges, or null if no path exists'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    BellmanFordShortestPath<V, E> alg = new BellmanFordShortestPath<V, E>(graph, startVertex);\n    return alg.getPathEdgeList(endVertex);\n}","methodRange":"(line 214,col 5)-(line 225,col 5)","methodTokenRange":"public static <V, E> List<E> findPathBetween(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        BellmanFordShortestPath<V, E> alg =\n            new BellmanFordShortestPath<V, E>(\n                graph,\n                startVertex);\n\n        return alg.getPathEdgeList(endVertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by hops, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"findPathBetween","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordShortestPath.findPathBetween","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convenience method to find the shortest path via a single static method\ncall. If you need a more advanced search (e.g. limited by hops, or\ncomputation of the path length), use the constructor instead.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of Edges, or null if no path exists'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordShortestPath.findPathBetween(org.jgrapht.Graph<V, E>, V, V)"}],"classJavadoc":"\/**\n * <a href=\"http:\/\/www.nist.gov\/dads\/HTML\/bellmanford.html\">Bellman-Ford\n * algorithm<\/a>: weights could be negative, paths could be constrained by a\n * maximum number of edges.\n *\/\n","className":"BellmanFordShortestPath","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 62)","fieldName":"DEFAULT_EPSILON","fieldJavadocComment":"","fieldTokenRange":"private static final double DEFAULT_EPSILON = 0.000000001;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 51)-(line 52,col 61)","literalExprId":1,"literalExpr":"0.000000001","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[0.000000001]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 57,col 5)-(line 57,col 32)","fieldName":"graph","fieldJavadocComment":"\n     * Graph on which shortest paths are searched.\n     ","fieldTokenRange":"protected Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"Graph on which shortest paths are searched.\n","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 62,col 5)-(line 62,col 28)","fieldName":"startVertex","fieldJavadocComment":"\n     * Start vertex.\n     ","fieldTokenRange":"protected V startVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"Start vertex.\n","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 64,col 5)-(line 64,col 43)","fieldName":"iter","fieldJavadocComment":"","fieldTokenRange":"private BellmanFordIterator<V, E> iter;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.BellmanFordIterator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordIterator.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.BellmanFordIterator.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"BellmanFordIterator<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.BellmanFordIterator<V, E>"},{"fieldRange":"(line 69,col 5)-(line 69,col 25)","fieldName":"nMaxHops","fieldJavadocComment":"\n     * Maximum number of edges of the calculated paths.\n     ","fieldTokenRange":"private int nMaxHops;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Maximum number of edges of the calculated paths.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 71,col 5)-(line 71,col 27)","fieldName":"passNumber","fieldJavadocComment":"","fieldTokenRange":"private int passNumber;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 73,col 5)-(line 73,col 27)","fieldName":"epsilon","fieldJavadocComment":"","fieldTokenRange":"private double epsilon;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":153,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.DijkstraShortestPath","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"},{"importId":4,"import":"import org.jgrapht.traverse.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be searched","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should start","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should end","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.DijkstraShortestPath(org.jgrapht.Graph<V, E>, V, V)","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     ","constructorDeclaration":"public DijkstraShortestPath(Graph<V, E> graph, V startVertex, V endVertex)","constructorBody":"{\n    this(graph, startVertex, endVertex, Double.POSITIVE_INFINITY);\n}","constructorName":"DijkstraShortestPath","constructorQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.DijkstraShortestPath","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"literalExprs":[],"constructorTokenRange":"public DijkstraShortestPath(Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        this(graph, startVertex, endVertex, Double.POSITIVE_INFINITY);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates and executes a new DijkstraShortestPath algorithm instance. An\ninstance is only good for a single search; after construction, it can be\naccessed to retrieve information about the path found.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be searched","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should start","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should end","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search","javadocBlockTagName":"radius","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search'}]}', name=Optional[radius]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.DijkstraShortestPath(org.jgrapht.Graph<V, E>, V, V, double)","variableDeclarationExprs":[{"variableType":"ClosestFirstIterator<V, E>","variableName":"iter","variableDeclarationExprId":1,"variableDeclarationExpr":"ClosestFirstIterator<V, E> iter = new ClosestFirstIterator<V, E>(graph, startVertex, radius)","variableDeclarationExprRange":"(line 98,col 9)-(line 99,col 70)","variableTypeResolved":"ReferenceType{org.jgrapht.traverse.ClosestFirstIterator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.ClosestFirstIterator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.traverse.ClosestFirstIterator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","variableRange":"(line 98,col 36)-(line 99,col 70)"},{"variableType":"V","variableName":"vertex","variableDeclarationExprId":2,"variableDeclarationExpr":"V vertex = iter.next()","variableDeclarationExprRange":"(line 102,col 13)-(line 102,col 34)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 102,col 15)-(line 102,col 34)"}],"constructorRange":"(line 87,col 5)-(line 111,col 5)","constructorJavadocComment":"\n     * Creates and executes a new DijkstraShortestPath algorithm instance. An\n     * instance is only good for a single search; after construction, it can be\n     * accessed to retrieve information about the path found.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     * @param radius limit on weighted path length, or Double.POSITIVE_INFINITY\n     * for unbounded search\n     ","constructorDeclaration":"public DijkstraShortestPath(Graph<V, E> graph, V startVertex, V endVertex, double radius)","constructorBody":"{\n    if (!graph.containsVertex(endVertex)) {\n        throw new IllegalArgumentException(\"graph must contain the end vertex\");\n    }\n    ClosestFirstIterator<V, E> iter = new ClosestFirstIterator<V, E>(graph, startVertex, radius);\n    while (iter.hasNext()) {\n        V vertex = iter.next();\n        if (vertex.equals(endVertex)) {\n            createEdgeList(graph, iter, startVertex, endVertex);\n            return;\n        }\n    }\n    path = null;\n}","constructorName":"DijkstraShortestPath","constructorQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.DijkstraShortestPath","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double radius","parameterName":"radius"}],"literalExprs":[{"literalExprRange":"(line 95,col 17)-(line 95,col 51)","literalExprId":1,"literalExpr":"\"graph must contain the end vertex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 110,col 16)-(line 110,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public DijkstraShortestPath(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex,\n        double radius)\n    {\n        if (!graph.containsVertex(endVertex)) {\n            throw new IllegalArgumentException(\n                \"graph must contain the end vertex\");\n        }\n\n        ClosestFirstIterator<V, E> iter =\n            new ClosestFirstIterator<V, E>(graph, startVertex, radius);\n\n        while (iter.hasNext()) {\n            V vertex = iter.next();\n\n            if (vertex.equals(endVertex)) {\n                createEdgeList(graph, iter, startVertex, endVertex);\n                return;\n            }\n        }\n\n        path = null;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates and executes a new DijkstraShortestPath algorithm instance. An\ninstance is only good for a single search; after construction, it can be\naccessed to retrieve information about the path found.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='limit on weighted path length, or Double.POSITIVE_INFINITY\nfor unbounded search'}]}', name=Optional[radius]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of Edges, or null if no path exists","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of Edges, or null if no path exists'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<E> getPathEdgeList()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (path == null) {\n        return null;\n    } else {\n        return path.getEdgeList();\n    }\n}","methodRange":"(line 118,col 5)-(line 125,col 5)","methodTokenRange":"public List<E> getPathEdgeList()\n    {\n        if (path == null) {\n            return null;\n        } else {\n            return path.getEdgeList();\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Return the edges making up the path found.\n     *\n     * @return List of Edges, or null if no path exists\n     ","methodParameters":[],"methodName":"getPathEdgeList","methodQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.getPathEdgeList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the edges making up the path found.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of Edges, or null if no path exists'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[{"literalExprRange":"(line 120,col 21)-(line 120,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 121,col 20)-(line 121,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.getPathEdgeList()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"path representation, or null if no path exists","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='path representation, or null if no path exists'}]}', name=Optional.empty}"}],"methodDeclaration":"public GraphPath<V, E> getPath()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return path;\n}","methodRange":"(line 132,col 5)-(line 135,col 5)","methodTokenRange":"public GraphPath<V, E> getPath()\n    {\n        return path;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Return the path found.\n     *\n     * @return path representation, or null if no path exists\n     ","methodParameters":[],"methodName":"getPath","methodQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.getPath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the path found.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='path representation, or null if no path exists'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"GraphPath<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.getPath()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"path length, or Double.POSITIVE_INFINITY if no path exists","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='path length, or Double.POSITIVE_INFINITY if no path exists'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getPathLength()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (path == null) {\n        return Double.POSITIVE_INFINITY;\n    } else {\n        return path.getWeight();\n    }\n}","methodRange":"(line 142,col 5)-(line 149,col 5)","methodTokenRange":"public double getPathLength()\n    {\n        if (path == null) {\n            return Double.POSITIVE_INFINITY;\n        } else {\n            return path.getWeight();\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Return the weighted length of the path found.\n     *\n     * @return path length, or Double.POSITIVE_INFINITY if no path exists\n     ","methodParameters":[],"methodName":"getPathLength","methodQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.getPathLength","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the weighted length of the path found.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='path length, or Double.POSITIVE_INFINITY if no path exists'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 144,col 21)-(line 144,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.getPathLength()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to be searched","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should start","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex at which the path should end","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of Edges, or null if no path exists","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of Edges, or null if no path exists'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<E> findPathBetween(Graph<V, E> graph, V startVertex, V endVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    DijkstraShortestPath<V, E> alg = new DijkstraShortestPath<V, E>(graph, startVertex, endVertex);\n    return alg.getPathEdgeList();\n}","methodRange":"(line 162,col 5)-(line 174,col 5)","methodTokenRange":"public static <V, E> List<E> findPathBetween(\n        Graph<V, E> graph,\n        V startVertex,\n        V endVertex)\n    {\n        DijkstraShortestPath<V, E> alg =\n            new DijkstraShortestPath<V, E>(\n                graph,\n                startVertex,\n                endVertex);\n\n        return alg.getPathEdgeList();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Convenience method to find the shortest path via a single static method\n     * call. If you need a more advanced search (e.g. limited by radius, or\n     * computation of the path length), use the constructor instead.\n     *\n     * @param graph the graph to be searched\n     * @param startVertex the vertex at which the path should start\n     * @param endVertex the vertex at which the path should end\n     *\n     * @return List of Edges, or null if no path exists\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"findPathBetween","methodQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.findPathBetween","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convenience method to find the shortest path via a single static method\ncall. If you need a more advanced search (e.g. limited by radius, or\ncomputation of the path length), use the constructor instead.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to be searched'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should start'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex at which the path should end'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of Edges, or null if no path exists'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.findPathBetween(org.jgrapht.Graph<V, E>, V, V)"},{"methodDeclaration":"private void createEdgeList(Graph<V, E> graph, ClosestFirstIterator<V, E> iter, V startVertex, V endVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<E> edgeList = new ArrayList<E>();\n    V v = endVertex;\n    while (true) {\n        E edge = iter.getSpanningTreeEdge(v);\n        if (edge == null) {\n            break;\n        }\n        edgeList.add(edge);\n        v = Graphs.getOppositeVertex(graph, edge, v);\n    }\n    Collections.reverse(edgeList);\n    double pathLength = iter.getShortestPathLength(endVertex);\n    path = new GraphPathImpl<V, E>(graph, startVertex, endVertex, edgeList, pathLength);\n}","methodRange":"(line 176,col 5)-(line 206,col 5)","methodTokenRange":"private void createEdgeList(\n        Graph<V, E> graph,\n        ClosestFirstIterator<V, E> iter,\n        V startVertex,\n        V endVertex)\n    {\n        List<E> edgeList = new ArrayList<E>();\n\n        V v = endVertex;\n\n        while (true) {\n            E edge = iter.getSpanningTreeEdge(v);\n\n            if (edge == null) {\n                break;\n            }\n\n            edgeList.add(edge);\n            v = Graphs.getOppositeVertex(graph, edge, v);\n        }\n\n        Collections.reverse(edgeList);\n        double pathLength = iter.getShortestPathLength(endVertex);\n        path =\n            new GraphPathImpl<V, E>(\n                graph,\n                startVertex,\n                endVertex,\n                edgeList,\n                pathLength);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"ClosestFirstIterator<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.traverse.ClosestFirstIterator, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.traverse.ClosestFirstIterator.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.traverse.ClosestFirstIterator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.traverse.ClosestFirstIterator<V, E>","parameter":"ClosestFirstIterator<V, E> iter","parameterName":"iter"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":4,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"createEdgeList","methodQualifiedSignature":"org.jgrapht.alg.DijkstraShortestPath.createEdgeList","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 186,col 16)-(line 186,col 19)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 189,col 25)-(line 189,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.DijkstraShortestPath.createEdgeList(org.jgrapht.Graph<V, E>, org.jgrapht.traverse.ClosestFirstIterator<V, E>, V, V)"}],"classJavadoc":"\/**\n * An implementation of <a\n * href=\"http:\/\/mathworld.wolfram.com\/DijkstrasAlgorithm.html\">Dijkstra's\n * shortest path algorithm<\/a> using <code>ClosestFirstIterator<\/code>.\n *\n * @author John V. Sichi\n * @since Sep 2, 2003\n *\/\n","className":"DijkstraShortestPath","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 33)","fieldName":"path","fieldJavadocComment":"","fieldTokenRange":"private GraphPath<V, E> path;","fieldTypeResolved":"ReferenceType{org.jgrapht.GraphPath, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.GraphPath.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.GraphPath.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"GraphPath<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.GraphPath<V, E>"}]}],"sourceFileId":154,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.RankingPathElement","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"pathElement","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the end vertex of the path element created.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the path element created.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"total cost of the created path element.","javadocBlockTagName":"weight","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='total cost of the created path element.'}]}', name=Optional[weight]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.RankingPathElement.RankingPathElement(org.jgrapht.Graph<V, E>, org.jgrapht.alg.RankingPathElement<V, E>, E, double)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Creates a path element by concatenation of an edge to a path element.\n     *\n     * @param pathElement\n     * @param edge edge reaching the end vertex of the path element created.\n     * @param weight total cost of the created path element.\n     ","constructorDeclaration":" RankingPathElement(Graph<V, E> graph, RankingPathElement<V, E> pathElement, E edge, double weight)","constructorBody":"{\n    super(graph, pathElement, edge);\n    this.weight = weight;\n}","constructorName":"RankingPathElement","constructorQualifiedName":"org.jgrapht.alg.RankingPathElement.RankingPathElement","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"RankingPathElement<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","parameter":"RankingPathElement<V, E> pathElement","parameterName":"pathElement"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"literalExprs":[],"constructorTokenRange":"RankingPathElement(\n        Graph<V, E> graph,\n        RankingPathElement<V, E> pathElement,\n        E edge,\n        double weight)\n    {\n        super(graph, pathElement, edge);\n        this.weight = weight;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a path element by concatenation of an edge to a path element.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the path element created.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='total cost of the created path element.'}]}', name=Optional[weight]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex of the path element.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the path element.'}]}', name=Optional[vertex]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.RankingPathElement.RankingPathElement(V)","variableDeclarationExprs":[],"constructorRange":"(line 79,col 5)-(line 83,col 5)","constructorJavadocComment":"\n     * Creates an empty path element.\n     *\n     * @param vertex end vertex of the path element.\n     ","constructorDeclaration":" RankingPathElement(V vertex)","constructorBody":"{\n    super(vertex);\n    this.weight = 0;\n}","constructorName":"RankingPathElement","constructorQualifiedName":"org.jgrapht.alg.RankingPathElement.RankingPathElement","constructorParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"literalExprs":[{"literalExprRange":"(line 82,col 23)-(line 82,col 23)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"RankingPathElement(V vertex)\n    {\n        super(vertex);\n        this.weight = 0;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty path element.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the path element.'}]}', name=Optional[vertex]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.weight;\n}","methodRange":"(line 90,col 5)-(line 93,col 5)","methodTokenRange":"public double getWeight()\n    {\n        return this.weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns the weight of the path.\n     *\n     * @return .\n     ","methodParameters":[],"methodName":"getWeight","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElement.getWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the weight of the path.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.RankingPathElement.getWeight()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>null<\/code> is the path is empty.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>null<\/code> is the path is empty.'}]}', name=Optional.empty}"}],"methodDeclaration":"public RankingPathElement<V, E> getPrevPathElement()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (RankingPathElement<V, E>) super.getPrevPathElement();\n}","methodRange":"(line 100,col 5)-(line 103,col 5)","methodTokenRange":"@Override public RankingPathElement<V, E> getPrevPathElement()\n    {\n        return (RankingPathElement<V, E>) super.getPrevPathElement();\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the previous path element.\n     *\n     * @return <code>null<\/code> is the path is empty.\n     ","methodParameters":[],"methodName":"getPrevPathElement","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElement.getPrevPathElement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the previous path element.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>null<\/code> is the path is empty.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","methodType":"RankingPathElement<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.RankingPathElement.getPrevPathElement()"}],"classJavadoc":"\/**\n * Helper class for {@link KShortestPaths}.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"RankingPathElement","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 26)","fieldName":"weight","fieldJavadocComment":"\n     * Weight of the path.\n     ","fieldTokenRange":"private double weight;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"Weight of the path.\n","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":155,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.AStarShortestPath","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"},{"importId":5,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"AStarShortestPath","constructorQualifiedName":"org.jgrapht.alg.AStarShortestPath.AStarShortestPath","constructorQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.AStarShortestPath(org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 95,col 22)-(line 95,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 96,col 48)-(line 96,col 70)","literalExprId":2,"literalExpr":"\"Graph cannot be null!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public AStarShortestPath(Graph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Graph cannot be null!\");\n        }\n        this.graph = graph;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 93,col 5)-(line 99,col 5)","constructorJavadocComment":"","constructorDeclaration":"public AStarShortestPath(Graph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Graph cannot be null!\");\n    }\n    this.graph = graph;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"admissible heuristic","javadocBlockTagName":"admissibleHeuristic","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='admissible heuristic'}]}', name=Optional[admissibleHeuristic]}"}],"methodDeclaration":"private void initialize(AStarAdmissibleHeuristic<V> admissibleHeuristic)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    this.admissibleHeuristic = admissibleHeuristic;\n    openList = new FibonacciHeap<V>();\n    vertexToHeapNodeMap = new HashMap<V, FibonacciHeapNode<V>>();\n    closedList = new HashSet<V>();\n    gScoreMap = new HashMap<V, Double>();\n    cameFrom = new HashMap<V, E>();\n    numberOfExpandedNodes = 0;\n}","methodRange":"(line 106,col 5)-(line 115,col 5)","methodTokenRange":"private void initialize(AStarAdmissibleHeuristic<V> admissibleHeuristic)\n    {\n        this.admissibleHeuristic = admissibleHeuristic;\n        openList = new FibonacciHeap<V>();\n        vertexToHeapNodeMap = new HashMap<V, FibonacciHeapNode<V>>();\n        closedList = new HashSet<V>();\n        gScoreMap = new HashMap<V, Double>();\n        cameFrom = new HashMap<V, E>();\n        numberOfExpandedNodes = 0;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Initializes the data structures\n     *\n     * @param admissibleHeuristic admissible heuristic\n     ","methodParameters":[{"parameterType":"AStarAdmissibleHeuristic<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic<V>","parameter":"AStarAdmissibleHeuristic<V> admissibleHeuristic","parameterName":"admissibleHeuristic"}],"methodName":"initialize","methodQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.initialize","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes the data structures'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='admissible heuristic'}]}', name=Optional[admissibleHeuristic]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 114,col 33)-(line 114,col 33)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AStarShortestPath.initialize(org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"admissible heuristic which estimates the\ndistance from a node to the target node.","javadocBlockTagName":"admissibleHeuristic","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='admissible heuristic which estimates the\ndistance from a node to the target node.'}]}', name=Optional[admissibleHeuristic]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the shortest path from sourceVertex to targetVertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the shortest path from sourceVertex to targetVertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public GraphPath<V, E> getShortestPath(V sourceVertex, V targetVertex, AStarAdmissibleHeuristic<V> admissibleHeuristic)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!graph.containsVertex(sourceVertex) || !graph.containsVertex(targetVertex)) {\n        throw new IllegalArgumentException(\"Source or target vertex not contained in the graph!\");\n    }\n    this.initialize(admissibleHeuristic);\n    gScoreMap.put(sourceVertex, 0.0);\n    FibonacciHeapNode<V> heapNode = new FibonacciHeapNode<V>(sourceVertex);\n    openList.insert(heapNode, 0.0);\n    vertexToHeapNodeMap.put(sourceVertex, heapNode);\n    do {\n        FibonacciHeapNode<V> currentNode = openList.removeMin();\n        if (currentNode.getData() == targetVertex) {\n            return this.buildGraphPath(sourceVertex, targetVertex, currentNode.getKey());\n        }\n        expandNode(currentNode, targetVertex);\n        closedList.add(currentNode.getData());\n    } while (!openList.isEmpty());\n    return null;\n}","methodRange":"(line 129,col 5)-(line 166,col 5)","methodTokenRange":"public GraphPath<V, E> getShortestPath(\n        V sourceVertex,\n        V targetVertex,\n        AStarAdmissibleHeuristic<V> admissibleHeuristic)\n    {\n        if (!graph.containsVertex(sourceVertex)\n            || !graph.containsVertex(targetVertex))\n        {\n            throw new IllegalArgumentException(\n                \"Source or target vertex not contained in the graph!\");\n        }\n\n        this.initialize(admissibleHeuristic);\n        gScoreMap.put(sourceVertex, 0.0);\n        FibonacciHeapNode<V> heapNode = new FibonacciHeapNode<V>(sourceVertex);\n        openList.insert(heapNode, 0.0);\n        vertexToHeapNodeMap.put(sourceVertex, heapNode);\n\n        do {\n            FibonacciHeapNode<V> currentNode = openList.removeMin();\n\n            \/\/Check whether we reached the target vertex\n            if (currentNode.getData() == targetVertex) {\n                \/\/Build the path\n                return this.buildGraphPath(\n                    sourceVertex,\n                    targetVertex,\n                    currentNode.getKey());\n            }\n\n            \/\/We haven't reached the target vertex yet; expand the node\n            expandNode(currentNode, targetVertex);\n            closedList.add(currentNode.getData());\n        } while (!openList.isEmpty());\n\n        \/\/No path exists from sourceVertex to TargetVertex\n        return null;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Calculates (and returns) the shortest path from the sourceVertex to the\n     * targetVertex. Note: each time you invoke this method, the path gets\n     * recomputed.\n     *\n     * @param sourceVertex source vertex\n     * @param targetVertex target vertex\n     * @param admissibleHeuristic admissible heuristic which estimates the\n     * distance from a node to the target node.\n     *\n     * @return the shortest path from sourceVertex to targetVertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"AStarAdmissibleHeuristic<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic<V>","parameter":"AStarAdmissibleHeuristic<V> admissibleHeuristic","parameterName":"admissibleHeuristic"}],"methodName":"getShortestPath","methodQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.getShortestPath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculates (and returns) the shortest path from the sourceVertex to the\ntargetVertex. Note: each time you invoke this method, the path gets\nrecomputed.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='admissible heuristic which estimates the\ndistance from a node to the target node.'}]}', name=Optional[admissibleHeuristic]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the shortest path from sourceVertex to targetVertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"GraphPath<V, E>","literalExprs":[{"literalExprRange":"(line 138,col 17)-(line 138,col 69)","literalExprId":1,"literalExpr":"\"Source or target vertex not contained in the graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 142,col 37)-(line 142,col 39)","literalExprId":2,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 144,col 35)-(line 144,col 37)","literalExprId":3,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 165,col 16)-(line 165,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AStarShortestPath.getShortestPath(V, V, org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic<V>)"},{"methodDeclaration":"private void expandNode(FibonacciHeapNode<V> currentNode, V endVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    numberOfExpandedNodes++;\n    Set<E> outgoingEdges = null;\n    if (graph instanceof UndirectedGraph) {\n        outgoingEdges = graph.edgesOf(currentNode.getData());\n    } else if (graph instanceof DirectedGraph) {\n        outgoingEdges = ((DirectedGraph) graph).outgoingEdgesOf(currentNode.getData());\n    }\n    for (E edge : outgoingEdges) {\n        V successor = Graphs.getOppositeVertex(graph, edge, currentNode.getData());\n        if ((successor == currentNode.getData()) || closedList.contains(successor)) {\n            continue;\n        }\n        double gScore_current = gScoreMap.get(currentNode.getData());\n        double tentativeGScore = gScore_current + graph.getEdgeWeight(edge);\n        if (!vertexToHeapNodeMap.containsKey(successor) || (tentativeGScore < gScoreMap.get(successor))) {\n            cameFrom.put(successor, edge);\n            gScoreMap.put(successor, tentativeGScore);\n            double fScore = tentativeGScore + admissibleHeuristic.getCostEstimate(successor, endVertex);\n            if (!vertexToHeapNodeMap.containsKey(successor)) {\n                FibonacciHeapNode<V> heapNode = new FibonacciHeapNode<V>(successor);\n                openList.insert(heapNode, fScore);\n                vertexToHeapNodeMap.put(successor, heapNode);\n            } else {\n                openList.decreaseKey(vertexToHeapNodeMap.get(successor), fScore);\n            }\n        }\n    }\n}","methodRange":"(line 168,col 5)-(line 213,col 5)","methodTokenRange":"private void expandNode(FibonacciHeapNode<V> currentNode, V endVertex)\n    {\n        numberOfExpandedNodes++;\n\n        Set<E> outgoingEdges = null;\n        if (graph instanceof UndirectedGraph) {\n            outgoingEdges = graph.edgesOf(currentNode.getData());\n        } else if (graph instanceof DirectedGraph) {\n            outgoingEdges =\n                ((DirectedGraph) graph).outgoingEdgesOf(currentNode.getData());\n        }\n\n        for (E edge : outgoingEdges) {\n            V successor =\n                Graphs.getOppositeVertex(graph, edge, currentNode.getData());\n            if ((successor == currentNode.getData())\n                || closedList.contains(successor))\n            { \/\/Ignore self-loops or nodes which have already been expanded\n                continue;\n            }\n\n            double gScore_current = gScoreMap.get(currentNode.getData());\n            double tentativeGScore = gScore_current + graph.getEdgeWeight(edge);\n\n            if (!vertexToHeapNodeMap.containsKey(successor)\n                || (tentativeGScore < gScoreMap.get(successor)))\n            {\n                cameFrom.put(successor, edge);\n                gScoreMap.put(successor, tentativeGScore);\n\n                double fScore =\n                    tentativeGScore\n                    + admissibleHeuristic.getCostEstimate(successor, endVertex);\n                if (!vertexToHeapNodeMap.containsKey(successor)) {\n                    FibonacciHeapNode<V> heapNode =\n                        new FibonacciHeapNode<V>(successor);\n                    openList.insert(heapNode, fScore);\n                    vertexToHeapNodeMap.put(successor, heapNode);\n                } else {\n                    openList.decreaseKey(\n                        vertexToHeapNodeMap.get(successor),\n                        fScore);\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"FibonacciHeapNode<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeapNode<V>","parameter":"FibonacciHeapNode<V> currentNode","parameterName":"currentNode"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"expandNode","methodQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.expandNode","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 172,col 32)-(line 172,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AStarShortestPath.expandNode(org.jgrapht.util.FibonacciHeapNode<V>, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"starting vertex of the path","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='starting vertex of the path'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"ending vertex of the path","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='ending vertex of the path'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"length of the path","javadocBlockTagName":"pathLength","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='length of the path'}]}', name=Optional[pathLength]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the shortest path from startVertex to endVertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the shortest path from startVertex to endVertex'}]}', name=Optional.empty}"}],"methodDeclaration":"private GraphPath<V, E> buildGraphPath(V startVertex, V targetVertex, double pathLength)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<E> edgeList = this.buildPath(targetVertex);\n    return new GraphPathImpl<V, E>(graph, startVertex, targetVertex, edgeList, pathLength);\n}","methodRange":"(line 224,col 5)-(line 236,col 5)","methodTokenRange":"private GraphPath<V, E> buildGraphPath(\n        V startVertex,\n        V targetVertex,\n        double pathLength)\n    {\n        List<E> edgeList = this.buildPath(targetVertex);\n        return new GraphPathImpl<V, E>(\n            graph,\n            startVertex,\n            targetVertex,\n            edgeList,\n            pathLength);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Builds the graph path\n     *\n     * @param startVertex starting vertex of the path\n     * @param targetVertex ending vertex of the path\n     * @param pathLength length of the path\n     *\n     * @return the shortest path from startVertex to endVertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double pathLength","parameterName":"pathLength"}],"methodName":"buildGraphPath","methodQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.buildGraphPath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds the graph path'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='starting vertex of the path'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='ending vertex of the path'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='length of the path'}]}', name=Optional[pathLength]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the shortest path from startVertex to endVertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"GraphPath<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AStarShortestPath.buildGraphPath(V, V, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"node","javadocBlockTagName":"currentNode","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node'}]}', name=Optional[currentNode]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of edges\/arcs that constitutes the path","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of edges\/arcs that constitutes the path'}]}', name=Optional.empty}"}],"methodDeclaration":"private List<E> buildPath(V currentNode)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (cameFrom.containsKey(currentNode)) {\n        List<E> path = buildPath(Graphs.getOppositeVertex(graph, cameFrom.get(currentNode), currentNode));\n        path.add(cameFrom.get(currentNode));\n        return path;\n    } else {\n        return new ArrayList<E>();\n    }\n}","methodRange":"(line 247,col 5)-(line 261,col 5)","methodTokenRange":"private List<E> buildPath(V currentNode)\n    {\n        if (cameFrom.containsKey(currentNode)) {\n            List<E> path =\n                buildPath(\n                    Graphs.getOppositeVertex(\n                        graph,\n                        cameFrom.get(currentNode),\n                        currentNode));\n            path.add(cameFrom.get(currentNode));\n            return path;\n        } else {\n            return new ArrayList<E>();\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Recursive method which traces the path from the targetVertex to the\n     * startVertex. The method traces back the path over the edges, so the\n     * method is safe to use for multi-graphs.\n     *\n     * @param currentNode node\n     *\n     * @return List of edges\/arcs that constitutes the path\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V currentNode","parameterName":"currentNode"}],"methodName":"buildPath","methodQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.buildPath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Recursive method which traces the path from the targetVertex to the\nstartVertex. The method traces back the path over the edges, so the\nmethod is safe to use for multi-graphs.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='node'}]}', name=Optional[currentNode]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of edges\/arcs that constitutes the path'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AStarShortestPath.buildPath(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of expanded nodes","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of expanded nodes'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getNumberOfExpandedNodes()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return numberOfExpandedNodes;\n}","methodRange":"(line 270,col 5)-(line 273,col 5)","methodTokenRange":"public int getNumberOfExpandedNodes()\n    {\n        return numberOfExpandedNodes;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns how many nodes have been expanded in the A* search procedure in\n     * its last invocation. A node is expanded if it is removed from the open\n     * list.\n     *\n     * @return number of expanded nodes\n     ","methodParameters":[],"methodName":"getNumberOfExpandedNodes","methodQualifiedSignature":"org.jgrapht.alg.AStarShortestPath.getNumberOfExpandedNodes","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns how many nodes have been expanded in the A* search procedure in\nits last invocation. A node is expanded if it is removed from the open\nlist.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of expanded nodes'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AStarShortestPath.getNumberOfExpandedNodes()"}],"classJavadoc":"\/**\n * An implementation of <a\n * href=\"http:\/\/en.wikipedia.org\/wiki\/A*_search_algorithm\">A* shortest path\n * algorithm<\/a>. <a href=\"http:\/\/de.wikipedia.org\/wiki\/A*-Algorithmus\">A*\n * shortest path algorithm german Wiki<\/a> . This class works for Directed and\n * Undirected graphs, as well as Multi-Graphs and Mixed-Graphs. It's ok if the\n * graph changes in between invocations of the {@link #getShortestPath(Object,\n * Object, AStarAdmissibleHeuristic)} getShortestPath} method; no new instance\n * of this class has to be created. The heuristic is implemented using a\n * FibonacciHeap data structure to maintain the set of open nodes. However,\n * there still exist several approaches in literature to improve the performance\n * of this heuristic which one could consider to implement. Another issue to\n * take into consideration is the following: given to candidate nodes, i, j to\n * expand, where f(i)=f(j), g(i)&gt;g(j), h(i)&lt;g(j), f(i)=g(i)+h(i), g(i) is\n * the actual distance from the source node to i, h(i) is the estimated distance\n * from i to the target node. Usually a depth-first search is desired, so\n * ideally we would expand node i first. Using the FibonacciHeap, this is not\n * necessarily the case though. This could be improved in a later version.\n *\n * @author Joris Kinable\n * @author Jon Robison\n * @author Thomas Breitbart\n * @since Aug, 2015\n *\/\n","className":"AStarShortestPath","fields":[{"fieldRange":"(line 71,col 5)-(line 71,col 36)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 74,col 5)-(line 74,col 40)","fieldName":"openList","fieldJavadocComment":"List of open nodes","fieldTokenRange":"protected FibonacciHeap<V> openList;","fieldTypeResolved":"ReferenceType{org.jgrapht.util.FibonacciHeap, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeap.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"FibonacciHeap<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.util.FibonacciHeap<V>"},{"fieldRange":"(line 75,col 5)-(line 75,col 63)","fieldName":"vertexToHeapNodeMap","fieldJavadocComment":"","fieldTokenRange":"protected Map<V, FibonacciHeapNode<V>> vertexToHeapNodeMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.util.FibonacciHeapNode, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.util.FibonacciHeapNode.T=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, FibonacciHeapNode<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.util.FibonacciHeapNode<V>>"},{"fieldRange":"(line 78,col 5)-(line 78,col 32)","fieldName":"closedList","fieldJavadocComment":"List of closed nodes","fieldTokenRange":"protected Set<V> closedList;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 81,col 5)-(line 81,col 39)","fieldName":"gScoreMap","fieldJavadocComment":"Mapping of nodes to their g-scores (g(x)).","fieldTokenRange":"protected Map<V, Double> gScoreMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Double>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Double>"},{"fieldRange":"(line 85,col 5)-(line 85,col 33)","fieldName":"cameFrom","fieldJavadocComment":"predecessor on its shortest path towards the targetVertex","fieldTokenRange":"protected Map<V, E> cameFrom;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, E>"},{"fieldRange":"(line 88,col 5)-(line 88,col 62)","fieldName":"admissibleHeuristic","fieldJavadocComment":"Reference to the admissible heuristic","fieldTokenRange":"protected AStarAdmissibleHeuristic<V> admissibleHeuristic;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"AStarAdmissibleHeuristic<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic<V>"},{"fieldRange":"(line 91,col 5)-(line 91,col 40)","fieldName":"numberOfExpandedNodes","fieldJavadocComment":"Counter which keeps track of the number of expanded nodes","fieldTokenRange":"protected int numberOfExpandedNodes;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":156,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.EdmondsKarpMaximumFlow","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"network, where maximum flow will be calculated","javadocBlockTagName":"network","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n     * <tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n     * <tt>network<\/tt> is weighted, then capacities are weights, otherwise all\n     * capacities are equal to one. Doubles are compared using <tt>\n     * DEFAULT_EPSILON<\/tt> tolerance.\n     *\n     * @param network network, where maximum flow will be calculated\n     ","constructorDeclaration":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network)","constructorBody":"{\n    this(network, DEFAULT_EPSILON);\n}","constructorName":"EdmondsKarpMaximumFlow","constructorQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> network","parameterName":"network"}],"literalExprs":[],"constructorTokenRange":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network)\n    {\n        this(network, DEFAULT_EPSILON);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n<tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n<tt>network<\/tt> is weighted, then capacities are weights, otherwise all\ncapacities are equal to one. Doubles are compared using <tt>\nDEFAULT_EPSILON<\/tt> tolerance.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"network, where maximum flow will be calculated","javadocBlockTagName":"network","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"tolerance for comparing doubles","javadocBlockTagName":"epsilon","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance for comparing doubles'}]}', name=Optional[epsilon]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow(org.jgrapht.DirectedGraph<V, E>, double)","variableDeclarationExprs":[],"constructorRange":"(line 83,col 5)-(line 89,col 5)","constructorJavadocComment":"\n     * Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n     * <tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n     * <tt>network<\/tt> is weighted, then capacities are weights, otherwise all\n     * capacities are equal to one.\n     *\n     * @param network network, where maximum flow will be calculated\n     * @param epsilon tolerance for comparing doubles\n     ","constructorDeclaration":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network, double epsilon)","constructorBody":"{\n    engine = new org.jgrapht.alg.flow.EdmondsKarpMaximumFlow<V, E>(network, epsilon);\n}","constructorName":"EdmondsKarpMaximumFlow","constructorQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> network","parameterName":"network"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[],"constructorTokenRange":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network, double epsilon)\n    {\n        engine =\n            new org.jgrapht.alg.flow.EdmondsKarpMaximumFlow<V, E>(\n                network,\n                epsilon);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n<tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n<tt>network<\/tt> is weighted, then capacities are weights, otherwise all\ncapacities are equal to one.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance for comparing doubles'}]}', name=Optional[epsilon]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"private void build()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    maxFlow = engine.buildMaximumFlow(currentSource, currentSink);\n}","methodRange":"(line 91,col 5)-(line 94,col 5)","methodTokenRange":"private void build()\n    {\n        maxFlow = engine.buildMaximumFlow(currentSource, currentSink);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"build","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.build","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.build()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"sink vertex","javadocBlockTagName":"sink","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='sink vertex'}]}', name=Optional[sink]}"}],"methodDeclaration":"public void calculateMaximumFlow(V source, V sink)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    currentSource = source;\n    currentSink = sink;\n    build();\n}","methodRange":"(line 105,col 5)-(line 113,col 5)","methodTokenRange":"public void calculateMaximumFlow(\n        V source,\n        V sink)\n    {\n        currentSource = source;\n        currentSink = sink;\n\n        build();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Sets current source to <tt>source<\/tt>, current sink to <tt>sink<\/tt>,\n     * then calculates maximum flow from <tt>source<\/tt> to <tt>sink<\/tt>. Note,\n     * that <tt>source<\/tt> and <tt>sink<\/tt> must be vertices of the <tt>\n     * network<\/tt> passed to the constructor, and they must be different.\n     *\n     * @param source source vertex\n     * @param sink sink vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sink","parameterName":"sink"}],"methodName":"calculateMaximumFlow","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.calculateMaximumFlow","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets current source to <tt>source<\/tt>, current sink to <tt>sink<\/tt>,\nthen calculates maximum flow from <tt>source<\/tt> to <tt>sink<\/tt>. Note,\nthat <tt>source<\/tt> and <tt>sink<\/tt> must be vertices of the <tt>\nnetwork<\/tt> passed to the constructor, and they must be different.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='sink vertex'}]}', name=Optional[sink]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.calculateMaximumFlow(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"maximum flow value","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum flow value'}]}', name=Optional.empty}"}],"methodDeclaration":"public Double getMaximumFlowValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return maxFlow.getValue();\n}","methodRange":"(line 122,col 5)-(line 125,col 5)","methodTokenRange":"public Double getMaximumFlowValue()\n    {\n        return maxFlow.getValue();\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Returns maximum flow value, that was calculated during last <tt>\n     * calculateMaximumFlow<\/tt> call, or <tt>null<\/tt>, if there was no <tt>\n     * calculateMaximumFlow<\/tt> calls.\n     *\n     * @return maximum flow value\n     ","methodParameters":[],"methodName":"getMaximumFlowValue","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getMaximumFlowValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns maximum flow value, that was calculated during last <tt>\ncalculateMaximumFlow<\/tt> call, or <tt>null<\/tt>, if there was no <tt>\ncalculateMaximumFlow<\/tt> calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum flow value'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Double","methodType":"Double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getMaximumFlowValue()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<i>read-only<\/i> mapping from edges to doubles - flow values","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<i>read-only<\/i> mapping from edges to doubles - flow values'}]}', name=Optional.empty}"}],"methodDeclaration":"public Map<E, Double> getMaximumFlow()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return Collections.unmodifiableMap(maxFlow.getFlow());\n}","methodRange":"(line 134,col 5)-(line 137,col 5)","methodTokenRange":"public Map<E, Double> getMaximumFlow()\n    {\n        return Collections.unmodifiableMap(maxFlow.getFlow());\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n     * Returns maximum flow, that was calculated during last <tt>\n     * calculateMaximumFlow<\/tt> call, or <tt>null<\/tt>, if there was no <tt>\n     * calculateMaximumFlow<\/tt> calls.\n     *\n     * @return <i>read-only<\/i> mapping from edges to doubles - flow values\n     ","methodParameters":[],"methodName":"getMaximumFlow","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getMaximumFlow","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns maximum flow, that was calculated during last <tt>\ncalculateMaximumFlow<\/tt> call, or <tt>null<\/tt>, if there was no <tt>\ncalculateMaximumFlow<\/tt> calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<i>read-only<\/i> mapping from edges to doubles - flow values'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Map<E, java.lang.Double>","methodType":"Map<E, Double>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getMaximumFlow()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"current source","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current source'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getCurrentSource()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return currentSource;\n}","methodRange":"(line 145,col 5)-(line 148,col 5)","methodTokenRange":"public V getCurrentSource()\n    {\n        return currentSource;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns current source vertex, or <tt>null<\/tt> if there was no <tt>\n     * calculateMaximumFlow<\/tt> calls.\n     *\n     * @return current source\n     ","methodParameters":[],"methodName":"getCurrentSource","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getCurrentSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns current source vertex, or <tt>null<\/tt> if there was no <tt>\ncalculateMaximumFlow<\/tt> calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current source'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getCurrentSource()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"current sink","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current sink'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getCurrentSink()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return currentSink;\n}","methodRange":"(line 156,col 5)-(line 159,col 5)","methodTokenRange":"public V getCurrentSink()\n    {\n        return currentSink;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns current sink vertex, or <tt>null<\/tt> if there was no <tt>\n     * calculateMaximumFlow<\/tt> calls.\n     *\n     * @return current sink\n     ","methodParameters":[],"methodName":"getCurrentSink","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getCurrentSink","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns current sink vertex, or <tt>null<\/tt> if there was no <tt>\ncalculateMaximumFlow<\/tt> calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current sink'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.getCurrentSink()"},{"methodDeclaration":"public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    currentSource = source;\n    currentSink = sink;\n    build();\n    return maxFlow;\n}","methodRange":"(line 161,col 5)-(line 169,col 5)","methodTokenRange":"@Override public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)\n    {\n        currentSource = source;\n        currentSink = sink;\n\n        build();\n\n        return maxFlow;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sink","parameterName":"sink"}],"methodName":"buildMaximumFlow","methodQualifiedSignature":"org.jgrapht.alg.EdmondsKarpMaximumFlow.buildMaximumFlow","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow<V, E>","methodType":"MaximumFlow<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsKarpMaximumFlow.buildMaximumFlow(V, V)"}],"classJavadoc":"\/**\n * @deprecated Use {@link org.jgrapht.alg.flow.EdmondsKarpMaximumFlow} instead\n *\/\n","className":"EdmondsKarpMaximumFlow","fields":[{"fieldRange":"(line 52,col 5)-(line 52,col 61)","fieldName":"DEFAULT_EPSILON","fieldJavadocComment":"\n     * Default tolerance.\n     ","fieldTokenRange":"public static final double DEFAULT_EPSILON = 0.000000001;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 52,col 50)-(line 52,col 60)","literalExprId":1,"literalExpr":"0.000000001","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[0.000000001]","fieldType":"double","fieldJavadoc":"Default tolerance.\n","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 53,col 5)-(line 53,col 69)","fieldName":"engine","fieldJavadocComment":"","fieldTokenRange":"private org.jgrapht.alg.flow.EdmondsKarpMaximumFlow<V, E> engine;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow<V, E>"},{"fieldRange":"(line 55,col 5)-(line 55,col 59)","fieldName":"maxFlow","fieldJavadocComment":"","fieldTokenRange":"private MaximumFlowAlgorithm.MaximumFlow<V, E> maxFlow;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"MaximumFlowAlgorithm.MaximumFlow<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow<V, E>"},{"fieldRange":"(line 57,col 5)-(line 57,col 28)","fieldName":"currentSource","fieldJavadocComment":"","fieldTokenRange":"private V currentSource;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 58,col 5)-(line 58,col 26)","fieldName":"currentSink","fieldJavadocComment":"","fieldTokenRange":"private V currentSink;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":157,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.BellmanFordPathElement","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"pathElement","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the end vertex of the path element created.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the path element created.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"total cost of the created path element.","javadocBlockTagName":"cost","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='total cost of the created path element.'}]}', name=Optional[cost]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"tolerance factor.","javadocBlockTagName":"epsilon","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordPathElement.BellmanFordPathElement(org.jgrapht.Graph<V, E>, org.jgrapht.alg.BellmanFordPathElement<V, E>, E, double, double)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Creates a path element by concatenation of an edge to a path element.\n     *\n     * @param pathElement\n     * @param edge edge reaching the end vertex of the path element created.\n     * @param cost total cost of the created path element.\n     * @param epsilon tolerance factor.\n     ","constructorDeclaration":"protected BellmanFordPathElement(Graph<V, E> graph, BellmanFordPathElement<V, E> pathElement, E edge, double cost, double epsilon)","constructorBody":"{\n    super(graph, pathElement, edge);\n    this.cost = cost;\n    this.epsilon = epsilon;\n}","constructorName":"BellmanFordPathElement","constructorQualifiedName":"org.jgrapht.alg.BellmanFordPathElement.BellmanFordPathElement","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"BellmanFordPathElement<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.BellmanFordPathElement<V, E>","parameter":"BellmanFordPathElement<V, E> pathElement","parameterName":"pathElement"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double cost","parameterName":"cost"},{"parameterType":"double","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[],"constructorTokenRange":"protected BellmanFordPathElement(\n        Graph<V, E> graph,\n        BellmanFordPathElement<V, E> pathElement,\n        E edge,\n        double cost,\n        double epsilon)\n    {\n        super(graph, pathElement, edge);\n\n        this.cost = cost;\n        this.epsilon = epsilon;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a path element by concatenation of an edge to a path element.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the path element created.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='total cost of the created path element.'}]}', name=Optional[cost]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source to copy from","javadocBlockTagName":"original","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source to copy from'}]}', name=Optional[original]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordPathElement.BellmanFordPathElement(org.jgrapht.alg.BellmanFordPathElement<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 79,col 5)-(line 84,col 5)","constructorJavadocComment":"\n     * Copy constructor.\n     *\n     * @param original source to copy from\n     ","constructorDeclaration":" BellmanFordPathElement(BellmanFordPathElement<V, E> original)","constructorBody":"{\n    super(original);\n    this.cost = original.cost;\n    this.epsilon = original.epsilon;\n}","constructorName":"BellmanFordPathElement","constructorQualifiedName":"org.jgrapht.alg.BellmanFordPathElement.BellmanFordPathElement","constructorParameters":[{"parameterType":"BellmanFordPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.BellmanFordPathElement<V, E>","parameter":"BellmanFordPathElement<V, E> original","parameterName":"original"}],"literalExprs":[],"constructorTokenRange":"BellmanFordPathElement(BellmanFordPathElement<V, E> original)\n    {\n        super(original);\n        this.cost = original.cost;\n        this.epsilon = original.epsilon;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Copy constructor.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source to copy from'}]}', name=Optional[original]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex of the path element.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the path element.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"tolerance factor.","javadocBlockTagName":"epsilon","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordPathElement.BellmanFordPathElement(V, double)","variableDeclarationExprs":[],"constructorRange":"(line 92,col 5)-(line 98,col 5)","constructorJavadocComment":"\n     * Creates an empty path element.\n     *\n     * @param vertex end vertex of the path element.\n     * @param epsilon tolerance factor.\n     ","constructorDeclaration":"protected BellmanFordPathElement(V vertex, double epsilon)","constructorBody":"{\n    super(vertex);\n    this.cost = 0;\n    this.epsilon = epsilon;\n}","constructorName":"BellmanFordPathElement","constructorQualifiedName":"org.jgrapht.alg.BellmanFordPathElement.BellmanFordPathElement","constructorParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[{"literalExprRange":"(line 96,col 21)-(line 96,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"protected BellmanFordPathElement(V vertex, double epsilon)\n    {\n        super(vertex);\n\n        this.cost = 0;\n        this.epsilon = epsilon;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty path element.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the path element.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getCost()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.cost;\n}","methodRange":"(line 105,col 5)-(line 108,col 5)","methodTokenRange":"public double getCost()\n    {\n        return this.cost;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns the total cost of the path element.\n     *\n     * @return .\n     ","methodParameters":[],"methodName":"getCost","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordPathElement.getCost","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the total cost of the path element.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordPathElement.getCost()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"candidatePrevPathElement","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[candidatePrevPathElement]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"candidateEdge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[candidateEdge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"candidateCost","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[candidateCost]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean improve(BellmanFordPathElement<V, E> candidatePrevPathElement, E candidateEdge, double candidateCost)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (candidateCost < (getCost() - epsilon)) {\n        this.prevPathElement = candidatePrevPathElement;\n        this.prevEdge = candidateEdge;\n        this.cost = candidateCost;\n        this.nHops = candidatePrevPathElement.getHopCount() + 1;\n        return true;\n    } else {\n        return false;\n    }\n}","methodRange":"(line 122,col 5)-(line 138,col 5)","methodTokenRange":"protected boolean improve(\n        BellmanFordPathElement<V, E> candidatePrevPathElement,\n        E candidateEdge,\n        double candidateCost)\n    {\n        \/\/ to avoid improvement only due to rounding errors.\n        if (candidateCost < (getCost() - epsilon)) {\n            this.prevPathElement = candidatePrevPathElement;\n            this.prevEdge = candidateEdge;\n            this.cost = candidateCost;\n            this.nHops = candidatePrevPathElement.getHopCount() + 1;\n\n            return true;\n        } else {\n            return false;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if the path has been improved, <code>\n     * false<\/code> otherwise. We use an \"epsilon\" precision to check whether\n     * the cost has been improved (because of many roundings, a formula equal to\n     * 0 could unfortunately be evaluated to 10^-14).\n     *\n     * @param candidatePrevPathElement\n     * @param candidateEdge\n     * @param candidateCost\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"BellmanFordPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.BellmanFordPathElement<V, E>","parameter":"BellmanFordPathElement<V, E> candidatePrevPathElement","parameterName":"candidatePrevPathElement"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E candidateEdge","parameterName":"candidateEdge"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double candidateCost","parameterName":"candidateCost"}],"methodName":"improve","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordPathElement.improve","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if the path has been improved, <code>\nfalse<\/code> otherwise. We use an \"epsilon\" precision to check whether\nthe cost has been improved (because of many roundings, a formula equal to\n0 could unfortunately be evaluated to 10^-14).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[candidatePrevPathElement]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[candidateEdge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[candidateCost]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 132,col 67)-(line 132,col 67)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 134,col 20)-(line 134,col 23)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 136,col 20)-(line 136,col 24)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordPathElement.improve(org.jgrapht.alg.BellmanFordPathElement<V, E>, E, double)"}],"classJavadoc":"\/**\n * Helper class for {@link BellmanFordShortestPath}; not intended for general\n * use.\n *\/\n","className":"BellmanFordPathElement","fields":[{"fieldRange":"(line 50,col 5)-(line 50,col 28)","fieldName":"cost","fieldJavadocComment":"","fieldTokenRange":"private double cost = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 50,col 27)-(line 50,col 27)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 51,col 5)-(line 51,col 27)","fieldName":"epsilon","fieldJavadocComment":"","fieldTokenRange":"private double epsilon;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":158,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.FloydWarshallShortestPaths","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"FloydWarshallShortestPaths","constructorQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.FloydWarshallShortestPaths","constructorQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.FloydWarshallShortestPaths(org.jgrapht.Graph<V, E>)","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 79,col 17)-(line 79,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FloydWarshallShortestPaths(Graph<V, E> graph)\n    {\n        this.graph = graph;\n        this.vertices = new ArrayList<V>(graph.vertexSet());\n        this.vertexIndices = new HashMap<V, Integer>(this.vertices.size());\n        int i = 0;\n        for (V vertex : vertices) {\n            vertexIndices.put(vertex, i++);\n        }\n    }","variableDeclarationExprs":[{"variableType":"int","variableName":"i","variableDeclarationExprId":1,"variableDeclarationExpr":"int i = 0","variableDeclarationExprRange":"(line 79,col 9)-(line 79,col 17)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 79,col 13)-(line 79,col 17)"},{"variableType":"V","variableName":"vertex","variableDeclarationExprId":2,"variableDeclarationExpr":"V vertex","variableDeclarationExprRange":"(line 80,col 14)-(line 80,col 21)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 80,col 16)-(line 80,col 21)"}],"constructorRange":"(line 74,col 5)-(line 83,col 5)","constructorJavadocComment":"","constructorDeclaration":"public FloydWarshallShortestPaths(Graph<V, E> graph)","constructorBody":"{\n    this.graph = graph;\n    this.vertices = new ArrayList<V>(graph.vertexSet());\n    this.vertexIndices = new HashMap<V, Integer>(this.vertices.size());\n    int i = 0;\n    for (V vertex : vertices) {\n        vertexIndices.put(vertex, i++);\n    }\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the graph on which this algorithm operates","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph on which this algorithm operates'}]}', name=Optional.empty}"}],"methodDeclaration":"public Graph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 88,col 5)-(line 91,col 5)","methodTokenRange":"public Graph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @return the graph on which this algorithm operates\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph on which this algorithm operates'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"Graph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"total number of shortest paths","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='total number of shortest paths'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getShortestPathsCount()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculatePaths();\n    return nShortestPaths;\n}","methodRange":"(line 96,col 5)-(line 100,col 5)","methodTokenRange":"public int getShortestPathsCount()\n    {\n        lazyCalculatePaths();\n        return nShortestPaths;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * @return total number of shortest paths\n     ","methodParameters":[],"methodName":"getShortestPathsCount","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPathsCount","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='total number of shortest paths'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPathsCount()"},{"javadocBlockTags":[],"methodDeclaration":"private void lazyCalculateMatrix()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (d != null) {\n        return;\n    }\n    int n = vertices.size();\n    backtrace = new int[n][n];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(backtrace[i], -1);\n    }\n    d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(d[i], Double.POSITIVE_INFINITY);\n    }\n    for (int i = 0; i < n; i++) {\n        d[i][i] = 0.0;\n    }\n    if (graph instanceof UndirectedGraph<?, ?>) {\n        for (E edge : graph.edgeSet()) {\n            int v_1 = vertexIndices.get(graph.getEdgeSource(edge));\n            int v_2 = vertexIndices.get(graph.getEdgeTarget(edge));\n            d[v_1][v_2] = d[v_2][v_1] = graph.getEdgeWeight(edge);\n            backtrace[v_1][v_2] = v_2;\n            backtrace[v_2][v_1] = v_1;\n        }\n    } else {\n        DirectedGraph<V, E> directedGraph = (DirectedGraph<V, E>) graph;\n        for (V v1 : directedGraph.vertexSet()) {\n            int v_1 = vertexIndices.get(v1);\n            for (V v2 : Graphs.successorListOf(directedGraph, v1)) {\n                int v_2 = vertexIndices.get(v2);\n                d[v_1][v_2] = directedGraph.getEdgeWeight(directedGraph.getEdge(v1, v2));\n                backtrace[v_1][v_2] = v_2;\n            }\n        }\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                double ik_kj = d[i][k] + d[k][j];\n                if (ik_kj < d[i][j]) {\n                    d[i][j] = ik_kj;\n                    backtrace[i][j] = backtrace[i][k];\n                }\n            }\n        }\n    }\n}","methodRange":"(line 106,col 5)-(line 169,col 5)","methodTokenRange":"private void lazyCalculateMatrix()\n    {\n        if (d != null) {\n            \/\/ already done\n            return;\n        }\n\n        int n = vertices.size();\n\n        \/\/ init the backtrace matrix\n        backtrace = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(backtrace[i], -1);\n        }\n\n        \/\/ initialize matrix, 0\n        d = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(d[i], Double.POSITIVE_INFINITY);\n        }\n\n        \/\/ initialize matrix, 1\n        for (int i = 0; i < n; i++) {\n            d[i][i] = 0.0;\n        }\n\n        \/\/ initialize matrix, 2\n        if (graph instanceof UndirectedGraph<?, ?>) {\n            for (E edge : graph.edgeSet()) {\n                int v_1 = vertexIndices.get(graph.getEdgeSource(edge));\n                int v_2 = vertexIndices.get(graph.getEdgeTarget(edge));\n                d[v_1][v_2] = d[v_2][v_1] = graph.getEdgeWeight(edge);\n                backtrace[v_1][v_2] = v_2;\n                backtrace[v_2][v_1] = v_1;\n            }\n        } else { \/\/This works for both Directed and Mixed graphs! Iterating over\n                 \/\/the arcs and querying source\/sink does not suffice for graphs\n                 \/\/which contain both edges and arcs\n            DirectedGraph<V, E> directedGraph = (DirectedGraph<V, E>) graph;\n            for (V v1 : directedGraph.vertexSet()) {\n                int v_1 = vertexIndices.get(v1);\n                for (V v2 : Graphs.successorListOf(directedGraph, v1)) {\n                    int v_2 = vertexIndices.get(v2);\n                    d[v_1][v_2] =\n                        directedGraph.getEdgeWeight(\n                            directedGraph.getEdge(v1, v2));\n                    backtrace[v_1][v_2] = v_2;\n                }\n            }\n        }\n\n        \/\/ run fw alg\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    double ik_kj = d[i][k] + d[k][j];\n                    if (ik_kj < d[i][j]) {\n                        d[i][j] = ik_kj;\n                        backtrace[i][j] = backtrace[i][k];\n                    }\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Calculates the matrix of all shortest paths, but does not populate the\n     * paths map.\n     ","methodParameters":[],"methodName":"lazyCalculateMatrix","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.lazyCalculateMatrix","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculates the matrix of all shortest paths, but does not populate the\npaths map.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 108,col 18)-(line 108,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 117,col 22)-(line 117,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 118,col 40)-(line 118,col 40)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 22)-(line 123,col 22)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 128,col 22)-(line 128,col 22)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 129,col 23)-(line 129,col 25)","literalExprId":6,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 158,col 22)-(line 158,col 22)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 26)-(line 159,col 26)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 160,col 30)-(line 160,col 30)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.lazyCalculateMatrix()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first vertex","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first vertex'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second vertex","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second vertex'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"shortest distance between a and b","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='shortest distance between a and b'}]}', name=Optional.empty}"}],"methodDeclaration":"public double shortestDistance(V a, V b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculateMatrix();\n    return d[vertexIndices.get(a)][vertexIndices.get(b)];\n}","methodRange":"(line 179,col 5)-(line 184,col 5)","methodTokenRange":"public double shortestDistance(V a, V b)\n    {\n        lazyCalculateMatrix();\n\n        return d[vertexIndices.get(a)][vertexIndices.get(b)];\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Get the length of a shortest path.\n     *\n     * @param a first vertex\n     * @param b second vertex\n     *\n     * @return shortest distance between a and b\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"shortestDistance","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.shortestDistance","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the length of a shortest path.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first vertex'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second vertex'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='shortest distance between a and b'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.shortestDistance(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the diameter (longest of all the shortest paths) computed for the\ngraph. If the graph is vertexless, return 0.0.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the diameter (longest of all the shortest paths) computed for the\ngraph. If the graph is vertexless, return 0.0.'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getDiameter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculateMatrix();\n    if (Double.isNaN(diameter)) {\n        diameter = 0.0;\n        int n = vertices.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!Double.isInfinite(d[i][j]) && (d[i][j] > diameter)) {\n                    diameter = d[i][j];\n                }\n            }\n        }\n    }\n    return diameter;\n}","methodRange":"(line 190,col 5)-(line 206,col 5)","methodTokenRange":"public double getDiameter()\n    {\n        lazyCalculateMatrix();\n\n        if (Double.isNaN(diameter)) {\n            diameter = 0.0;\n            int n = vertices.size();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (!Double.isInfinite(d[i][j]) && (d[i][j] > diameter)) {\n                        diameter = d[i][j];\n                    }\n                }\n            }\n        }\n        return diameter;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * @return the diameter (longest of all the shortest paths) computed for the\n     * graph. If the graph is vertexless, return 0.0.\n     ","methodParameters":[],"methodName":"getDiameter","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getDiameter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the diameter (longest of all the shortest paths) computed for the\ngraph. If the graph is vertexless, return 0.0.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 195,col 24)-(line 195,col 26)","literalExprId":1,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 197,col 26)-(line 197,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 198,col 30)-(line 198,col 30)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getDiameter()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"From vertice","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='From vertice'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"To vertice","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='To vertice'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the path, or null if none found","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the path, or null if none found'}]}', name=Optional.empty}"}],"methodDeclaration":"public GraphPath<V, E> getShortestPath(V a, V b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculateMatrix();\n    int v_a = vertexIndices.get(a);\n    int v_b = vertexIndices.get(b);\n    if (backtrace[v_a][v_b] == -1) {\n        return null;\n    }\n    List<E> edges = new ArrayList<E>();\n    int u = v_a;\n    while (u != v_b) {\n        int v = backtrace[u][v_b];\n        edges.add(graph.getEdge(vertices.get(u), vertices.get(v)));\n        u = v;\n    }\n    return new GraphPathImpl<V, E>(graph, a, b, edges, d[v_a][v_b]);\n}","methodRange":"(line 216,col 5)-(line 236,col 5)","methodTokenRange":"public GraphPath<V, E> getShortestPath(V a, V b)\n    {\n        lazyCalculateMatrix();\n\n        int v_a = vertexIndices.get(a);\n        int v_b = vertexIndices.get(b);\n\n        if (backtrace[v_a][v_b] == -1) { \/\/No path exists\n            return null;\n        }\n\n        \/\/Reconstruct the path\n        List<E> edges = new ArrayList<E>();\n        int u = v_a;\n        while (u != v_b) {\n            int v = backtrace[u][v_b];\n            edges.add(graph.getEdge(vertices.get(u), vertices.get(v)));\n            u = v;\n        }\n        return new GraphPathImpl<V, E>(graph, a, b, edges, d[v_a][v_b]);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Get the shortest path between two vertices.\n     *\n     * @param a From vertice\n     * @param b To vertice\n     *\n     * @return the path, or null if none found\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"getShortestPath","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the shortest path between two vertices.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='From vertice'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='To vertice'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the path, or null if none found'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"GraphPath<V, E>","literalExprs":[{"literalExprRange":"(line 223,col 37)-(line 223,col 37)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 20)-(line 224,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPath(V, V)"},{"methodDeclaration":"public List<V> getShortestPathAsVertexList(V a, V b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculateMatrix();\n    int v_a = vertexIndices.get(a);\n    int v_b = vertexIndices.get(b);\n    if (backtrace[v_a][v_b] == -1) {\n        return null;\n    }\n    List<V> pathVertexList = new ArrayList<V>();\n    pathVertexList.add(a);\n    int u = v_a;\n    while (u != v_b) {\n        int v = backtrace[u][v_b];\n        pathVertexList.add(vertices.get(v));\n        u = v;\n    }\n    return pathVertexList;\n}","methodRange":"(line 238,col 5)-(line 259,col 5)","methodTokenRange":"public List<V> getShortestPathAsVertexList(V a, V b)\n    {\n        lazyCalculateMatrix();\n\n        int v_a = vertexIndices.get(a);\n        int v_b = vertexIndices.get(b);\n\n        if (backtrace[v_a][v_b] == -1) { \/\/No path exists\n            return null;\n        }\n\n        \/\/Reconstruct the path\n        List<V> pathVertexList = new ArrayList<V>();\n        pathVertexList.add(a);\n        int u = v_a;\n        while (u != v_b) {\n            int v = backtrace[u][v_b];\n            pathVertexList.add(vertices.get(v));\n            u = v;\n        }\n        return pathVertexList;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"getShortestPathAsVertexList","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPathAsVertexList","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[{"literalExprRange":"(line 245,col 37)-(line 245,col 37)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 246,col 20)-(line 246,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPathAsVertexList(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the originating vertex","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the originating vertex'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of paths","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of paths'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<GraphPath<V, E>> getShortestPaths(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculatePaths();\n    return Collections.unmodifiableList(paths.get(v));\n}","methodRange":"(line 268,col 5)-(line 272,col 5)","methodTokenRange":"public List<GraphPath<V, E>> getShortestPaths(V v)\n    {\n        lazyCalculatePaths();\n        return Collections.unmodifiableList(paths.get(v));\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Get shortest paths from a vertex to all other vertices in the graph.\n     *\n     * @param v the originating vertex\n     *\n     * @return List of paths\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getShortestPaths","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get shortest paths from a vertex to all other vertices in the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the originating vertex'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of paths'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<GraphPath<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPaths(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of paths","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of paths'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<GraphPath<V, E>> getShortestPaths()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    lazyCalculatePaths();\n    List<GraphPath<V, E>> allPaths = new ArrayList<GraphPath<V, E>>();\n    for (List<GraphPath<V, E>> pathSubset : paths.values()) {\n        allPaths.addAll(pathSubset);\n    }\n    return allPaths;\n}","methodRange":"(line 279,col 5)-(line 288,col 5)","methodTokenRange":"public List<GraphPath<V, E>> getShortestPaths()\n    {\n        lazyCalculatePaths();\n        List<GraphPath<V, E>> allPaths = new ArrayList<GraphPath<V, E>>();\n        for (List<GraphPath<V, E>> pathSubset : paths.values()) {\n            allPaths.addAll(pathSubset);\n        }\n\n        return allPaths;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Get all shortest paths in the graph.\n     *\n     * @return List of paths\n     ","methodParameters":[],"methodName":"getShortestPaths","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get all shortest paths in the graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of paths'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<GraphPath<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.getShortestPaths()"},{"javadocBlockTags":[],"methodDeclaration":"private void lazyCalculatePaths()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (paths != null) {\n        return;\n    }\n    lazyCalculateMatrix();\n    paths = new LinkedHashMap<V, List<GraphPath<V, E>>>();\n    int n = vertices.size();\n    for (int i = 0; i < n; i++) {\n        V v_i = vertices.get(i);\n        paths.put(v_i, new ArrayList<GraphPath<V, E>>());\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                continue;\n            }\n            V v_j = vertices.get(j);\n            GraphPath<V, E> path = getShortestPath(v_i, v_j);\n            if (path != null) {\n                paths.get(v_i).add(path);\n                nShortestPaths++;\n            }\n        }\n    }\n}","methodRange":"(line 297,col 5)-(line 326,col 5)","methodTokenRange":"private void lazyCalculatePaths()\n    {\n        \/\/ already we have calculated it once.\n        if (paths != null) {\n            return;\n        }\n\n        lazyCalculateMatrix();\n\n        paths = new LinkedHashMap<V, List<GraphPath<V, E>>>();\n        int n = vertices.size();\n        for (int i = 0; i < n; i++) {\n            V v_i = vertices.get(i);\n            paths.put(v_i, new ArrayList<GraphPath<V, E>>());\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    continue;\n                }\n\n                V v_j = vertices.get(j);\n\n                GraphPath<V, E> path = getShortestPath(v_i, v_j);\n\n                if (path != null) {\n                    paths.get(v_i).add(path);\n                    nShortestPaths++;\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Calculate the shortest paths (not done per default) TODO: This method can\n     * be optimized. Instead of calculating each path individidually, use a\n     * constructive method. TODO: I.e. if we have a shortest path from i to j:\n     * [i,....j] and we know that the shortest path from j to k, we can simply\n     * glue the paths together to obtain the shortest path from i to k\n     ","methodParameters":[],"methodName":"lazyCalculatePaths","methodQualifiedSignature":"org.jgrapht.alg.FloydWarshallShortestPaths.lazyCalculatePaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Calculate the shortest paths (not done per default) TODO: This method can\nbe optimized. Instead of calculating each path individidually, use a\nconstructive method. TODO: I.e. if we have a shortest path from i to j:\n[i,....j] and we know that the shortest path from j to k, we can simply\nglue the paths together to obtain the shortest path from i to k'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 300,col 22)-(line 300,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 308,col 22)-(line 308,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 311,col 26)-(line 311,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 320,col 29)-(line 320,col 32)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.FloydWarshallShortestPaths.lazyCalculatePaths()"}],"classJavadoc":"\/**\n * The <a href=\"http:\/\/en.wikipedia.org\/wiki\/Floyd-Warshall_algorithm\">\n * Floyd-Warshall algorithm<\/a> finds all shortest paths (all n^2 of them) in\n * O(n^3) time. It can also calculate the graph diameter. Note that during\n * construction time, no computations are performed! All computations are\n * performed the first time one of the member methods of this class is invoked.\n * The results are stored, so all subsequent calls to the same method are\n * computationally efficient. Warning: This code has not been tested (and\n * probably doesn't work) on multi-graphs. Code should be updated to work\n * properly on multi-graphs.\n *\n * @author Tom Larkworthy\n * @author Soren Davidsen (soren@tanesha.net)\n * @author Joris Kinable\n *\/\n","className":"FloydWarshallShortestPaths","fields":[{"fieldRange":"(line 64,col 5)-(line 64,col 36)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 65,col 5)-(line 65,col 35)","fieldName":"vertices","fieldJavadocComment":"","fieldTokenRange":"private final List<V> vertices;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"},{"fieldRange":"(line 66,col 5)-(line 66,col 48)","fieldName":"vertexIndices","fieldJavadocComment":"","fieldTokenRange":"private final Map<V, Integer> vertexIndices;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 68,col 5)-(line 68,col 35)","fieldName":"nShortestPaths","fieldJavadocComment":"","fieldTokenRange":"private int nShortestPaths = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 68,col 34)-(line 68,col 34)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 69,col 5)-(line 69,col 41)","fieldName":"diameter","fieldJavadocComment":"","fieldTokenRange":"private double diameter = Double.NaN;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Double.NaN]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 70,col 5)-(line 70,col 33)","fieldName":"d","fieldJavadocComment":"","fieldTokenRange":"private double [][] d = null;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 70,col 29)-(line 70,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"double[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"double[][]"},{"fieldRange":"(line 71,col 5)-(line 71,col 38)","fieldName":"backtrace","fieldJavadocComment":"","fieldTokenRange":"private int [][] backtrace = null;","fieldTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 71,col 34)-(line 71,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"int[][]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[][]"},{"fieldRange":"(line 72,col 5)-(line 72,col 55)","fieldName":"paths","fieldJavadocComment":"","fieldTokenRange":"private Map<V, List<GraphPath<V, E>>> paths = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.GraphPath, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.GraphPath.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.GraphPath.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 72,col 51)-(line 72,col 54)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, List<GraphPath<V, E>>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.List<org.jgrapht.GraphPath<V, E>>>"}]}],"sourceFileId":159,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.util.UnionFind","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.util.UnionFind.UnionFind(java.util.Set<T>)","variableDeclarationExprs":[{"variableType":"T","variableName":"element","variableDeclarationExprId":1,"variableDeclarationExpr":"T element","variableDeclarationExprRange":"(line 66,col 14)-(line 66,col 22)","variableTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","variableRange":"(line 66,col 16)-(line 66,col 22)"}],"constructorRange":"(line 62,col 5)-(line 70,col 5)","constructorJavadocComment":"\n     * Creates a UnionFind instance with all of the elements of elements in\n     * seperate sets.\n     ","constructorDeclaration":"public UnionFind(Set<T> elements)","constructorBody":"{\n    parentMap = new HashMap<T, T>();\n    rankMap = new HashMap<T, Integer>();\n    for (T element : elements) {\n        parentMap.put(element, element);\n        rankMap.put(element, 0);\n    }\n}","constructorName":"UnionFind","constructorQualifiedName":"org.jgrapht.alg.util.UnionFind.UnionFind","constructorParameters":[{"parameterType":"Set<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<T>","parameter":"Set<T> elements","parameterName":"elements"}],"literalExprs":[{"literalExprRange":"(line 68,col 34)-(line 68,col 34)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public UnionFind(Set<T> elements)\n    {\n        parentMap = new HashMap<T, T>();\n        rankMap = new HashMap<T, Integer>();\n        for (T element : elements) {\n            parentMap.put(element, element);\n            rankMap.put(element, 0);\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a UnionFind instance with all of the elements of elements in\nseperate sets.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The element to add.","javadocBlockTagName":"element","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The element to add.'}]}', name=Optional[element]}"}],"methodDeclaration":"public void addElement(T element)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    parentMap.put(element, element);\n    rankMap.put(element, 0);\n}","methodRange":"(line 77,col 5)-(line 81,col 5)","methodTokenRange":"public void addElement(T element)\n    {\n        parentMap.put(element, element);\n        rankMap.put(element, 0);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Adds a new element to the data structure in its own set.\n     *\n     * @param element The element to add.\n     ","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T element","parameterName":"element"}],"methodName":"addElement","methodQualifiedSignature":"org.jgrapht.alg.util.UnionFind.addElement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds a new element to the data structure in its own set.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The element to add.'}]}', name=Optional[element]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 80,col 30)-(line 80,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.util.UnionFind.addElement(T)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"map from element to parent element","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='map from element to parent element'}]}', name=Optional.empty}"}],"methodDeclaration":"protected Map<T, T> getParentMap()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return parentMap;\n}","methodRange":"(line 86,col 5)-(line 89,col 5)","methodTokenRange":"protected Map<T, T> getParentMap()\n    {\n        return parentMap;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n     * @return map from element to parent element\n     ","methodParameters":[],"methodName":"getParentMap","methodQualifiedSignature":"org.jgrapht.alg.util.UnionFind.getParentMap","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='map from element to parent element'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Map<T, T>","methodType":"Map<T, T>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.util.UnionFind.getParentMap()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"map from element to rank","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='map from element to rank'}]}', name=Optional.empty}"}],"methodDeclaration":"protected Map<T, Integer> getRankMap()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return rankMap;\n}","methodRange":"(line 94,col 5)-(line 97,col 5)","methodTokenRange":"protected Map<T, Integer> getRankMap()\n    {\n        return rankMap;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n     * @return map from element to rank\n     ","methodParameters":[],"methodName":"getRankMap","methodQualifiedSignature":"org.jgrapht.alg.util.UnionFind.getRankMap","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='map from element to rank'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Map<T, java.lang.Integer>","methodType":"Map<T, Integer>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.util.UnionFind.getRankMap()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The element to find.","javadocBlockTagName":"element","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The element to find.'}]}', name=Optional[element]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The element representing the set the element is in.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The element representing the set the element is in.'}]}', name=Optional.empty}"}],"methodDeclaration":"public T find(T element)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!parentMap.containsKey(element)) {\n        throw new IllegalArgumentException(\"elements must be contained in given set\");\n    }\n    T parent = parentMap.get(element);\n    if (parent.equals(element)) {\n        return element;\n    }\n    T newParent = find(parent);\n    parentMap.put(element, newParent);\n    return newParent;\n}","methodRange":"(line 106,col 5)-(line 121,col 5)","methodTokenRange":"public T find(T element)\n    {\n        if (!parentMap.containsKey(element)) {\n            throw new IllegalArgumentException(\n                \"elements must be contained in given set\");\n        }\n\n        T parent = parentMap.get(element);\n        if (parent.equals(element)) {\n            return element;\n        }\n\n        T newParent = find(parent);\n        parentMap.put(element, newParent);\n        return newParent;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","methodJavadocComment":"\n     * Returns the representative element of the set that element is in.\n     *\n     * @param element The element to find.\n     *\n     * @return The element representing the set the element is in.\n     ","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T element","parameterName":"element"}],"methodName":"find","methodQualifiedSignature":"org.jgrapht.alg.util.UnionFind.find","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the representative element of the set that element is in.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The element to find.'}]}', name=Optional[element]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The element representing the set the element is in.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T","methodType":"T","literalExprs":[{"literalExprRange":"(line 110,col 17)-(line 110,col 57)","literalExprId":1,"literalExpr":"\"elements must be contained in given set\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.util.UnionFind.find(T)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The first element to union.","javadocBlockTagName":"element1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The first element to union.'}]}', name=Optional[element1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"The second element to union.","javadocBlockTagName":"element2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The second element to union.'}]}', name=Optional[element2]}"}],"methodDeclaration":"public void union(T element1, T element2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!parentMap.containsKey(element1) || !parentMap.containsKey(element2)) {\n        throw new IllegalArgumentException(\"elements must be contained in given set\");\n    }\n    T parent1 = find(element1);\n    T parent2 = find(element2);\n    if (parent1.equals(parent2)) {\n        return;\n    }\n    int rank1 = rankMap.get(parent1);\n    int rank2 = rankMap.get(parent2);\n    if (rank1 > rank2) {\n        parentMap.put(parent2, parent1);\n    } else if (rank1 < rank2) {\n        parentMap.put(parent1, parent2);\n    } else {\n        parentMap.put(parent2, parent1);\n        rankMap.put(parent1, rank1 + 1);\n    }\n}","methodRange":"(line 129,col 5)-(line 156,col 5)","methodTokenRange":"public void union(T element1, T element2)\n    {\n        if (!parentMap.containsKey(element1)\n            || !parentMap.containsKey(element2))\n        {\n            throw new IllegalArgumentException(\n                \"elements must be contained in given set\");\n        }\n\n        T parent1 = find(element1);\n        T parent2 = find(element2);\n\n        \/\/check if the elements are already in the same set\n        if (parent1.equals(parent2)) {\n            return;\n        }\n\n        int rank1 = rankMap.get(parent1);\n        int rank2 = rankMap.get(parent2);\n        if (rank1 > rank2) {\n            parentMap.put(parent2, parent1);\n        } else if (rank1 < rank2) {\n            parentMap.put(parent1, parent2);\n        } else {\n            parentMap.put(parent2, parent1);\n            rankMap.put(parent1, rank1 + 1);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Merges the sets which contain element1 and element2.\n     *\n     * @param element1 The first element to union.\n     * @param element2 The second element to union.\n     ","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T element1","parameterName":"element1"},{"parameterType":"T","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T element2","parameterName":"element2"}],"methodName":"union","methodQualifiedSignature":"org.jgrapht.alg.util.UnionFind.union","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Merges the sets which contain element1 and element2.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The first element to union.'}]}', name=Optional[element1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The second element to union.'}]}', name=Optional[element2]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 135,col 17)-(line 135,col 57)","literalExprId":1,"literalExpr":"\"elements must be contained in given set\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 42)-(line 154,col 42)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.util.UnionFind.union(T, T)"}],"classJavadoc":"\/**\n * An implementation of <a\n * href=\"http:\/\/en.wikipedia.org\/wiki\/Disjoint-set_data_structure\">Union\n * Find<\/a> data structure. Union Find is a disjoint-set data structure. It\n * supports two operations: finding the set a specific element is in, and\n * merging two sets. The implementation uses union by rank and path compression\n * to achieve an amortized cost of O(a(n)) per operation where a is the inverse\n * Ackermann function. UnionFind uses the hashCode and equals method of the\n * elements it operates on.\n *\n * @author Tom Conerly\n * @since Feb 10, 2010\n *\/\n","className":"UnionFind","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 32)","fieldName":"parentMap","fieldJavadocComment":"","fieldTokenRange":"private Map<T, T> parentMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<T, T>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<T, T>"},{"fieldRange":"(line 56,col 5)-(line 56,col 36)","fieldName":"rankMap","fieldJavadocComment":"","fieldTokenRange":"private Map<T, Integer> rankMap;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<T, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<T, java.lang.Integer>"}]}],"sourceFileId":160,"packageName":"org.jgrapht.alg.util"},{"sourceFileName":"org.jgrapht.alg.util.AlwaysEqualComparator","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public int compare(T arg0, T arg1)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return 0;\n}","methodRange":"(line 48,col 5)-(line 51,col 5)","methodTokenRange":"@Override public int compare(T arg0, T arg1)\n    {\n        return 0;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T arg0","parameterName":"arg0"},{"parameterType":"T","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T arg1","parameterName":"arg1"}],"methodName":"compare","methodQualifiedSignature":"org.jgrapht.alg.util.AlwaysEqualComparator.compare","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 50,col 16)-(line 50,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.util.AlwaysEqualComparator.compare(T, T)"}],"classJavadoc":"\/**\n * A default implementation for a check on equality (that always holds)\n *\/\n","className":"AlwaysEqualComparator","fields":[]}],"sourceFileId":161,"packageName":"org.jgrapht.alg.util"},{"sourceFileName":"org.jgrapht.alg.util.Extension","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"Extension","constructorQualifiedName":"org.jgrapht.alg.util.Extension.Extension","constructorQualifiedSignature":"org.jgrapht.alg.util.Extension.Extension(org.jgrapht.alg.util.Extension.ExtensionFactory<E>)","constructorParameters":[{"parameterType":"ExtensionFactory<E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<E>","parameter":"ExtensionFactory<E> factory","parameterName":"factory"}],"literalExprs":[],"constructorTokenRange":"public Extension(ExtensionFactory<E> factory)\n    {\n        this.extensionFactory = factory;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 52,col 5)-(line 55,col 5)","constructorJavadocComment":"","constructorDeclaration":"public Extension(ExtensionFactory<E> factory)","constructorBody":"{\n    this.extensionFactory = factory;\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 79,col 5)-(line 82,col 5)","classOrInterfaceTokenRange":"public interface ExtensionFactory<E>\n    {\n        E create();\n    }","classOrInterfaceJavadocComment":"\n     * Factory capable of producing given extension objects of the given\n     * class-type\n     *\n     * @param <E> extension concept class-type\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Factory capable of producing given extension objects of the given\nclass-type'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='extension concept class-type'}]}', name=Optional[<E>]}]}]"},{"classOrInterfaceRange":"(line 84,col 5)-(line 89,col 5)","classOrInterfaceTokenRange":"public static abstract class BaseExtension\n    {\n        public BaseExtension()\n        {\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 91,col 5)-(line 100,col 5)","classOrInterfaceTokenRange":"public static class ExtensionManagerInstantiationException\n        extends RuntimeException\n    {\n        Exception exception;\n\n        public ExtensionManagerInstantiationException(Exception e)\n        {\n            exception = e;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"methodDeclaration":"public E createInstance()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return extensionFactory.create();\n}","methodRange":"(line 57,col 5)-(line 60,col 5)","methodTokenRange":"public E createInstance()\n    {\n        return extensionFactory.create();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[],"methodName":"createInstance","methodQualifiedSignature":"org.jgrapht.alg.util.Extension.createInstance","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.util.Extension.createInstance()"},{"methodDeclaration":"public E get(T t)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (extensions.containsKey(t)) {\n        return extensions.get(t);\n    }\n    E x = createInstance();\n    extensions.put(t, x);\n    return x;\n}","methodRange":"(line 62,col 5)-(line 71,col 5)","methodTokenRange":"public E get(T t)\n    {\n        if (extensions.containsKey(t)) {\n            return extensions.get(t);\n        }\n\n        E x = createInstance();\n        extensions.put(t, x);\n        return x;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T t","parameterName":"t"}],"methodName":"get","methodQualifiedSignature":"org.jgrapht.alg.util.Extension.get","methodJavadoc":"","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.util.Extension.get(T)"}],"classJavadoc":"\/**\n * Abstract extension manager allowing to extend given class-types with supplied\n * extension's class-type saving source class object references\n *\n * @param <T> class-type to be extended\n * @param <E> extension concept class-type\n *\/\n","className":"Extension","fields":[{"fieldRange":"(line 49,col 5)-(line 49,col 49)","fieldName":"extensionFactory","fieldJavadocComment":"","fieldTokenRange":"private ExtensionFactory<E> extensionFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ExtensionFactory<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<E>"},{"fieldRange":"(line 50,col 5)-(line 50,col 55)","fieldName":"extensions","fieldJavadocComment":"","fieldTokenRange":"private Map<T, E> extensions = new HashMap<T, E>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<T, E>()]","fieldType":"Map<T, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<T, E>"}]}],"sourceFileId":162,"packageName":"org.jgrapht.alg.util"},{"sourceFileName":"org.jgrapht.alg.util.VertexDegreeComparator","imports":[{"importId":1,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph with respect to which the degree is calculated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph with respect to which the degree is calculated.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.util.VertexDegreeComparator.VertexDegreeComparator(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 73,col 5)-(line 76,col 5)","constructorJavadocComment":"\n     * Creates a comparator for comparing the degrees of vertices in the\n     * specified graph. The comparator compares in ascending order of degrees\n     * (lowest first).\n     *\n     * @param g graph with respect to which the degree is calculated.\n     ","constructorDeclaration":"public VertexDegreeComparator(UndirectedGraph<V, E> g)","constructorBody":"{\n    this(g, true);\n}","constructorName":"VertexDegreeComparator","constructorQualifiedName":"org.jgrapht.alg.util.VertexDegreeComparator.VertexDegreeComparator","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[{"literalExprRange":"(line 75,col 17)-(line 75,col 20)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public VertexDegreeComparator(UndirectedGraph<V, E> g)\n    {\n        this(g, true);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a comparator for comparing the degrees of vertices in the\nspecified graph. The comparator compares in ascending order of degrees\n(lowest first).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph with respect to which the degree is calculated.'}]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph with respect to which the degree is calculated.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph with respect to which the degree is calculated.'}]}', name=Optional[g]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"true - compares in ascending order of degrees\n(lowest first), false - compares in descending order of degrees (highest\nfirst).","javadocBlockTagName":"ascendingOrder","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='true - compares in ascending order of degrees\n(lowest first), false - compares in descending order of degrees (highest\nfirst).'}]}', name=Optional[ascendingOrder]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.util.VertexDegreeComparator.VertexDegreeComparator(org.jgrapht.UndirectedGraph<V, E>, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 87,col 5)-(line 93,col 5)","constructorJavadocComment":"\n     * Creates a comparator for comparing the degrees of vertices in the\n     * specified graph.\n     *\n     * @param g graph with respect to which the degree is calculated.\n     * @param ascendingOrder true - compares in ascending order of degrees\n     * (lowest first), false - compares in descending order of degrees (highest\n     * first).\n     ","constructorDeclaration":"public VertexDegreeComparator(UndirectedGraph<V, E> g, boolean ascendingOrder)","constructorBody":"{\n    graph = g;\n    this.ascendingOrder = ascendingOrder;\n}","constructorName":"VertexDegreeComparator","constructorQualifiedName":"org.jgrapht.alg.util.VertexDegreeComparator.VertexDegreeComparator","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean ascendingOrder","parameterName":"ascendingOrder"}],"literalExprs":[],"constructorTokenRange":"public VertexDegreeComparator(\n        UndirectedGraph<V, E> g,\n        boolean ascendingOrder)\n    {\n        graph = g;\n        this.ascendingOrder = ascendingOrder;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a comparator for comparing the degrees of vertices in the\nspecified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph with respect to which the degree is calculated.'}]}', name=Optional[g]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='true - compares in ascending order of degrees\n(lowest first), false - compares in descending order of degrees (highest\nfirst).'}]}', name=Optional[ascendingOrder]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first vertex to be compared.","javadocBlockTagName":"v1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first vertex to be compared.'}]}', name=Optional[v1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second vertex to be compared.","javadocBlockTagName":"v2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second vertex to be compared.'}]}', name=Optional[v2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"-1 if <code>v1<\/code> comes before <code>v2<\/code>, +1 if <code>\nv1<\/code> comes after <code>v2<\/code>, 0 if equal.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='-1 if <code>v1<\/code> comes before <code>v2<\/code>, +1 if <code>\nv1<\/code> comes after <code>v2<\/code>, 0 if equal.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int compare(V v1, V v2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int degree1 = graph.degreeOf(v1);\n    int degree2 = graph.degreeOf(v2);\n    if (((degree1 < degree2) && ascendingOrder) || ((degree1 > degree2) && !ascendingOrder)) {\n        return -1;\n    } else if (((degree1 > degree2) && ascendingOrder) || ((degree1 < degree2) && !ascendingOrder)) {\n        return 1;\n    } else {\n        return 0;\n    }\n}","methodRange":"(line 105,col 5)-(line 122,col 5)","methodTokenRange":"@Override public int compare(V v1, V v2)\n    {\n        int degree1 = graph.degreeOf(v1);\n        int degree2 = graph.degreeOf(v2);\n\n        if (((degree1 < degree2) && ascendingOrder)\n            || ((degree1 > degree2) && !ascendingOrder))\n        {\n            return -1;\n        } else if (\n            ((degree1 > degree2) && ascendingOrder)\n            || ((degree1 < degree2) && !ascendingOrder))\n        {\n            return 1;\n        } else {\n            return 0;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Compare the degrees of <code>v1<\/code> and <code>v2<\/code>, taking into\n     * account whether ascending or descending order is used.\n     *\n     * @param v1 the first vertex to be compared.\n     * @param v2 the second vertex to be compared.\n     *\n     * @return -1 if <code>v1<\/code> comes before <code>v2<\/code>, +1 if <code>\n     * v1<\/code> comes after <code>v2<\/code>, 0 if equal.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v1","parameterName":"v1"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v2","parameterName":"v2"}],"methodName":"compare","methodQualifiedSignature":"org.jgrapht.alg.util.VertexDegreeComparator.compare","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare the degrees of <code>v1<\/code> and <code>v2<\/code>, taking into\naccount whether ascending or descending order is used.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first vertex to be compared.'}]}', name=Optional[v1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second vertex to be compared.'}]}', name=Optional[v2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='-1 if <code>v1<\/code> comes before <code>v2<\/code>, +1 if <code>\nv1<\/code> comes after <code>v2<\/code>, 0 if equal.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 113,col 21)-(line 113,col 21)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 118,col 20)-(line 118,col 20)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 120,col 20)-(line 120,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.util.VertexDegreeComparator.compare(V, V)"}],"classJavadoc":"\/**\n * Compares two vertices based on their degree.\n *\n * <p>Used by greedy algorithms that need to sort vertices by their degree. Two\n * vertices are considered equal if their degrees are equal.<\/p>\n *\n * @author Linda Buisman\n * @since Nov 6, 2003\n *\/\n","className":"VertexDegreeComparator","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 40)","fieldName":"graph","fieldJavadocComment":"\n     * The graph that contains the vertices to be compared.\n     ","fieldTokenRange":"private UndirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"The graph that contains the vertices to be compared.\n","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 64,col 5)-(line 64,col 35)","fieldName":"ascendingOrder","fieldJavadocComment":"\n     * The sort order for vertex degree. <code>true<\/code> for ascending degree\n     * order (smaller degrees first), <code>false<\/code> for descending.\n     ","fieldTokenRange":"private boolean ascendingOrder;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"The sort order for vertex degree. <code>true<\/code> for ascending degree\norder (smaller degrees first), <code>false<\/code> for descending.\n","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":163,"packageName":"org.jgrapht.alg.util"},{"sourceFileName":"org.jgrapht.alg.util.Pair","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"Pair","constructorQualifiedName":"org.jgrapht.alg.util.Pair.Pair","constructorQualifiedSignature":"org.jgrapht.alg.util.Pair.Pair(A, B)","constructorParameters":[{"parameterType":"A","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(A, bounds=[])}","parameterTypeResolvedDescribed":"A","parameter":"A a","parameterName":"a"},{"parameterType":"B","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[])}","parameterTypeResolvedDescribed":"B","parameter":"B b","parameterName":"b"}],"literalExprs":[],"constructorTokenRange":"public Pair(A a, B b)\n    {\n        this.first = a;\n        this.second = b;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 51,col 5)-(line 55,col 5)","constructorJavadocComment":"","constructorDeclaration":"public Pair(A a, B b)","constructorBody":"{\n    this.first = a;\n    this.second = b;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public boolean equals(Object other)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (other instanceof Pair) && Objects.equals(this.first, ((Pair) other).first) && Objects.equals(this.second, ((Pair) other).second);\n}","methodRange":"(line 57,col 5)-(line 62,col 5)","methodTokenRange":"public boolean equals(Object other)\n    {\n        return (other instanceof Pair)\n            && Objects.equals(this.first, ((Pair) other).first)\n            && Objects.equals(this.second, ((Pair) other).second);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object other","parameterName":"other"}],"methodName":"equals","methodQualifiedSignature":"org.jgrapht.alg.util.Pair.equals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.util.Pair.equals(java.lang.Object)"},{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (this.first == null) ? ((this.second == null) ? 0 : (this.second.hashCode() + 1)) : ((this.second == null) ? (this.first.hashCode() + 3) : ((this.first.hashCode() * 19) + this.second.hashCode()));\n}","methodRange":"(line 64,col 5)-(line 70,col 5)","methodTokenRange":"public int hashCode()\n    {\n        return (this.first == null)\n            ? ((this.second == null) ? 0 : (this.second.hashCode() + 1))\n            : ((this.second == null) ? (this.first.hashCode() + 3)\n                : ((this.first.hashCode() * 19) + this.second.hashCode()));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"org.jgrapht.alg.util.Pair.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 66,col 31)-(line 66,col 34)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 67,col 32)-(line 67,col 35)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 67,col 40)-(line 67,col 40)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 67,col 70)-(line 67,col 70)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 32)-(line 68,col 35)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 68,col 65)-(line 68,col 65)","literalExprId":6,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 69,col 45)-(line 69,col 46)","literalExprId":7,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.util.Pair.hashCode()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first element","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first element'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second element","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second element'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"new pair","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new pair'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Pair<A, B> of(A a, B b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new Pair<A, B>(a, b);\n}","methodRange":"(line 81,col 5)-(line 84,col 5)","methodTokenRange":"public static <A, B> Pair<A, B> of(A a, B b)\n    {\n        return new Pair<A, B>(a, b);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.util.Pair, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Pair.A=TypeVariable {JPTypeParameter(A, bounds=[])}, org.jgrapht.alg.util.Pair.B=TypeVariable {JPTypeParameter(B, bounds=[])}}}}","methodJavadocComment":"\n     * Creates new pair of elements pulling of the necessity to provide\n     * corresponding types of the elements supplied\n     *\n     * @param a first element\n     * @param b second element\n     *\n     * @return new pair\n     ","methodParameters":[{"parameterType":"A","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(A, bounds=[])}","parameterTypeResolvedDescribed":"A","parameter":"A a","parameterName":"a"},{"parameterType":"B","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[])}","parameterTypeResolvedDescribed":"B","parameter":"B b","parameterName":"b"}],"methodName":"of","methodQualifiedSignature":"org.jgrapht.alg.util.Pair.of","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates new pair of elements pulling of the necessity to provide\ncorresponding types of the elements supplied'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first element'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second element'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new pair'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.alg.util.Pair<A, B>","methodType":"Pair<A, B>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.util.Pair.of(A, B)"}],"classJavadoc":"\/**\n * Generic pair.<br>\n * Although the instances of this class are immutable, it is impossible to\n * ensure that the references passed to the constructor will not be modified by\n * the caller.\n *\/\n","className":"Pair","fields":[{"fieldRange":"(line 48,col 5)-(line 48,col 19)","fieldName":"first","fieldJavadocComment":"","fieldTokenRange":"public A first;","fieldTypeResolved":"TypeVariable {JPTypeParameter(A, bounds=[])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"A","fieldJavadoc":"","fieldTypeResolvedDescribed":"A"},{"fieldRange":"(line 49,col 5)-(line 49,col 20)","fieldName":"second","fieldJavadocComment":"","fieldTokenRange":"public B second;","fieldTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"B","fieldJavadoc":"","fieldTypeResolvedDescribed":"B"}]}],"sourceFileId":164,"packageName":"org.jgrapht.alg.util"},{"sourceFileName":"org.jgrapht.alg.GabowStrongConnectivityInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to inspect","javadocBlockTagName":"directedGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to inspect'}]}', name=Optional[directedGraph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.GabowStrongConnectivityInspector(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 96,col 5)","constructorJavadocComment":"\n     * The constructor of GabowStrongConnectivityInspector class.\n     *\n     * @param directedGraph the graph to inspect\n     *\n     * @throws IllegalArgumentException\n     ","constructorDeclaration":"public GabowStrongConnectivityInspector(DirectedGraph<V, E> directedGraph)","constructorBody":"{\n    if (directedGraph == null) {\n        throw new IllegalArgumentException(\"null not allowed for graph!\");\n    }\n    graph = directedGraph;\n    vertexToVertexNumber = null;\n    stronglyConnectedSets = null;\n}","constructorName":"GabowStrongConnectivityInspector","constructorQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.GabowStrongConnectivityInspector","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> directedGraph","parameterName":"directedGraph"}],"literalExprs":[{"literalExprRange":"(line 88,col 30)-(line 88,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 89,col 48)-(line 89,col 76)","literalExprId":2,"literalExpr":"\"null not allowed for graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 93,col 32)-(line 93,col 35)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 95,col 33)-(line 95,col 36)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public GabowStrongConnectivityInspector(DirectedGraph<V, E> directedGraph)\n    {\n        if (directedGraph == null) {\n            throw new IllegalArgumentException(\"null not allowed for graph!\");\n        }\n\n        graph = directedGraph;\n        vertexToVertexNumber = null;\n\n        stronglyConnectedSets = null;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The constructor of GabowStrongConnectivityInspector class.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to inspect'}]}', name=Optional[directedGraph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 241,col 5)-(line 268,col 5)","classOrInterfaceTokenRange":"private static final class VertexNumber<V>\n    {\n        V vertex;\n        int number = 0;\n\n        private VertexNumber(\n            V vertex,\n            int number)\n        {\n            this.vertex = vertex;\n            this.number = number;\n        }\n\n        int getNumber()\n        {\n            return number;\n        }\n\n        V getVertex()\n        {\n            return vertex;\n        }\n\n        Integer setNumber(int n)\n        {\n            return number = n;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the graph inspected","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected'}]}', name=Optional.empty}"}],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 103,col 5)-(line 106,col 5)","methodTokenRange":"public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph inspected\n     *\n     * @return the graph inspected\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph inspected'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the graph is strongly connected, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isStronglyConnected()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return stronglyConnectedSets().size() == 1;\n}","methodRange":"(line 113,col 5)-(line 116,col 5)","methodTokenRange":"public boolean isStronglyConnected()\n    {\n        return stronglyConnectedSets().size() == 1;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns true if the graph instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     ","methodParameters":[],"methodName":"isStronglyConnected","methodQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.isStronglyConnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the graph instance is strongly connected.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 115,col 50)-(line 115,col 50)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.isStronglyConnected()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<Set<V>> stronglyConnectedSets()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (stronglyConnectedSets == null) {\n        stronglyConnectedSets = new Vector<Set<V>>();\n        createVertexNumber();\n        for (VertexNumber<V> data : vertexToVertexNumber.values()) {\n            if (data.getNumber() == 0) {\n                dfsVisit(graph, data);\n            }\n        }\n        vertexToVertexNumber = null;\n        stack = null;\n        B = null;\n    }\n    return stronglyConnectedSets;\n}","methodRange":"(line 126,col 5)-(line 147,col 5)","methodTokenRange":"public List<Set<V>> stronglyConnectedSets()\n    {\n        if (stronglyConnectedSets == null) {\n            stronglyConnectedSets = new Vector<Set<V>>();\n\n            \/\/ create VertexData objects for all vertices, store them\n            createVertexNumber();\n\n            \/\/ perform  DFS\n            for (VertexNumber<V> data : vertexToVertexNumber.values()) {\n                if (data.getNumber() == 0) {\n                    dfsVisit(graph, data);\n                }\n            }\n\n            vertexToVertexNumber = null;\n            stack = null;\n            B = null;\n        }\n\n        return stronglyConnectedSets;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List<\/code> of <code>Set<\/code> s containing the strongly\n     * connected components\n     ","methodParameters":[],"methodName":"stronglyConnectedSets","methodQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.stronglyConnectedSets","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes a '}, JavadocInlineTag{tagName='link', type=LINK, content=' List'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Set'}, JavadocSnippet{text='s, where each set contains vertices\nwhich together form a strongly connected component within the given\ngraph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[{"literalExprRange":"(line 128,col 38)-(line 128,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 136,col 41)-(line 136,col 41)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 141,col 36)-(line 141,col 39)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 142,col 21)-(line 142,col 24)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 143,col 17)-(line 143,col 20)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.stronglyConnectedSets()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of subgraphs representing the strongly connected\ncomponents","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (stronglyConnectedSubgraphs == null) {\n        List<Set<V>> sets = stronglyConnectedSets();\n        stronglyConnectedSubgraphs = new Vector<DirectedSubgraph<V, E>>(sets.size());\n        for (Set<V> set : sets) {\n            stronglyConnectedSubgraphs.add(new DirectedSubgraph<V, E>(graph, set, null));\n        }\n    }\n    return stronglyConnectedSubgraphs;\n}","methodRange":"(line 162,col 5)-(line 179,col 5)","methodTokenRange":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()\n    {\n        if (stronglyConnectedSubgraphs == null) {\n            List<Set<V>> sets = stronglyConnectedSets();\n            stronglyConnectedSubgraphs =\n                new Vector<DirectedSubgraph<V, E>>(sets.size());\n\n            for (Set<V> set : sets) {\n                stronglyConnectedSubgraphs.add(\n                    new DirectedSubgraph<V, E>(\n                        graph,\n                        set,\n                        null));\n            }\n        }\n\n        return stronglyConnectedSubgraphs;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.<\/p>\n     *\n     * <p>NOTE: Calling this method will first execute {@link\n     * GabowStrongConnectivityInspector#stronglyConnectedSets()}. If you don't\n     * need subgraphs, use that method.<\/p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     ","methodParameters":[],"methodName":"stronglyConnectedSubgraphs","methodQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.stronglyConnectedSubgraphs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Computes a list of '}, JavadocInlineTag{tagName='link', type=LINK, content=' DirectedSubgraph'}, JavadocSnippet{text='s of the given graph. Each\nsubgraph will represent a strongly connected component and will contain\nall vertices of that component. The subgraph will have an edge (u,v) iff\nu and v are contained in the strongly connected component.<\/p>\n\n<p>NOTE: Calling this method will first execute '}, JavadocInlineTag{tagName='link', type=LINK, content='\nGabowStrongConnectivityInspector#stronglyConnectedSets()'}, JavadocSnippet{text='. If you don't\nneed subgraphs, use that method.<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<DirectedSubgraph<V, E>>","literalExprs":[{"literalExprRange":"(line 164,col 43)-(line 164,col 46)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 174,col 25)-(line 174,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.stronglyConnectedSubgraphs()"},{"methodDeclaration":"private void createVertexNumber()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    c = graph.vertexSet().size();\n    vertexToVertexNumber = new HashMap<V, VertexNumber<V>>(c);\n    for (V vertex : graph.vertexSet()) {\n        vertexToVertexNumber.put(vertex, new VertexNumber<V>(vertex, 0));\n    }\n    stack = new ArrayDeque<VertexNumber<V>>(c);\n    B = new ArrayDeque<Integer>(c);\n}","methodRange":"(line 187,col 5)-(line 200,col 5)","methodTokenRange":"private void createVertexNumber()\n    {\n        c = graph.vertexSet().size();\n        vertexToVertexNumber = new HashMap<V, VertexNumber<V>>(c);\n\n        for (V vertex : graph.vertexSet()) {\n            vertexToVertexNumber.put(\n                vertex,\n                new VertexNumber<V>(vertex, 0));\n        }\n\n        stack = new ArrayDeque<VertexNumber<V>>(c);\n        B = new ArrayDeque<Integer>(c);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"createVertexNumber","methodQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.createVertexNumber","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 195,col 45)-(line 195,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.createVertexNumber()"},{"methodDeclaration":"private void dfsVisit(DirectedGraph<V, E> visitedGraph, VertexNumber<V> v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    VertexNumber<V> w;\n    stack.add(v);\n    B.add(v.setNumber(stack.size() - 1));\n    for (E edge : visitedGraph.outgoingEdgesOf(v.getVertex())) {\n        w = vertexToVertexNumber.get(visitedGraph.getEdgeTarget(edge));\n        if (w.getNumber() == 0) {\n            dfsVisit(graph, w);\n        } else {\n            while (w.getNumber() < B.getLast()) {\n                B.removeLast();\n            }\n        }\n    }\n    Set<V> L = new HashSet<V>();\n    if (v.getNumber() == (B.getLast())) {\n        B.removeLast();\n        c++;\n        while (v.getNumber() <= (stack.size() - 1)) {\n            VertexNumber<V> r = stack.removeLast();\n            L.add(r.getVertex());\n            r.setNumber(c);\n        }\n        stronglyConnectedSets.add(L);\n    }\n}","methodRange":"(line 205,col 5)-(line 239,col 5)","methodTokenRange":"private void dfsVisit(DirectedGraph<V, E> visitedGraph, VertexNumber<V> v)\n    {\n        VertexNumber<V> w;\n        stack.add(v);\n        B.add(v.setNumber(stack.size() - 1));\n\n        \/\/ follow all edges\n\n        for (E edge : visitedGraph.outgoingEdgesOf(v.getVertex())) {\n            w = vertexToVertexNumber.get(\n                visitedGraph.getEdgeTarget(edge));\n\n            if (w.getNumber() == 0) {\n                dfsVisit(graph, w);\n            } else { \/*contract if necessary*\/\n                while (w.getNumber() < B.getLast()) {\n                    B.removeLast();\n                }\n            }\n        }\n        Set<V> L = new HashSet<V>();\n        if (v.getNumber() == (B.getLast())) {\n            \/* number vertices of the next\n                strong component *\/\n            B.removeLast();\n\n            c++;\n            while (v.getNumber() <= (stack.size() - 1)) {\n                VertexNumber<V> r = stack.removeLast();\n                L.add(r.getVertex());\n                r.setNumber(c);\n            }\n            stronglyConnectedSets.add(L);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * The subroutine of DFS.\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> visitedGraph","parameterName":"visitedGraph"},{"parameterType":"VertexNumber<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber<V>","parameter":"VertexNumber<V> v","parameterName":"v"}],"methodName":"dfsVisit","methodQualifiedSignature":"org.jgrapht.alg.GabowStrongConnectivityInspector.dfsVisit","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 209,col 42)-(line 209,col 42)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 217,col 34)-(line 217,col 34)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 232,col 53)-(line 232,col 53)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.GabowStrongConnectivityInspector.dfsVisit(org.jgrapht.DirectedGraph<V, E>, org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber<V>)"}],"classJavadoc":"","className":"GabowStrongConnectivityInspector","fields":[{"fieldRange":"(line 59,col 5)-(line 59,col 44)","fieldName":"graph","fieldJavadocComment":" the graph to compute the strongly connected sets","fieldTokenRange":"private final DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 62,col 5)-(line 62,col 77)","fieldName":"stack","fieldJavadocComment":" stores the vertices","fieldTokenRange":"private Deque<VertexNumber<V>> stack = new ArrayDeque<VertexNumber<V>>();","fieldTypeResolved":"ReferenceType{java.util.Deque, typeParametersMap=TypeParametersMap{nameToValue={java.util.Deque.E=ReferenceType{org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayDeque<VertexNumber<V>>()]","fieldType":"Deque<VertexNumber<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Deque<org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber<V>>"},{"fieldRange":"(line 65,col 5)-(line 65,col 47)","fieldName":"stronglyConnectedSets","fieldJavadocComment":" the result of the computation, cached for future calls","fieldTokenRange":"private List<Set<V>> stronglyConnectedSets;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.Set<V>>"},{"fieldRange":"(line 68,col 5)-(line 68,col 68)","fieldName":"stronglyConnectedSubgraphs","fieldJavadocComment":" the result of the computation, cached for future calls","fieldTokenRange":"private List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{org.jgrapht.graph.DirectedSubgraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.DirectedSubgraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.DirectedSubgraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<DirectedSubgraph<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<org.jgrapht.graph.DirectedSubgraph<V, E>>"},{"fieldRange":"(line 71,col 5)-(line 71,col 57)","fieldName":"vertexToVertexNumber","fieldJavadocComment":" maps vertices to their VertexNumber object","fieldTokenRange":"private Map<V, VertexNumber<V>> vertexToVertexNumber;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, VertexNumber<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.GabowStrongConnectivityInspector.VertexNumber<V>>"},{"fieldRange":"(line 74,col 5)-(line 74,col 57)","fieldName":"B","fieldJavadocComment":"store the numbers","fieldTokenRange":"private Deque<Integer> B = new ArrayDeque<Integer>();","fieldTypeResolved":"ReferenceType{java.util.Deque, typeParametersMap=TypeParametersMap{nameToValue={java.util.Deque.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayDeque<Integer>()]","fieldType":"Deque<Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Deque<java.lang.Integer>"},{"fieldRange":"(line 77,col 5)-(line 77,col 18)","fieldName":"c","fieldJavadocComment":"number of vertices","fieldTokenRange":"private int c;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":165,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.HawickJamesSimpleCycles()","variableDeclarationExprs":[],"constructorRange":"(line 91,col 5)-(line 93,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder with an unspecified graph.\n     ","constructorDeclaration":"public HawickJamesSimpleCycles()","constructorBody":"{\n}","constructorName":"HawickJamesSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.HawickJamesSimpleCycles","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public HawickJamesSimpleCycles()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder with an unspecified graph.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the DirectedGraph in which to find cycles.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph argument is <code>\nnull<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.HawickJamesSimpleCycles(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 103,col 5)-(line 110,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"public HawickJamesSimpleCycles(DirectedGraph<V, E> graph) throws IllegalArgumentException","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","constructorName":"HawickJamesSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.HawickJamesSimpleCycles","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 106,col 22)-(line 106,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 107,col 48)-(line 107,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public HawickJamesSimpleCycles(DirectedGraph<V, E> graph)\n        throws IllegalArgumentException\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"private void initState(Operation o)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    nCycles = 0;\n    nVertices = graph.vertexSet().size();\n    if (o == Operation.ENUMERATE) {\n        cycles = new ArrayList<List<V>>();\n    }\n    blocked = new boolean[nVertices];\n    stack = new ArrayDeque<Integer>(nVertices);\n    B = new ArrayList[nVertices];\n    for (int i = 0; i < nVertices; i++) {\n        B[i] = new ArrayList<Integer>();\n    }\n    iToV = (V[]) graph.vertexSet().toArray();\n    vToI = new HashMap<V, Integer>();\n    for (int i = 0; i < iToV.length; i++) {\n        vToI.put(iToV[i], i);\n    }\n    Ak = buildAdjacencyList();\n    stack.clear();\n}","methodRange":"(line 112,col 5)-(line 138,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    private void initState(Operation o)\n    {\n        nCycles = 0;\n        nVertices = graph.vertexSet().size();\n        if (o == Operation.ENUMERATE) {\n            cycles = new ArrayList<List<V>>();\n        }\n        blocked = new boolean[nVertices];\n        stack = new ArrayDeque<Integer>(nVertices);\n\n        B = new ArrayList[nVertices];\n        for (int i = 0; i < nVertices; i++) {\n            \/\/B[i] = new ArrayList<Integer>(nVertices);\n            B[i] = new ArrayList<Integer>();\n        }\n\n        iToV = (V []) graph.vertexSet().toArray();\n        vToI = new HashMap<V, Integer>();\n        for (int i = 0; i < iToV.length; i++) {\n            vToI.put(iToV[i], i);\n        }\n\n        Ak = buildAdjacencyList();\n\n        stack.clear();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Operation","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.cycle.HawickJamesSimpleCycles.Operation, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.Operation","parameter":"Operation o","parameterName":"o"}],"methodName":"initState","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.initState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 112,col 23)-(line 112,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 115,col 19)-(line 115,col 19)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 124,col 22)-(line 124,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 131,col 22)-(line 131,col 22)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.initState(org.jgrapht.alg.cycle.HawickJamesSimpleCycles.Operation)"},{"methodDeclaration":"private List<Integer>[] buildAdjacencyList()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    @SuppressWarnings(\"rawtypes\")\n    List[] Ak = new ArrayList[nVertices];\n    for (int j = 0; j < nVertices; j++) {\n        V v = iToV[j];\n        List<V> s = Graphs.successorListOf(graph, v);\n        Ak[j] = new ArrayList<Integer>(s.size());\n        Iterator<V> iterator = s.iterator();\n        while (iterator.hasNext()) {\n            Ak[j].add(vToI.get(iterator.next()));\n        }\n    }\n    return Ak;\n}","methodRange":"(line 140,col 5)-(line 157,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    private List<Integer> [] buildAdjacencyList()\n    {\n        @SuppressWarnings(\"rawtypes\")\n        List [] Ak = new ArrayList[nVertices];\n        for (int j = 0; j < nVertices; j++) {\n            V v = iToV[j];\n            List<V> s = Graphs.successorListOf(graph, v);\n            Ak[j] = new ArrayList<Integer>(s.size());\n\n            Iterator<V> iterator = s.iterator();\n            while (iterator.hasNext()) {\n                Ak[j].add(vToI.get(iterator.next()));\n            }\n        }\n\n        return Ak;\n    }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"buildAdjacencyList","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.buildAdjacencyList","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<java.lang.Integer>[]","methodType":"List<Integer>[]","literalExprs":[{"literalExprRange":"(line 140,col 23)-(line 140,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 143,col 27)-(line 143,col 36)","literalExprId":2,"literalExpr":"\"rawtypes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 145,col 22)-(line 145,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.buildAdjacencyList()"},{"methodDeclaration":"private void clearState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Ak = null;\n    nVertices = 0;\n    blocked = null;\n    stack = null;\n    iToV = null;\n    vToI = null;\n    for (int i = 0; i < nVertices; i++) {\n        Ak[i] = null;\n        B[i] = null;\n    }\n    Ak = null;\n    B = null;\n}","methodRange":"(line 159,col 5)-(line 175,col 5)","methodTokenRange":"private void clearState()\n    {\n        Ak = null;\n        nVertices = 0;\n        blocked = null;\n        stack = null;\n        iToV = null;\n        vToI = null;\n\n        for (int i = 0; i < nVertices; i++) {\n            Ak[i] = null;\n            B[i] = null;\n        }\n\n        Ak = null;\n        B = null;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"clearState","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.clearState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 161,col 14)-(line 161,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 162,col 21)-(line 162,col 21)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 163,col 19)-(line 163,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 164,col 17)-(line 164,col 20)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 165,col 16)-(line 165,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 166,col 16)-(line 166,col 19)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 168,col 22)-(line 168,col 22)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 169,col 21)-(line 169,col 24)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 170,col 20)-(line 170,col 23)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 173,col 14)-(line 173,col 17)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 174,col 13)-(line 174,col 16)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.clearState()"},{"methodDeclaration":"private boolean circuit(Integer v, Operation o)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    boolean f = false;\n    stack.push(v);\n    blocked[v] = true;\n    Iterator<Integer> iteratorAk = Ak[v].iterator();\n    while (iteratorAk.hasNext()) {\n        Integer w = iteratorAk.next();\n        if (w < start) {\n            continue;\n        }\n        if (w == start) {\n            if (o == Operation.ENUMERATE) {\n                List<V> cycle = new ArrayList<V>(stack.size());\n                Iterator<Integer> iteratorStack = stack.iterator();\n                while (iteratorStack.hasNext()) {\n                    cycle.add(iToV[iteratorStack.next()]);\n                }\n                cycles.add(cycle);\n            }\n            if (o == Operation.PRINT_ONLY) {\n                for (Integer i : stack) {\n                    System.out.print(iToV[i].toString() + \" \");\n                }\n                System.out.println(\"\");\n            }\n            nCycles++;\n            f = true;\n        } else if (!blocked[w]) {\n            if (circuit(w, o)) {\n                f = true;\n            }\n        }\n    }\n    if (f) {\n        unblock(v);\n    } else {\n        iteratorAk = Ak[v].iterator();\n        while (iteratorAk.hasNext()) {\n            Integer w = iteratorAk.next();\n            if (w < start) {\n                continue;\n            }\n            if (!B[w].contains(v)) {\n                B[w].add(v);\n            }\n        }\n    }\n    stack.pop();\n    return f;\n}","methodRange":"(line 177,col 5)-(line 241,col 5)","methodTokenRange":"private boolean circuit(Integer v, Operation o)\n    {\n        boolean f = false;\n\n        stack.push(v);\n        blocked[v] = true;\n\n        Iterator<Integer> iteratorAk = Ak[v].iterator();\n        while (iteratorAk.hasNext()) {\n            Integer w = iteratorAk.next();\n\n            if (w < start) {\n                continue;\n            }\n\n            if (w == start) {\n                if (o == Operation.ENUMERATE) {\n                    List<V> cycle = new ArrayList<V>(stack.size());\n\n                    Iterator<Integer> iteratorStack = stack.iterator();\n                    while (iteratorStack.hasNext()) {\n                        cycle.add(iToV[iteratorStack.next()]);\n                    }\n\n                    cycles.add(cycle);\n                }\n\n                if (o == Operation.PRINT_ONLY) {\n                    for (Integer i : stack) {\n                        System.out.print(iToV[i].toString() + \" \");\n                    }\n                    System.out.println(\"\");\n                }\n\n                nCycles++;\n\n                f = true;\n            } else if (!blocked[w]) {\n                if (circuit(w, o)) {\n                    f = true;\n                }\n            }\n        }\n\n        if (f) {\n            unblock(v);\n        } else {\n            iteratorAk = Ak[v].iterator();\n            while (iteratorAk.hasNext()) {\n                Integer w = iteratorAk.next();\n\n                if (w < start) {\n                    continue;\n                }\n\n                if (!B[w].contains(v)) {\n                    B[w].add(v);\n                }\n            }\n        }\n\n        stack.pop();\n\n        return f;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Integer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer v","parameterName":"v"},{"parameterType":"Operation","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.cycle.HawickJamesSimpleCycles.Operation, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.Operation","parameter":"Operation o","parameterName":"o"}],"methodName":"circuit","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.circuit","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 179,col 21)-(line 179,col 25)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 182,col 22)-(line 182,col 25)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 206,col 63)-(line 206,col 65)","literalExprId":3,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 208,col 40)-(line 208,col 41)","literalExprId":4,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 213,col 21)-(line 213,col 24)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 216,col 25)-(line 216,col 28)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.circuit(java.lang.Integer, org.jgrapht.alg.cycle.HawickJamesSimpleCycles.Operation)"},{"methodDeclaration":"private void unblock(Integer u)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    blocked[u] = false;\n    for (int wPos = 0; wPos < B[u].size(); wPos++) {\n        Integer w = B[u].get(wPos);\n        wPos -= removeFromList(B[u], w);\n        if (blocked[w]) {\n            unblock(w);\n        }\n    }\n}","methodRange":"(line 243,col 5)-(line 256,col 5)","methodTokenRange":"private void unblock(Integer u)\n    {\n        blocked[u] = false;\n\n        for (int wPos = 0; wPos < B[u].size(); wPos++) {\n            Integer w = B[u].get(wPos);\n\n            wPos -= removeFromList(B[u], w);\n\n            if (blocked[w]) {\n                unblock(w);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Integer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer u","parameterName":"u"}],"methodName":"unblock","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.unblock","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 245,col 22)-(line 245,col 26)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 247,col 25)-(line 247,col 25)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.unblock(java.lang.Integer)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Integer to be removed.","javadocBlockTagName":"u","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Integer to be removed.'}]}', name=Optional[u]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list from which all the occurrences of u must be removed.","javadocBlockTagName":"list","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list from which all the occurrences of u must be removed.'}]}', name=Optional[list]}"}],"methodDeclaration":"private int removeFromList(List<Integer> list, Integer u)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int nOccurrences = 0;\n    Iterator<Integer> iterator = list.iterator();\n    while (iterator.hasNext()) {\n        Integer w = iterator.next();\n        if (w == u) {\n            nOccurrences++;\n            iterator.remove();\n        }\n    }\n    return nOccurrences;\n}","methodRange":"(line 264,col 5)-(line 278,col 5)","methodTokenRange":"private int removeFromList(List<Integer> list, Integer u)\n    {\n        int nOccurrences = 0;\n\n        Iterator<Integer> iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Integer w = iterator.next();\n            if (w == u) {\n                nOccurrences++;\n                iterator.remove();\n            }\n        }\n\n        return nOccurrences;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Remove all occurrences of a value from the list.\n     *\n     * @param u the Integer to be removed.\n     * @param list the list from which all the occurrences of u must be removed.\n     ","methodParameters":[{"parameterType":"List<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.Integer>","parameter":"List<Integer> list","parameterName":"list"},{"parameterType":"Integer","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer u","parameterName":"u"}],"methodName":"removeFromList","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.removeFromList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Remove all occurrences of a value from the list.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Integer to be removed.'}]}', name=Optional[u]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list from which all the occurrences of u must be removed.'}]}', name=Optional[list]}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 266,col 28)-(line 266,col 28)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.removeFromList(java.util.List<java.lang.Integer>, java.lang.Integer)"},{"javadocBlockTags":[],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 283,col 5)-(line 286,col 5)","methodTokenRange":"@Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.getGraph()"},{"javadocBlockTags":[],"methodDeclaration":"public void setGraph(DirectedGraph<V, E> graph) throws IllegalArgumentException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","methodRange":"(line 291,col 5)-(line 298,col 5)","methodTokenRange":"@Override public void setGraph(DirectedGraph<V, E> graph)\n        throws IllegalArgumentException\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 294,col 22)-(line 294,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 295,col 48)-(line 295,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.setGraph(org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"public List<List<V>> findSimpleCycles() throws IllegalArgumentException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    initState(Operation.ENUMERATE);\n    for (int i = 0; i < nVertices; i++) {\n        for (int j = 0; j < nVertices; j++) {\n            blocked[j] = false;\n            B[j].clear();\n        }\n        start = vToI.get(iToV[i]);\n        circuit(start, Operation.ENUMERATE);\n    }\n    List<List<V>> result = cycles;\n    clearState();\n    return result;\n}","methodRange":"(line 303,col 5)-(line 325,col 5)","methodTokenRange":"@Override public List<List<V>> findSimpleCycles()\n        throws IllegalArgumentException\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n\n        initState(Operation.ENUMERATE);\n\n        for (int i = 0; i < nVertices; i++) {\n            for (int j = 0; j < nVertices; j++) {\n                blocked[j] = false;\n                B[j].clear();\n            }\n\n            start = vToI.get(iToV[i]);\n            circuit(start, Operation.ENUMERATE);\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"findSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.findSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[{"literalExprRange":"(line 306,col 22)-(line 306,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 307,col 48)-(line 307,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 312,col 22)-(line 312,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 313,col 26)-(line 313,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 314,col 30)-(line 314,col 34)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.findSimpleCycles()"},{"javadocBlockTags":[],"methodDeclaration":"public void printSimpleCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    initState(Operation.PRINT_ONLY);\n    for (int i = 0; i < nVertices; i++) {\n        for (int j = 0; j < nVertices; j++) {\n            blocked[j] = false;\n            B[j].clear();\n        }\n        start = vToI.get(iToV[i]);\n        circuit(start, Operation.PRINT_ONLY);\n    }\n    clearState();\n}","methodRange":"(line 332,col 5)-(line 351,col 5)","methodTokenRange":"public void printSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n\n        initState(Operation.PRINT_ONLY);\n\n        for (int i = 0; i < nVertices; i++) {\n            for (int j = 0; j < nVertices; j++) {\n                blocked[j] = false;\n                B[j].clear();\n            }\n\n            start = vToI.get(iToV[i]);\n            circuit(start, Operation.PRINT_ONLY);\n        }\n\n        clearState();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Print to the standard output all simple cycles without building a list to\n     * keep them, thus avoiding high memory consumption when investigating large\n     * and much connected graphs.\n     ","methodParameters":[],"methodName":"printSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.printSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print to the standard output all simple cycles without building a list to\nkeep them, thus avoiding high memory consumption when investigating large\nand much connected graphs.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 334,col 22)-(line 334,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 335,col 48)-(line 335,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 340,col 22)-(line 340,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 341,col 26)-(line 341,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 342,col 30)-(line 342,col 34)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.printSimpleCycles()"},{"javadocBlockTags":[],"methodDeclaration":"public long countSimpleCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    initState(Operation.COUNT_ONLY);\n    for (int i = 0; i < nVertices; i++) {\n        for (int j = 0; j < nVertices; j++) {\n            blocked[j] = false;\n            B[j].clear();\n        }\n        start = vToI.get(iToV[i]);\n        circuit(start, Operation.COUNT_ONLY);\n    }\n    clearState();\n    return nCycles;\n}","methodRange":"(line 357,col 5)-(line 378,col 5)","methodTokenRange":"public long countSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n\n        initState(Operation.COUNT_ONLY);\n\n        for (int i = 0; i < nVertices; i++) {\n            for (int j = 0; j < nVertices; j++) {\n                blocked[j] = false;\n                B[j].clear();\n            }\n\n            start = vToI.get(iToV[i]);\n            circuit(start, Operation.COUNT_ONLY);\n        }\n\n        clearState();\n\n        return nCycles;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n     * Count the number of simple cycles. It can count up to Long.MAX cycles in\n     * a graph.\n     ","methodParameters":[],"methodName":"countSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.countSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Count the number of simple cycles. It can count up to Long.MAX cycles in\na graph.'}]}, blockTags=[]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 359,col 22)-(line 359,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 360,col 48)-(line 360,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 365,col 22)-(line 365,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 366,col 26)-(line 366,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 367,col 30)-(line 367,col 34)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.HawickJamesSimpleCycles.countSimpleCycles()"}],"classJavadoc":"\/**\n * Find all simple cycles of a directed graph using the algorithm described by\n * Hawick and James.\n *\n * <p>See:<br>\n * K. A. Hawick, H. A. James. Enumerating Circuits and Loops in Graphs with\n * Self-Arcs and Multiple-Arcs. Computational Science Technical Note CSTN-013,\n * 2008\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Luiz Kill\n *\/\n","className":"HawickJamesSimpleCycles","fields":[{"fieldRange":"(line 66,col 5)-(line 66,col 45)","fieldName":"graph","fieldJavadocComment":" The graph","fieldTokenRange":"private DirectedGraph<V, E> graph = null;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 66,col 41)-(line 66,col 44)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 69,col 5)-(line 69,col 30)","fieldName":"nVertices","fieldJavadocComment":" Number of vertices","fieldTokenRange":"private int nVertices = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 69,col 29)-(line 69,col 29)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 72,col 5)-(line 72,col 29)","fieldName":"nCycles","fieldJavadocComment":" Number of simple cycles","fieldTokenRange":"private long nCycles = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 72,col 28)-(line 72,col 28)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 75,col 5)-(line 75,col 40)","fieldName":"cycles","fieldJavadocComment":" Simple cycles found","fieldTokenRange":"private List<List<V>> cycles = null;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 75,col 36)-(line 75,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<List<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.List<V>>"},{"fieldRange":"(line 78,col 5)-(line 78,col 30)","fieldName":"start","fieldJavadocComment":" The main state of the algorithm","fieldTokenRange":"private Integer start = 0;","fieldTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 78,col 29)-(line 78,col 29)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"Integer","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Integer"},{"fieldRange":"(line 79,col 5)-(line 79,col 39)","fieldName":"Ak","fieldJavadocComment":"","fieldTokenRange":"private List<Integer> [] Ak = null;","fieldTypeResolved":"ResolvedArrayType{ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 79,col 35)-(line 79,col 38)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<Integer>[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.Integer>[]"},{"fieldRange":"(line 80,col 5)-(line 80,col 38)","fieldName":"B","fieldJavadocComment":"","fieldTokenRange":"private List<Integer> [] B = null;","fieldTypeResolved":"ResolvedArrayType{ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 80,col 34)-(line 80,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<Integer>[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.Integer>[]"},{"fieldRange":"(line 81,col 5)-(line 81,col 38)","fieldName":"blocked","fieldJavadocComment":"","fieldTokenRange":"private boolean [] blocked = null;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 81,col 34)-(line 81,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"boolean[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean[]"},{"fieldRange":"(line 82,col 5)-(line 82,col 45)","fieldName":"stack","fieldJavadocComment":"","fieldTokenRange":"private ArrayDeque<Integer> stack = null;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 82,col 41)-(line 82,col 44)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"ArrayDeque<Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<java.lang.Integer>"},{"fieldRange":"(line 85,col 5)-(line 85,col 29)","fieldName":"iToV","fieldJavadocComment":" Giving an index to every V","fieldTokenRange":"private V [] iToV = null;","fieldTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(V, bounds=[])}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 85,col 25)-(line 85,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"V[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"V[]"},{"fieldRange":"(line 86,col 5)-(line 86,col 40)","fieldName":"vToI","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vToI = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 86,col 36)-(line 86,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"}]}],"sourceFileId":166,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.DirectedSimpleCycles","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"The graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The graph.'}]}', name=Optional.empty}"}],"methodDeclaration":" DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 60,col 5)-(line 60,col 35)","methodTokenRange":"DirectedGraph<V, E> getGraph();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph on which the simple cycle search algorithm is executed\n     * by this object.\n     *\n     * @return The graph.\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.DirectedSimpleCycles.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph on which the simple cycle search algorithm is executed\nby this object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.DirectedSimpleCycles.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the argument is <code>null<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the argument is <code>null<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":" void setGraph(DirectedGraph<V, E> graph)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 70,col 5)-(line 70,col 45)","methodTokenRange":"void setGraph(DirectedGraph<V, E> graph);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Sets the graph on which the simple cycle search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null<\/code>.\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.DirectedSimpleCycles.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the graph on which the simple cycle search algorithm is executed by\nthis object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the argument is <code>null<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.DirectedSimpleCycles.setGraph(org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"The list of all simple cycles. Possibly empty but never <code>\nnull<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The list of all simple cycles. Possibly empty but never <code>\nnull<\/code>.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the current graph is null.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the current graph is null.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":" List<List<V>> findSimpleCycles()","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 82,col 5)-(line 82,col 37)","methodTokenRange":"List<List<V>> findSimpleCycles();","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Finds the simple cycles of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return The list of all simple cycles. Possibly empty but never <code>\n     * null<\/code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     ","methodParameters":[],"methodName":"findSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.DirectedSimpleCycles.findSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds the simple cycles of the graph.<br>\nNote that the full algorithm is executed on every call since the graph\nmay have changed between calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The list of all simple cycles. Possibly empty but never <code>\nnull<\/code>.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the current graph is null.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.DirectedSimpleCycles.findSimpleCycles()"}],"classJavadoc":"\/**\n * A common interface for classes implementing algorithms for enumeration of the\n * simple cycles of a directed graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"DirectedSimpleCycles","fields":[]}],"sourceFileId":167,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.JohnsonSimpleCycles()","variableDeclarationExprs":[],"constructorRange":"(line 81,col 5)-(line 83,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder with an unspecified graph.\n     ","constructorDeclaration":"public JohnsonSimpleCycles()","constructorBody":"{\n}","constructorName":"JohnsonSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.JohnsonSimpleCycles","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public JohnsonSimpleCycles()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder with an unspecified graph.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"- the DirectedGraph in which to find cycles.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph argument is <code>\nnull<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.JohnsonSimpleCycles(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 93,col 5)-(line 99,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"public JohnsonSimpleCycles(DirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","constructorName":"JohnsonSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.JohnsonSimpleCycles","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 95,col 22)-(line 95,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 96,col 48)-(line 96,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public JohnsonSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 104,col 5)-(line 107,col 5)","methodTokenRange":"@Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.getGraph()"},{"javadocBlockTags":[],"methodDeclaration":"public void setGraph(DirectedGraph<V, E> graph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","methodRange":"(line 112,col 5)-(line 118,col 5)","methodTokenRange":"@Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 114,col 22)-(line 114,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 115,col 48)-(line 115,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.setGraph(org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"public List<List<V>> findSimpleCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    initState();\n    int startIndex = 0;\n    int size = graph.vertexSet().size();\n    while (startIndex < size) {\n        Object[] minSCCGResult = findMinSCSG(startIndex);\n        if (minSCCGResult[0] != null) {\n            startIndex = (Integer) minSCCGResult[1];\n            @SuppressWarnings(\"unchecked\")\n            DirectedGraph<V, E> scg = (DirectedGraph<V, E>) minSCCGResult[0];\n            V startV = toV(startIndex);\n            for (E e : scg.outgoingEdgesOf(startV)) {\n                V v = graph.getEdgeTarget(e);\n                blocked.remove(v);\n                getBSet(v).clear();\n            }\n            findCyclesInSCG(startIndex, startIndex, scg);\n            startIndex++;\n        } else {\n            break;\n        }\n    }\n    List<List<V>> result = cycles;\n    clearState();\n    return result;\n}","methodRange":"(line 123,col 5)-(line 155,col 5)","methodTokenRange":"@Override public List<List<V>> findSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        initState();\n\n        int startIndex = 0;\n        int size = graph.vertexSet().size();\n        while (startIndex < size) {\n            Object [] minSCCGResult = findMinSCSG(startIndex);\n            if (minSCCGResult[0] != null) {\n                startIndex = (Integer) minSCCGResult[1];\n                @SuppressWarnings(\"unchecked\")\n                DirectedGraph<V, E> scg =\n                    (DirectedGraph<V, E>) minSCCGResult[0];\n                V startV = toV(startIndex);\n                for (E e : scg.outgoingEdgesOf(startV)) {\n                    V v = graph.getEdgeTarget(e);\n                    blocked.remove(v);\n                    getBSet(v).clear();\n                }\n                findCyclesInSCG(startIndex, startIndex, scg);\n                startIndex++;\n            } else {\n                break;\n            }\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"findSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[{"literalExprRange":"(line 125,col 22)-(line 125,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 126,col 48)-(line 126,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 130,col 26)-(line 130,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 134,col 31)-(line 134,col 31)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 134,col 37)-(line 134,col 40)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 135,col 54)-(line 135,col 54)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 136,col 35)-(line 136,col 45)","literalExprId":7,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 138,col 57)-(line 138,col 57)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findSimpleCycles()"},{"methodDeclaration":"private Object[] findMinSCSG(int startIndex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    initMinSCGState();\n    Object[] result = new Object[2];\n    List<Set<V>> SCCs = findSCCS(startIndex);\n    int minIndexFound = Integer.MAX_VALUE;\n    Set<V> minSCC = null;\n    for (Set<V> scc : SCCs) {\n        for (V v : scc) {\n            int t = toI(v);\n            if (t < minIndexFound) {\n                minIndexFound = t;\n                minSCC = scc;\n            }\n        }\n    }\n    if (minSCC == null) {\n        return result;\n    }\n    @SuppressWarnings(\"unchecked\")\n    DirectedGraph<V, E> resultGraph = new DefaultDirectedGraph<V, E>(new ClassBasedEdgeFactory<V, E>((Class<? extends E>) DefaultEdge.class));\n    for (V v : minSCC) {\n        resultGraph.addVertex(v);\n    }\n    for (V v : minSCC) {\n        for (V w : minSCC) {\n            if (graph.containsEdge(v, w)) {\n                resultGraph.addEdge(v, w);\n            }\n        }\n    }\n    result[0] = resultGraph;\n    result[1] = minIndexFound;\n    clearMinSCCState();\n    return result;\n}","methodRange":"(line 157,col 5)-(line 214,col 5)","methodTokenRange":"private Object [] findMinSCSG(int startIndex)\n    {\n        \/\/ Per Johnson : \"adjacency structure of strong\n        \/\/ component K with least vertex in subgraph of\n        \/\/ G induced by {s, s+ 1, n}\".\n        \/\/ Or in contemporary terms: the strongly connected\n        \/\/ component of the subgraph induced by {v1,...,vn}\n        \/\/ which contains the minimum (among those SCCs)\n        \/\/ vertex index. We return that index together with\n        \/\/ the graph.\n        initMinSCGState();\n        Object [] result = new Object[2];\n\n        List<Set<V>> SCCs = findSCCS(startIndex);\n\n        \/\/ find the SCC with the minimum index\n        int minIndexFound = Integer.MAX_VALUE;\n        Set<V> minSCC = null;\n        for (Set<V> scc : SCCs) {\n            for (V v : scc) {\n                int t = toI(v);\n                if (t < minIndexFound) {\n                    minIndexFound = t;\n                    minSCC = scc;\n                }\n            }\n        }\n        if (minSCC == null) {\n            return result;\n        }\n\n        \/\/ build a graph for the SCC found\n        @SuppressWarnings(\"unchecked\")\n        DirectedGraph<V, E> resultGraph =\n            new DefaultDirectedGraph<V, E>(\n                new ClassBasedEdgeFactory<V, E>(\n                    (Class<? extends E>) DefaultEdge.class));\n        for (V v : minSCC) {\n            resultGraph.addVertex(v);\n        }\n        for (V v : minSCC) {\n            for (V w : minSCC) {\n                if (graph.containsEdge(v, w)) {\n                    resultGraph.addEdge(v, w);\n                }\n            }\n        }\n\n        \/\/ It is ugly to return results in an array\n        \/\/ of Object but the idea is to restrict\n        \/\/ dependencies to JgraphT only and there is\n        \/\/ no utility pair container in JgraphT.\n        result[0] = resultGraph;\n        result[1] = minIndexFound;\n\n        clearMinSCCState();\n        return result;\n    }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startIndex","parameterName":"startIndex"}],"methodName":"findMinSCSG","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findMinSCSG","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Object[]","methodType":"Object[]","literalExprs":[{"literalExprRange":"(line 168,col 39)-(line 168,col 39)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 174,col 25)-(line 174,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 184,col 23)-(line 184,col 26)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 189,col 27)-(line 189,col 37)","literalExprId":4,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 16)-(line 209,col 16)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 210,col 16)-(line 210,col 16)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findMinSCSG(int)"},{"methodDeclaration":"private List<Set<V>> findSCCS(int startIndex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V v : graph.vertexSet()) {\n        int vI = toI(v);\n        if (vI < startIndex) {\n            continue;\n        }\n        if (!vIndex.containsKey(v)) {\n            getSCCs(startIndex, vI);\n        }\n    }\n    List<Set<V>> result = SCCs;\n    SCCs = null;\n    return result;\n}","methodRange":"(line 216,col 5)-(line 239,col 5)","methodTokenRange":"private List<Set<V>> findSCCS(int startIndex)\n    {\n        \/\/ Find SCCs in the subgraph induced\n        \/\/ by vertices startIndex and beyond.\n        \/\/ A call to StrongConnectivityAlgorithm\n        \/\/ would be too expensive because of the\n        \/\/ need to materialize the subgraph.\n        \/\/ So - do a local search by the Tarjan's\n        \/\/ algorithm and pretend that vertices\n        \/\/ with an index smaller than startIndex\n        \/\/ do not exist.\n        for (V v : graph.vertexSet()) {\n            int vI = toI(v);\n            if (vI < startIndex) {\n                continue;\n            }\n            if (!vIndex.containsKey(v)) {\n                getSCCs(startIndex, vI);\n            }\n        }\n        List<Set<V>> result = SCCs;\n        SCCs = null;\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startIndex","parameterName":"startIndex"}],"methodName":"findSCCS","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findSCCS","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[{"literalExprRange":"(line 237,col 16)-(line 237,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findSCCS(int)"},{"methodDeclaration":"private void getSCCs(int startIndex, int vertexIndex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V vertex = toV(vertexIndex);\n    vIndex.put(vertex, index);\n    vLowlink.put(vertex, index);\n    index++;\n    path.push(vertex);\n    pathSet.add(vertex);\n    Set<E> edges = graph.outgoingEdgesOf(vertex);\n    for (E e : edges) {\n        V successor = graph.getEdgeTarget(e);\n        int successorIndex = toI(successor);\n        if (successorIndex < startIndex) {\n            continue;\n        }\n        if (!vIndex.containsKey(successor)) {\n            getSCCs(startIndex, successorIndex);\n            vLowlink.put(vertex, Math.min(vLowlink.get(vertex), vLowlink.get(successor)));\n        } else if (pathSet.contains(successor)) {\n            vLowlink.put(vertex, Math.min(vLowlink.get(vertex), vIndex.get(successor)));\n        }\n    }\n    if (vLowlink.get(vertex).equals(vIndex.get(vertex))) {\n        Set<V> result = new HashSet<V>();\n        V temp = null;\n        do {\n            temp = path.pop();\n            pathSet.remove(temp);\n            result.add(temp);\n        } while (!vertex.equals(temp));\n        if (result.size() == 1) {\n            V v = result.iterator().next();\n            if (graph.containsEdge(vertex, v)) {\n                SCCs.add(result);\n            }\n        } else {\n            SCCs.add(result);\n        }\n    }\n}","methodRange":"(line 241,col 5)-(line 287,col 5)","methodTokenRange":"private void getSCCs(int startIndex, int vertexIndex)\n    {\n        V vertex = toV(vertexIndex);\n        vIndex.put(vertex, index);\n        vLowlink.put(vertex, index);\n        index++;\n        path.push(vertex);\n        pathSet.add(vertex);\n\n        Set<E> edges = graph.outgoingEdgesOf(vertex);\n        for (E e : edges) {\n            V successor = graph.getEdgeTarget(e);\n            int successorIndex = toI(successor);\n            if (successorIndex < startIndex) {\n                continue;\n            }\n            if (!vIndex.containsKey(successor)) {\n                getSCCs(startIndex, successorIndex);\n                vLowlink.put(\n                    vertex,\n                    Math.min(vLowlink.get(vertex),\n                        vLowlink.get(successor)));\n            } else if (pathSet.contains(successor)) {\n                vLowlink.put(\n                    vertex,\n                    Math.min(vLowlink.get(vertex),\n                        vIndex.get(successor)));\n            }\n        }\n        if (vLowlink.get(vertex).equals(vIndex.get(vertex))) {\n            Set<V> result = new HashSet<V>();\n            V temp = null;\n            do {\n                temp = path.pop();\n                pathSet.remove(temp);\n                result.add(temp);\n            } while (!vertex.equals(temp));\n            if (result.size() == 1) {\n                V v = result.iterator().next();\n                if (graph.containsEdge(vertex, v)) {\n                    SCCs.add(result);\n                }\n            } else {\n                SCCs.add(result);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startIndex","parameterName":"startIndex"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int vertexIndex","parameterName":"vertexIndex"}],"methodName":"getSCCs","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.getSCCs","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 272,col 22)-(line 272,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 278,col 34)-(line 278,col 34)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.getSCCs(int, int)"},{"methodDeclaration":"private boolean findCyclesInSCG(int startIndex, int vertexIndex, DirectedGraph<V, E> scg)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    boolean foundCycle = false;\n    V vertex = toV(vertexIndex);\n    stack.push(vertex);\n    blocked.add(vertex);\n    for (E e : scg.outgoingEdgesOf(vertex)) {\n        V successor = scg.getEdgeTarget(e);\n        int successorIndex = toI(successor);\n        if (successorIndex == startIndex) {\n            List<V> cycle = new ArrayList<V>();\n            cycle.addAll(stack);\n            cycles.add(cycle);\n            foundCycle = true;\n        } else if (!blocked.contains(successor)) {\n            boolean gotCycle = findCyclesInSCG(startIndex, successorIndex, scg);\n            foundCycle = foundCycle || gotCycle;\n        }\n    }\n    if (foundCycle) {\n        unblock(vertex);\n    } else {\n        for (E ew : scg.outgoingEdgesOf(vertex)) {\n            V w = scg.getEdgeTarget(ew);\n            Set<V> bSet = getBSet(w);\n            bSet.add(vertex);\n        }\n    }\n    stack.pop();\n    return foundCycle;\n}","methodRange":"(line 289,col 5)-(line 326,col 5)","methodTokenRange":"private boolean findCyclesInSCG(\n        int startIndex,\n        int vertexIndex,\n        DirectedGraph<V, E> scg)\n    {\n        \/\/ Find cycles in a strongly connected graph\n        \/\/ per Johnson.\n        boolean foundCycle = false;\n        V vertex = toV(vertexIndex);\n        stack.push(vertex);\n        blocked.add(vertex);\n\n        for (E e : scg.outgoingEdgesOf(vertex)) {\n            V successor = scg.getEdgeTarget(e);\n            int successorIndex = toI(successor);\n            if (successorIndex == startIndex) {\n                List<V> cycle = new ArrayList<V>();\n                cycle.addAll(stack);\n                cycles.add(cycle);\n                foundCycle = true;\n            } else if (!blocked.contains(successor)) {\n                boolean gotCycle =\n                    findCyclesInSCG(startIndex, successorIndex, scg);\n                foundCycle = foundCycle || gotCycle;\n            }\n        }\n        if (foundCycle) {\n            unblock(vertex);\n        } else {\n            for (E ew : scg.outgoingEdgesOf(vertex)) {\n                V w = scg.getEdgeTarget(ew);\n                Set<V> bSet = getBSet(w);\n                bSet.add(vertex);\n            }\n        }\n        stack.pop();\n        return foundCycle;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startIndex","parameterName":"startIndex"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int vertexIndex","parameterName":"vertexIndex"},{"parameterType":"DirectedGraph<V, E>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> scg","parameterName":"scg"}],"methodName":"findCyclesInSCG","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findCyclesInSCG","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 296,col 30)-(line 296,col 34)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 308,col 30)-(line 308,col 33)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.findCyclesInSCG(int, int, org.jgrapht.DirectedGraph<V, E>)"},{"methodDeclaration":"private void unblock(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    blocked.remove(vertex);\n    Set<V> bSet = getBSet(vertex);\n    while (bSet.size() > 0) {\n        V w = bSet.iterator().next();\n        bSet.remove(w);\n        if (blocked.contains(w)) {\n            unblock(w);\n        }\n    }\n}","methodRange":"(line 328,col 5)-(line 339,col 5)","methodTokenRange":"private void unblock(V vertex)\n    {\n        blocked.remove(vertex);\n        Set<V> bSet = getBSet(vertex);\n        while (bSet.size() > 0) {\n            V w = bSet.iterator().next();\n            bSet.remove(w);\n            if (blocked.contains(w)) {\n                unblock(w);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"unblock","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.unblock","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 332,col 30)-(line 332,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.unblock(V)"},{"methodDeclaration":"private void initState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    cycles = new LinkedList<List<V>>();\n    iToV = (V[]) graph.vertexSet().toArray();\n    vToI = new HashMap<V, Integer>();\n    blocked = new HashSet<V>();\n    bSets = new HashMap<V, Set<V>>();\n    stack = new ArrayDeque<V>();\n    for (int i = 0; i < iToV.length; i++) {\n        vToI.put(iToV[i], i);\n    }\n}","methodRange":"(line 341,col 5)-(line 354,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    private void initState()\n    {\n        cycles = new LinkedList<List<V>>();\n        iToV = (V []) graph.vertexSet().toArray();\n        vToI = new HashMap<V, Integer>();\n        blocked = new HashSet<V>();\n        bSets = new HashMap<V, Set<V>>();\n        stack = new ArrayDeque<V>();\n\n        for (int i = 0; i < iToV.length; i++) {\n            vToI.put(iToV[i], i);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"initState","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.initState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 341,col 23)-(line 341,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 351,col 22)-(line 351,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.initState()"},{"methodDeclaration":"private void clearState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    cycles = null;\n    iToV = null;\n    vToI = null;\n    blocked = null;\n    bSets = null;\n    stack = null;\n}","methodRange":"(line 356,col 5)-(line 364,col 5)","methodTokenRange":"private void clearState()\n    {\n        cycles = null;\n        iToV = null;\n        vToI = null;\n        blocked = null;\n        bSets = null;\n        stack = null;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"clearState","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.clearState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 358,col 18)-(line 358,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 359,col 16)-(line 359,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 360,col 16)-(line 360,col 19)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 361,col 19)-(line 361,col 22)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 362,col 17)-(line 362,col 20)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 363,col 17)-(line 363,col 20)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.clearState()"},{"methodDeclaration":"private void initMinSCGState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    index = 0;\n    SCCs = new ArrayList<Set<V>>();\n    vIndex = new HashMap<V, Integer>();\n    vLowlink = new HashMap<V, Integer>();\n    path = new ArrayDeque<V>();\n    pathSet = new HashSet<V>();\n}","methodRange":"(line 366,col 5)-(line 374,col 5)","methodTokenRange":"private void initMinSCGState()\n    {\n        index = 0;\n        SCCs = new ArrayList<Set<V>>();\n        vIndex = new HashMap<V, Integer>();\n        vLowlink = new HashMap<V, Integer>();\n        path = new ArrayDeque<V>();\n        pathSet = new HashSet<V>();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"initMinSCGState","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.initMinSCGState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 368,col 17)-(line 368,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.initMinSCGState()"},{"methodDeclaration":"private void clearMinSCCState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    index = 0;\n    SCCs = null;\n    vIndex = null;\n    vLowlink = null;\n    path = null;\n    pathSet = null;\n}","methodRange":"(line 376,col 5)-(line 384,col 5)","methodTokenRange":"private void clearMinSCCState()\n    {\n        index = 0;\n        SCCs = null;\n        vIndex = null;\n        vLowlink = null;\n        path = null;\n        pathSet = null;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"clearMinSCCState","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.clearMinSCCState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 378,col 17)-(line 378,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 379,col 16)-(line 379,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 380,col 18)-(line 380,col 21)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 381,col 20)-(line 381,col 23)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 382,col 16)-(line 382,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 383,col 19)-(line 383,col 22)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.clearMinSCCState()"},{"methodDeclaration":"private Integer toI(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return vToI.get(vertex);\n}","methodRange":"(line 386,col 5)-(line 389,col 5)","methodTokenRange":"private Integer toI(V vertex)\n    {\n        return vToI.get(vertex);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"toI","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.toI","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.toI(V)"},{"methodDeclaration":"private V toV(Integer i)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return iToV[i];\n}","methodRange":"(line 391,col 5)-(line 394,col 5)","methodTokenRange":"private V toV(Integer i)\n    {\n        return iToV[i];\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"Integer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer i","parameterName":"i"}],"methodName":"toV","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.toV","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.toV(java.lang.Integer)"},{"methodDeclaration":"private Set<V> getBSet(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<V> result = bSets.get(v);\n    if (result == null) {\n        result = new HashSet<V>();\n        bSets.put(v, result);\n    }\n    return result;\n}","methodRange":"(line 396,col 5)-(line 406,col 5)","methodTokenRange":"private Set<V> getBSet(V v)\n    {\n        \/\/ B sets typically not all needed,\n        \/\/ so instantiate lazily.\n        Set<V> result = bSets.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            bSets.put(v, result);\n        }\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getBSet","methodQualifiedSignature":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.getBSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 401,col 23)-(line 401,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.JohnsonSimpleCycles.getBSet(V)"}],"classJavadoc":"\/**\n * Find all simple cycles of a directed graph using the Johnson's algorithm.\n *\n * <p>See:<br>\n * D.B.Johnson, Finding all the elementary circuits of a directed graph, SIAM J.\n * Comput., 4 (1975), pp. 77-84.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"JohnsonSimpleCycles","fields":[{"fieldRange":"(line 60,col 5)-(line 60,col 38)","fieldName":"graph","fieldJavadocComment":" The graph.","fieldTokenRange":"private DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 63,col 5)-(line 63,col 40)","fieldName":"cycles","fieldJavadocComment":" The main state of the algorithm.","fieldTokenRange":"private List<List<V>> cycles = null;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 63,col 36)-(line 63,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<List<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.List<V>>"},{"fieldRange":"(line 64,col 5)-(line 64,col 29)","fieldName":"iToV","fieldJavadocComment":"","fieldTokenRange":"private V [] iToV = null;","fieldTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(V, bounds=[])}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 64,col 25)-(line 64,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"V[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"V[]"},{"fieldRange":"(line 65,col 5)-(line 65,col 40)","fieldName":"vToI","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vToI = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 65,col 36)-(line 65,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 66,col 5)-(line 66,col 34)","fieldName":"blocked","fieldJavadocComment":"","fieldTokenRange":"private Set<V> blocked = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 66,col 30)-(line 66,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 67,col 5)-(line 67,col 40)","fieldName":"bSets","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Set<V>> bSets = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 67,col 36)-(line 67,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.Set<V>>"},{"fieldRange":"(line 68,col 5)-(line 68,col 39)","fieldName":"stack","fieldJavadocComment":"","fieldTokenRange":"private ArrayDeque<V> stack = null;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 68,col 35)-(line 68,col 38)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"ArrayDeque<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<V>"},{"fieldRange":"(line 71,col 5)-(line 71,col 37)","fieldName":"SCCs","fieldJavadocComment":" The state of the embedded Tarjan SCC algorithm.","fieldTokenRange":"private List<Set<V>> SCCs = null;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 71,col 33)-(line 71,col 36)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.Set<V>>"},{"fieldRange":"(line 72,col 5)-(line 72,col 26)","fieldName":"index","fieldJavadocComment":"","fieldTokenRange":"private int index = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 72,col 25)-(line 72,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 73,col 5)-(line 73,col 42)","fieldName":"vIndex","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vIndex = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 73,col 38)-(line 73,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 74,col 5)-(line 74,col 44)","fieldName":"vLowlink","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vLowlink = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 74,col 40)-(line 74,col 43)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 75,col 5)-(line 75,col 38)","fieldName":"path","fieldJavadocComment":"","fieldTokenRange":"private ArrayDeque<V> path = null;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 75,col 34)-(line 75,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"ArrayDeque<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<V>"},{"fieldRange":"(line 76,col 5)-(line 76,col 34)","fieldName":"pathSet","fieldJavadocComment":"","fieldTokenRange":"private Set<V> pathSet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 76,col 30)-(line 76,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"}]}],"sourceFileId":168,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.TiernanSimpleCycles","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.TiernanSimpleCycles.TiernanSimpleCycles()","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 65,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder with an unspecified graph.\n     ","constructorDeclaration":"public TiernanSimpleCycles()","constructorBody":"{\n}","constructorName":"TiernanSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.TiernanSimpleCycles.TiernanSimpleCycles","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public TiernanSimpleCycles()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder with an unspecified graph.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"- the DirectedGraph in which to find cycles.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph argument is <code>\nnull<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.TiernanSimpleCycles.TiernanSimpleCycles(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 75,col 5)-(line 81,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"public TiernanSimpleCycles(DirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","constructorName":"TiernanSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.TiernanSimpleCycles.TiernanSimpleCycles","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 77,col 22)-(line 77,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 78,col 48)-(line 78,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public TiernanSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 86,col 5)-(line 89,col 5)","methodTokenRange":"@Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.TiernanSimpleCycles.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.TiernanSimpleCycles.getGraph()"},{"javadocBlockTags":[],"methodDeclaration":"public void setGraph(DirectedGraph<V, E> graph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","methodRange":"(line 94,col 5)-(line 100,col 5)","methodTokenRange":"@Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.TiernanSimpleCycles.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 96,col 22)-(line 96,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 97,col 48)-(line 97,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TiernanSimpleCycles.setGraph(org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"public List<List<V>> findSimpleCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    Map<V, Integer> indices = new HashMap<V, Integer>();\n    List<V> path = new ArrayList<V>();\n    Set<V> pathSet = new HashSet<V>();\n    Map<V, Set<V>> blocked = new HashMap<V, Set<V>>();\n    List<List<V>> cycles = new LinkedList<List<V>>();\n    int index = 0;\n    for (V v : graph.vertexSet()) {\n        blocked.put(v, new HashSet<V>());\n        indices.put(v, index++);\n    }\n    Iterator<V> vertexIterator = graph.vertexSet().iterator();\n    if (!vertexIterator.hasNext()) {\n        return cycles;\n    }\n    V startOfPath = null;\n    V endOfPath = null;\n    V temp = null;\n    int endIndex = 0;\n    boolean extensionFound = false;\n    endOfPath = vertexIterator.next();\n    path.add(endOfPath);\n    pathSet.add(endOfPath);\n    while (true) {\n        do {\n            extensionFound = false;\n            for (E e : graph.outgoingEdgesOf(endOfPath)) {\n                V n = graph.getEdgeTarget(e);\n                int cmp = indices.get(n).compareTo(indices.get(path.get(0)));\n                if ((cmp > 0) && !pathSet.contains(n) && !blocked.get(endOfPath).contains(n)) {\n                    path.add(n);\n                    pathSet.add(n);\n                    endOfPath = n;\n                    extensionFound = true;\n                    break;\n                }\n            }\n        } while (extensionFound);\n        startOfPath = path.get(0);\n        if (graph.containsEdge(endOfPath, startOfPath)) {\n            List<V> cycle = new ArrayList<V>();\n            cycle.addAll(path);\n            cycles.add(cycle);\n        }\n        if (path.size() > 1) {\n            blocked.get(endOfPath).clear();\n            endIndex = path.size() - 1;\n            path.remove(endIndex);\n            pathSet.remove(endOfPath);\n            --endIndex;\n            temp = endOfPath;\n            endOfPath = path.get(endIndex);\n            blocked.get(endOfPath).add(temp);\n            continue;\n        }\n        if (vertexIterator.hasNext()) {\n            path.clear();\n            pathSet.clear();\n            endOfPath = vertexIterator.next();\n            path.add(endOfPath);\n            pathSet.add(endOfPath);\n            for (V vt : blocked.keySet()) {\n                blocked.get(vt).clear();\n            }\n            continue;\n        }\n        break;\n    }\n    return cycles;\n}","methodRange":"(line 105,col 5)-(line 201,col 5)","methodTokenRange":"@Override public List<List<V>> findSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        Map<V, Integer> indices = new HashMap<V, Integer>();\n        List<V> path = new ArrayList<V>();\n        Set<V> pathSet = new HashSet<V>();\n        Map<V, Set<V>> blocked = new HashMap<V, Set<V>>();\n        List<List<V>> cycles = new LinkedList<List<V>>();\n\n        int index = 0;\n        for (V v : graph.vertexSet()) {\n            blocked.put(v, new HashSet<V>());\n            indices.put(v, index++);\n        }\n\n        Iterator<V> vertexIterator = graph.vertexSet().iterator();\n        if (!vertexIterator.hasNext()) {\n            return cycles;\n        }\n\n        V startOfPath = null;\n        V endOfPath = null;\n        V temp = null;\n        int endIndex = 0;\n        boolean extensionFound = false;\n\n        endOfPath = vertexIterator.next();\n        path.add(endOfPath);\n        pathSet.add(endOfPath);\n\n        \/\/ A mostly straightforward implementation\n        \/\/ of the algorithm. Except that there is\n        \/\/ no real need for the state machine from\n        \/\/ the original paper.\n        while (true) {\n            \/\/ path extension\n            do {\n                extensionFound = false;\n                for (E e : graph.outgoingEdgesOf(endOfPath)) {\n                    V n = graph.getEdgeTarget(e);\n                    int cmp =\n                        indices.get(n).compareTo(indices.get(path.get(0)));\n                    if ((cmp > 0)\n                        && !pathSet.contains(n)\n                        && !blocked.get(endOfPath).contains(n))\n                    {\n                        path.add(n);\n                        pathSet.add(n);\n                        endOfPath = n;\n                        extensionFound = true;\n                        break;\n                    }\n                }\n            } while (extensionFound);\n\n            \/\/ circuit confirmation\n            startOfPath = path.get(0);\n            if (graph.containsEdge(endOfPath, startOfPath)) {\n                List<V> cycle = new ArrayList<V>();\n                cycle.addAll(path);\n                cycles.add(cycle);\n            }\n\n            \/\/ vertex closure\n            if (path.size() > 1) {\n                blocked.get(endOfPath).clear();\n                endIndex = path.size() - 1;\n                path.remove(endIndex);\n                pathSet.remove(endOfPath);\n                --endIndex;\n                temp = endOfPath;\n                endOfPath = path.get(endIndex);\n                blocked.get(endOfPath).add(temp);\n                continue;\n            }\n\n            \/\/ advance initial index\n            if (vertexIterator.hasNext()) {\n                path.clear();\n                pathSet.clear();\n                endOfPath = vertexIterator.next();\n                path.add(endOfPath);\n                pathSet.add(endOfPath);\n                for (V vt : blocked.keySet()) {\n                    blocked.get(vt).clear();\n                }\n                continue;\n            }\n\n            \/\/ terminate\n            break;\n        }\n\n        return cycles;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"findSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.TiernanSimpleCycles.findSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[{"literalExprRange":"(line 107,col 22)-(line 107,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 108,col 48)-(line 108,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 116,col 21)-(line 116,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 127,col 25)-(line 127,col 28)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 128,col 23)-(line 128,col 26)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 129,col 18)-(line 129,col 21)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 130,col 24)-(line 130,col 24)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 131,col 34)-(line 131,col 38)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 141,col 16)-(line 141,col 19)","literalExprId":9,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 144,col 34)-(line 144,col 38)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 148,col 71)-(line 148,col 71)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 149,col 32)-(line 149,col 32)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 156,col 42)-(line 156,col 45)","literalExprId":13,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 163,col 36)-(line 163,col 36)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 171,col 31)-(line 171,col 31)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 173,col 42)-(line 173,col 42)","literalExprId":16,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TiernanSimpleCycles.findSimpleCycles()"}],"classJavadoc":"\/**\n * Find all simple cycles of a directed graph using the Tiernan's algorithm.\n *\n * <p>See:<br>\n * J.C.Tiernan An Efficient Search Algorithm Find the Elementary Circuits of a\n * Graph., Communications of the ACM, vol.13, 12, (1970), pp. 722 - 726.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"TiernanSimpleCycles","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 38)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"}]}],"sourceFileId":169,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.UndirectedCycleBase","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"The graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The graph.'}]}', name=Optional.empty}"}],"methodDeclaration":" UndirectedGraph<V, E> getGraph()","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 60,col 5)-(line 60,col 37)","methodTokenRange":"UndirectedGraph<V, E> getGraph();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @return The graph.\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.UndirectedCycleBase.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph on which the cycle base search algorithm is executed by\nthis object.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.UndirectedCycleBase.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the argument is <code>null<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the argument is <code>null<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":" void setGraph(UndirectedGraph<V, E> graph)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 70,col 5)-(line 70,col 47)","methodTokenRange":"void setGraph(UndirectedGraph<V, E> graph);","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Sets the graph on which the cycle base search algorithm is executed by\n     * this object.\n     *\n     * @param graph the graph.\n     *\n     * @throws IllegalArgumentException if the argument is <code>null<\/code>.\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.UndirectedCycleBase.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the graph on which the cycle base search algorithm is executed by\nthis object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the argument is <code>null<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.UndirectedCycleBase.setGraph(org.jgrapht.UndirectedGraph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"A list of cycles constituting a cycle base for the graph.\nPossibly empty but never <code>null<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A list of cycles constituting a cycle base for the graph.\nPossibly empty but never <code>null<\/code>.'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the current graph is null.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the current graph is null.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":" List<List<V>> findCycleBase()","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 82,col 5)-(line 82,col 34)","methodTokenRange":"List<List<V>> findCycleBase();","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Finds a cycle base of the graph.<br>\n     * Note that the full algorithm is executed on every call since the graph\n     * may have changed between calls.\n     *\n     * @return A list of cycles constituting a cycle base for the graph.\n     * Possibly empty but never <code>null<\/code>.\n     *\n     * @throws IllegalArgumentException if the current graph is null.\n     ","methodParameters":[],"methodName":"findCycleBase","methodQualifiedSignature":"org.jgrapht.alg.cycle.UndirectedCycleBase.findCycleBase","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a cycle base of the graph.<br>\nNote that the full algorithm is executed on every call since the graph\nmay have changed between calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A list of cycles constituting a cycle base for the graph.\nPossibly empty but never <code>null<\/code>.'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the current graph is null.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.UndirectedCycleBase.findCycleBase()"}],"classJavadoc":"\/**\n * A common interface for classes implementing algorithms for finding a cycle\n * base of an undirected graph.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"UndirectedCycleBase","fields":[]}],"sourceFileId":170,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.PatonCycleBase","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.PatonCycleBase.PatonCycleBase()","variableDeclarationExprs":[],"constructorRange":"(line 63,col 5)-(line 65,col 5)","constructorJavadocComment":"\n     * Create a cycle base finder with an unspecified graph.\n     ","constructorDeclaration":"public PatonCycleBase()","constructorBody":"{\n}","constructorName":"PatonCycleBase","constructorQualifiedName":"org.jgrapht.alg.cycle.PatonCycleBase.PatonCycleBase","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public PatonCycleBase()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a cycle base finder with an unspecified graph.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"- the DirectedGraph in which to find cycles.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph argument is <code>\nnull<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.PatonCycleBase.PatonCycleBase(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 75,col 5)-(line 81,col 5)","constructorJavadocComment":"\n     * Create a cycle base finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"public PatonCycleBase(UndirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","constructorName":"PatonCycleBase","constructorQualifiedName":"org.jgrapht.alg.cycle.PatonCycleBase.PatonCycleBase","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 77,col 22)-(line 77,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 78,col 48)-(line 78,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public PatonCycleBase(UndirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a cycle base finder for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public UndirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 86,col 5)-(line 89,col 5)","methodTokenRange":"@Override public UndirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.PatonCycleBase.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.PatonCycleBase.getGraph()"},{"javadocBlockTags":[],"methodDeclaration":"public void setGraph(UndirectedGraph<V, E> graph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","methodRange":"(line 94,col 5)-(line 100,col 5)","methodTokenRange":"@Override public void setGraph(UndirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.PatonCycleBase.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 96,col 22)-(line 96,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 97,col 48)-(line 97,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.PatonCycleBase.setGraph(org.jgrapht.UndirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"public List<List<V>> findCycleBase()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    Map<V, Set<V>> used = new HashMap<V, Set<V>>();\n    Map<V, V> parent = new HashMap<V, V>();\n    ArrayDeque<V> stack = new ArrayDeque<V>();\n    List<List<V>> cycles = new ArrayList<List<V>>();\n    for (V root : graph.vertexSet()) {\n        if (parent.containsKey(root)) {\n            continue;\n        }\n        used.clear();\n        parent.put(root, root);\n        used.put(root, new HashSet<V>());\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            V current = stack.pop();\n            Set<V> currentUsed = used.get(current);\n            for (E e : graph.edgesOf(current)) {\n                V neighbor = graph.getEdgeTarget(e);\n                if (neighbor.equals(current)) {\n                    neighbor = graph.getEdgeSource(e);\n                }\n                if (!used.containsKey(neighbor)) {\n                    parent.put(neighbor, current);\n                    Set<V> neighbourUsed = new HashSet<V>();\n                    neighbourUsed.add(current);\n                    used.put(neighbor, neighbourUsed);\n                    stack.push(neighbor);\n                } else if (neighbor.equals(current)) {\n                    List<V> cycle = new ArrayList<V>();\n                    cycle.add(current);\n                    cycles.add(cycle);\n                } else if (!currentUsed.contains(neighbor)) {\n                    Set<V> neighbourUsed = used.get(neighbor);\n                    List<V> cycle = new ArrayList<V>();\n                    cycle.add(neighbor);\n                    cycle.add(current);\n                    V p = parent.get(current);\n                    while (!neighbourUsed.contains(p)) {\n                        cycle.add(p);\n                        p = parent.get(p);\n                    }\n                    cycle.add(p);\n                    cycles.add(cycle);\n                    neighbourUsed.add(current);\n                }\n            }\n        }\n    }\n    return cycles;\n}","methodRange":"(line 105,col 5)-(line 174,col 5)","methodTokenRange":"@Override public List<List<V>> findCycleBase()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        Map<V, Set<V>> used = new HashMap<V, Set<V>>();\n        Map<V, V> parent = new HashMap<V, V>();\n        ArrayDeque<V> stack = new ArrayDeque<V>();\n        List<List<V>> cycles = new ArrayList<List<V>>();\n\n        for (V root : graph.vertexSet()) {\n            \/\/ Loop over the connected\n            \/\/ components of the graph.\n            if (parent.containsKey(root)) {\n                continue;\n            }\n\n            \/\/ Free some memory in case of\n            \/\/ multiple connected components.\n            used.clear();\n\n            \/\/ Prepare to walk the spanning tree.\n            parent.put(root, root);\n            used.put(root, new HashSet<V>());\n            stack.push(root);\n\n            \/\/ Do the walk. It is a BFS with\n            \/\/ a LIFO instead of the usual\n            \/\/ FIFO. Thus it is easier to\n            \/\/ find the cycles in the tree.\n            while (!stack.isEmpty()) {\n                V current = stack.pop();\n                Set<V> currentUsed = used.get(current);\n                for (E e : graph.edgesOf(current)) {\n                    V neighbor = graph.getEdgeTarget(e);\n                    if (neighbor.equals(current)) {\n                        neighbor = graph.getEdgeSource(e);\n                    }\n                    if (!used.containsKey(neighbor)) {\n                        \/\/ found a new node\n                        parent.put(neighbor, current);\n                        Set<V> neighbourUsed = new HashSet<V>();\n                        neighbourUsed.add(current);\n                        used.put(neighbor, neighbourUsed);\n                        stack.push(neighbor);\n                    } else if (neighbor.equals(current)) {\n                        \/\/ found a self loop\n                        List<V> cycle = new ArrayList<V>();\n                        cycle.add(current);\n                        cycles.add(cycle);\n                    } else if (!currentUsed.contains(neighbor)) {\n                        \/\/ found a cycle\n                        Set<V> neighbourUsed = used.get(neighbor);\n                        List<V> cycle = new ArrayList<V>();\n                        cycle.add(neighbor);\n                        cycle.add(current);\n                        V p = parent.get(current);\n                        while (!neighbourUsed.contains(p)) {\n                            cycle.add(p);\n                            p = parent.get(p);\n                        }\n                        cycle.add(p);\n                        cycles.add(cycle);\n                        neighbourUsed.add(current);\n                    }\n                }\n            }\n        }\n        return cycles;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"findCycleBase","methodQualifiedSignature":"org.jgrapht.alg.cycle.PatonCycleBase.findCycleBase","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[{"literalExprRange":"(line 107,col 22)-(line 107,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 108,col 48)-(line 108,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.PatonCycleBase.findCycleBase()"}],"classJavadoc":"\/**\n * Find a cycle base of an undirected graph using the Paton's algorithm.\n *\n * <p>See:<br>\n * K. Paton, An algorithm for finding a fundamental set of cycles for an\n * undirected linear graph, Comm. ACM 12 (1969), pp. 514-518.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"PatonCycleBase","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 40)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private UndirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"}]}],"sourceFileId":171,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.TarjanSimpleCycles","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.TarjanSimpleCycles()","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 72,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder with an unspecified graph.\n     ","constructorDeclaration":"public TarjanSimpleCycles()","constructorBody":"{\n}","constructorName":"TarjanSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.TarjanSimpleCycles","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public TarjanSimpleCycles()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder with an unspecified graph.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"- the DirectedGraph in which to find cycles.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph argument is <code>\nnull<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.TarjanSimpleCycles(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 82,col 5)-(line 88,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"public TarjanSimpleCycles(DirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","constructorName":"TarjanSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.TarjanSimpleCycles","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 84,col 22)-(line 84,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 85,col 48)-(line 85,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public TarjanSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 93,col 5)-(line 96,col 5)","methodTokenRange":"@Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.getGraph()"},{"javadocBlockTags":[],"methodDeclaration":"public void setGraph(DirectedGraph<V, E> graph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","methodRange":"(line 101,col 5)-(line 107,col 5)","methodTokenRange":"@Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 103,col 22)-(line 103,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 104,col 48)-(line 104,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.setGraph(org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"public List<List<V>> findSimpleCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    initState();\n    for (V start : graph.vertexSet()) {\n        backtrack(start, start);\n        while (!markedStack.isEmpty()) {\n            marked.remove(markedStack.pop());\n        }\n    }\n    List<List<V>> result = cycles;\n    clearState();\n    return result;\n}","methodRange":"(line 112,col 5)-(line 129,col 5)","methodTokenRange":"@Override public List<List<V>> findSimpleCycles()\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        initState();\n\n        for (V start : graph.vertexSet()) {\n            backtrack(start, start);\n            while (!markedStack.isEmpty()) {\n                marked.remove(markedStack.pop());\n            }\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"findSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.findSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[{"literalExprRange":"(line 114,col 22)-(line 114,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 115,col 48)-(line 115,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.findSimpleCycles()"},{"methodDeclaration":"private boolean backtrack(V start, V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    boolean foundCycle = false;\n    pointStack.push(vertex);\n    marked.add(vertex);\n    markedStack.push(vertex);\n    for (E currentEdge : graph.outgoingEdgesOf(vertex)) {\n        V currentVertex = graph.getEdgeTarget(currentEdge);\n        if (getRemoved(vertex).contains(currentVertex)) {\n            continue;\n        }\n        int comparison = toI(currentVertex).compareTo(toI(start));\n        if (comparison < 0) {\n            getRemoved(vertex).add(currentVertex);\n        } else if (comparison == 0) {\n            foundCycle = true;\n            List<V> cycle = new ArrayList<V>();\n            Iterator<V> it = pointStack.descendingIterator();\n            V v = null;\n            while (it.hasNext()) {\n                v = it.next();\n                if (start.equals(v)) {\n                    break;\n                }\n            }\n            cycle.add(start);\n            while (it.hasNext()) {\n                cycle.add(it.next());\n            }\n            cycles.add(cycle);\n        } else if (!marked.contains(currentVertex)) {\n            boolean gotCycle = backtrack(start, currentVertex);\n            foundCycle = foundCycle || gotCycle;\n        }\n    }\n    if (foundCycle) {\n        while (!markedStack.peek().equals(vertex)) {\n            marked.remove(markedStack.pop());\n        }\n        marked.remove(markedStack.pop());\n    }\n    pointStack.pop();\n    return foundCycle;\n}","methodRange":"(line 131,col 5)-(line 177,col 5)","methodTokenRange":"private boolean backtrack(V start, V vertex)\n    {\n        boolean foundCycle = false;\n        pointStack.push(vertex);\n        marked.add(vertex);\n        markedStack.push(vertex);\n\n        for (E currentEdge : graph.outgoingEdgesOf(vertex)) {\n            V currentVertex = graph.getEdgeTarget(currentEdge);\n            if (getRemoved(vertex).contains(currentVertex)) {\n                continue;\n            }\n            int comparison = toI(currentVertex).compareTo(toI(start));\n            if (comparison < 0) {\n                getRemoved(vertex).add(currentVertex);\n            } else if (comparison == 0) {\n                foundCycle = true;\n                List<V> cycle = new ArrayList<V>();\n                Iterator<V> it = pointStack.descendingIterator();\n                V v = null;\n                while (it.hasNext()) {\n                    v = it.next();\n                    if (start.equals(v)) {\n                        break;\n                    }\n                }\n                cycle.add(start);\n                while (it.hasNext()) {\n                    cycle.add(it.next());\n                }\n                cycles.add(cycle);\n            } else if (!marked.contains(currentVertex)) {\n                boolean gotCycle = backtrack(start, currentVertex);\n                foundCycle = foundCycle || gotCycle;\n            }\n        }\n\n        if (foundCycle) {\n            while (!markedStack.peek().equals(vertex)) {\n                marked.remove(markedStack.pop());\n            }\n            marked.remove(markedStack.pop());\n        }\n\n        pointStack.pop();\n        return foundCycle;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V start","parameterName":"start"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"backtrack","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.backtrack","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 133,col 30)-(line 133,col 34)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 144,col 30)-(line 144,col 30)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 38)-(line 146,col 38)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 30)-(line 147,col 33)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 150,col 23)-(line 150,col 26)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.backtrack(V, V)"},{"methodDeclaration":"private void initState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    cycles = new ArrayList<List<V>>();\n    marked = new HashSet<V>();\n    markedStack = new ArrayDeque<V>();\n    pointStack = new ArrayDeque<V>();\n    vToI = new HashMap<V, Integer>();\n    removed = new HashMap<V, Set<V>>();\n    int index = 0;\n    for (V v : graph.vertexSet()) {\n        vToI.put(v, index++);\n    }\n}","methodRange":"(line 179,col 5)-(line 191,col 5)","methodTokenRange":"private void initState()\n    {\n        cycles = new ArrayList<List<V>>();\n        marked = new HashSet<V>();\n        markedStack = new ArrayDeque<V>();\n        pointStack = new ArrayDeque<V>();\n        vToI = new HashMap<V, Integer>();\n        removed = new HashMap<V, Set<V>>();\n        int index = 0;\n        for (V v : graph.vertexSet()) {\n            vToI.put(v, index++);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"initState","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.initState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 187,col 21)-(line 187,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.initState()"},{"methodDeclaration":"private void clearState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    cycles = null;\n    marked = null;\n    markedStack = null;\n    pointStack = null;\n    vToI = null;\n}","methodRange":"(line 193,col 5)-(line 200,col 5)","methodTokenRange":"private void clearState()\n    {\n        cycles = null;\n        marked = null;\n        markedStack = null;\n        pointStack = null;\n        vToI = null;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"clearState","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.clearState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 195,col 18)-(line 195,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 196,col 18)-(line 196,col 21)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 197,col 23)-(line 197,col 26)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 198,col 22)-(line 198,col 25)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 199,col 16)-(line 199,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.clearState()"},{"methodDeclaration":"private Integer toI(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return vToI.get(v);\n}","methodRange":"(line 202,col 5)-(line 205,col 5)","methodTokenRange":"private Integer toI(V v)\n    {\n        return vToI.get(v);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"toI","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.toI","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.toI(V)"},{"methodDeclaration":"private Set<V> getRemoved(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<V> result = removed.get(v);\n    if (result == null) {\n        result = new HashSet<V>();\n        removed.put(v, result);\n    }\n    return result;\n}","methodRange":"(line 207,col 5)-(line 217,col 5)","methodTokenRange":"private Set<V> getRemoved(V v)\n    {\n        \/\/ Removed sets typically not all\n        \/\/ needed, so instantiate lazily.\n        Set<V> result = removed.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            removed.put(v, result);\n        }\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getRemoved","methodQualifiedSignature":"org.jgrapht.alg.cycle.TarjanSimpleCycles.getRemoved","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 212,col 23)-(line 212,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.TarjanSimpleCycles.getRemoved(V)"}],"classJavadoc":"\/**\n * Find all simple cycles of a directed graph using the Tarjan's algorithm.\n *\n * <p>See:<br>\n * R. Tarjan, Enumeration of the elementary circuits of a directed graph, SIAM\n * J. Comput., 2 (1973), pp. 211-216.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"TarjanSimpleCycles","fields":[{"fieldRange":"(line 58,col 5)-(line 58,col 38)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 60,col 5)-(line 60,col 33)","fieldName":"cycles","fieldJavadocComment":"","fieldTokenRange":"private List<List<V>> cycles;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<List<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.List<V>>"},{"fieldRange":"(line 61,col 5)-(line 61,col 26)","fieldName":"marked","fieldJavadocComment":"","fieldTokenRange":"private Set<V> marked;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 62,col 5)-(line 62,col 38)","fieldName":"markedStack","fieldJavadocComment":"","fieldTokenRange":"private ArrayDeque<V> markedStack;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ArrayDeque<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<V>"},{"fieldRange":"(line 63,col 5)-(line 63,col 37)","fieldName":"pointStack","fieldJavadocComment":"","fieldTokenRange":"private ArrayDeque<V> pointStack;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ArrayDeque<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<V>"},{"fieldRange":"(line 64,col 5)-(line 64,col 33)","fieldName":"vToI","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vToI;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 65,col 5)-(line 65,col 35)","fieldName":"removed","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Set<V>> removed;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.Set<V>>"}]}],"sourceFileId":172,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.SzwarcfiterLauerSimpleCycles()","variableDeclarationExprs":[],"constructorRange":"(line 79,col 5)-(line 81,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder with an unspecified graph.\n     ","constructorDeclaration":"public SzwarcfiterLauerSimpleCycles()","constructorBody":"{\n}","constructorName":"SzwarcfiterLauerSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.SzwarcfiterLauerSimpleCycles","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public SzwarcfiterLauerSimpleCycles()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder with an unspecified graph.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"- the DirectedGraph in which to find cycles.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph argument is <code>\nnull<\/code>.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.SzwarcfiterLauerSimpleCycles(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 91,col 5)-(line 97,col 5)","constructorJavadocComment":"\n     * Create a simple cycle finder for the specified graph.\n     *\n     * @param graph - the DirectedGraph in which to find cycles.\n     *\n     * @throws IllegalArgumentException if the graph argument is <code>\n     * null<\/code>.\n     ","constructorDeclaration":"public SzwarcfiterLauerSimpleCycles(DirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","constructorName":"SzwarcfiterLauerSimpleCycles","constructorQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.SzwarcfiterLauerSimpleCycles","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 93,col 22)-(line 93,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 94,col 48)-(line 94,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public SzwarcfiterLauerSimpleCycles(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a simple cycle finder for the specified graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- the DirectedGraph in which to find cycles.'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph argument is <code>\nnull<\/code>.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 102,col 5)-(line 105,col 5)","methodTokenRange":"@Override public DirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.getGraph()"},{"javadocBlockTags":[],"methodDeclaration":"public void setGraph(DirectedGraph<V, E> graph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph argument.\");\n    }\n    this.graph = graph;\n}","methodRange":"(line 110,col 5)-(line 116,col 5)","methodTokenRange":"@Override public void setGraph(DirectedGraph<V, E> graph)\n    {\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph argument.\");\n        }\n        this.graph = graph;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"setGraph","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.setGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 112,col 22)-(line 112,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 113,col 48)-(line 113,col 69)","literalExprId":2,"literalExpr":"\"Null graph argument.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.setGraph(org.jgrapht.DirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"public List<List<V>> findSimpleCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (graph == null) {\n        throw new IllegalArgumentException(\"Null graph.\");\n    }\n    initState();\n    KosarajuStrongConnectivityInspector<V, E> inspector = new KosarajuStrongConnectivityInspector<V, E>(graph);\n    List<Set<V>> sccs = inspector.stronglyConnectedSets();\n    for (Set<V> scc : sccs) {\n        int maxInDegree = -1;\n        V startVertex = null;\n        for (V v : scc) {\n            int inDegree = graph.inDegreeOf(v);\n            if (inDegree > maxInDegree) {\n                maxInDegree = inDegree;\n                startVertex = v;\n            }\n        }\n        startVertices.add(startVertex);\n    }\n    for (V vertex : startVertices) {\n        cycle(toI(vertex), 0);\n    }\n    List<List<V>> result = cycles;\n    clearState();\n    return result;\n}","methodRange":"(line 121,col 5)-(line 152,col 5)","methodTokenRange":"@Override public List<List<V>> findSimpleCycles()\n    {\n        \/\/ Just a straightforward implementation of\n        \/\/ the algorithm.\n        if (graph == null) {\n            throw new IllegalArgumentException(\"Null graph.\");\n        }\n        initState();\n        KosarajuStrongConnectivityInspector<V, E> inspector =\n            new KosarajuStrongConnectivityInspector<V, E>(graph);\n        List<Set<V>> sccs = inspector.stronglyConnectedSets();\n        for (Set<V> scc : sccs) {\n            int maxInDegree = -1;\n            V startVertex = null;\n            for (V v : scc) {\n                int inDegree = graph.inDegreeOf(v);\n                if (inDegree > maxInDegree) {\n                    maxInDegree = inDegree;\n                    startVertex = v;\n                }\n            }\n            startVertices.add(startVertex);\n        }\n\n        for (V vertex : startVertices) {\n            cycle(toI(vertex), 0);\n        }\n\n        List<List<V>> result = cycles;\n        clearState();\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * {@inheritDoc}\n     ","methodParameters":[],"methodName":"findSimpleCycles","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.findSimpleCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocInlineTag{tagName='inheritDoc', type=INHERIT_DOC, content=''}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.List<java.util.List<V>>","methodType":"List<List<V>>","literalExprs":[{"literalExprRange":"(line 125,col 22)-(line 125,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 126,col 48)-(line 126,col 60)","literalExprId":2,"literalExpr":"\"Null graph.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 133,col 32)-(line 133,col 32)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 134,col 29)-(line 134,col 32)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 146,col 32)-(line 146,col 32)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.findSimpleCycles()"},{"methodDeclaration":"private boolean cycle(int v, int q)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    boolean foundCycle = false;\n    V vV = toV(v);\n    marked.add(vV);\n    stack.push(vV);\n    int t = stack.size();\n    position[v] = t;\n    if (!reach[v]) {\n        q = t;\n    }\n    Set<V> avRemoved = getRemoved(vV);\n    Set<E> edgeSet = graph.outgoingEdgesOf(vV);\n    Iterator<E> avIt = edgeSet.iterator();\n    while (avIt.hasNext()) {\n        E e = avIt.next();\n        V wV = graph.getEdgeTarget(e);\n        if (avRemoved.contains(wV)) {\n            continue;\n        }\n        int w = toI(wV);\n        if (!marked.contains(wV)) {\n            boolean gotCycle = cycle(w, q);\n            if (gotCycle) {\n                foundCycle = gotCycle;\n            } else {\n                noCycle(v, w);\n            }\n        } else if (position[w] <= q) {\n            foundCycle = true;\n            List<V> cycle = new ArrayList<V>();\n            Iterator<V> it = stack.descendingIterator();\n            V current = null;\n            while (it.hasNext()) {\n                current = it.next();\n                if (wV.equals(current)) {\n                    break;\n                }\n            }\n            cycle.add(wV);\n            while (it.hasNext()) {\n                current = it.next();\n                cycle.add(current);\n                if (current.equals(vV)) {\n                    break;\n                }\n            }\n            cycles.add(cycle);\n        } else {\n            noCycle(v, w);\n        }\n    }\n    stack.pop();\n    if (foundCycle) {\n        unmark(v);\n    }\n    reach[v] = true;\n    position[v] = graph.vertexSet().size();\n    return foundCycle;\n}","methodRange":"(line 154,col 5)-(line 213,col 5)","methodTokenRange":"private boolean cycle(int v, int q)\n    {\n        boolean foundCycle = false;\n        V vV = toV(v);\n        marked.add(vV);\n        stack.push(vV);\n        int t = stack.size();\n        position[v] = t;\n        if (!reach[v]) {\n            q = t;\n        }\n        Set<V> avRemoved = getRemoved(vV);\n        Set<E> edgeSet = graph.outgoingEdgesOf(vV);\n        Iterator<E> avIt = edgeSet.iterator();\n        while (avIt.hasNext()) {\n            E e = avIt.next();\n            V wV = graph.getEdgeTarget(e);\n            if (avRemoved.contains(wV)) {\n                continue;\n            }\n            int w = toI(wV);\n            if (!marked.contains(wV)) {\n                boolean gotCycle = cycle(w, q);\n                if (gotCycle) {\n                    foundCycle = gotCycle;\n                } else {\n                    noCycle(v, w);\n                }\n            } else if (position[w] <= q) {\n                foundCycle = true;\n                List<V> cycle = new ArrayList<V>();\n                Iterator<V> it = stack.descendingIterator();\n                V current = null;\n                while (it.hasNext()) {\n                    current = it.next();\n                    if (wV.equals(current)) {\n                        break;\n                    }\n                }\n                cycle.add(wV);\n                while (it.hasNext()) {\n                    current = it.next();\n                    cycle.add(current);\n                    if (current.equals(vV)) {\n                        break;\n                    }\n                }\n                cycles.add(cycle);\n            } else {\n                noCycle(v, w);\n            }\n        }\n        stack.pop();\n        if (foundCycle) {\n            unmark(v);\n        }\n        reach[v] = true;\n        position[v] = graph.vertexSet().size();\n        return foundCycle;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int v","parameterName":"v"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int q","parameterName":"q"}],"methodName":"cycle","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.cycle","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 156,col 30)-(line 156,col 34)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 183,col 30)-(line 183,col 33)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 186,col 29)-(line 186,col 32)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 210,col 20)-(line 210,col 23)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.cycle(int, int)"},{"methodDeclaration":"private void noCycle(int x, int y)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V xV = toV(x);\n    V yV = toV(y);\n    Set<V> by = getBSet(yV);\n    Set<V> axRemoved = getRemoved(xV);\n    by.add(xV);\n    axRemoved.add(yV);\n}","methodRange":"(line 215,col 5)-(line 225,col 5)","methodTokenRange":"private void noCycle(int x, int y)\n    {\n        V xV = toV(x);\n        V yV = toV(y);\n\n        Set<V> by = getBSet(yV);\n        Set<V> axRemoved = getRemoved(xV);\n\n        by.add(xV);\n        axRemoved.add(yV);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"noCycle","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.noCycle","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.noCycle(int, int)"},{"methodDeclaration":"private void unmark(int x)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V xV = toV(x);\n    marked.remove(xV);\n    Set<V> bx = getBSet(xV);\n    for (V yV : bx) {\n        Set<V> ayRemoved = getRemoved(yV);\n        ayRemoved.remove(xV);\n        if (marked.contains(yV)) {\n            unmark(toI(yV));\n        }\n    }\n    bx.clear();\n}","methodRange":"(line 227,col 5)-(line 240,col 5)","methodTokenRange":"private void unmark(int x)\n    {\n        V xV = toV(x);\n        marked.remove(xV);\n        Set<V> bx = getBSet(xV);\n        for (V yV : bx) {\n            Set<V> ayRemoved = getRemoved(yV);\n            ayRemoved.remove(xV);\n            if (marked.contains(yV)) {\n                unmark(toI(yV));\n            }\n        }\n        bx.clear();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"}],"methodName":"unmark","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.unmark","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.unmark(int)"},{"methodDeclaration":"private void initState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    cycles = new ArrayList<List<V>>();\n    iToV = (V[]) graph.vertexSet().toArray();\n    vToI = new HashMap<V, Integer>();\n    bSets = new HashMap<V, Set<V>>();\n    stack = new ArrayDeque<V>();\n    marked = new HashSet<V>();\n    removed = new HashMap<V, Set<V>>();\n    int size = graph.vertexSet().size();\n    position = new int[size];\n    reach = new boolean[size];\n    startVertices = new ArrayList<V>();\n    for (int i = 0; i < iToV.length; i++) {\n        vToI.put(iToV[i], i);\n    }\n}","methodRange":"(line 242,col 5)-(line 260,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    private void initState()\n    {\n        cycles = new ArrayList<List<V>>();\n        iToV = (V []) graph.vertexSet().toArray();\n        vToI = new HashMap<V, Integer>();\n        bSets = new HashMap<V, Set<V>>();\n        stack = new ArrayDeque<V>();\n        marked = new HashSet<V>();\n        removed = new HashMap<V, Set<V>>();\n        int size = graph.vertexSet().size();\n        position = new int[size];\n        reach = new boolean[size];\n        startVertices = new ArrayList<V>();\n\n        for (int i = 0; i < iToV.length; i++) {\n            vToI.put(iToV[i], i);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"initState","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.initState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 242,col 23)-(line 242,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 257,col 22)-(line 257,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.initState()"},{"methodDeclaration":"private void clearState()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    cycles = null;\n    iToV = null;\n    vToI = null;\n    bSets = null;\n    stack = null;\n    marked = null;\n    removed = null;\n    position = null;\n    reach = null;\n    startVertices = null;\n}","methodRange":"(line 262,col 5)-(line 274,col 5)","methodTokenRange":"private void clearState()\n    {\n        cycles = null;\n        iToV = null;\n        vToI = null;\n        bSets = null;\n        stack = null;\n        marked = null;\n        removed = null;\n        position = null;\n        reach = null;\n        startVertices = null;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"clearState","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.clearState","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 264,col 18)-(line 264,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 265,col 16)-(line 265,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 266,col 16)-(line 266,col 19)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 267,col 17)-(line 267,col 20)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 268,col 17)-(line 268,col 20)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 269,col 18)-(line 269,col 21)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 270,col 19)-(line 270,col 22)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 271,col 20)-(line 271,col 23)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 272,col 17)-(line 272,col 20)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 273,col 25)-(line 273,col 28)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.clearState()"},{"methodDeclaration":"private Integer toI(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return vToI.get(v);\n}","methodRange":"(line 276,col 5)-(line 279,col 5)","methodTokenRange":"private Integer toI(V v)\n    {\n        return vToI.get(v);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"toI","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.toI","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.toI(V)"},{"methodDeclaration":"private V toV(int i)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return iToV[i];\n}","methodRange":"(line 281,col 5)-(line 284,col 5)","methodTokenRange":"private V toV(int i)\n    {\n        return iToV[i];\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int i","parameterName":"i"}],"methodName":"toV","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.toV","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.toV(int)"},{"methodDeclaration":"private Set<V> getBSet(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<V> result = bSets.get(v);\n    if (result == null) {\n        result = new HashSet<V>();\n        bSets.put(v, result);\n    }\n    return result;\n}","methodRange":"(line 286,col 5)-(line 296,col 5)","methodTokenRange":"private Set<V> getBSet(V v)\n    {\n        \/\/ B sets are typically not all\n        \/\/ needed, so instantiate lazily.\n        Set<V> result = bSets.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            bSets.put(v, result);\n        }\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getBSet","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.getBSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 291,col 23)-(line 291,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.getBSet(V)"},{"methodDeclaration":"private Set<V> getRemoved(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<V> result = removed.get(v);\n    if (result == null) {\n        result = new HashSet<V>();\n        removed.put(v, result);\n    }\n    return result;\n}","methodRange":"(line 298,col 5)-(line 308,col 5)","methodTokenRange":"private Set<V> getRemoved(V v)\n    {\n        \/\/ Removed sets typically not all\n        \/\/ needed, so instantiate lazily.\n        Set<V> result = removed.get(v);\n        if (result == null) {\n            result = new HashSet<V>();\n            removed.put(v, result);\n        }\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getRemoved","methodQualifiedSignature":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.getRemoved","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 303,col 23)-(line 303,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles.getRemoved(V)"}],"classJavadoc":"\/**\n * Find all simple cycles of a directed graph using the Schwarcfiter and Lauer's\n * algorithm.\n *\n * <p>See:<br>\n * J.L.Szwarcfiter and P.E.Lauer, Finding the elementary cycles of a directed\n * graph in O(n + m) per cycle, Technical Report Series, #60, May 1974, Univ. of\n * Newcastle upon Tyne, Newcastle upon Tyne, England.\n *\n * @param <V> the vertex type.\n * @param <E> the edge type.\n *\n * @author Nikolay Ognyanov\n *\/\n","className":"SzwarcfiterLauerSimpleCycles","fields":[{"fieldRange":"(line 62,col 5)-(line 62,col 38)","fieldName":"graph","fieldJavadocComment":" The graph.","fieldTokenRange":"private DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 65,col 5)-(line 65,col 40)","fieldName":"cycles","fieldJavadocComment":" The state of the algorithm.","fieldTokenRange":"private List<List<V>> cycles = null;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 65,col 36)-(line 65,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<List<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.List<V>>"},{"fieldRange":"(line 66,col 5)-(line 66,col 29)","fieldName":"iToV","fieldJavadocComment":"","fieldTokenRange":"private V [] iToV = null;","fieldTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(V, bounds=[])}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 66,col 25)-(line 66,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"V[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"V[]"},{"fieldRange":"(line 67,col 5)-(line 67,col 40)","fieldName":"vToI","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Integer> vToI = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 67,col 36)-(line 67,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>"},{"fieldRange":"(line 68,col 5)-(line 68,col 40)","fieldName":"bSets","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Set<V>> bSets = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 68,col 36)-(line 68,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.Set<V>>"},{"fieldRange":"(line 69,col 5)-(line 69,col 39)","fieldName":"stack","fieldJavadocComment":"","fieldTokenRange":"private ArrayDeque<V> stack = null;","fieldTypeResolved":"ReferenceType{java.util.ArrayDeque, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayDeque.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 69,col 35)-(line 69,col 38)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"ArrayDeque<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayDeque<V>"},{"fieldRange":"(line 70,col 5)-(line 70,col 33)","fieldName":"marked","fieldJavadocComment":"","fieldTokenRange":"private Set<V> marked = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 70,col 29)-(line 70,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 71,col 5)-(line 71,col 42)","fieldName":"removed","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Set<V>> removed = null;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 71,col 38)-(line 71,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Map<V, Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.Set<V>>"},{"fieldRange":"(line 72,col 5)-(line 72,col 35)","fieldName":"position","fieldJavadocComment":"","fieldTokenRange":"private int [] position = null;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 72,col 31)-(line 72,col 34)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[]"},{"fieldRange":"(line 73,col 5)-(line 73,col 36)","fieldName":"reach","fieldJavadocComment":"","fieldTokenRange":"private boolean [] reach = null;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 73,col 32)-(line 73,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"boolean[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean[]"},{"fieldRange":"(line 74,col 5)-(line 74,col 41)","fieldName":"startVertices","fieldJavadocComment":"","fieldTokenRange":"private List<V> startVertices = null;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 74,col 37)-(line 74,col 40)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"List<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<V>"}]}],"sourceFileId":173,"packageName":"org.jgrapht.alg.cycle"},{"sourceFileName":"org.jgrapht.alg.BiconnectivityInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.BiconnectivityInspector.BiconnectivityInspector(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 60,col 5)-(line 64,col 5)","constructorJavadocComment":"\n     * Running time = O(m) where m is the number of edges.\n     ","constructorDeclaration":"public BiconnectivityInspector(UndirectedGraph<V, E> graph)","constructorBody":"{\n    super();\n    this.blockCutpointGraph = new BlockCutpointGraph<V, E>(graph);\n}","constructorName":"BiconnectivityInspector","constructorQualifiedName":"org.jgrapht.alg.BiconnectivityInspector.BiconnectivityInspector","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[],"constructorTokenRange":"public BiconnectivityInspector(UndirectedGraph<V, E> graph)\n    {\n        super();\n        this.blockCutpointGraph = new BlockCutpointGraph<V, E>(graph);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Running time = O(m) where m is the number of edges.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public Set<Set<V>> getBiconnectedVertexComponents()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<Set<V>> biconnectedVertexComponents = new HashSet<Set<V>>();\n    for (Iterator<UndirectedGraph<V, E>> iter = this.blockCutpointGraph.vertexSet().iterator(); iter.hasNext(); ) {\n        UndirectedGraph<V, E> subgraph = iter.next();\n        if (!subgraph.edgeSet().isEmpty()) {\n            biconnectedVertexComponents.add(subgraph.vertexSet());\n        }\n    }\n    return biconnectedVertexComponents;\n}","methodRange":"(line 69,col 5)-(line 84,col 5)","methodTokenRange":"public Set<Set<V>> getBiconnectedVertexComponents()\n    {\n        Set<Set<V>> biconnectedVertexComponents = new HashSet<Set<V>>();\n        for (\n            Iterator<UndirectedGraph<V, E>> iter =\n                this.blockCutpointGraph.vertexSet().iterator();\n            iter.hasNext();)\n        {\n            UndirectedGraph<V, E> subgraph = iter.next();\n            if (!subgraph.edgeSet().isEmpty()) {\n                biconnectedVertexComponents.add(subgraph.vertexSet());\n            }\n        }\n\n        return biconnectedVertexComponents;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Returns the biconnected vertex-components of the graph.\n     ","methodParameters":[],"methodName":"getBiconnectedVertexComponents","methodQualifiedSignature":"org.jgrapht.alg.BiconnectivityInspector.getBiconnectedVertexComponents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the biconnected vertex-components of the graph.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.Set<java.util.Set<V>>","methodType":"Set<Set<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BiconnectivityInspector.getBiconnectedVertexComponents()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"set of all biconnected vertex-components containing the vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of all biconnected vertex-components containing the vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<Set<V>> getBiconnectedVertexComponents(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<Set<V>> vertexComponents = new HashSet<Set<V>>();\n    for (Iterator<Set<V>> iter = getBiconnectedVertexComponents().iterator(); iter.hasNext(); ) {\n        Set<V> vertexComponent = iter.next();\n        if (vertexComponent.contains(vertex)) {\n            vertexComponents.add(vertexComponent);\n        }\n    }\n    return vertexComponents;\n}","methodRange":"(line 96,col 5)-(line 109,col 5)","methodTokenRange":"public Set<Set<V>> getBiconnectedVertexComponents(V vertex)\n    {\n        Set<Set<V>> vertexComponents = new HashSet<Set<V>>();\n        for (\n            Iterator<Set<V>> iter = getBiconnectedVertexComponents().iterator();\n            iter.hasNext();)\n        {\n            Set<V> vertexComponent = iter.next();\n            if (vertexComponent.contains(vertex)) {\n                vertexComponents.add(vertexComponent);\n            }\n        }\n        return vertexComponents;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Returns the biconnected vertex-components containing the vertex. A\n     * biconnected vertex-component contains all the vertices in the component.\n     * A vertex which is not a cutpoint is contained in exactly one component. A\n     * cutpoint is contained is at least 2 components.\n     *\n     * @param vertex\n     *\n     * @return set of all biconnected vertex-components containing the vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getBiconnectedVertexComponents","methodQualifiedSignature":"org.jgrapht.alg.BiconnectivityInspector.getBiconnectedVertexComponents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the biconnected vertex-components containing the vertex. A\nbiconnected vertex-component contains all the vertices in the component.\nA vertex which is not a cutpoint is contained in exactly one component. A\ncutpoint is contained is at least 2 components.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of all biconnected vertex-components containing the vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<java.util.Set<V>>","methodType":"Set<Set<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BiconnectivityInspector.getBiconnectedVertexComponents(V)"},{"javadocBlockTags":[],"methodDeclaration":"public Set<V> getCutpoints()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.blockCutpointGraph.getCutpoints();\n}","methodRange":"(line 114,col 5)-(line 117,col 5)","methodTokenRange":"public Set<V> getCutpoints()\n    {\n        return this.blockCutpointGraph.getCutpoints();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the cutpoints of the graph.\n     ","methodParameters":[],"methodName":"getCutpoints","methodQualifiedSignature":"org.jgrapht.alg.BiconnectivityInspector.getCutpoints","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the cutpoints of the graph.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BiconnectivityInspector.getCutpoints()"},{"javadocBlockTags":[],"methodDeclaration":"public boolean isBiconnected()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.blockCutpointGraph.vertexSet().size() == 1;\n}","methodRange":"(line 123,col 5)-(line 126,col 5)","methodTokenRange":"public boolean isBiconnected()\n    {\n        return this.blockCutpointGraph.vertexSet().size() == 1;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns <code>true<\/code> if the graph is biconnected (no cutpoint),\n     * <code>false<\/code> otherwise.\n     ","methodParameters":[],"methodName":"isBiconnected","methodQualifiedSignature":"org.jgrapht.alg.BiconnectivityInspector.isBiconnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns <code>true<\/code> if the graph is biconnected (no cutpoint),\n<code>false<\/code> otherwise.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 125,col 62)-(line 125,col 62)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BiconnectivityInspector.isBiconnected()"}],"classJavadoc":"\/**\n * Inspects a graph for the biconnectivity property. See {@link\n * BlockCutpointGraph} for more information. A biconnected graph has only one\n * block (i.e. no cutpoints).\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"BiconnectivityInspector","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 56)","fieldName":"blockCutpointGraph","fieldJavadocComment":"","fieldTokenRange":"private BlockCutpointGraph<V, E> blockCutpointGraph;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.BlockCutpointGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BlockCutpointGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BlockCutpointGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"BlockCutpointGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.BlockCutpointGraph<V, E>"}]}],"sourceFileId":174,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.ConnectivityInspector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.event.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"},{"importId":5,"import":"import org.jgrapht.traverse.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which a connectivity inspector to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a connectivity inspector to be created.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.ConnectivityInspector(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 90,col 5)","constructorJavadocComment":"\n     * Creates a connectivity inspector for the specified undirected graph.\n     *\n     * @param g the graph for which a connectivity inspector to be created.\n     ","constructorDeclaration":"public ConnectivityInspector(UndirectedGraph<V, E> g)","constructorBody":"{\n    init();\n    this.graph = g;\n}","constructorName":"ConnectivityInspector","constructorQualifiedName":"org.jgrapht.alg.ConnectivityInspector.ConnectivityInspector","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public ConnectivityInspector(UndirectedGraph<V, E> g)\n    {\n        init();\n        this.graph = g;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a connectivity inspector for the specified undirected graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a connectivity inspector to be created.'}]}', name=Optional[g]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which a connectivity inspector to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a connectivity inspector to be created.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.ConnectivityInspector(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 97,col 5)-(line 101,col 5)","constructorJavadocComment":"\n     * Creates a connectivity inspector for the specified directed graph.\n     *\n     * @param g the graph for which a connectivity inspector to be created.\n     ","constructorDeclaration":"public ConnectivityInspector(DirectedGraph<V, E> g)","constructorBody":"{\n    init();\n    this.graph = new AsUndirectedGraph<V, E>(g);\n}","constructorName":"ConnectivityInspector","constructorQualifiedName":"org.jgrapht.alg.ConnectivityInspector.ConnectivityInspector","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public ConnectivityInspector(DirectedGraph<V, E> g)\n    {\n        init();\n        this.graph = new AsUndirectedGraph<V, E>(g);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a connectivity inspector for the specified directed graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a connectivity inspector to be created.'}]}', name=Optional[g]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 257,col 5)-(line 289,col 5)","classOrInterfaceTokenRange":"private class MyTraversalListener\n        extends TraversalListenerAdapter<V, E>\n    {\n        private Set<V> currentConnectedSet;\n\n        \/**\n         * @see TraversalListenerAdapter#connectedComponentFinished(ConnectedComponentTraversalEvent)\n         *\/\n        @Override public void connectedComponentFinished(\n            ConnectedComponentTraversalEvent e)\n        {\n            connectedSets.add(currentConnectedSet);\n        }\n\n        \/**\n         * @see TraversalListenerAdapter#connectedComponentStarted(ConnectedComponentTraversalEvent)\n         *\/\n        @Override public void connectedComponentStarted(\n            ConnectedComponentTraversalEvent e)\n        {\n            currentConnectedSet = new HashSet<V>();\n        }\n\n        \/**\n         * @see TraversalListenerAdapter#vertexTraversed(VertexTraversalEvent)\n         *\/\n        @Override public void vertexTraversed(VertexTraversalEvent<V> e)\n        {\n            V v = e.getVertex();\n            currentConnectedSet.add(v);\n            vertexToConnectedSet.put(v, currentConnectedSet);\n        }\n    }","classOrInterfaceJavadocComment":"\n     * A traversal listener that groups all vertices according to to their\n     * containing connected set.\n     *\n     * @author Barak Naveh\n     * @since Aug 6, 2003\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A traversal listener that groups all vertices according to to their\ncontaining connected set.'}]}, blockTags=[JavadocBlockTag{type=AUTHOR, content='JavadocDescription{elements=[JavadocSnippet{text='Barak Naveh'}]}', name=Optional.empty}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='Aug 6, 2003'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if and only if inspected graph is connected.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if inspected graph is connected.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isGraphConnected()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return lazyFindConnectedSets().size() == 1;\n}","methodRange":"(line 109,col 5)-(line 112,col 5)","methodTokenRange":"public boolean isGraphConnected()\n    {\n        return lazyFindConnectedSets().size() == 1;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Test if the inspected graph is connected. An empty graph is <i>not<\/i>\n     * considered connected.\n     *\n     * @return <code>true<\/code> if and only if inspected graph is connected.\n     ","methodParameters":[],"methodName":"isGraphConnected","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.isGraphConnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test if the inspected graph is connected. An empty graph is <i>not<\/i>\nconsidered connected.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if inspected graph is connected.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 111,col 50)-(line 111,col 50)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.isGraphConnected()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex for which the connected set to be returned.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the connected set to be returned.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of all vertices that are in the maximally connected\ncomponent together with the specified vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all vertices that are in the maximally connected\ncomponent together with the specified vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> connectedSetOf(V vertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> connectedSet = vertexToConnectedSet.get(vertex);\n    if (connectedSet == null) {\n        connectedSet = new HashSet<V>();\n        BreadthFirstIterator<V, E> i = new BreadthFirstIterator<V, E>(graph, vertex);\n        while (i.hasNext()) {\n            connectedSet.add(i.next());\n        }\n        vertexToConnectedSet.put(vertex, connectedSet);\n    }\n    return connectedSet;\n}","methodRange":"(line 126,col 5)-(line 144,col 5)","methodTokenRange":"public Set<V> connectedSetOf(V vertex)\n    {\n        Set<V> connectedSet = vertexToConnectedSet.get(vertex);\n\n        if (connectedSet == null) {\n            connectedSet = new HashSet<V>();\n\n            BreadthFirstIterator<V, E> i =\n                new BreadthFirstIterator<V, E>(graph, vertex);\n\n            while (i.hasNext()) {\n                connectedSet.add(i.next());\n            }\n\n            vertexToConnectedSet.put(vertex, connectedSet);\n        }\n\n        return connectedSet;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a set of all vertices that are in the maximally connected\n     * component together with the specified vertex. For more on maximally\n     * connected component, see <a\n     * href=\"http:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html\">\n     * http:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html<\/a>.\n     *\n     * @param vertex the vertex for which the connected set to be returned.\n     *\n     * @return a set of all vertices that are in the maximally connected\n     * component together with the specified vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"connectedSetOf","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.connectedSetOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a set of all vertices that are in the maximally connected\ncomponent together with the specified vertex. For more on maximally\nconnected component, see <a\nhref=\"http:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html\">\nhttp:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html<\/a>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex for which the connected set to be returned.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of all vertices that are in the maximally connected\ncomponent together with the specified vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 130,col 29)-(line 130,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.connectedSetOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Returns a list of <code>Set<\/code> s, where each set contains all\nvertices that are in the same maximally connected component.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Returns a list of <code>Set<\/code> s, where each set contains all\nvertices that are in the same maximally connected component.'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<Set<V>> connectedSets()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return lazyFindConnectedSets();\n}","methodRange":"(line 157,col 5)-(line 160,col 5)","methodTokenRange":"public List<Set<V>> connectedSets()\n    {\n        return lazyFindConnectedSets();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Returns a list of <code>Set<\/code> s, where each set contains all\n     * vertices that are in the same maximally connected component. All graph\n     * vertices occur in exactly one set. For more on maximally connected\n     * component, see <a\n     * href=\"http:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html\">\n     * http:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html<\/a>.\n     *\n     * @return Returns a list of <code>Set<\/code> s, where each set contains all\n     * vertices that are in the same maximally connected component.\n     ","methodParameters":[],"methodName":"connectedSets","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.connectedSets","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of <code>Set<\/code> s, where each set contains all\nvertices that are in the same maximally connected component. All graph\nvertices occur in exactly one set. For more on maximally connected\ncomponent, see <a\nhref=\"http:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html\">\nhttp:\/\/www.nist.gov\/dads\/HTML\/maximallyConnectedComponent.html<\/a>.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Returns a list of <code>Set<\/code> s, where each set contains all\nvertices that are in the same maximally connected component.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.connectedSets()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphListener#edgeAdded(GraphEdgeChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeAdded(GraphEdgeChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeAdded(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    init();\n}","methodRange":"(line 165,col 5)-(line 169,col 5)","methodTokenRange":"@Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n    {\n        init(); \/\/ for now invalidate cached results, in the future need to\n                \/\/ amend them.\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeAdded","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.edgeAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeAdded(GraphEdgeChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.edgeAdded(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphListener#edgeRemoved(GraphEdgeChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeRemoved(GraphEdgeChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    init();\n}","methodRange":"(line 174,col 5)-(line 178,col 5)","methodTokenRange":"@Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n    {\n        init(); \/\/ for now invalidate cached results, in the future need to\n                \/\/ amend them.\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeRemoved","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.edgeRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeRemoved(GraphEdgeChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.edgeRemoved(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"one end of the path.","javadocBlockTagName":"sourceVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='one end of the path.'}]}', name=Optional[sourceVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"another end of the path.","javadocBlockTagName":"targetVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='another end of the path.'}]}', name=Optional[targetVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if and only if there is a path from the source\nvertex to the target vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if there is a path from the source\nvertex to the target vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean pathExists(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> sourceSet = connectedSetOf(sourceVertex);\n    return sourceSet.contains(targetVertex);\n}","methodRange":"(line 194,col 5)-(line 203,col 5)","methodTokenRange":"public boolean pathExists(V sourceVertex, V targetVertex)\n    {\n        \/*\n         * TODO: Ignoring edge direction for directed graph may be\n         * confusing. For directed graphs, consider Dijkstra's algorithm.\n         *\/\n        Set<V> sourceSet = connectedSetOf(sourceVertex);\n\n        return sourceSet.contains(targetVertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Tests if there is a path from the specified source vertex to the\n     * specified target vertices. For a directed graph, direction is ignored for\n     * this interpretation of path.\n     *\n     * <p>Note: Future versions of this method might not ignore edge directions\n     * for directed graphs.<\/p>\n     *\n     * @param sourceVertex one end of the path.\n     * @param targetVertex another end of the path.\n     *\n     * @return <code>true<\/code> if and only if there is a path from the source\n     * vertex to the target vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"pathExists","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.pathExists","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests if there is a path from the specified source vertex to the\nspecified target vertices. For a directed graph, direction is ignored for\nthis interpretation of path.\n\n<p>Note: Future versions of this method might not ignore edge directions\nfor directed graphs.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='one end of the path.'}]}', name=Optional[sourceVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='another end of the path.'}]}', name=Optional[targetVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if and only if there is a path from the source\nvertex to the target vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.pathExists(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexSetListener#vertexAdded(GraphVertexChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexAdded(GraphVertexChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexAdded(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    init();\n}","methodRange":"(line 208,col 5)-(line 212,col 5)","methodTokenRange":"@Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n    {\n        init(); \/\/ for now invalidate cached results, in the future need to\n                \/\/ amend them.\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexAdded","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.vertexAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexAdded(GraphVertexChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.vertexAdded(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexSetListener#vertexRemoved(GraphVertexChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexRemoved(GraphVertexChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexRemoved(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    init();\n}","methodRange":"(line 217,col 5)-(line 221,col 5)","methodTokenRange":"@Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n    {\n        init(); \/\/ for now invalidate cached results, in the future need to\n                \/\/ amend them.\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexRemoved","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.vertexRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexRemoved(GraphVertexChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.vertexRemoved(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"methodDeclaration":"private void init()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    connectedSets = null;\n    vertexToConnectedSet = new HashMap<V, Set<V>>();\n}","methodRange":"(line 223,col 5)-(line 227,col 5)","methodTokenRange":"private void init()\n    {\n        connectedSets = null;\n        vertexToConnectedSet = new HashMap<V, Set<V>>();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"init","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.init","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 225,col 25)-(line 225,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.init()"},{"methodDeclaration":"private List<Set<V>> lazyFindConnectedSets()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (connectedSets == null) {\n        connectedSets = new ArrayList<Set<V>>();\n        Set<V> vertexSet = graph.vertexSet();\n        if (vertexSet.size() > 0) {\n            BreadthFirstIterator<V, E> i = new BreadthFirstIterator<V, E>(graph, null);\n            i.addTraversalListener(new MyTraversalListener());\n            while (i.hasNext()) {\n                i.next();\n            }\n        }\n    }\n    return connectedSets;\n}","methodRange":"(line 229,col 5)-(line 248,col 5)","methodTokenRange":"private List<Set<V>> lazyFindConnectedSets()\n    {\n        if (connectedSets == null) {\n            connectedSets = new ArrayList<Set<V>>();\n\n            Set<V> vertexSet = graph.vertexSet();\n\n            if (vertexSet.size() > 0) {\n                BreadthFirstIterator<V, E> i =\n                    new BreadthFirstIterator<V, E>(graph, null);\n                i.addTraversalListener(new MyTraversalListener());\n\n                while (i.hasNext()) {\n                    i.next();\n                }\n            }\n        }\n\n        return connectedSets;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"lazyFindConnectedSets","methodQualifiedSignature":"org.jgrapht.alg.ConnectivityInspector.lazyFindConnectedSets","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[{"literalExprRange":"(line 231,col 30)-(line 231,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 236,col 36)-(line 236,col 36)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 238,col 59)-(line 238,col 62)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.ConnectivityInspector.lazyFindConnectedSets()"}],"classJavadoc":"\/**\n * Allows obtaining various connectivity aspects of a graph. The <i>inspected\n * graph<\/i> is specified at construction time and cannot be modified.\n * Currently, the inspector supports connected components for an undirected\n * graph and weakly connected components for a directed graph. To find strongly\n * connected components, use {@link KosarajuStrongConnectivityInspector}\n * instead.\n *\n * <p>The inspector methods work in a lazy fashion: no computation is performed\n * unless immediately necessary. Computation are done once and results and\n * cached within this class for future need.<\/p>\n *\n * <p>The inspector is also a {@link org.jgrapht.event.GraphListener}. If added\n * as a listener to the inspected graph, the inspector will amend internal\n * cached results instead of recomputing them. It is efficient when a few\n * modifications are applied to a large graph. If many modifications are\n * expected it will not be efficient due to added overhead on graph update\n * operations. If inspector is added as listener to a graph other than the one\n * it inspects, results are undefined.<\/p>\n *\n * @author Barak Naveh\n * @author John V. Sichi\n * @since Aug 6, 2003\n *\/\n","className":"ConnectivityInspector","fields":[{"fieldRange":"(line 77,col 5)-(line 77,col 31)","fieldName":"connectedSets","fieldJavadocComment":"","fieldTokenRange":"List<Set<V>> connectedSets;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"List<Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.util.Set<V>>"},{"fieldRange":"(line 78,col 5)-(line 78,col 40)","fieldName":"vertexToConnectedSet","fieldJavadocComment":"","fieldTokenRange":"Map<V, Set<V>> vertexToConnectedSet;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Set<V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.util.Set<V>>"},{"fieldRange":"(line 79,col 5)-(line 79,col 30)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"}]}],"sourceFileId":175,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.MinSourceSinkCut","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.flow.EdmondsKarpMaximumFlow;\n"},{"importId":4,"import":"import org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"MinSourceSinkCut","constructorQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.MinSourceSinkCut","constructorQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.MinSourceSinkCut(org.jgrapht.DirectedGraph<V, E>)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[],"constructorTokenRange":"public MinSourceSinkCut(DirectedGraph<V, E> graph)\n    {\n        this.ekMaxFlow = new EdmondsKarpMaximumFlow<V, E>(graph);\n        this.graph = graph;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 64,col 5)-(line 68,col 5)","constructorJavadocComment":"","constructorDeclaration":"public MinSourceSinkCut(DirectedGraph<V, E> graph)","constructorBody":"{\n    this.ekMaxFlow = new EdmondsKarpMaximumFlow<V, E>(graph);\n    this.graph = graph;\n}","constructorJavadoc":""},{"constructorName":"MinSourceSinkCut","constructorQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.MinSourceSinkCut","constructorQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.MinSourceSinkCut(org.jgrapht.DirectedGraph<V, E>, double)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[],"constructorTokenRange":"public MinSourceSinkCut(DirectedGraph<V, E> graph, double epsilon)\n    {\n        this.ekMaxFlow = new EdmondsKarpMaximumFlow<V, E>(graph);\n        this.graph = graph;\n        this.epsilon = epsilon;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 75,col 5)","constructorJavadocComment":"","constructorDeclaration":"public MinSourceSinkCut(DirectedGraph<V, E> graph, double epsilon)","constructorBody":"{\n    this.ekMaxFlow = new EdmondsKarpMaximumFlow<V, E>(graph);\n    this.graph = graph;\n    this.epsilon = epsilon;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"sink","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[sink]}"}],"methodDeclaration":"public void computeMinCut(V source, V sink)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.source = source;\n    this.sink = sink;\n    minCut = new HashSet<V>();\n    MaximumFlow<V, E> maxFlow = ekMaxFlow.buildMaximumFlow(source, sink);\n    this.cutWeight = maxFlow.getValue();\n    Queue<V> processQueue = new LinkedList<V>();\n    processQueue.add(source);\n    while (!processQueue.isEmpty()) {\n        V vertex = processQueue.remove();\n        if (minCut.contains(vertex)) {\n            continue;\n        } else {\n            minCut.add(vertex);\n        }\n        Set<E> outEdges = new HashSet<E>(graph.outgoingEdgesOf(vertex));\n        for (Iterator<E> it = outEdges.iterator(); it.hasNext(); ) {\n            E edge = it.next();\n            double edgeCapacity = graph.getEdgeWeight(edge);\n            double flowValue = maxFlow.getFlow().get(edge);\n            if (Math.abs(edgeCapacity - flowValue) <= epsilon) {\n                it.remove();\n            }\n        }\n        for (E edge : outEdges) {\n            processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));\n        }\n        Set<E> inEdges = new HashSet<E>(graph.incomingEdgesOf(vertex));\n        for (Iterator<E> it = inEdges.iterator(); it.hasNext(); ) {\n            E edge = it.next();\n            double flowValue = maxFlow.getFlow().get(edge);\n            if (flowValue <= epsilon) {\n                it.remove();\n            }\n        }\n        for (E edge : inEdges) {\n            processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));\n        }\n    }\n}","methodRange":"(line 83,col 5)-(line 134,col 5)","methodTokenRange":"public void computeMinCut(V source, V sink)\n    {\n        this.source = source;\n        this.sink = sink;\n        minCut = new HashSet<V>();\n\n        \/\/First compute a maxFlow from source to sink\n        MaximumFlow<V, E> maxFlow = ekMaxFlow.buildMaximumFlow(source, sink);\n\n        this.cutWeight = maxFlow.getValue();\n\n        Queue<V> processQueue = new LinkedList<V>();\n        processQueue.add(source);\n\n        while (!processQueue.isEmpty()) {\n            V vertex = processQueue.remove();\n            if (minCut.contains(vertex)) {\n                continue;\n            } else {\n                minCut.add(vertex);\n            }\n\n            \/\/1. Get the forward edges with residual capacity\n            Set<E> outEdges = new HashSet<E>(graph.outgoingEdgesOf(vertex));\n            for (Iterator<E> it = outEdges.iterator(); it.hasNext();) {\n                E edge = it.next();\n                double edgeCapacity = graph.getEdgeWeight(edge);\n                double flowValue = maxFlow.getFlow().get(edge);\n                if (Math.abs(edgeCapacity - flowValue) <= epsilon) { \/\/No residual capacity on the edge\n                    it.remove();\n                }\n            }\n            for (E edge : outEdges) {\n                processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));\n            }\n\n            \/\/2. Get the backward edges with non-zero flow\n            Set<E> inEdges = new HashSet<E>(graph.incomingEdgesOf(vertex));\n            for (Iterator<E> it = inEdges.iterator(); it.hasNext();) {\n                E edge = it.next();\n\n                \/\/double edgeCapacity=graph.getEdgeWeight(edge);\n                double flowValue = maxFlow.getFlow().get(edge);\n                if (flowValue <= epsilon) { \/\/There is no flow on this edge\n                    it.remove();\n                }\n            }\n            for (E edge : inEdges) {\n                processQueue.add(Graphs.getOppositeVertex(graph, edge, vertex));\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Compute a minimum s-t cut\n     *\n     * @param source\n     * @param sink\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sink","parameterName":"sink"}],"methodName":"computeMinCut","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.computeMinCut","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compute a minimum s-t cut'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[sink]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.computeMinCut(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Returns the min cut partition containing the source, or null if\nthere was no call to computeMinCut(V source, V sink)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Returns the min cut partition containing the source, or null if\nthere was no call to computeMinCut(V source, V sink)'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> getSourcePartition()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return Collections.unmodifiableSet(minCut);\n}","methodRange":"(line 140,col 5)-(line 143,col 5)","methodTokenRange":"public Set<V> getSourcePartition()\n    {\n        return Collections.unmodifiableSet(minCut);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * @return Returns the min cut partition containing the source, or null if\n     * there was no call to computeMinCut(V source, V sink)\n     ","methodParameters":[],"methodName":"getSourcePartition","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.getSourcePartition","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Returns the min cut partition containing the source, or null if\nthere was no call to computeMinCut(V source, V sink)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.getSourcePartition()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"returns the min cut partition containing the sink","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='returns the min cut partition containing the sink'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> getSinkPartition()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (minCut == null) {\n        return null;\n    }\n    Set<V> set = new HashSet<V>(graph.vertexSet());\n    set.removeAll(minCut);\n    return Collections.unmodifiableSet(set);\n}","methodRange":"(line 150,col 5)-(line 158,col 5)","methodTokenRange":"public Set<V> getSinkPartition()\n    {\n        if (minCut == null) {\n            return null;\n        }\n        Set<V> set = new HashSet<V>(graph.vertexSet());\n        set.removeAll(minCut);\n        return Collections.unmodifiableSet(set);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the min cut partition containing the sink\n     *\n     * @return returns the min cut partition containing the sink\n     ","methodParameters":[],"methodName":"getSinkPartition","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.getSinkPartition","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the min cut partition containing the sink'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='returns the min cut partition containing the sink'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 152,col 23)-(line 152,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 153,col 20)-(line 153,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.getSinkPartition()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"cut weight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='cut weight'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getCutWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return cutWeight;\n}","methodRange":"(line 165,col 5)-(line 168,col 5)","methodTokenRange":"public double getCutWeight()\n    {\n        return cutWeight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Get the cut weight. This is equal to the max s-t flow\n     *\n     * @return cut weight\n     ","methodParameters":[],"methodName":"getCutWeight","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.getCutWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the cut weight. This is equal to the max s-t flow'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='cut weight'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.getCutWeight()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"all edges which have their tail in S, and their head in T. If\ncomputeMinCut(V source, V sink) has not been invoked, this method returns\nnull.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all edges which have their tail in S, and their head in T. If\ncomputeMinCut(V source, V sink) has not been invoked, this method returns\nnull.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getCutEdges()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (minCut == null) {\n        return null;\n    }\n    Set<E> cutEdges = new HashSet<E>();\n    for (V vertex : minCut) {\n        for (E edge : graph.outgoingEdgesOf(vertex)) {\n            if (!minCut.contains(Graphs.getOppositeVertex(graph, edge, vertex))) {\n                cutEdges.add(edge);\n            }\n        }\n    }\n    return Collections.unmodifiableSet(cutEdges);\n}","methodRange":"(line 179,col 5)-(line 195,col 5)","methodTokenRange":"public Set<E> getCutEdges()\n    {\n        if (minCut == null) {\n            return null;\n        }\n        Set<E> cutEdges = new HashSet<E>();\n        for (V vertex : minCut) {\n            for (E edge : graph.outgoingEdgesOf(vertex)) {\n                if (!minCut.contains(\n                        Graphs.getOppositeVertex(graph, edge, vertex)))\n                {\n                    cutEdges.add(edge);\n                }\n            }\n        }\n        return Collections.unmodifiableSet(cutEdges);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Let S be the set containing the source, and T be the set containing the\n     * sink, i.e. T=V\\S. This method returns the edges which have their tail in\n     * S, and their head in T\n     *\n     * @return all edges which have their tail in S, and their head in T. If\n     * computeMinCut(V source, V sink) has not been invoked, this method returns\n     * null.\n     ","methodParameters":[],"methodName":"getCutEdges","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.getCutEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Let S be the set containing the source, and T be the set containing the\nsink, i.e. T=V\\S. This method returns the edges which have their tail in\nS, and their head in T'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all edges which have their tail in S, and their head in T. If\ncomputeMinCut(V source, V sink) has not been invoked, this method returns\nnull.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 181,col 23)-(line 181,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 182,col 20)-(line 182,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.getCutEdges()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"source of last minCut call, null if there was no call","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='source of last minCut call, null if there was no call'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getCurrentSource()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return source;\n}","methodRange":"(line 202,col 5)-(line 205,col 5)","methodTokenRange":"public V getCurrentSource()\n    {\n        return source;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the source of the last call\n     *\n     * @return source of last minCut call, null if there was no call\n     ","methodParameters":[],"methodName":"getCurrentSource","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.getCurrentSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the source of the last call'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='source of last minCut call, null if there was no call'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.getCurrentSource()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"sink of last minCut call, null if there was no call","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='sink of last minCut call, null if there was no call'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getCurrentSink()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return sink;\n}","methodRange":"(line 212,col 5)-(line 215,col 5)","methodTokenRange":"public V getCurrentSink()\n    {\n        return sink;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the sink of the last call\n     *\n     * @return sink of last minCut call, null if there was no call\n     ","methodParameters":[],"methodName":"getCurrentSink","methodQualifiedSignature":"org.jgrapht.alg.MinSourceSinkCut.getCurrentSink","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the sink of the last call'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='sink of last minCut call, null if there was no call'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MinSourceSinkCut.getCurrentSink()"}],"classJavadoc":"\/**\n * Given a directed, weighted graph G(V,E). This class computes a minimum s-t\n * cut. For this, it relies on the EdmondsKarpMaximumFlow implementation. Note:\n * it is not recommended to use this class to calculate the overall minimum cut\n * in a graph by iteratively invoking this class for all source-sink pairs. This\n * is computationally expensive. Instead, use the StoerWagnerMinimumCut\n * implementation.\n *\n * @author Joris Kinable\n *\/\n","className":"MinSourceSinkCut","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 43)","fieldName":"ekMaxFlow","fieldJavadocComment":"","fieldTokenRange":"EdmondsKarpMaximumFlow<V, E> ekMaxFlow;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"EdmondsKarpMaximumFlow<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow<V, E>"},{"fieldRange":"(line 57,col 5)-(line 57,col 25)","fieldName":"minCut","fieldJavadocComment":"","fieldTokenRange":"Set<V> minCut = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 57,col 21)-(line 57,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 58,col 5)-(line 58,col 30)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 59,col 5)-(line 59,col 21)","fieldName":"cutWeight","fieldJavadocComment":"","fieldTokenRange":"double cutWeight;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 60,col 5)-(line 60,col 20)","fieldName":"source","fieldJavadocComment":"","fieldTokenRange":"V source = null;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 60,col 16)-(line 60,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 61,col 5)-(line 61,col 18)","fieldName":"sink","fieldJavadocComment":"","fieldTokenRange":"V sink = null;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 61,col 14)-(line 61,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 62,col 5)-(line 62,col 60)","fieldName":"epsilon","fieldJavadocComment":"","fieldTokenRange":"double epsilon = EdmondsKarpMaximumFlow.DEFAULT_EPSILON;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[EdmondsKarpMaximumFlow.DEFAULT_EPSILON]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":176,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.RankingPathElementList","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"max number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='max number of paths the list is able to store.'}]}', name=Optional[maxSize]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList(org.jgrapht.Graph<V, E>, int, org.jgrapht.alg.RankingPathElement<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 69,col 5)-(line 75,col 5)","constructorJavadocComment":"\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize max number of paths the list is able to store.\n     ","constructorDeclaration":" RankingPathElementList(Graph<V, E> graph, int maxSize, RankingPathElement<V, E> pathElement)","constructorBody":"{\n    super(graph, maxSize, pathElement);\n}","constructorName":"RankingPathElementList","constructorQualifiedName":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"RankingPathElement<V, E>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","parameter":"RankingPathElement<V, E> pathElement","parameterName":"pathElement"}],"literalExprs":[],"constructorTokenRange":"RankingPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        RankingPathElement<V, E> pathElement)\n    {\n        super(graph, maxSize, pathElement);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a list with an empty path. The list size is 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='max number of paths the list is able to store.'}]}', name=Optional[maxSize]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"paths, list of <code>\nRankingPathElement<\/code>.","javadocBlockTagName":"prevPathElementList","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths, list of <code>\nRankingPathElement<\/code>.'}]}', name=Optional[prevPathElementList]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the end vertex of the created paths.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the created paths.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList(org.jgrapht.Graph<V, E>, int, org.jgrapht.alg.RankingPathElementList<V, E>, E)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 95,col 5)","constructorJavadocComment":"\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param prevPathElementList paths, list of <code>\n     * RankingPathElement<\/code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     * @param maxSize maximum number of paths the list is able to store.\n     ","constructorDeclaration":" RankingPathElementList(Graph<V, E> graph, int maxSize, RankingPathElementList<V, E> elementList, E edge)","constructorBody":"{\n    this(graph, maxSize, elementList, edge, null);\n    assert (!this.pathElements.isEmpty());\n}","constructorName":"RankingPathElementList","constructorQualifiedName":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"RankingPathElementList<V, E>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElementList, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElementList.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElementList.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElementList<V, E>","parameter":"RankingPathElementList<V, E> elementList","parameterName":"elementList"},{"parameterType":"E","parameterId":4,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"literalExprs":[{"literalExprRange":"(line 92,col 49)-(line 92,col 52)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"RankingPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        RankingPathElementList<V, E> elementList,\n        E edge)\n    {\n        this(graph, maxSize, elementList, edge, null);\n\n        assert (!this.pathElements.isEmpty());\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates paths obtained by concatenating the specified edge to the\nspecified paths.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths, list of <code>\nRankingPathElement<\/code>.'}]}', name=Optional[prevPathElementList]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the created paths.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"paths, list of <code>\nRankingPathElement<\/code>.","javadocBlockTagName":"prevPathElementList","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths, list of <code>\nRankingPathElement<\/code>.'}]}', name=Optional[prevPathElementList]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the end vertex of the created paths.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the created paths.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList(org.jgrapht.Graph<V, E>, int, org.jgrapht.alg.RankingPathElementList<V, E>, E, V)","variableDeclarationExprs":[{"variableType":"int","variableName":"i","variableDeclarationExprId":1,"variableDeclarationExpr":"int i = 0","variableDeclarationExprRange":"(line 117,col 14)-(line 117,col 22)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 117,col 18)-(line 117,col 22)"},{"variableType":"RankingPathElement<V, E>","variableName":"prevPathElement","variableDeclarationExprId":2,"variableDeclarationExpr":"RankingPathElement<V, E> prevPathElement = elementList.get(i)","variableDeclarationExprRange":"(line 118,col 13)-(line 118,col 73)","variableTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","variableRange":"(line 118,col 38)-(line 118,col 73)"},{"variableType":"double","variableName":"weight","variableDeclarationExprId":3,"variableDeclarationExpr":"double weight = calculatePathWeight(prevPathElement, edge)","variableDeclarationExprRange":"(line 125,col 13)-(line 125,col 70)","variableTypeResolved":"PrimitiveTypeUsage{name='double'}","variableRange":"(line 125,col 20)-(line 125,col 70)"},{"variableType":"RankingPathElement<V, E>","variableName":"newPathElement","variableDeclarationExprId":4,"variableDeclarationExpr":"RankingPathElement<V, E> newPathElement = new RankingPathElement<V, E>(this.graph, prevPathElement, edge, weight)","variableDeclarationExprRange":"(line 126,col 13)-(line 131,col 27)","variableTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","variableRange":"(line 126,col 38)-(line 131,col 27)"}],"constructorRange":"(line 106,col 5)-(line 136,col 5)","constructorJavadocComment":"\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param prevPathElementList paths, list of <code>\n     * RankingPathElement<\/code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     * @param maxSize maximum number of paths the list is able to store.\n     ","constructorDeclaration":" RankingPathElementList(Graph<V, E> graph, int maxSize, RankingPathElementList<V, E> elementList, E edge, V guardVertexToNotDisconnect)","constructorBody":"{\n    super(graph, maxSize, elementList, edge);\n    this.guardVertexToNotDisconnect = guardVertexToNotDisconnect;\n    for (int i = 0; (i < elementList.size()) && (size() < maxSize); i++) {\n        RankingPathElement<V, E> prevPathElement = elementList.get(i);\n        if (isNotValidPath(prevPathElement, edge)) {\n            continue;\n        }\n        double weight = calculatePathWeight(prevPathElement, edge);\n        RankingPathElement<V, E> newPathElement = new RankingPathElement<V, E>(this.graph, prevPathElement, edge, weight);\n        this.pathElements.add(newPathElement);\n    }\n}","constructorName":"RankingPathElementList","constructorQualifiedName":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"RankingPathElementList<V, E>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElementList, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElementList.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElementList.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElementList<V, E>","parameter":"RankingPathElementList<V, E> elementList","parameterName":"elementList"},{"parameterType":"E","parameterId":4,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"V","parameterId":5,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V guardVertexToNotDisconnect","parameterName":"guardVertexToNotDisconnect"}],"literalExprs":[{"literalExprRange":"(line 117,col 22)-(line 117,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"RankingPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        RankingPathElementList<V, E> elementList,\n        E edge,\n        V guardVertexToNotDisconnect)\n    {\n        super(graph, maxSize, elementList, edge);\n        this.guardVertexToNotDisconnect = guardVertexToNotDisconnect;\n\n        \/\/ loop over the path elements in increasing order of weight.\n        for (int i = 0; (i < elementList.size()) && (size() < maxSize); i++) {\n            RankingPathElement<V, E> prevPathElement = elementList.get(i);\n\n            if (isNotValidPath(prevPathElement, edge)) {\n                \/\/ go to the next path element in the loop\n                continue;\n            }\n\n            double weight = calculatePathWeight(prevPathElement, edge);\n            RankingPathElement<V, E> newPathElement =\n                new RankingPathElement<V, E>(\n                    this.graph,\n                    prevPathElement,\n                    edge,\n                    weight);\n\n            \/\/ the new path is inserted at the end of the list.\n            this.pathElements.add(newPathElement);\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates paths obtained by concatenating the specified edge to the\nspecified paths.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths, list of <code>\nRankingPathElement<\/code>.'}]}', name=Optional[prevPathElementList]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the created paths.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"max number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='max number of paths the list is able to store.'}]}', name=Optional[maxSize]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList(org.jgrapht.Graph<V, E>, int, V)","variableDeclarationExprs":[],"constructorRange":"(line 143,col 5)-(line 146,col 5)","constructorJavadocComment":"\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize max number of paths the list is able to store.\n     ","constructorDeclaration":" RankingPathElementList(Graph<V, E> graph, int maxSize, V vertex)","constructorBody":"{\n    super(graph, maxSize, vertex);\n}","constructorName":"RankingPathElementList","constructorQualifiedName":"org.jgrapht.alg.RankingPathElementList.RankingPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"literalExprs":[],"constructorTokenRange":"RankingPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        super(graph, maxSize, vertex);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty list. The list size is 0.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='max number of paths the list is able to store.'}]}', name=Optional[maxSize]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 391,col 5)-(line 428,col 5)","classOrInterfaceTokenRange":"private static class PathMask<V, E>\n        implements MaskFunctor<V, E>\n    {\n        private Set<E> maskedEdges;\n\n        private Set<V> maskedVertices;\n\n        \/**\n         * Creates a mask for all the edges and the vertices of the path\n         * (including the 2 extremity vertices).\n         *\n         * @param pathElement\n         *\/\n        PathMask(RankingPathElement<V, E> pathElement)\n        {\n            this.maskedEdges = new HashSet<E>();\n            this.maskedVertices = new HashSet<V>();\n\n            while (pathElement.getPrevEdge() != null) {\n                this.maskedEdges.add(pathElement.getPrevEdge());\n                this.maskedVertices.add(pathElement.getVertex());\n                pathElement = pathElement.getPrevPathElement();\n            }\n            this.maskedVertices.add(pathElement.getVertex());\n        }\n\n        \/\/ implement MaskFunctor\n        @Override public boolean isEdgeMasked(E edge)\n        {\n            return this.maskedEdges.contains(edge);\n        }\n\n        \/\/ implement MaskFunctor\n        @Override public boolean isVertexMasked(V vertex)\n        {\n            return this.maskedVertices.contains(vertex);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"list of paths at vertex v.","javadocBlockTagName":"elementList","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of paths at vertex v.'}]}', name=Optional[elementList]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge (v->y).","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge (v->y).'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if at least one path has been added in the\nlist, <code>false<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if at least one path has been added in the\nlist, <code>false<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean addPathElements(RankingPathElementList<V, E> elementList, E edge)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert (this.vertex.equals(Graphs.getOppositeVertex(this.graph, edge, elementList.getVertex())));\n    boolean pathAdded = false;\n    for (int vIndex = 0, yIndex = 0; vIndex < elementList.size(); vIndex++) {\n        RankingPathElement<V, E> prevPathElement = elementList.get(vIndex);\n        if (isNotValidPath(prevPathElement, edge)) {\n            continue;\n        }\n        double newPathWeight = calculatePathWeight(prevPathElement, edge);\n        RankingPathElement<V, E> newPathElement = new RankingPathElement<V, E>(this.graph, prevPathElement, edge, newPathWeight);\n        RankingPathElement<V, E> yPathElement = null;\n        for (; yIndex < size(); yIndex++) {\n            yPathElement = get(yIndex);\n            if (newPathWeight < yPathElement.getWeight()) {\n                this.pathElements.add(yIndex, newPathElement);\n                pathAdded = true;\n                if (size() > this.maxSize) {\n                    this.pathElements.remove(this.maxSize);\n                }\n                break;\n            }\n            if (newPathWeight == yPathElement.getWeight()) {\n                this.pathElements.add(yIndex + 1, newPathElement);\n                pathAdded = true;\n                if (size() > this.maxSize) {\n                    this.pathElements.remove(this.maxSize);\n                }\n                break;\n            }\n        }\n        if (newPathWeight > yPathElement.getWeight()) {\n            if (size() < this.maxSize) {\n                this.pathElements.add(newPathElement);\n                pathAdded = true;\n            } else {\n                break;\n            }\n        }\n    }\n    return pathAdded;\n}","methodRange":"(line 173,col 5)-(line 256,col 5)","methodTokenRange":"public boolean addPathElements(\n        RankingPathElementList<V, E> elementList,\n        E edge)\n    {\n        assert (this.vertex.equals(\n            Graphs.getOppositeVertex(\n                this.graph,\n                edge,\n                elementList.getVertex())));\n\n        boolean pathAdded = false;\n\n        \/\/ loop over the paths elements of the list at vertex v.\n        for (\n            int vIndex = 0, yIndex = 0;\n            vIndex < elementList.size();\n            vIndex++)\n        {\n            RankingPathElement<V, E> prevPathElement = elementList.get(vIndex);\n\n            if (isNotValidPath(prevPathElement, edge)) {\n                \/\/ checks if path is simple and if guard-vertex is not\n                \/\/ disconnected.\n                continue;\n            }\n            double newPathWeight = calculatePathWeight(prevPathElement, edge);\n            RankingPathElement<V, E> newPathElement =\n                new RankingPathElement<V, E>(\n                    this.graph,\n                    prevPathElement,\n                    edge,\n                    newPathWeight);\n\n            \/\/ loop over the paths of the list at vertex y from yIndex to the\n            \/\/ end.\n            RankingPathElement<V, E> yPathElement = null;\n            for (; yIndex < size(); yIndex++) {\n                yPathElement = get(yIndex);\n\n                \/\/ case when the new path is shorter than the path Py stored at\n                \/\/ index y\n                if (newPathWeight < yPathElement.getWeight()) {\n                    this.pathElements.add(yIndex, newPathElement);\n                    pathAdded = true;\n\n                    \/\/ ensures max size limit is not exceeded.\n                    if (size() > this.maxSize) {\n                        this.pathElements.remove(this.maxSize);\n                    }\n                    break;\n                }\n\n                \/\/ case when the new path is of the same length as the path Py\n                \/\/ stored at index y\n                if (newPathWeight == yPathElement.getWeight()) {\n                    this.pathElements.add(yIndex + 1, newPathElement);\n                    pathAdded = true;\n\n                    \/\/ ensures max size limit is not exceeded.\n                    if (size() > this.maxSize) {\n                        this.pathElements.remove(this.maxSize);\n                    }\n                    break;\n                }\n            }\n\n            \/\/ case when the new path is longer than the longest path in the\n            \/\/ list (Py stored at the last index y)\n            if (newPathWeight > yPathElement.getWeight()) {\n                \/\/ ensures max size limit is not exceeded.\n                if (size() < this.maxSize) {\n                    \/\/ the new path is inserted at the end of the list.\n                    this.pathElements.add(newPathElement);\n                    pathAdded = true;\n                } else {\n                    \/\/ max size limit is reached -> end of the loop over the\n                    \/\/ paths elements of the list at vertex v.\n                    break;\n                }\n            }\n        }\n\n        return pathAdded;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * <p>Adds paths in the list at vertex y. Candidate paths are obtained by\n     * concatenating the specified edge (v->y) to the paths <code>\n     * elementList<\/code> at vertex v.<\/p>\n     *\n     * Complexity =\n     *\n     * <ul>\n     * <li>w\/o guard-vertex: O(<code>k*np<\/code>) where <code>k<\/code> is the\n     * max size limit of the list and <code>np<\/code> is the maximum number of\n     * vertices in the paths stored in the list<\/li>\n     * <li>with guard-vertex: O(<code>k*(m+n)<\/code>) where <code>k<\/code> is\n     * the max size limit of the list, <code>m<\/code> is the number of edges of\n     * the graph and <code>n<\/code> is the number of vertices of the graph,\n     * O(<code>m+n<\/code>) being the complexity of the <code>\n     * ConnectivityInspector<\/code> to check whether a path exists towards the\n     * guard-vertex<\/li>\n     * <\/ul>\n     *\n     * @param elementList list of paths at vertex v.\n     * @param edge edge (v->y).\n     *\n     * @return <code>true<\/code> if at least one path has been added in the\n     * list, <code>false<\/code> otherwise.\n     ","methodParameters":[{"parameterType":"RankingPathElementList<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElementList, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElementList.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElementList.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElementList<V, E>","parameter":"RankingPathElementList<V, E> elementList","parameterName":"elementList"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"addPathElements","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.addPathElements","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Adds paths in the list at vertex y. Candidate paths are obtained by\nconcatenating the specified edge (v->y) to the paths <code>\nelementList<\/code> at vertex v.<\/p>\n\nComplexity =\n\n<ul>\n<li>w\/o guard-vertex: O(<code>k*np<\/code>) where <code>k<\/code> is the\nmax size limit of the list and <code>np<\/code> is the maximum number of\nvertices in the paths stored in the list<\/li>\n<li>with guard-vertex: O(<code>k*(m+n)<\/code>) where <code>k<\/code> is\nthe max size limit of the list, <code>m<\/code> is the number of edges of\nthe graph and <code>n<\/code> is the number of vertices of the graph,\nO(<code>m+n<\/code>) being the complexity of the <code>\nConnectivityInspector<\/code> to check whether a path exists towards the\nguard-vertex<\/li>\n<\/ul>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of paths at vertex v.'}]}', name=Optional[elementList]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge (v->y).'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if at least one path has been added in the\nlist, <code>false<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 183,col 29)-(line 183,col 33)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 187,col 26)-(line 187,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 187,col 38)-(line 187,col 38)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 208,col 53)-(line 208,col 56)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 216,col 33)-(line 216,col 36)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 228,col 52)-(line 228,col 52)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 229,col 33)-(line 229,col 36)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 246,col 33)-(line 246,col 36)","literalExprId":8,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.RankingPathElementList.addPathElements(org.jgrapht.alg.RankingPathElementList<V, E>, E)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of <code>RankingPathElement<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>RankingPathElement<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":" List<RankingPathElement<V, E>> getPathElements()","methodAccessSpecifier":"NONE","methodBody":"{\n    return this.pathElements;\n}","methodRange":"(line 261,col 5)-(line 264,col 5)","methodTokenRange":"List<RankingPathElement<V, E>> getPathElements()\n    {\n        return this.pathElements;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @return list of <code>RankingPathElement<\/code>.\n     ","methodParameters":[],"methodName":"getPathElements","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.getPathElements","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>RankingPathElement<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<RankingPathElement<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.RankingPathElementList.getPathElements()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"pathElement","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the cost obtained by concatenation.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the cost obtained by concatenation.'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight(E)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(E)'}]}', name=Optional.empty}"}],"methodDeclaration":"private double calculatePathWeight(RankingPathElement<V, E> pathElement, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    double pathWeight = this.graph.getEdgeWeight(edge);\n    if ((pathElement.getPrevEdge() != null)) {\n        pathWeight += pathElement.getWeight();\n    }\n    return pathWeight;\n}","methodRange":"(line 277,col 5)-(line 289,col 5)","methodTokenRange":"private double calculatePathWeight(\n        RankingPathElement<V, E> pathElement,\n        E edge)\n    {\n        double pathWeight = this.graph.getEdgeWeight(edge);\n\n        \/\/ otherwise it's the start vertex.\n        if ((pathElement.getPrevEdge() != null)) {\n            pathWeight += pathElement.getWeight();\n        }\n\n        return pathWeight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Costs taken into account are the weights stored in <code>Edge<\/code>\n     * objects.\n     *\n     * @param pathElement\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the cost obtained by concatenation.\n     *\n     * @see Graph#getEdgeWeight(E)\n     ","methodParameters":[{"parameterType":"RankingPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","parameter":"RankingPathElement<V, E> pathElement","parameterName":"pathElement"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"calculatePathWeight","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.calculatePathWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Costs taken into account are the weights stored in <code>Edge<\/code>\nobjects.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the cost obtained by concatenation.'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(E)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 284,col 43)-(line 284,col 46)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.RankingPathElementList.calculatePathWeight(org.jgrapht.alg.RankingPathElement<V, E>, E)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the specified path element disconnects the\nguard-vertex, <code>false<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the specified path element disconnects the\nguard-vertex, <code>false<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"private boolean isGuardVertexDisconnected(RankingPathElement<V, E> prevPathElement)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (this.guardVertexToNotDisconnect == null) {\n        return false;\n    }\n    if (this.path2disconnect.containsKey(prevPathElement)) {\n        return this.path2disconnect.get(prevPathElement);\n    }\n    ConnectivityInspector<V, E> connectivityInspector;\n    MaskFunctor<V, E> connectivityMask;\n    if (this.graph instanceof DirectedGraph<?, ?>) {\n        connectivityMask = new PathMask<V, E>(prevPathElement);\n        DirectedMaskSubgraph<V, E> connectivityGraph = new DirectedMaskSubgraph<V, E>((DirectedGraph<V, E>) this.graph, connectivityMask);\n        connectivityInspector = new ConnectivityInspector<V, E>(connectivityGraph);\n    } else {\n        connectivityMask = new PathMask<V, E>(prevPathElement);\n        UndirectedMaskSubgraph<V, E> connectivityGraph = new UndirectedMaskSubgraph<V, E>((UndirectedGraph<V, E>) this.graph, connectivityMask);\n        connectivityInspector = new ConnectivityInspector<V, E>(connectivityGraph);\n    }\n    if (connectivityMask.isVertexMasked(this.guardVertexToNotDisconnect)) {\n        this.path2disconnect.put(prevPathElement, true);\n        return true;\n    }\n    if (!connectivityInspector.pathExists(this.vertex, this.guardVertexToNotDisconnect)) {\n        this.path2disconnect.put(prevPathElement, true);\n        return true;\n    }\n    this.path2disconnect.put(prevPathElement, false);\n    return false;\n}","methodRange":"(line 297,col 5)-(line 347,col 5)","methodTokenRange":"private boolean isGuardVertexDisconnected(\n        RankingPathElement<V, E> prevPathElement)\n    {\n        if (this.guardVertexToNotDisconnect == null) {\n            return false;\n        }\n\n        if (this.path2disconnect.containsKey(prevPathElement)) {\n            return this.path2disconnect.get(prevPathElement);\n        }\n\n        ConnectivityInspector<V, E> connectivityInspector;\n        MaskFunctor<V, E> connectivityMask;\n\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            connectivityMask = new PathMask<V, E>(prevPathElement);\n            DirectedMaskSubgraph<V, E> connectivityGraph =\n                new DirectedMaskSubgraph<V, E>(\n                    (DirectedGraph<V, E>) this.graph,\n                    connectivityMask);\n            connectivityInspector =\n                new ConnectivityInspector<V, E>(\n                    connectivityGraph);\n        } else {\n            connectivityMask = new PathMask<V, E>(prevPathElement);\n            UndirectedMaskSubgraph<V, E> connectivityGraph =\n                new UndirectedMaskSubgraph<V, E>(\n                    (UndirectedGraph<V, E>) this.graph,\n                    connectivityMask);\n            connectivityInspector =\n                new ConnectivityInspector<V, E>(\n                    connectivityGraph);\n        }\n\n        if (connectivityMask.isVertexMasked(this.guardVertexToNotDisconnect)) {\n            \/\/ the guard-vertex was already in the path element -> invalid path\n            this.path2disconnect.put(prevPathElement, true);\n            return true;\n        }\n\n        if (!connectivityInspector.pathExists(\n                this.vertex,\n                this.guardVertexToNotDisconnect))\n        {\n            this.path2disconnect.put(prevPathElement, true);\n            return true;\n        }\n\n        this.path2disconnect.put(prevPathElement, false);\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Ensures that paths of the list do not disconnect the guard-vertex.\n     *\n     * @return <code>true<\/code> if the specified path element disconnects the\n     * guard-vertex, <code>false<\/code> otherwise.\n     ","methodParameters":[{"parameterType":"RankingPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","parameter":"RankingPathElement<V, E> prevPathElement","parameterName":"prevPathElement"}],"methodName":"isGuardVertexDisconnected","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.isGuardVertexDisconnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Ensures that paths of the list do not disconnect the guard-vertex.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the specified path element disconnects the\nguard-vertex, <code>false<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 300,col 48)-(line 300,col 51)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 301,col 20)-(line 301,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 333,col 55)-(line 333,col 58)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 334,col 20)-(line 334,col 23)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 341,col 55)-(line 341,col 58)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 342,col 20)-(line 342,col 23)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 345,col 51)-(line 345,col 55)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 346,col 16)-(line 346,col 20)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.RankingPathElementList.isGuardVertexDisconnected(org.jgrapht.alg.RankingPathElement<V, E>)"},{"methodDeclaration":"private boolean isNotValidPath(RankingPathElement<V, E> prevPathElement, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return !isSimplePath(prevPathElement, edge) || isGuardVertexDisconnected(prevPathElement);\n}","methodRange":"(line 349,col 5)-(line 355,col 5)","methodTokenRange":"private boolean isNotValidPath(\n        RankingPathElement<V, E> prevPathElement,\n        E edge)\n    {\n        return !isSimplePath(prevPathElement, edge)\n            || isGuardVertexDisconnected(prevPathElement);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"RankingPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","parameter":"RankingPathElement<V, E> prevPathElement","parameterName":"prevPathElement"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"isNotValidPath","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.isNotValidPath","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.RankingPathElementList.isNotValidPath(org.jgrapht.alg.RankingPathElement<V, E>, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"prevPathElement","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[prevPathElement]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the resulting path (obtained by\nconcatenating the specified edge to the specified path) is simple, <code>\nfalse<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the resulting path (obtained by\nconcatenating the specified edge to the specified path) is simple, <code>\nfalse<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"private boolean isSimplePath(RankingPathElement<V, E> prevPathElement, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    V endVertex = Graphs.getOppositeVertex(this.graph, edge, prevPathElement.getVertex());\n    assert (endVertex.equals(this.vertex));\n    RankingPathElement<V, E> pathElementToTest = prevPathElement;\n    do {\n        if (pathElementToTest.getVertex().equals(endVertex)) {\n            return false;\n        } else {\n            pathElementToTest = pathElementToTest.getPrevPathElement();\n        }\n    } while (pathElementToTest != null);\n    return true;\n}","methodRange":"(line 368,col 5)-(line 389,col 5)","methodTokenRange":"private boolean isSimplePath(\n        RankingPathElement<V, E> prevPathElement,\n        E edge)\n    {\n        V endVertex =\n            Graphs.getOppositeVertex(\n                this.graph,\n                edge,\n                prevPathElement.getVertex());\n        assert (endVertex.equals(this.vertex));\n\n        RankingPathElement<V, E> pathElementToTest = prevPathElement;\n        do {\n            if (pathElementToTest.getVertex().equals(endVertex)) {\n                return false;\n            } else {\n                pathElementToTest = pathElementToTest.getPrevPathElement();\n            }\n        } while (pathElementToTest != null);\n\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Ensures that paths of the list are simple (check that the vertex was not\n     * already in the path element).\n     *\n     * @param prevPathElement\n     * @param edge\n     *\n     * @return <code>true<\/code> if the resulting path (obtained by\n     * concatenating the specified edge to the specified path) is simple, <code>\n     * false<\/code> otherwise.\n     ","methodParameters":[{"parameterType":"RankingPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.RankingPathElement<V, E>","parameter":"RankingPathElement<V, E> prevPathElement","parameterName":"prevPathElement"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"isSimplePath","methodQualifiedSignature":"org.jgrapht.alg.RankingPathElementList.isSimplePath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Ensures that paths of the list are simple (check that the vertex was not\nalready in the path element).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[prevPathElement]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the resulting path (obtained by\nconcatenating the specified edge to the specified path) is simple, <code>\nfalse<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 382,col 24)-(line 382,col 28)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 386,col 39)-(line 386,col 42)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 388,col 16)-(line 388,col 19)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.RankingPathElementList.isSimplePath(org.jgrapht.alg.RankingPathElement<V, E>, E)"}],"classJavadoc":"\/**\n * List of simple paths in increasing order of weight.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"RankingPathElementList","fields":[{"fieldRange":"(line 59,col 5)-(line 59,col 48)","fieldName":"guardVertexToNotDisconnect","fieldJavadocComment":"\n     * Vertex that paths of the list must not disconnect.\n     ","fieldTokenRange":"private V guardVertexToNotDisconnect = null;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 59,col 44)-(line 59,col 47)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"V","fieldJavadoc":"Vertex that paths of the list must not disconnect.\n","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 61,col 5)-(line 62,col 57)","fieldName":"path2disconnect","fieldJavadocComment":"","fieldTokenRange":"private Map<RankingPathElement<V, E>, Boolean> path2disconnect =\n        new HashMap<RankingPathElement<V, E>, Boolean>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{org.jgrapht.alg.RankingPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.RankingPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.RankingPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}, java.util.Map.V=ReferenceType{java.lang.Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<RankingPathElement<V, E>, Boolean>()]","fieldType":"Map<RankingPathElement<V, E>, Boolean>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<org.jgrapht.alg.RankingPathElement<V, E>, java.lang.Boolean>"}]}],"sourceFileId":177,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.EdmondsBlossomShrinking","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"EdmondsBlossomShrinking","constructorQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.EdmondsBlossomShrinking","constructorQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.EdmondsBlossomShrinking()","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"@Deprecated public EdmondsBlossomShrinking()\n    {\n    }","variableDeclarationExprs":[],"constructorRange":"(line 68,col 5)-(line 70,col 5)","constructorJavadocComment":"","constructorDeclaration":"public EdmondsBlossomShrinking()","constructorBody":"{\n}","constructorJavadoc":""},{"constructorName":"EdmondsBlossomShrinking","constructorQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.EdmondsBlossomShrinking","constructorQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.EdmondsBlossomShrinking(org.jgrapht.UndirectedGraph<V, E>)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"final UndirectedGraph<V, E> G","parameterName":"G"}],"literalExprs":[],"constructorTokenRange":"public EdmondsBlossomShrinking(final UndirectedGraph<V, E> G)\n    {\n        this.graph = G;\n    }","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 75,col 5)","constructorJavadocComment":"","constructorDeclaration":"public EdmondsBlossomShrinking(final UndirectedGraph<V, E> G)","constructorBody":"{\n    this.graph = G;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public Set<E> findMatch(final UndirectedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new EdmondsBlossomShrinking<V, E>(g).getMatching();\n}","methodRange":"(line 83,col 5)-(line 86,col 5)","methodTokenRange":"@Deprecated public Set<E> findMatch(final UndirectedGraph<V, E> g)\n    {\n        return new EdmondsBlossomShrinking<V, E>(g).getMatching();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * See `getMatching` as preferred alternative to this one\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"final UndirectedGraph<V, E> g","parameterName":"g"}],"methodName":"findMatch","methodQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.findMatch","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='See `getMatching` as preferred alternative to this one'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.findMatch(org.jgrapht.UndirectedGraph<V, E>)"},{"methodDeclaration":"public Set<E> getMatching()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (matching == null) {\n        matching = findMatch();\n    }\n    return Collections.unmodifiableSet(matching);\n}","methodRange":"(line 91,col 5)-(line 97,col 5)","methodTokenRange":"@Override public Set<E> getMatching()\n    {\n        if (matching == null) {\n            matching = findMatch();\n        }\n        return Collections.unmodifiableSet(matching);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getMatching","methodQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.getMatching","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 93,col 25)-(line 93,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.getMatching()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"set of Edges","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of Edges'}]}', name=Optional.empty}"}],"methodDeclaration":"private Set<E> findMatch()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<E> result = new ArrayUnenforcedSet<E>();\n    match = new HashMap<V, V>();\n    path = new HashMap<V, V>();\n    contracted = new HashMap<V, V>();\n    for (V i : graph.vertexSet()) {\n        if (!match.containsKey(i)) {\n            V v = findPath(i);\n            while (v != null) {\n                V pv = path.get(v);\n                V ppv = match.get(pv);\n                match.put(v, pv);\n                match.put(pv, v);\n                v = ppv;\n            }\n        }\n    }\n    Set<V> seen = new HashSet<V>();\n    for (V v : graph.vertexSet()) {\n        if (!seen.contains(v) && match.containsKey(v)) {\n            seen.add(v);\n            seen.add(match.get(v));\n            result.add(graph.getEdge(v, match.get(v)));\n        }\n    }\n    return result;\n}","methodRange":"(line 104,col 5)-(line 138,col 5)","methodTokenRange":"private Set<E> findMatch()\n    {\n        Set<E> result = new ArrayUnenforcedSet<E>();\n        match = new HashMap<V, V>();\n        path = new HashMap<V, V>();\n        contracted = new HashMap<V, V>();\n\n        for (V i : graph.vertexSet()) {\n            \/\/ Any augmenting path should start with _exposed_ vertex\n            \/\/ (vertex may not escape match-set being added once)\n            if (!match.containsKey(i)) {\n                \/\/ Match is maximal iff graph G contains no more augmenting\n                \/\/ paths\n                V v = findPath(i);\n                while (v != null) {\n                    V pv = path.get(v);\n                    V ppv = match.get(pv);\n                    match.put(v, pv);\n                    match.put(pv, v);\n                    v = ppv;\n                }\n            }\n        }\n\n        Set<V> seen = new HashSet<V>();\n        for (V v : graph.vertexSet()) {\n            if (!seen.contains(v) && match.containsKey(v)) {\n                seen.add(v);\n                seen.add(match.get(v));\n                result.add(graph.getEdge(v, match.get(v)));\n            }\n        }\n\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Runs the algorithm on the input graph and returns the match edge set.\n     *\n     * @return set of Edges\n     ","methodParameters":[],"methodName":"findMatch","methodQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.findMatch","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Runs the algorithm on the input graph and returns the match edge set.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of Edges'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 118,col 29)-(line 118,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.findMatch()"},{"methodDeclaration":"private V findPath(V root)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<V> used = new HashSet<V>();\n    Queue<V> q = new ArrayDeque<V>();\n    path.clear();\n    contracted.clear();\n    for (V i : graph.vertexSet()) {\n        contracted.put(i, i);\n    }\n    used.add(root);\n    q.add(root);\n    while (!q.isEmpty()) {\n        V v = q.remove();\n        for (E e : graph.edgesOf(v)) {\n            V to = graph.getEdgeSource(e);\n            if (to == v) {\n                to = graph.getEdgeTarget(e);\n            }\n            if ((contracted.get(v) == contracted.get(to)) || (match.get(v) == to)) {\n                continue;\n            }\n            if ((to == root) || ((match.containsKey(to)) && (path.containsKey(match.get(to))))) {\n                V stem = lca(v, to);\n                Set<V> blossom = new HashSet<V>();\n                markPath(v, to, stem, blossom);\n                markPath(to, v, stem, blossom);\n                for (V i : graph.vertexSet()) {\n                    if (contracted.containsKey(i) && blossom.contains(contracted.get(i))) {\n                        contracted.put(i, stem);\n                        if (!used.contains(i)) {\n                            used.add(i);\n                            q.add(i);\n                        }\n                    }\n                }\n            } else if (!path.containsKey(to)) {\n                path.put(to, v);\n                if (!match.containsKey(to)) {\n                    return to;\n                }\n                to = match.get(to);\n                used.add(to);\n                q.add(to);\n            }\n        }\n    }\n    return null;\n}","methodRange":"(line 140,col 5)-(line 216,col 5)","methodTokenRange":"private V findPath(V root)\n    {\n        Set<V> used = new HashSet<V>();\n        Queue<V> q = new ArrayDeque<V>();\n\n        \/\/ Expand graph back from its contracted state\n        path.clear();\n        contracted.clear();\n\n        for (V i : graph.vertexSet()) {\n            contracted.put(i, i);\n        }\n\n        used.add(root);\n        q.add(root);\n\n        while (!q.isEmpty()) {\n            V v = q.remove();\n\n            for (E e : graph.edgesOf(v)) {\n                V to = graph.getEdgeSource(e);\n\n                if (to == v) {\n                    to = graph.getEdgeTarget(e);\n                }\n\n                if ((contracted.get(v) == contracted.get(to))\n                    || (match.get(v) == to))\n                {\n                    continue;\n                }\n\n                \/\/ Check whether we've hit a 'blossom'\n                if ((to == root)\n                    || ((match.containsKey(to))\n                        && (path.containsKey(match.get(to)))))\n                {\n                    V stem = lca(v, to);\n\n                    Set<V> blossom = new HashSet<V>();\n\n                    \/\/ ?\n                    markPath(v, to, stem, blossom);\n                    markPath(to, v, stem, blossom);\n\n                    for (V i : graph.vertexSet()) {\n                        if (contracted.containsKey(i)\n                            && blossom.contains(contracted.get(i)))\n                        {\n                            contracted.put(i, stem);\n\n                            \/\/ ???\n                            if (!used.contains(i)) {\n                                used.add(i);\n                                q.add(i);\n                            }\n                        }\n                    }\n\n                    \/\/ Check whether we've had hit a loop (of even length (!)\n                    \/\/ presumably)\n                } else if (!path.containsKey(to)) {\n                    path.put(to, v);\n\n                    if (!match.containsKey(to)) {\n                        return to;\n                    }\n\n                    to = match.get(to);\n\n                    used.add(to);\n                    q.add(to);\n                }\n            }\n        }\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V root","parameterName":"root"}],"methodName":"findPath","methodQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.findPath","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 215,col 16)-(line 215,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.findPath(V)"},{"methodDeclaration":"private void markPath(V v, V child, V stem, Set<V> blossom)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    while (contracted.get(v) != stem) {\n        blossom.add(contracted.get(v));\n        blossom.add(contracted.get(match.get(v)));\n        path.put(v, child);\n        child = match.get(v);\n        v = path.get(match.get(v));\n    }\n}","methodRange":"(line 218,col 5)-(line 227,col 5)","methodTokenRange":"private void markPath(V v, V child, V stem, Set<V> blossom)\n    {\n        while (contracted.get(v) != stem) {\n            blossom.add(contracted.get(v));\n            blossom.add(contracted.get(match.get(v)));\n            path.put(v, child);\n            child = match.get(v);\n            v = path.get(match.get(v));\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V child","parameterName":"child"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V stem","parameterName":"stem"},{"parameterType":"Set<V>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> blossom","parameterName":"blossom"}],"methodName":"markPath","methodQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.markPath","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.markPath(V, V, V, java.util.Set<V>)"},{"methodDeclaration":"private V lca(V a, V b)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<V> seen = new HashSet<V>();\n    for (; ; ) {\n        a = contracted.get(a);\n        seen.add(a);\n        if (!match.containsKey(a)) {\n            break;\n        }\n        a = path.get(match.get(a));\n    }\n    for (; ; ) {\n        b = contracted.get(b);\n        if (seen.contains(b)) {\n            return b;\n        }\n        b = path.get(match.get(b));\n    }\n}","methodRange":"(line 229,col 5)-(line 247,col 5)","methodTokenRange":"private V lca(V a, V b)\n    {\n        Set<V> seen = new HashSet<V>();\n        for (;;) {\n            a = contracted.get(a);\n            seen.add(a);\n            if (!match.containsKey(a)) {\n                break;\n            }\n            a = path.get(match.get(a));\n        }\n        for (;;) {\n            b = contracted.get(b);\n            if (seen.contains(b)) {\n                return b;\n            }\n            b = path.get(match.get(b));\n        }\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"lca","methodQualifiedSignature":"org.jgrapht.alg.EdmondsBlossomShrinking.lca","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.EdmondsBlossomShrinking.lca(V, V)"}],"classJavadoc":"\/**\n * An implementation of Edmonds Blossom Shrinking algorithm for constructing\n * maximum matchings on graphs. The algorithm runs in time O(V^4).\n *\n * @author Alejandro R. Lopez del Huerto\n * @since Jan 24, 2012\n *\/\n","className":"EdmondsBlossomShrinking","fields":[{"fieldRange":"(line 57,col 5)-(line 57,col 40)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private UndirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 59,col 5)-(line 59,col 28)","fieldName":"matching","fieldJavadocComment":"","fieldTokenRange":"private Set<E> matching;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 61,col 5)-(line 61,col 28)","fieldName":"match","fieldJavadocComment":"","fieldTokenRange":"private Map<V, V> match;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, V>"},{"fieldRange":"(line 62,col 5)-(line 62,col 27)","fieldName":"path","fieldJavadocComment":"","fieldTokenRange":"private Map<V, V> path;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, V>"},{"fieldRange":"(line 63,col 5)-(line 63,col 33)","fieldName":"contracted","fieldJavadocComment":"","fieldTokenRange":"private Map<V, V> contracted;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, V>"}]}],"sourceFileId":178,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.TransitiveClosure","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.TransitiveClosure.TransitiveClosure()","variableDeclarationExprs":[],"constructorRange":"(line 58,col 5)-(line 60,col 5)","constructorJavadocComment":"\n     * Private Constructor.\n     ","constructorDeclaration":"private TransitiveClosure()","constructorBody":"{\n}","constructorName":"TransitiveClosure","constructorQualifiedName":"org.jgrapht.alg.TransitiveClosure.TransitiveClosure","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"private TransitiveClosure()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private Constructor.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"- Graph to compute transitive closure for.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- Graph to compute transitive closure for.'}]}', name=Optional[graph]}"}],"methodDeclaration":"public void closeSimpleDirectedGraph(SimpleDirectedGraph<V, E> graph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> vertexSet = graph.vertexSet();\n    Set<V> newEdgeTargets = new HashSet<V>();\n    int bound = computeBinaryLog(vertexSet.size());\n    boolean done = false;\n    for (int i = 0; !done && (i < bound); ++i) {\n        done = true;\n        for (V v1 : vertexSet) {\n            newEdgeTargets.clear();\n            for (E v1OutEdge : graph.outgoingEdgesOf(v1)) {\n                V v2 = graph.getEdgeTarget(v1OutEdge);\n                for (E v2OutEdge : graph.outgoingEdgesOf(v2)) {\n                    V v3 = graph.getEdgeTarget(v2OutEdge);\n                    if (v1.equals(v3)) {\n                        continue;\n                    }\n                    if (graph.getEdge(v1, v3) != null) {\n                        continue;\n                    }\n                    newEdgeTargets.add(v3);\n                    done = false;\n                }\n            }\n            for (V v3 : newEdgeTargets) {\n                graph.addEdge(v1, v3);\n            }\n        }\n    }\n}","methodRange":"(line 67,col 5)-(line 110,col 5)","methodTokenRange":"public <V, E> void closeSimpleDirectedGraph(SimpleDirectedGraph<V, E> graph)\n    {\n        Set<V> vertexSet = graph.vertexSet();\n\n        Set<V> newEdgeTargets = new HashSet<V>();\n\n        \/\/ At every iteration of the outer loop, we add a path of length 1\n        \/\/ between nodes that originally had a path of length 2. In the worst\n        \/\/ case, we need to make floor(log |V|) + 1 iterations. We stop earlier\n        \/\/ if there is no change to the output graph.\n\n        int bound = computeBinaryLog(vertexSet.size());\n        boolean done = false;\n        for (int i = 0; !done && (i < bound); ++i) {\n            done = true;\n            for (V v1 : vertexSet) {\n                newEdgeTargets.clear();\n\n                for (E v1OutEdge : graph.outgoingEdgesOf(v1)) {\n                    V v2 = graph.getEdgeTarget(v1OutEdge);\n                    for (E v2OutEdge : graph.outgoingEdgesOf(v2)) {\n                        V v3 = graph.getEdgeTarget(v2OutEdge);\n\n                        if (v1.equals(v3)) {\n                            \/\/ Its a simple graph, so no self loops.\n                            continue;\n                        }\n\n                        if (graph.getEdge(v1, v3) != null) {\n                            \/\/ There is already an edge from v1 ---> v3, skip;\n                            continue;\n                        }\n\n                        newEdgeTargets.add(v3);\n                        done = false;\n                    }\n                }\n\n                for (V v3 : newEdgeTargets) {\n                    graph.addEdge(v1, v3);\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Computes the transitive closure of the given graph.\n     *\n     * @param graph - Graph to compute transitive closure for.\n     ","methodParameters":[{"parameterType":"SimpleDirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.SimpleDirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.SimpleDirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.SimpleDirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.SimpleDirectedGraph<V, E>","parameter":"SimpleDirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"closeSimpleDirectedGraph","methodQualifiedSignature":"org.jgrapht.alg.TransitiveClosure.closeSimpleDirectedGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes the transitive closure of the given graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='- Graph to compute transitive closure for.'}]}', name=Optional[graph]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 79,col 24)-(line 79,col 28)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 80,col 22)-(line 80,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 81,col 20)-(line 81,col 23)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 95,col 54)-(line 95,col 57)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 101,col 32)-(line 101,col 36)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.TransitiveClosure.closeSimpleDirectedGraph(org.jgrapht.graph.SimpleDirectedGraph<V, E>)"},{"javadocBlockTags":[],"methodDeclaration":"private int computeBinaryLog(int n)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    assert n >= 0;\n    int result = 0;\n    while (n > 0) {\n        n >>= 1;\n        ++result;\n    }\n    return result;\n}","methodRange":"(line 115,col 5)-(line 126,col 5)","methodTokenRange":"private int computeBinaryLog(int n)\n    {\n        assert n >= 0;\n\n        int result = 0;\n        while (n > 0) {\n            n >>= 1;\n            ++result;\n        }\n\n        return result;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Computes floor(log_2(n)) + 1\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int n","parameterName":"n"}],"methodName":"computeBinaryLog","methodQualifiedSignature":"org.jgrapht.alg.TransitiveClosure.computeBinaryLog","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes floor(log_2(n)) + 1'}]}, blockTags=[]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 117,col 21)-(line 117,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 119,col 22)-(line 119,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 120,col 20)-(line 120,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 121,col 19)-(line 121,col 19)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.TransitiveClosure.computeBinaryLog(int)"}],"classJavadoc":"\/**\n * Constructs the transitive closure of the input graph.\n *\n * @author Vinayak R. Borkar\n * @since May 5, 2007\n *\/\n","className":"TransitiveClosure","fields":[{"fieldRange":"(line 53,col 5)-(line 53,col 77)","fieldName":"INSTANCE","fieldJavadocComment":"\n     * Singleton instance.\n     ","fieldTokenRange":"public static final TransitiveClosure INSTANCE = new TransitiveClosure();","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.TransitiveClosure, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new TransitiveClosure()]","fieldType":"TransitiveClosure","fieldJavadoc":"Singleton instance.\n","fieldTypeResolvedDescribed":"org.jgrapht.alg.TransitiveClosure"}]}],"sourceFileId":179,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"HopcroftKarpBipartiteMatching","constructorQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.HopcroftKarpBipartiteMatching","constructorQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.HopcroftKarpBipartiteMatching(org.jgrapht.UndirectedGraph<V, E>, java.util.Set<V>, java.util.Set<V>)","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> partition1","parameterName":"partition1"},{"parameterType":"Set<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> partition2","parameterName":"partition2"}],"literalExprs":[],"constructorTokenRange":"public HopcroftKarpBipartiteMatching(\n        UndirectedGraph<V, E> graph,\n        Set<V> partition1,\n        Set<V> partition2)\n    {\n        this.graph = graph;\n        this.partition1 = partition1;\n        this.partition2 = partition2;\n        matching = new HashSet<E>();\n\n        unmatchedVertices1 = new HashSet<V>(partition1);\n        unmatchedVertices2 = new HashSet<V>(partition2);\n\n        assert this.checkInputData();\n        this.maxMatching();\n    }","variableDeclarationExprs":[],"constructorRange":"(line 70,col 5)-(line 85,col 5)","constructorJavadocComment":"","constructorDeclaration":"public HopcroftKarpBipartiteMatching(UndirectedGraph<V, E> graph, Set<V> partition1, Set<V> partition2)","constructorBody":"{\n    this.graph = graph;\n    this.partition1 = partition1;\n    this.partition2 = partition2;\n    matching = new HashSet<E>();\n    unmatchedVertices1 = new HashSet<V>(partition1);\n    unmatchedVertices2 = new HashSet<V>(partition2);\n    assert this.checkInputData();\n    this.maxMatching();\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"private boolean checkInputData()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (graph instanceof Multigraph) {\n        throw new IllegalArgumentException(\"Multi graphs are not allowed as input, only simple graphs!\");\n    }\n    Set<V> neighborsSet1 = new HashSet<V>();\n    for (V v : partition1) {\n        neighborsSet1.addAll(Graphs.neighborListOf(graph, v));\n    }\n    if (interSectionNotEmpty(partition1, neighborsSet1)) {\n        throw new IllegalArgumentException(\"There are edges within partition 1, i.e. not a bipartite graph\");\n    }\n    Set<V> neighborsSet2 = new HashSet<V>();\n    for (V v : partition2) {\n        neighborsSet2.addAll(Graphs.neighborListOf(graph, v));\n    }\n    if (interSectionNotEmpty(partition2, neighborsSet2)) {\n        throw new IllegalArgumentException(\"There are edges within partition 2, i.e. not a bipartite graph\");\n    }\n    return true;\n}","methodRange":"(line 91,col 5)-(line 116,col 5)","methodTokenRange":"private boolean checkInputData()\n    {\n        if (graph instanceof Multigraph) {\n            throw new IllegalArgumentException(\n                \"Multi graphs are not allowed as input, only simple graphs!\");\n        }\n\n        \/\/Test the bipartite-ness\n        Set<V> neighborsSet1 = new HashSet<V>();\n        for (V v : partition1) {\n            neighborsSet1.addAll(Graphs.neighborListOf(graph, v));\n        }\n        if (interSectionNotEmpty(partition1, neighborsSet1)) {\n            throw new IllegalArgumentException(\n                \"There are edges within partition 1, i.e. not a bipartite graph\");\n        }\n        Set<V> neighborsSet2 = new HashSet<V>();\n        for (V v : partition2) {\n            neighborsSet2.addAll(Graphs.neighborListOf(graph, v));\n        }\n        if (interSectionNotEmpty(partition2, neighborsSet2)) {\n            throw new IllegalArgumentException(\n                \"There are edges within partition 2, i.e. not a bipartite graph\");\n        }\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Checks whether the input data meets the requirements: simple undirected\n     * graph and bipartite partitions.\n     ","methodParameters":[],"methodName":"checkInputData","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.checkInputData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks whether the input data meets the requirements: simple undirected\ngraph and bipartite partitions.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 95,col 17)-(line 95,col 76)","literalExprId":1,"literalExpr":"\"Multi graphs are not allowed as input, only simple graphs!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 105,col 17)-(line 105,col 80)","literalExprId":2,"literalExpr":"\"There are edges within partition 1, i.e. not a bipartite graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 113,col 17)-(line 113,col 80)","literalExprId":3,"literalExpr":"\"There are edges within partition 2, i.e. not a bipartite graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 115,col 16)-(line 115,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.checkInputData()"},{"javadocBlockTags":[],"methodDeclaration":"private void greedyMatch()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    HashSet<V> usedVertices = new HashSet<V>();\n    for (V vertex1 : partition1) {\n        for (V vertex2 : Graphs.neighborListOf(graph, vertex1)) {\n            if (!usedVertices.contains(vertex2)) {\n                usedVertices.add(vertex2);\n                unmatchedVertices1.remove(vertex1);\n                unmatchedVertices2.remove(vertex2);\n                matching.add(graph.getEdge(vertex1, vertex2));\n                break;\n            }\n        }\n    }\n}","methodRange":"(line 123,col 5)-(line 138,col 5)","methodTokenRange":"private void greedyMatch()\n    {\n        HashSet<V> usedVertices = new HashSet<V>();\n\n        for (V vertex1 : partition1) {\n            for (V vertex2 : Graphs.neighborListOf(graph, vertex1)) {\n                if (!usedVertices.contains(vertex2)) {\n                    usedVertices.add(vertex2);\n                    unmatchedVertices1.remove(vertex1);\n                    unmatchedVertices2.remove(vertex2);\n                    matching.add(graph.getEdge(vertex1, vertex2));\n                    break;\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Greedily match the vertices in partition1 to the vertices in partition2.\n     * For each vertex in partition 1, check whether there is an edge to an\n     * unmatched vertex in partition 2. If so, add the edge to the matching.\n     ","methodParameters":[],"methodName":"greedyMatch","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.greedyMatch","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Greedily match the vertices in partition1 to the vertices in partition2.\nFor each vertex in partition 1, check whether there is an edge to an\nunmatched vertex in partition 2. If so, add the edge to the matching.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.greedyMatch()"},{"javadocBlockTags":[],"methodDeclaration":"private void maxMatching()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    this.greedyMatch();\n    List<LinkedList<V>> augmentingPaths = this.getAugmentingPaths();\n    while (!augmentingPaths.isEmpty()) {\n        for (Iterator<LinkedList<V>> it = augmentingPaths.iterator(); it.hasNext(); ) {\n            LinkedList<V> augmentingPath = it.next();\n            unmatchedVertices1.remove(augmentingPath.getFirst());\n            unmatchedVertices2.remove(augmentingPath.getLast());\n            this.symmetricDifference(augmentingPath);\n            it.remove();\n        }\n        augmentingPaths.addAll(this.getAugmentingPaths());\n    }\n}","methodRange":"(line 145,col 5)-(line 163,col 5)","methodTokenRange":"private void maxMatching()\n    {\n        this.greedyMatch();\n\n        List<LinkedList<V>> augmentingPaths = this.getAugmentingPaths(); \/\/Get a list with augmenting paths\n        while (!augmentingPaths.isEmpty()) {\n            for (\n                Iterator<LinkedList<V>> it = augmentingPaths.iterator();\n                it.hasNext();)\n            { \/\/Process all augmenting paths\n                LinkedList<V> augmentingPath = it.next();\n                unmatchedVertices1.remove(augmentingPath.getFirst());\n                unmatchedVertices2.remove(augmentingPath.getLast());\n                this.symmetricDifference(augmentingPath);\n                it.remove();\n            }\n            augmentingPaths.addAll(this.getAugmentingPaths()); \/\/Check whether there are new augmenting paths available\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * This method is the main method of the class. First it finds a greedy\n     * matching. Next it tries to improve the matching by finding all the\n     * augmenting paths. This leads to a maximum matching.\n     ","methodParameters":[],"methodName":"maxMatching","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.maxMatching","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This method is the main method of the class. First it finds a greedy\nmatching. Next it tries to improve the matching by finding all the\naugmenting paths. This leads to a maximum matching.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.maxMatching()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"augmentingPath","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[augmentingPath]}"}],"methodDeclaration":"private void symmetricDifference(LinkedList<V> augmentingPath)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int operation = 0;\n    while (augmentingPath.size() > 0) {\n        E edge = graph.getEdge(augmentingPath.poll(), augmentingPath.peek());\n        if ((operation % 2) == 0) {\n            matching.add(edge);\n        } else {\n            matching.remove(edge);\n        }\n        operation++;\n    }\n}","methodRange":"(line 173,col 5)-(line 190,col 5)","methodTokenRange":"private void symmetricDifference(LinkedList<V> augmentingPath)\n    {\n        int operation = 0;\n\n        \/\/The augmenting path alternatingly has an edge which is not part of the\n        \/\/matching, and an edge which is part of the matching. Edges which are\n        \/\/already part of the matching are removed, the others are added.\n        while (augmentingPath.size() > 0) {\n            E edge =\n                graph.getEdge(augmentingPath.poll(), augmentingPath.peek());\n            if ((operation % 2) == 0) {\n                matching.add(edge);\n            } else {\n                matching.remove(edge);\n            }\n            operation++;\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Given are the current matching and a new augmenting path p. p.getFirst()\n     * and p.getLast() are newly matched vertices. This method updates the edges\n     * which are part of the existing matching with the new augmenting path. As\n     * a result, the size of the matching increases with 1.\n     *\n     * @param augmentingPath\n     ","methodParameters":[{"parameterType":"LinkedList<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.LinkedList<V>","parameter":"LinkedList<V> augmentingPath","parameterName":"augmentingPath"}],"methodName":"symmetricDifference","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.symmetricDifference","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given are the current matching and a new augmenting path p. p.getFirst()\nand p.getLast() are newly matched vertices. This method updates the edges\nwhich are part of the existing matching with the new augmenting path. As\na result, the size of the matching increases with 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[augmentingPath]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 175,col 25)-(line 175,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 40)-(line 180,col 40)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 183,col 30)-(line 183,col 30)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 183,col 36)-(line 183,col 36)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.symmetricDifference(java.util.LinkedList<V>)"},{"methodDeclaration":"private List<LinkedList<V>> getAugmentingPaths()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<LinkedList<V>> augmentingPaths = new ArrayList<LinkedList<V>>();\n    Map<V, Set<V>> layeredMap = new HashMap<V, Set<V>>();\n    for (V vertex : unmatchedVertices1) {\n        layeredMap.put(vertex, new HashSet<V>());\n    }\n    Set<V> oddLayer = new HashSet<V>(unmatchedVertices1);\n    Set<V> evenLayer;\n    Set<V> usedVertices = new HashSet<V>(unmatchedVertices1);\n    while (true) {\n        evenLayer = new HashSet<V>();\n        for (V vertex : oddLayer) {\n            List<V> neighbors = Graphs.neighborListOf(graph, vertex);\n            for (V neighbor : neighbors) {\n                if (usedVertices.contains(neighbor)) {\n                    continue;\n                } else {\n                    evenLayer.add(neighbor);\n                    if (!layeredMap.containsKey(neighbor)) {\n                        layeredMap.put(neighbor, new HashSet<V>());\n                    }\n                    layeredMap.get(neighbor).add(vertex);\n                }\n            }\n        }\n        usedVertices.addAll(evenLayer);\n        if ((evenLayer.size() == 0) || this.interSectionNotEmpty(evenLayer, unmatchedVertices2)) {\n            break;\n        }\n        oddLayer = new HashSet<V>();\n        for (V vertex : evenLayer) {\n            List<V> neighbors = Graphs.neighborListOf(graph, vertex);\n            for (V neighbor : neighbors) {\n                if (usedVertices.contains(neighbor) || !matching.contains(graph.getEdge(vertex, neighbor))) {\n                    continue;\n                } else {\n                    oddLayer.add(neighbor);\n                    if (!layeredMap.containsKey(neighbor)) {\n                        layeredMap.put(neighbor, new HashSet<V>());\n                    }\n                    layeredMap.get(neighbor).add(vertex);\n                }\n            }\n        }\n        usedVertices.addAll(oddLayer);\n    }\n    if (evenLayer.size() == 0) {\n        return augmentingPaths;\n    } else {\n        evenLayer.retainAll(unmatchedVertices2);\n    }\n    for (V vertex : evenLayer) {\n        LinkedList<V> augmentingPath = dfs(vertex, layeredMap);\n        if (augmentingPath != null) {\n            augmentingPaths.add(augmentingPath);\n            for (V augmentingVertex : augmentingPath) {\n                layeredMap.remove(augmentingVertex);\n            }\n        }\n    }\n    return augmentingPaths;\n}","methodRange":"(line 192,col 5)-(line 292,col 5)","methodTokenRange":"private List<LinkedList<V>> getAugmentingPaths()\n    {\n        List<LinkedList<V>> augmentingPaths = new ArrayList<LinkedList<V>>();\n\n        \/\/1. Build data structure\n        Map<V, Set<V>> layeredMap = new HashMap<V, Set<V>>();\n        for (V vertex : unmatchedVertices1) {\n            layeredMap.put(vertex, new HashSet<V>());\n        }\n\n        Set<V> oddLayer = new HashSet<V>(unmatchedVertices1); \/\/Layer L0 contains the unmatchedVertices1.\n        Set<V> evenLayer;\n        Set<V> usedVertices = new HashSet<V>(unmatchedVertices1);\n\n        while (true) {\n            \/\/Create a new even Layer A new layer can ONLY contain vertices\n            \/\/which are not used in the previous layers Edges between odd and\n            \/\/even layers can NOT be part of the matching\n            evenLayer = new HashSet<V>();\n            for (V vertex : oddLayer) {\n                \/\/List<V> neighbors=this.getNeighbors(vertex);\n                List<V> neighbors = Graphs.neighborListOf(graph, vertex);\n                for (V neighbor : neighbors) {\n                    if (usedVertices.contains(neighbor)) {\n                        \/\/ Vertices placed into odd-layer may not be matched by\n                        \/\/ any other vertices except for the one we came from\n                        continue;\n                    } else {\n                        evenLayer.add(neighbor);\n                        if (!layeredMap.containsKey(neighbor)) {\n                            layeredMap.put(neighbor, new HashSet<V>());\n                        }\n                        layeredMap.get(neighbor).add(vertex);\n                    }\n                }\n            }\n            usedVertices.addAll(evenLayer);\n\n            \/\/Check whether we are finished generating layers. We are finished\n            \/\/if 1. the last layer is empty or 2. if we reached free vertices\n            \/\/in partition2.\n            if ((evenLayer.size() == 0)\n                || this.interSectionNotEmpty(evenLayer, unmatchedVertices2))\n            {\n                break;\n            }\n\n            \/\/Create a new odd Layer A new layer can ONLY contain vertices which\n            \/\/are not used in the previous layers Edges between EVEN and ODD\n            \/\/layers SHOULD be part of the matching\n            oddLayer = new HashSet<V>();\n            for (V vertex : evenLayer) {\n                List<V> neighbors = Graphs.neighborListOf(graph, vertex);\n                for (V neighbor : neighbors) {\n                    if (usedVertices.contains(neighbor)\n                        || !matching.contains(\n                            graph.getEdge(vertex, neighbor)))\n                    {\n                        continue;\n                    } else {\n                        oddLayer.add(neighbor);\n                        if (!layeredMap.containsKey(neighbor)) {\n                            layeredMap.put(neighbor, new HashSet<V>());\n                        }\n                        layeredMap.get(neighbor).add(vertex);\n                    }\n                }\n            }\n            usedVertices.addAll(oddLayer);\n        }\n\n        \/\/Check whether there exist augmenting paths. If not, return an empty\n        \/\/list. Else, we need to generate the augmenting paths which start at\n        \/\/free vertices in the even layer and end at the free vertices at the\n        \/\/first odd layer (L0).\n        if (evenLayer.size() == 0) {\n            return augmentingPaths;\n        } else {\n            evenLayer.retainAll(unmatchedVertices2);\n        }\n\n        \/\/Finally, do a depth-first search, starting on the free vertices in the\n        \/\/last even layer. Objective is to find as many vertex disjoint paths\n        \/\/as possible.\n        for (V vertex : evenLayer) {\n            \/\/Calculate an augmenting path, starting at the given vertex.\n            LinkedList<V> augmentingPath = dfs(vertex, layeredMap);\n\n            \/\/If the augmenting path exists, add it to the list of paths and\n            \/\/remove the vertices from the map to enforce that the paths are\n            \/\/vertex disjoint, i.e. a vertex cannot occur in more than 1 path.\n            if (augmentingPath != null) {\n                augmentingPaths.add(augmentingPath);\n                for (V augmentingVertex : augmentingPath) {\n                    layeredMap.remove(augmentingVertex);\n                }\n            }\n        }\n\n        return augmentingPaths;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getAugmentingPaths","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.getAugmentingPaths","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<java.util.LinkedList<V>>","methodType":"List<LinkedList<V>>","literalExprs":[{"literalExprRange":"(line 206,col 16)-(line 206,col 19)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 233,col 38)-(line 233,col 38)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 267,col 33)-(line 267,col 33)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 283,col 35)-(line 283,col 38)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.getAugmentingPaths()"},{"methodDeclaration":"private LinkedList<V> dfs(V startVertex, Map<V, Set<V>> layeredMap)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!layeredMap.containsKey(startVertex)) {\n        return null;\n    } else if (unmatchedVertices1.contains(startVertex)) {\n        LinkedList<V> list = new LinkedList<V>();\n        list.add(startVertex);\n        return list;\n    } else {\n        LinkedList<V> partialPath = null;\n        for (V vertex : layeredMap.get(startVertex)) {\n            partialPath = dfs(vertex, layeredMap);\n            if (partialPath != null) {\n                partialPath.add(startVertex);\n                break;\n            }\n        }\n        return partialPath;\n    }\n}","methodRange":"(line 294,col 5)-(line 313,col 5)","methodTokenRange":"private LinkedList<V> dfs(V startVertex, Map<V, Set<V>> layeredMap)\n    {\n        if (!layeredMap.containsKey(startVertex)) {\n            return null;\n        } else if (unmatchedVertices1.contains(startVertex)) {\n            LinkedList<V> list = new LinkedList<V>();\n            list.add(startVertex);\n            return list;\n        } else {\n            LinkedList<V> partialPath = null;\n            for (V vertex : layeredMap.get(startVertex)) {\n                partialPath = dfs(vertex, layeredMap);\n                if (partialPath != null) {\n                    partialPath.add(startVertex);\n                    break;\n                }\n            }\n            return partialPath;\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"Map<V, Set<V>>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.util.Set<V>>","parameter":"Map<V, Set<V>> layeredMap","parameterName":"layeredMap"}],"methodName":"dfs","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.dfs","methodJavadoc":"","methodReturnTypeDescribed":"java.util.LinkedList<V>","methodType":"LinkedList<V>","literalExprs":[{"literalExprRange":"(line 297,col 20)-(line 297,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 303,col 41)-(line 303,col 44)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 306,col 36)-(line 306,col 39)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.dfs(V, java.util.Map<V, java.util.Set<V>>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertexSet1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexSet1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertexSet2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexSet2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the intersection is NOT empty.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the intersection is NOT empty.'}]}', name=Optional.empty}"}],"methodDeclaration":"private boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V vertex : vertexSet1) {\n        if (vertexSet2.contains(vertex)) {\n            return true;\n        }\n    }\n    return false;\n}","methodRange":"(line 323,col 5)-(line 331,col 5)","methodTokenRange":"private boolean interSectionNotEmpty(Set<V> vertexSet1, Set<V> vertexSet2)\n    {\n        for (V vertex : vertexSet1) {\n            if (vertexSet2.contains(vertex)) {\n                return true;\n            }\n        }\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Helper method which checks whether the intersection of 2 sets is empty.\n     *\n     * @param vertexSet1\n     * @param vertexSet2\n     *\n     * @return true if the intersection is NOT empty.\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSet1","parameterName":"vertexSet1"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSet2","parameterName":"vertexSet2"}],"methodName":"interSectionNotEmpty","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.interSectionNotEmpty","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Helper method which checks whether the intersection of 2 sets is empty.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexSet1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertexSet2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the intersection is NOT empty.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 327,col 24)-(line 327,col 27)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 330,col 16)-(line 330,col 20)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.interSectionNotEmpty(java.util.Set<V>, java.util.Set<V>)"},{"methodDeclaration":"public Set<E> getMatching()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return Collections.unmodifiableSet(matching);\n}","methodRange":"(line 333,col 5)-(line 336,col 5)","methodTokenRange":"@Override public Set<E> getMatching()\n    {\n        return Collections.unmodifiableSet(matching);\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getMatching","methodQualifiedSignature":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.getMatching","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.HopcroftKarpBipartiteMatching.getMatching()"}],"classJavadoc":"","className":"HopcroftKarpBipartiteMatching","fields":[{"fieldRange":"(line 61,col 5)-(line 61,col 46)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final UndirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 62,col 5)-(line 62,col 36)","fieldName":"partition1","fieldJavadocComment":"Partitions of bipartite graph","fieldTokenRange":"private final Set<V> partition1;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 63,col 5)-(line 63,col 36)","fieldName":"partition2","fieldJavadocComment":"","fieldTokenRange":"private final Set<V> partition2;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 64,col 5)-(line 64,col 28)","fieldName":"matching","fieldJavadocComment":"Set containing the matchings","fieldTokenRange":"private Set<E> matching;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 66,col 5)-(line 66,col 44)","fieldName":"unmatchedVertices1","fieldJavadocComment":"Set which contains the unmatched","fieldTokenRange":"private final Set<V> unmatchedVertices1;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 68,col 5)-(line 68,col 44)","fieldName":"unmatchedVertices2","fieldJavadocComment":"vertices in partition 1","fieldTokenRange":"private final Set<V> unmatchedVertices2;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"}]}],"sourceFileId":180,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.StoerWagnerMinimumCut","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph over which to run algorithm","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph over which to run algorithm'}]}', name=Optional[graph]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if a negative weight edge is found","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a negative weight edge is found'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if graph has less than 2 vertices","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if graph has less than 2 vertices'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.StoerWagnerMinimumCut.StoerWagnerMinimumCut(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[{"variableType":"Map<V, Set<V>>","variableName":"vertexMap","variableDeclarationExprId":1,"variableDeclarationExpr":"Map<V, Set<V>> vertexMap = new HashMap<V, Set<V>>()","variableDeclarationExprRange":"(line 80,col 9)-(line 80,col 59)","variableTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","variableRange":"(line 80,col 24)-(line 80,col 59)"},{"variableType":"V","variableName":"v","variableDeclarationExprId":2,"variableDeclarationExpr":"V v","variableDeclarationExprRange":"(line 81,col 14)-(line 81,col 16)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 81,col 16)-(line 81,col 16)"},{"variableType":"Set<V>","variableName":"list","variableDeclarationExprId":3,"variableDeclarationExpr":"Set<V> list = new HashSet<V>()","variableDeclarationExprRange":"(line 82,col 13)-(line 82,col 42)","variableTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 82,col 20)-(line 82,col 42)"},{"variableType":"E","variableName":"e","variableDeclarationExprId":4,"variableDeclarationExpr":"E e","variableDeclarationExprRange":"(line 87,col 14)-(line 87,col 16)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 87,col 16)-(line 87,col 16)"},{"variableType":"V","variableName":"s","variableDeclarationExprId":5,"variableDeclarationExpr":"V s = graph.getEdgeSource(e)","variableDeclarationExprRange":"(line 93,col 13)-(line 93,col 40)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 93,col 15)-(line 93,col 40)"},{"variableType":"Set<V>","variableName":"sNew","variableDeclarationExprId":6,"variableDeclarationExpr":"Set<V> sNew = vertexMap.get(s)","variableDeclarationExprRange":"(line 94,col 13)-(line 94,col 42)","variableTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 94,col 20)-(line 94,col 42)"},{"variableType":"V","variableName":"t","variableDeclarationExprId":7,"variableDeclarationExpr":"V t = graph.getEdgeTarget(e)","variableDeclarationExprRange":"(line 95,col 13)-(line 95,col 40)","variableTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","variableRange":"(line 95,col 15)-(line 95,col 40)"},{"variableType":"Set<V>","variableName":"tNew","variableDeclarationExprId":8,"variableDeclarationExpr":"Set<V> tNew = vertexMap.get(t)","variableDeclarationExprRange":"(line 96,col 13)-(line 96,col 42)","variableTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 96,col 20)-(line 96,col 42)"},{"variableType":"DefaultWeightedEdge","variableName":"eNew","variableDeclarationExprId":9,"variableDeclarationExpr":"DefaultWeightedEdge eNew = workingGraph.getEdge(sNew, tNew)","variableDeclarationExprRange":"(line 100,col 13)-(line 100,col 71)","variableTypeResolved":"ReferenceType{org.jgrapht.graph.DefaultWeightedEdge, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 100,col 33)-(line 100,col 71)"},{"variableType":"Set<V>","variableName":"a","variableDeclarationExprId":10,"variableDeclarationExpr":"Set<V> a = workingGraph.vertexSet().iterator().next()","variableDeclarationExprRange":"(line 112,col 9)-(line 112,col 61)","variableTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","variableRange":"(line 112,col 16)-(line 112,col 61)"}],"constructorRange":"(line 69,col 5)-(line 117,col 5)","constructorJavadocComment":"\n     * Will compute the minimum cut in graph.\n     *\n     * @param graph graph over which to run algorithm\n     *\n     * @throws IllegalArgumentException if a negative weight edge is found\n     * @throws IllegalArgumentException if graph has less than 2 vertices\n     ","constructorDeclaration":"public StoerWagnerMinimumCut(UndirectedGraph<V, E> graph)","constructorBody":"{\n    if (graph.vertexSet().size() < 2) {\n        throw new IllegalArgumentException(\"Graph has less than 2 vertices\");\n    }\n    workingGraph = new SimpleWeightedGraph<Set<V>, DefaultWeightedEdge>(DefaultWeightedEdge.class);\n    Map<V, Set<V>> vertexMap = new HashMap<V, Set<V>>();\n    for (V v : graph.vertexSet()) {\n        Set<V> list = new HashSet<V>();\n        list.add(v);\n        vertexMap.put(v, list);\n        workingGraph.addVertex(list);\n    }\n    for (E e : graph.edgeSet()) {\n        if (graph.getEdgeWeight(e) < 0.0) {\n            throw new IllegalArgumentException(\"Negative edge weights not allowed\");\n        }\n        V s = graph.getEdgeSource(e);\n        Set<V> sNew = vertexMap.get(s);\n        V t = graph.getEdgeTarget(e);\n        Set<V> tNew = vertexMap.get(t);\n        DefaultWeightedEdge eNew = workingGraph.getEdge(sNew, tNew);\n        if (eNew == null) {\n            eNew = workingGraph.addEdge(sNew, tNew);\n            workingGraph.setEdgeWeight(eNew, graph.getEdgeWeight(e));\n        } else {\n            workingGraph.setEdgeWeight(eNew, workingGraph.getEdgeWeight(eNew) + graph.getEdgeWeight(e));\n        }\n    }\n    Set<V> a = workingGraph.vertexSet().iterator().next();\n    while (workingGraph.vertexSet().size() > 1) {\n        minimumCutPhase(a);\n    }\n}","constructorName":"StoerWagnerMinimumCut","constructorQualifiedName":"org.jgrapht.alg.StoerWagnerMinimumCut.StoerWagnerMinimumCut","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[{"literalExprRange":"(line 71,col 40)-(line 71,col 40)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 73,col 17)-(line 73,col 48)","literalExprId":2,"literalExpr":"\"Graph has less than 2 vertices\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 88,col 42)-(line 88,col 44)","literalExprId":3,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 90,col 21)-(line 90,col 55)","literalExprId":4,"literalExpr":"\"Negative edge weights not allowed\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 101,col 25)-(line 101,col 28)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 114,col 50)-(line 114,col 50)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public StoerWagnerMinimumCut(UndirectedGraph<V, E> graph)\n    {\n        if (graph.vertexSet().size() < 2) {\n            throw new IllegalArgumentException(\n                \"Graph has less than 2 vertices\");\n        }\n\n        \/\/get a version of this graph where each vertex is wrapped with a list\n        workingGraph =\n            new SimpleWeightedGraph<Set<V>, DefaultWeightedEdge>(\n                DefaultWeightedEdge.class);\n        Map<V, Set<V>> vertexMap = new HashMap<V, Set<V>>();\n        for (V v : graph.vertexSet()) {\n            Set<V> list = new HashSet<V>();\n            list.add(v);\n            vertexMap.put(v, list);\n            workingGraph.addVertex(list);\n        }\n        for (E e : graph.edgeSet()) {\n            if (graph.getEdgeWeight(e) < 0.0) {\n                throw new IllegalArgumentException(\n                    \"Negative edge weights not allowed\");\n            }\n\n            V s = graph.getEdgeSource(e);\n            Set<V> sNew = vertexMap.get(s);\n            V t = graph.getEdgeTarget(e);\n            Set<V> tNew = vertexMap.get(t);\n\n            \/\/ For multigraphs, we sum the edge weights (either all are\n            \/\/ contained in a cut, or none)\n            DefaultWeightedEdge eNew = workingGraph.getEdge(sNew, tNew);\n            if (eNew == null) {\n                eNew = workingGraph.addEdge(sNew, tNew);\n                workingGraph.setEdgeWeight(eNew, graph.getEdgeWeight(e));\n            } else {\n                workingGraph.setEdgeWeight(\n                    eNew,\n                    workingGraph.getEdgeWeight(eNew) + graph.getEdgeWeight(e));\n            }\n        }\n\n        \/\/arbitrary vertex used to seed the algorithm.\n        Set<V> a = workingGraph.vertexSet().iterator().next();\n\n        while (workingGraph.vertexSet().size() > 1) {\n            minimumCutPhase(a);\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Will compute the minimum cut in graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph over which to run algorithm'}]}', name=Optional[graph]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a negative weight edge is found'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if graph has less than 2 vertices'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 251,col 5)-(line 289,col 5)","classOrInterfaceTokenRange":"protected class VertexAndWeight\n        implements Comparable<VertexAndWeight>\n    {\n        public Set<V> vertex;\n        public Double weight;\n        public boolean active; \/\/ active == neighbour in A\n\n        public VertexAndWeight(Set<V> v, double w, boolean active)\n        {\n            this.vertex = v;\n            this.weight = w;\n            this.active = active;\n        }\n\n        \/**\n         * compareTo that sorts in reverse order because we need extract-max and\n         * queue provides extract-min.\n         *\/\n        @Override public int compareTo(VertexAndWeight that)\n        {\n            if (this.active && that.active) {\n                return -Double.compare(weight, that.weight);\n            }\n            if (this.active && !that.active) {\n                return -1;\n            }\n            if (!this.active && that.active) {\n                return +1;\n            }\n\n            \/\/ both inactive\n            return 0;\n        }\n\n        @Override public String toString()\n        {\n            return \"(\" + vertex + \", \" + weight + \")\";\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Class for weighted vertices\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Class for weighted vertices'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[],"methodDeclaration":"protected void minimumCutPhase(Set<V> a)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    Set<V> last = a, beforelast = null;\n    PriorityQueue<VertexAndWeight> queue = new PriorityQueue<VertexAndWeight>();\n    Map<Set<V>, VertexAndWeight> dmap = new HashMap<Set<V>, VertexAndWeight>();\n    for (Set<V> v : workingGraph.vertexSet()) {\n        if (v == a) {\n            continue;\n        }\n        DefaultWeightedEdge e = workingGraph.getEdge(v, a);\n        Double w = (e == null) ? 0.0 : workingGraph.getEdgeWeight(e);\n        VertexAndWeight vandw = new VertexAndWeight(v, w, e != null);\n        queue.add(vandw);\n        dmap.put(v, vandw);\n    }\n    while (!queue.isEmpty()) {\n        Set<V> v = queue.poll().vertex;\n        dmap.remove(v);\n        beforelast = last;\n        last = v;\n        for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n            Set<V> vc = Graphs.getOppositeVertex(workingGraph, e, v);\n            VertexAndWeight vcandw = dmap.get(vc);\n            if (vcandw != null) {\n                queue.remove(vcandw);\n                vcandw.active = true;\n                vcandw.weight += workingGraph.getEdgeWeight(e);\n                queue.add(vcandw);\n            }\n        }\n    }\n    double w = vertexWeight(last);\n    if (w < bestCutWeight) {\n        bestCutWeight = w;\n        bestCut = last;\n    }\n    mergeVertices(beforelast, last);\n}","methodRange":"(line 122,col 5)-(line 177,col 5)","methodTokenRange":"protected void minimumCutPhase(Set<V> a)\n    {\n        \/\/ The last and before last vertices added to A.\n        Set<V> last = a, beforelast = null;\n\n        \/\/ queue contains vertices not in A ordered by max weight of edges to A.\n        PriorityQueue<VertexAndWeight> queue =\n            new PriorityQueue<VertexAndWeight>();\n\n        \/\/ Maps vertices to elements of queue\n        Map<Set<V>, VertexAndWeight> dmap =\n            new HashMap<Set<V>, VertexAndWeight>();\n\n        \/\/ Initialize queue\n        for (Set<V> v : workingGraph.vertexSet()) {\n            if (v == a) {\n                continue;\n            }\n            DefaultWeightedEdge e = workingGraph.getEdge(v, a);\n            Double w = (e == null) ? 0.0 : workingGraph.getEdgeWeight(e);\n            VertexAndWeight vandw = new VertexAndWeight(v, w, e != null);\n            queue.add(vandw);\n            dmap.put(v, vandw);\n        }\n\n        \/\/ Now iteratively update the queue to get the required vertex ordering\n\n        while (!queue.isEmpty()) {\n            Set<V> v = queue.poll().vertex;\n            dmap.remove(v);\n\n            beforelast = last;\n            last = v;\n\n            for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n                Set<V> vc = Graphs.getOppositeVertex(workingGraph, e, v);\n                VertexAndWeight vcandw = dmap.get(vc);\n                if (vcandw != null) {\n                    queue.remove(vcandw); \/\/this is O(logn) but could be O(1)?\n                    vcandw.active = true;\n                    vcandw.weight += workingGraph.getEdgeWeight(e);\n                    queue.add(vcandw); \/\/this is O(logn) but could be O(1)?\n                }\n            }\n        }\n\n        \/\/ Update the best cut\n        double w = vertexWeight(last);\n        if (w < bestCutWeight) {\n            bestCutWeight = w;\n            bestCut = last;\n        }\n\n        \/\/merge the last added vertices\n        mergeVertices(beforelast, last);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Implements the MinimumCutPhase function of Stoer and Wagner\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> a","parameterName":"a"}],"methodName":"minimumCutPhase","methodQualifiedSignature":"org.jgrapht.alg.StoerWagnerMinimumCut.minimumCutPhase","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Implements the MinimumCutPhase function of Stoer and Wagner'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 125,col 39)-(line 125,col 42)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 141,col 30)-(line 141,col 33)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 141,col 38)-(line 141,col 40)","literalExprId":3,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 142,col 68)-(line 142,col 71)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 159,col 31)-(line 159,col 34)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 161,col 37)-(line 161,col 40)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StoerWagnerMinimumCut.minimumCutPhase(java.util.Set<V>)"},{"javadocBlockTags":[],"methodDeclaration":"public double minCutWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return bestCutWeight;\n}","methodRange":"(line 182,col 5)-(line 185,col 5)","methodTokenRange":"public double minCutWeight()\n    {\n        return bestCutWeight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Return the weight of the minimum cut\n     ","methodParameters":[],"methodName":"minCutWeight","methodQualifiedSignature":"org.jgrapht.alg.StoerWagnerMinimumCut.minCutWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the weight of the minimum cut'}]}, blockTags=[]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.StoerWagnerMinimumCut.minCutWeight()"},{"javadocBlockTags":[],"methodDeclaration":"public Set<V> minCut()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return bestCut;\n}","methodRange":"(line 190,col 5)-(line 193,col 5)","methodTokenRange":"public Set<V> minCut()\n    {\n        return bestCut;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Return a set of vertices on one side of the cut\n     ","methodParameters":[],"methodName":"minCut","methodQualifiedSignature":"org.jgrapht.alg.StoerWagnerMinimumCut.minCut","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a set of vertices on one side of the cut'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.StoerWagnerMinimumCut.minCut()"},{"javadocBlockTags":[],"methodDeclaration":"protected VertexAndWeight mergeVertices(Set<V> s, Set<V> t)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    Set<V> set = new HashSet<V>();\n    set.addAll(s);\n    set.addAll(t);\n    workingGraph.addVertex(set);\n    double wsum = 0.0;\n    for (Set<V> v : workingGraph.vertexSet()) {\n        if ((s != v) && (t != v)) {\n            double neww = 0.0;\n            DefaultWeightedEdge etv = workingGraph.getEdge(t, v);\n            DefaultWeightedEdge esv = workingGraph.getEdge(s, v);\n            if (etv != null) {\n                neww += workingGraph.getEdgeWeight(etv);\n            }\n            if (esv != null) {\n                neww += workingGraph.getEdgeWeight(esv);\n            }\n            if ((etv != null) || (esv != null)) {\n                wsum += neww;\n                workingGraph.setEdgeWeight(workingGraph.addEdge(set, v), neww);\n            }\n        }\n    }\n    workingGraph.removeVertex(t);\n    workingGraph.removeVertex(s);\n    return new VertexAndWeight(set, wsum, false);\n}","methodRange":"(line 199,col 5)-(line 234,col 5)","methodTokenRange":"protected VertexAndWeight mergeVertices(Set<V> s, Set<V> t)\n    {\n        \/\/construct the new combinedvertex\n        Set<V> set = new HashSet<V>();\n        set.addAll(s);\n        set.addAll(t);\n        workingGraph.addVertex(set);\n\n        \/\/add edges and weights to the combined vertex\n        double wsum = 0.0;\n        for (Set<V> v : workingGraph.vertexSet()) {\n            if ((s != v) && (t != v)) {\n                double neww = 0.0;\n                DefaultWeightedEdge etv = workingGraph.getEdge(t, v);\n                DefaultWeightedEdge esv = workingGraph.getEdge(s, v);\n                if (etv != null) {\n                    neww += workingGraph.getEdgeWeight(etv);\n                }\n                if (esv != null) {\n                    neww += workingGraph.getEdgeWeight(esv);\n                }\n                if ((etv != null) || (esv != null)) {\n                    wsum += neww;\n                    workingGraph.setEdgeWeight(\n                        workingGraph.addEdge(set, v),\n                        neww);\n                }\n            }\n        }\n\n        \/\/remove original vertices\n        workingGraph.removeVertex(t);\n        workingGraph.removeVertex(s);\n\n        return new VertexAndWeight(set, wsum, false);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.StoerWagnerMinimumCut.VertexAndWeight, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n     * Merges vertex t into vertex s, summing the weights as required. Returns\n     * the merged vertex and the sum of its weights\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> s","parameterName":"s"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> t","parameterName":"t"}],"methodName":"mergeVertices","methodQualifiedSignature":"org.jgrapht.alg.StoerWagnerMinimumCut.mergeVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Merges vertex t into vertex s, summing the weights as required. Returns\nthe merged vertex and the sum of its weights'}]}, blockTags=[]}","methodReturnTypeDescribed":"org.jgrapht.alg.StoerWagnerMinimumCut.VertexAndWeight","methodType":"VertexAndWeight","literalExprs":[{"literalExprRange":"(line 208,col 23)-(line 208,col 25)","literalExprId":1,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 211,col 31)-(line 211,col 33)","literalExprId":2,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 214,col 28)-(line 214,col 31)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 217,col 28)-(line 217,col 31)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 220,col 29)-(line 220,col 32)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 220,col 46)-(line 220,col 49)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 233,col 47)-(line 233,col 51)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StoerWagnerMinimumCut.mergeVertices(java.util.Set<V>, java.util.Set<V>)"},{"javadocBlockTags":[],"methodDeclaration":"public double vertexWeight(Set<V> v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double wsum = 0.0;\n    for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n        wsum += workingGraph.getEdgeWeight(e);\n    }\n    return wsum;\n}","methodRange":"(line 239,col 5)-(line 246,col 5)","methodTokenRange":"public double vertexWeight(Set<V> v)\n    {\n        double wsum = 0.0;\n        for (DefaultWeightedEdge e : workingGraph.edgesOf(v)) {\n            wsum += workingGraph.getEdgeWeight(e);\n        }\n        return wsum;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Compute the sum of the weights entering a vertex\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> v","parameterName":"v"}],"methodName":"vertexWeight","methodQualifiedSignature":"org.jgrapht.alg.StoerWagnerMinimumCut.vertexWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compute the sum of the weights entering a vertex'}]}, blockTags=[]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 241,col 23)-(line 241,col 25)","literalExprId":1,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.StoerWagnerMinimumCut.vertexWeight(java.util.Set<V>)"}],"classJavadoc":"\/**\n * Implements the <a href=\"http:\/\/dl.acm.org\/citation.cfm?id=263872\">Stoer and\n * Wagner minimum cut algorithm<\/a>. Deterministically computes the minimum cut\n * in O(|V||E| + |V|log|V|) time. This implementation uses Java's PriorityQueue\n * and requires O(|V||E|log|E|) time. M. Stoer and F. Wagner, \"A Simple Min-Cut\n * Algorithm\", Journal of the ACM, volume 44, number 4. pp 585-591, 1997.\n *\n * @author Robby McKilliam, Ernst de Ridder\n *\/\n","className":"StoerWagnerMinimumCut","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 66)","fieldName":"workingGraph","fieldJavadocComment":"","fieldTokenRange":"final WeightedGraph<Set<V>, DefaultWeightedEdge> workingGraph;","fieldTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=ReferenceType{org.jgrapht.graph.DefaultWeightedEdge, typeParametersMap=TypeParametersMap{nameToValue={}}}, org.jgrapht.WeightedGraph.V=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"WeightedGraph<Set<V>, DefaultWeightedEdge>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.WeightedGraph<java.util.Set<V>, org.jgrapht.graph.DefaultWeightedEdge>"},{"fieldRange":"(line 58,col 5)-(line 58,col 62)","fieldName":"bestCutWeight","fieldJavadocComment":"","fieldTokenRange":"protected double bestCutWeight = Double.POSITIVE_INFINITY;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"Optional[Double.POSITIVE_INFINITY]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 59,col 5)-(line 59,col 29)","fieldName":"bestCut","fieldJavadocComment":"","fieldTokenRange":"protected Set<V> bestCut;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"}]}],"sourceFileId":181,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.AbstractPathElementList","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"paths, list of <code>AbstractPathElement<\/code>.","javadocBlockTagName":"elementList","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths, list of <code>AbstractPathElement<\/code>.'}]}', name=Optional[elementList]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the end vertex of the created paths.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the created paths.'}]}', name=Optional[edge]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified prevPathElementList or edge\nis <code>null<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified prevPathElementList or edge\nis <code>null<\/code>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if <code>maxSize<\/code> is negative or\n0.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>maxSize<\/code> is negative or\n0.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.AbstractPathElementList.AbstractPathElementList(org.jgrapht.Graph<V, E>, int, org.jgrapht.alg.AbstractPathElementList<V, E, T>, E)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 106,col 5)","constructorJavadocComment":"\n     * Creates paths obtained by concatenating the specified edge to the\n     * specified paths.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     * @param elementList paths, list of <code>AbstractPathElement<\/code>.\n     * @param edge edge reaching the end vertex of the created paths.\n     *\n     * @throws NullPointerException if the specified prevPathElementList or edge\n     * is <code>null<\/code>.\n     * @throws IllegalArgumentException if <code>maxSize<\/code> is negative or\n     * 0.\n     ","constructorDeclaration":"protected AbstractPathElementList(Graph<V, E> graph, int maxSize, AbstractPathElementList<V, E, T> elementList, E edge)","constructorBody":"{\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    if (elementList == null) {\n        throw new NullPointerException(\"elementList is null\");\n    }\n    if (edge == null) {\n        throw new NullPointerException(\"edge is null\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n}","constructorName":"AbstractPathElementList","constructorQualifiedName":"org.jgrapht.alg.AbstractPathElementList.AbstractPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"AbstractPathElementList<V, E, T>","parameterId":3,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.AbstractPathElementList, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.AbstractPathElementList.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.AbstractPathElementList.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.AbstractPathElementList.T=TypeVariable {JPTypeParameter(T, bounds=[AbstractPathElement<V, E>])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.AbstractPathElementList<V, E, T>","parameter":"AbstractPathElementList<V, E, T> elementList","parameterName":"elementList"},{"parameterType":"E","parameterId":4,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"literalExprs":[{"literalExprRange":"(line 92,col 24)-(line 92,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 93,col 48)-(line 93,col 73)","literalExprId":2,"literalExpr":"\"maxSize is negative or 0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 28)-(line 95,col 31)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 96,col 44)-(line 96,col 64)","literalExprId":4,"literalExpr":"\"elementList is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 98,col 21)-(line 98,col 24)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 99,col 44)-(line 99,col 57)","literalExprId":6,"literalExpr":"\"edge is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        AbstractPathElementList<V, E, T> elementList,\n        E edge)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (elementList == null) {\n            throw new NullPointerException(\"elementList is null\");\n        }\n        if (edge == null) {\n            throw new NullPointerException(\"edge is null\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex =\n            Graphs.getOppositeVertex(graph, edge, elementList.getVertex());\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates paths obtained by concatenating the specified edge to the\nspecified paths.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths, list of <code>AbstractPathElement<\/code>.'}]}', name=Optional[elementList]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the created paths.'}]}', name=Optional[edge]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified prevPathElementList or edge\nis <code>null<\/code>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>maxSize<\/code> is negative or\n0.'}]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified path-element is <code>\nnull<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified path-element is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if <code>maxSize<\/code> is negative or\n0.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>maxSize<\/code> is negative or\n0.'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if <code>pathElement<\/code> is not\nempty.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>pathElement<\/code> is not\nempty.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.AbstractPathElementList.AbstractPathElementList(org.jgrapht.Graph<V, E>, int, T)","variableDeclarationExprs":[],"constructorRange":"(line 120,col 5)-(line 140,col 5)","constructorJavadocComment":"\n     * Creates a list with an empty path. The list size is 1.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws NullPointerException if the specified path-element is <code>\n     * null<\/code>.\n     * @throws IllegalArgumentException if <code>maxSize<\/code> is negative or\n     * 0.\n     * @throws IllegalArgumentException if <code>pathElement<\/code> is not\n     * empty.\n     ","constructorDeclaration":"protected AbstractPathElementList(Graph<V, E> graph, int maxSize, T pathElement)","constructorBody":"{\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    if (pathElement == null) {\n        throw new NullPointerException(\"pathElement is null\");\n    }\n    if (pathElement.getPrevEdge() != null) {\n        throw new IllegalArgumentException(\"path must be empty\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = pathElement.getVertex();\n    this.pathElements.add(pathElement);\n}","constructorName":"AbstractPathElementList","constructorQualifiedName":"org.jgrapht.alg.AbstractPathElementList.AbstractPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"T","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[AbstractPathElement<V, E>])}","parameterTypeResolvedDescribed":"T","parameter":"T pathElement","parameterName":"pathElement"}],"literalExprs":[{"literalExprRange":"(line 125,col 24)-(line 125,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 126,col 48)-(line 126,col 73)","literalExprId":2,"literalExpr":"\"maxSize is negative or 0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 128,col 28)-(line 128,col 31)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 129,col 44)-(line 129,col 64)","literalExprId":4,"literalExpr":"\"pathElement is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 131,col 42)-(line 131,col 45)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 132,col 48)-(line 132,col 67)","literalExprId":6,"literalExpr":"\"path must be empty\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"protected AbstractPathElementList(\n        Graph<V, E> graph,\n        int maxSize,\n        T pathElement)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n        if (pathElement == null) {\n            throw new NullPointerException(\"pathElement is null\");\n        }\n        if (pathElement.getPrevEdge() != null) {\n            throw new IllegalArgumentException(\"path must be empty\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = pathElement.getVertex();\n\n        this.pathElements.add(pathElement);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a list with an empty path. The list size is 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified path-element is <code>\nnull<\/code>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>maxSize<\/code> is negative or\n0.'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>pathElement<\/code> is not\nempty.'}]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of paths the list is able to store.","javadocBlockTagName":"maxSize","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if <code>maxSize<\/code> is negative or\n0.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>maxSize<\/code> is negative or\n0.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.AbstractPathElementList.AbstractPathElementList(org.jgrapht.Graph<V, E>, int, V)","variableDeclarationExprs":[],"constructorRange":"(line 150,col 5)-(line 159,col 5)","constructorJavadocComment":"\n     * Creates an empty list. The list size is 0.\n     *\n     * @param maxSize maximum number of paths the list is able to store.\n     *\n     * @throws IllegalArgumentException if <code>maxSize<\/code> is negative or\n     * 0.\n     ","constructorDeclaration":"protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)","constructorBody":"{\n    if (maxSize <= 0) {\n        throw new IllegalArgumentException(\"maxSize is negative or 0\");\n    }\n    this.graph = graph;\n    this.maxSize = maxSize;\n    this.vertex = vertex;\n}","constructorName":"AbstractPathElementList","constructorQualifiedName":"org.jgrapht.alg.AbstractPathElementList.AbstractPathElementList","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int maxSize","parameterName":"maxSize"},{"parameterType":"V","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"literalExprs":[{"literalExprRange":"(line 152,col 24)-(line 152,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 48)-(line 153,col 73)","literalExprId":2,"literalExpr":"\"maxSize is negative or 0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"protected AbstractPathElementList(Graph<V, E> graph, int maxSize, V vertex)\n    {\n        if (maxSize <= 0) {\n            throw new IllegalArgumentException(\"maxSize is negative or 0\");\n        }\n\n        this.graph = graph;\n        this.maxSize = maxSize;\n        this.vertex = vertex;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty list. The list size is 0.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of paths the list is able to store.'}]}', name=Optional[maxSize]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if <code>maxSize<\/code> is negative or\n0.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public T get(int index)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.pathElements.get(index);\n}","methodRange":"(line 165,col 5)-(line 168,col 5)","methodTokenRange":"@Override public T get(int index)\n    {\n        return this.pathElements.get(index);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[AbstractPathElement<V, E>])}","methodJavadocComment":"\n     * Returns path <code>AbstractPathElement<\/code> stored at the specified\n     * index.\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int index","parameterName":"index"}],"methodName":"get","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElementList.get","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns path <code>AbstractPathElement<\/code> stored at the specified\nindex.'}]}, blockTags=[]}","methodReturnTypeDescribed":"T","methodType":"T","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElementList.get(int)"},{"javadocBlockTags":[],"methodDeclaration":"public V getVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.vertex;\n}","methodRange":"(line 173,col 5)-(line 176,col 5)","methodTokenRange":"public V getVertex()\n    {\n        return this.vertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns target vertex.\n     ","methodParameters":[],"methodName":"getVertex","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElementList.getVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns target vertex.'}]}, blockTags=[]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElementList.getVertex()"},{"javadocBlockTags":[],"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.pathElements.size();\n}","methodRange":"(line 181,col 5)-(line 184,col 5)","methodTokenRange":"@Override public int size()\n    {\n        return this.pathElements.size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the number of paths stored in the list.\n     ","methodParameters":[],"methodName":"size","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElementList.size","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the number of paths stored in the list.'}]}, blockTags=[]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElementList.size()"}],"classJavadoc":"\/**\n * List of paths <code>AbstractPathElement<\/code> with same target vertex.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"AbstractPathElementList","fields":[{"fieldRange":"(line 56,col 5)-(line 56,col 32)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"protected Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 61,col 5)-(line 61,col 26)","fieldName":"maxSize","fieldJavadocComment":"\n     * Max number of stored paths.\n     ","fieldTokenRange":"protected int maxSize;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Max number of stored paths.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 66,col 5)-(line 66,col 61)","fieldName":"pathElements","fieldJavadocComment":"\n     * Stored paths, list of <code>AbstractPathElement<\/code>.\n     ","fieldTokenRange":"protected ArrayList<T> pathElements = new ArrayList<T>();","fieldTypeResolved":"ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=TypeVariable {JPTypeParameter(T, bounds=[AbstractPathElement<V, E>])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<T>()]","fieldType":"ArrayList<T>","fieldJavadoc":"Stored paths, list of <code>AbstractPathElement<\/code>.\n","fieldTypeResolvedDescribed":"java.util.ArrayList<T>"},{"fieldRange":"(line 71,col 5)-(line 71,col 23)","fieldName":"vertex","fieldJavadocComment":"\n     * Target vertex of the paths.\n     ","fieldTokenRange":"protected V vertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"Target vertex of the paths.\n","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":182,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"target weighted bipartite graph to find matching in","javadocBlockTagName":"G","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target weighted bipartite graph to find matching in'}]}', name=Optional[G]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"first vertex partition of the target bipartite graph","javadocBlockTagName":"S","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first vertex partition of the target bipartite graph'}]}', name=Optional[S]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second vertex partition of the target bipartite graph","javadocBlockTagName":"T","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second vertex partition of the target bipartite graph'}]}', name=Optional[T]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching.KuhnMunkresMinimalWeightBipartitePerfectMatching(org.jgrapht.WeightedGraph<V, E>, java.util.List<? extends V>, java.util.List<? extends V>)","variableDeclarationExprs":[{"variableType":"int","variableName":"edges","variableDeclarationExprId":1,"variableDeclarationExpr":"int partition = S.size(), edges = G.edgeSet().size()","variableDeclarationExprRange":"(line 82,col 9)-(line 82,col 60)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 82,col 35)-(line 82,col 60)"}],"constructorRange":"(line 71,col 5)-(line 102,col 5)","constructorJavadocComment":"\n     * @param G target weighted bipartite graph to find matching in\n     * @param S first vertex partition of the target bipartite graph\n     * @param T second vertex partition of the target bipartite graph\n     ","constructorDeclaration":"public KuhnMunkresMinimalWeightBipartitePerfectMatching(final WeightedGraph<V, E> G, List<? extends V> S, List<? extends V> T)","constructorBody":"{\n    if (S.size() != T.size()) {\n        throw new IllegalArgumentException(\"Graph supplied isn't complete bipartite with equally sized partitions!\");\n    }\n    int partition = S.size(), edges = G.edgeSet().size();\n    if (edges != (partition * partition)) {\n        throw new IllegalArgumentException(\"Graph supplied isn't complete bipartite with equally sized partitions!\");\n    }\n    graph = G;\n    firstPartition = S;\n    secondPartition = T;\n    if (G.vertexSet().isEmpty()) {\n        matching = new int[] {};\n    } else {\n        matching = new KuhnMunkresMatrixImplementation<V, E>(G, S, T).buildMatching();\n    }\n}","constructorName":"KuhnMunkresMinimalWeightBipartitePerfectMatching","constructorQualifiedName":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching.KuhnMunkresMinimalWeightBipartitePerfectMatching","constructorParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"final WeightedGraph<V, E> G","parameterName":"G"},{"parameterType":"List<? extends V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends V>","parameter":"List<? extends V> S","parameterName":"S"},{"parameterType":"List<? extends V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends V>","parameter":"List<? extends V> T","parameterName":"T"}],"literalExprs":[{"literalExprRange":"(line 79,col 17)-(line 79,col 88)","literalExprId":1,"literalExpr":"\"Graph supplied isn't complete bipartite with equally sized partitions!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 86,col 17)-(line 86,col 88)","literalExprId":2,"literalExpr":"\"Graph supplied isn't complete bipartite with equally sized partitions!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public KuhnMunkresMinimalWeightBipartitePerfectMatching(\n        final WeightedGraph<V, E> G,\n        List<? extends V> S,\n        List<? extends V> T)\n    {\n        \/\/ Validate graph being complete bipartite with equally-sized partitions\n        if (S.size() != T.size()) {\n            throw new IllegalArgumentException(\n                \"Graph supplied isn't complete bipartite with equally sized partitions!\");\n        }\n\n        int partition = S.size(), edges = G.edgeSet().size();\n\n        if (edges != (partition * partition)) {\n            throw new IllegalArgumentException(\n                \"Graph supplied isn't complete bipartite with equally sized partitions!\");\n        }\n\n        graph = G;\n        firstPartition = S;\n        secondPartition = T;\n\n        \/\/ Expected behaviour for an empty graph is to return an empty set, so\n        \/\/ we check this last\n        if (G.vertexSet().isEmpty()) {\n            matching = new int[] {};\n        } else {\n            matching =\n                new KuhnMunkresMatrixImplementation<V, E>(G, S, T)\n                .buildMatching();\n        }\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target weighted bipartite graph to find matching in'}]}', name=Optional[G]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first vertex partition of the target bipartite graph'}]}', name=Optional[S]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second vertex partition of the target bipartite graph'}]}', name=Optional[T]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 132,col 5)-(line 643,col 5)","classOrInterfaceTokenRange":"protected static class KuhnMunkresMatrixImplementation<V, E>\n    {\n        \/**\n         * Cost matrix\n         *\/\n        private double [][] costMatrix;\n\n        \/**\n         * Excess matrix\n         *\/\n        private double [][] excessMatrix;\n\n        \/**\n         * Rows coverage bit-mask\n         *\/\n        boolean [] rowsCovered;\n\n        \/**\n         * Columns coverage bit-mask\n         *\/\n        boolean [] columnsCovered;\n\n        \/**\n         * ``columnMatched[i]'' is the column # of the ZERO matched at the i-th\n         * row\n         *\/\n        private int [] columnMatched;\n\n        \/**\n         * ``rowMatched[j]'' is the row # of the ZERO matched at the j-th column\n         *\/\n        private int [] rowMatched;\n\n        public KuhnMunkresMatrixImplementation(\n            final WeightedGraph<V, E> G,\n            final List<? extends V> S,\n            final List<? extends V> T)\n        {\n            int partition = S.size();\n\n            \/\/ Build an excess-matrix corresponding to the supplied weighted\n            \/\/ complete bipartite graph\n\n            costMatrix = new double[partition][];\n\n            for (int i = 0; i < S.size(); ++i) {\n                V source = S.get(i);\n                costMatrix[i] = new double[partition];\n                for (int j = 0; j < T.size(); ++j) {\n                    V target = T.get(j);\n                    if (source.equals(target)) {\n                        continue;\n                    }\n                    costMatrix[i][j] =\n                        G.getEdgeWeight(G.getEdge(source, target));\n                }\n            }\n        }\n\n        \/**\n         * Gets costs-matrix as input and returns assignment of tasks\n         * (designated by the columns of cost-matrix) to the workers (designated\n         * by the rows of the cost-matrix) so that to MINIMIZE total\n         * tasks-tackling costs\n         *\/\n        protected int [] buildMatching()\n        {\n            int height = costMatrix.length, width = costMatrix[0].length;\n\n            \/\/ Make an excess-matrix\n            excessMatrix = makeExcessMatrix();\n\n            \/\/ Build row\/column coverage\n            rowsCovered = new boolean[height];\n            columnsCovered = new boolean[width];\n\n            \/\/ Cached values of zeroes' indices in particular columns\/rows\n            columnMatched = new int[height];\n            rowMatched = new int[width];\n\n            Arrays.fill(columnMatched, -1);\n            Arrays.fill(rowMatched, -1);\n\n            \/\/ Find perfect matching corresponding to the optimal assignment\n\n            while (buildMaximalMatching() < width) {\n                buildVertexCoverage();\n                extendEqualityGraph();\n            }\n\n            \/\/ Almost done!\n\n            return Arrays.copyOf(columnMatched, height);\n        }\n\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n        \/**\n         * Composes excess-matrix corresponding to the given cost-matrix\n         *\/\n        double [][] makeExcessMatrix()\n        {\n            double [][] excessMatrix = new double[costMatrix.length][];\n\n            for (int i = 0; i < excessMatrix.length; ++i) {\n                excessMatrix[i] =\n                    Arrays.copyOf(costMatrix[i], costMatrix[i].length);\n            }\n\n            \/\/ Subtract minimal costs across the rows\n\n            for (int i = 0; i < excessMatrix.length; ++i) {\n                double cheapestTaskCost = Double.MAX_VALUE;\n\n                for (int j = 0; j < excessMatrix[i].length; ++j) {\n                    if (cheapestTaskCost > excessMatrix[i][j]) {\n                        cheapestTaskCost = excessMatrix[i][j];\n                    }\n                }\n\n                for (int j = 0; j < excessMatrix[i].length; ++j) {\n                    excessMatrix[i][j] -= cheapestTaskCost;\n                }\n            }\n\n            \/\/ Subtract minimal costs across the columns\n            \/\/\n            \/\/ NOTE:  Makes nothing if there is any worker that can more\n            \/\/ (cost-)effectively tackle this task than any other, i.e. there\n            \/\/ is any row having zero in this column. However, if there is no\n            \/\/ one, reduce the cost-demands of each worker to the size of the\n            \/\/ min-cost (we can easily do this, since we have particular\n            \/\/ interest of the relative values only), i.e. subtract the value\n            \/\/ of the minimum cost-demands to highlight (with zero) the\n            \/\/ worker that can tackle this task demanding lowest reward.\n\n            for (int j = 0; j < excessMatrix[0].length; ++j) {\n                double cheapestWorkerCost = Double.MAX_VALUE;\n\n                for (int i = 0; i < excessMatrix.length; ++i) {\n                    if (cheapestWorkerCost > excessMatrix[i][j]) {\n                        cheapestWorkerCost = excessMatrix[i][j];\n                    }\n                }\n\n                for (int i = 0; i < excessMatrix.length; ++i) {\n                    excessMatrix[i][j] -= cheapestWorkerCost;\n                }\n            }\n\n            return excessMatrix;\n        }\n\n        \/**\n         * Builds maximal matching corresponding to the given excess-matrix\n         *\n         * @return size of a maximal matching built\n         *\/\n        int buildMaximalMatching()\n        {\n            \/\/ Match all zeroes non-staying in the same column\/row\n\n            int matchingSizeLowerBound = 0;\n\n            for (int i = 0; i < columnMatched.length; ++i) {\n                if (columnMatched[i] != -1) {\n                    ++matchingSizeLowerBound;\n                }\n            }\n\n            \/\/ Compose first-approximation by matching zeroes in a greed fashion\n\n            for (int j = 0; j < excessMatrix[0].length; ++j) {\n                if (rowMatched[j] == -1) {\n                    for (int i = 0; i < excessMatrix.length; ++i) {\n                        if ((excessMatrix[i][j] == 0)\n                            && (columnMatched[i] == -1))\n                        {\n                            ++matchingSizeLowerBound;\n                            columnMatched[i] = j;\n                            rowMatched[j] = i;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            \/\/ Check whether perfect matching is found\n\n            if (matchingSizeLowerBound == excessMatrix[0].length) {\n                return matchingSizeLowerBound;\n            }\n\n            \/\/\n            \/\/As to E. Burge: Matching is maximal iff bipartite graph doesn't\n            \/\/contain any matching-augmenting paths.\n            \/\/\n            \/\/Try to find any match-augmenting path\n\n            boolean [] rowsVisited = new boolean[excessMatrix.length];\n            boolean [] colsVisited = new boolean[excessMatrix[0].length];\n\n            int matchingSize = 0;\n\n            boolean extending = true;\n\n            while (extending && (matchingSize < excessMatrix.length)) {\n                Arrays.fill(rowsVisited, false);\n                Arrays.fill(colsVisited, false);\n\n                extending = false;\n\n                for (int j = 0; j < excessMatrix.length; ++j) {\n                    if ((rowMatched[j] == -1) && !colsVisited[j]) {\n                        extending |=\n                            new MatchExtender(rowsVisited, colsVisited).extend(\n                                j); \/* Try to extend matching *\/\n                    }\n                }\n\n                matchingSize = 0;\n\n                for (int j = 0; j < rowMatched.length; ++j) {\n                    if (rowMatched[j] != -1) {\n                        ++matchingSize;\n                    }\n                }\n            }\n\n            return matchingSize;\n        }\n\n        \/**\n         * Builds vertex-cover given built up matching\n         *\/\n        void buildVertexCoverage()\n        {\n            Arrays.fill(columnsCovered, false);\n            Arrays.fill(rowsCovered, false);\n\n            boolean [] invertible = new boolean[rowsCovered.length];\n\n            for (int i = 0; i < excessMatrix.length; ++i) {\n                if (columnMatched[i] != -1) {\n                    invertible[i] = true;\n                    continue;\n                }\n\n                for (int j = 0; j < excessMatrix[i].length; ++j) {\n                    if (Double.valueOf(excessMatrix[i][j]).compareTo(0.) == 0) {\n                        rowsCovered[i] = invertible[i] = true;\n                        break;\n                    }\n                }\n            }\n\n            boolean cont = true;\n\n            while (cont) {\n                for (int i = 0; i < excessMatrix.length; ++i) {\n                    if (rowsCovered[i]) {\n                        for (int j = 0; j < excessMatrix[i].length; ++j) {\n                            if ((Double.valueOf(excessMatrix[i][j]).compareTo(\n                                        0.) == 0)\n                                && !columnsCovered[j])\n                            {\n                                columnsCovered[j] = true;\n                            }\n                        }\n                    }\n                }\n\n                \/\/ Shall we continue?\n\n                cont = false;\n\n                for (int j = 0; j < columnsCovered.length; ++j) {\n                    if (columnsCovered[j] && (rowMatched[j] != -1)) {\n                        if (!rowsCovered[rowMatched[j]]) {\n                            cont = true;\n                            rowsCovered[rowMatched[j]] = true;\n                        }\n                    }\n                }\n            }\n\n            \/\/ Invert covered rows selection\n\n            for (int i = 0; i < rowsCovered.length; ++i) {\n                if (invertible[i]) {\n                    rowsCovered[i] ^= true;\n                }\n            }\n\n            assert uncovered(excessMatrix, rowsCovered, columnsCovered) == 0;\n            assert minimal(rowMatched, rowsCovered, columnsCovered);\n        }\n\n        \/**\n         * Extends equality-graph subtracting minimal excess from all the\n         * COLUMNS UNCOVERED and adding it to the all ROWS COVERED\n         *\/\n        void extendEqualityGraph()\n        {\n            double minExcess = Double.MAX_VALUE;\n\n            for (int i = 0; i < excessMatrix.length; ++i) {\n                if (rowsCovered[i]) {\n                    continue;\n                }\n                for (int j = 0; j < excessMatrix[i].length; ++j) {\n                    if (columnsCovered[j]) {\n                        continue;\n                    }\n                    if (minExcess > excessMatrix[i][j]) {\n                        minExcess = excessMatrix[i][j];\n                    }\n                }\n            }\n\n            \/\/ Add up to all elements of the COVERED ROWS\n\n            for (int i = 0; i < excessMatrix.length; ++i) {\n                if (!rowsCovered[i]) {\n                    continue;\n                }\n                for (int j = 0; j < excessMatrix[i].length; ++j) {\n                    excessMatrix[i][j] += minExcess;\n                }\n            }\n\n            \/\/ Subtract from all elements of the UNCOVERED COLUMNS\n\n            for (int j = 0; j < excessMatrix[0].length; ++j) {\n                if (columnsCovered[j]) {\n                    continue;\n                }\n                for (int i = 0; i < excessMatrix.length; ++i) {\n                    excessMatrix[i][j] -= minExcess;\n                }\n            }\n        }\n\n        \/**\n         * Assures given column-n-rows-coverage\/zero-matching to be\n         * minimal\/maximal\n         *\n         * @param match zero-matching to check\n         * @param rowsCovered rows coverage to check\n         * @param colsCovered columns coverage to check\n         *\n         * @return true if given matching and coverage are maximal and minimal\n         * respectively\n         *\/\n        private static boolean minimal(\n            final int [] match,\n            final boolean [] rowsCovered,\n            final boolean [] colsCovered)\n        {\n            int matched = 0;\n            for (int i = 0; i < match.length; ++i) {\n                if (match[i] != -1) {\n                    ++matched;\n                }\n            }\n\n            int covered = 0;\n            for (int i = 0; i < rowsCovered.length; ++i) {\n                if (rowsCovered[i]) {\n                    ++covered;\n                }\n                if (colsCovered[i]) {\n                    ++covered;\n                }\n            }\n\n            return matched == covered;\n        }\n\n        \/**\n         * Accounts for zeroes being uncovered\n         *\n         * @param excessMatrix target excess-matrix\n         * @param rowsCovered rows coverage to check\n         * @param colsCovered columns coverage to check\n         *\/\n        private static int uncovered(\n            final double [][] excessMatrix,\n            final boolean [] rowsCovered,\n            final boolean [] colsCovered)\n        {\n            int uncoveredZero = 0;\n\n            for (int i = 0; i < excessMatrix.length; ++i) {\n                if (rowsCovered[i]) {\n                    continue;\n                }\n                for (int j = 0; j < excessMatrix[i].length; ++j) {\n                    if (colsCovered[j]) {\n                        continue;\n                    }\n                    if (Double.valueOf(excessMatrix[i][j]).compareTo(0.) == 0) {\n                        ++uncoveredZero;\n                    }\n                }\n            }\n\n            return uncoveredZero;\n        }\n\n        \/**\n         * Aggregates utilities to extend matching\n         *\/\n        protected class MatchExtender\n        {\n            private final boolean [] rowsVisited;\n            private final boolean [] colsVisited;\n\n            private MatchExtender(\n                final boolean [] rowsVisited,\n                final boolean [] colsVisited)\n            {\n                this.rowsVisited = rowsVisited;\n                this.colsVisited = colsVisited;\n            }\n\n            \/**\n             * Performs DFS to seek after matching-augmenting path starting at\n             * the initial-vertex\n             *\n             * @return true when some augmenting-path found, false otherwise\n             *\/\n            public boolean extend(int initialCol)\n            {\n                return extendMatchingEL(initialCol);\n            }\n\n            \/**\n             * DFS helper #1 (applicable for ODD-LENGTH paths ONLY)\n             *\n             * @param pathTailRow row # of tail of the matching-augmenting path\n             * @param pathTailCol column # of tail of the matching-augmenting\n             * path\n             *\n             * @return true if matching-augmenting path found, false otherwise\n             *\/\n            private boolean extendMatchingOL(int pathTailRow, int pathTailCol)\n            {\n                \/\/ Seek after already matched zero\n\n                \/\/ Check whether row occupied by the 'tail' vertex isn't matched\n\n                if (columnMatched[pathTailRow] == -1) {\n                    \/\/ There is no way to continue: mark zero as matched,\n                    \/\/ trigger along-side flipping\n                    columnMatched[pathTailRow] = pathTailCol;\n                    rowMatched[pathTailCol] = pathTailRow;\n\n                    return true;\n                } else {\n                    \/\/ Add next matched zero: mark current vertex as \"visited\"\n                    rowsVisited[pathTailRow] = true;\n\n                    \/\/ Check whether we can proceed\n                    if (colsVisited[columnMatched[pathTailRow]]) {\n                        return false;\n                    }\n\n                    boolean extending =\n                        extendMatchingEL(\n                            columnMatched[pathTailRow]);\n\n                    if (extending) {\n                        columnMatched[pathTailRow] = pathTailCol;\n                        rowMatched[pathTailCol] = pathTailRow;\n                    }\n\n                    return extending;\n                }\n            }\n\n            \/**\n             * DFS helper #1 (applicable for ODD-LENGTH paths ONLY)\n             *\n             * @param pathTailCol column # of tail of the matching-augmenting\n             * path\n             *\n             * @return true if matching-augmenting path found, false otherwise\n             *\/\n            private boolean extendMatchingEL(int pathTailCol)\n            {\n                colsVisited[pathTailCol] = true;\n\n                for (int i = 0; i < excessMatrix.length; ++i) {\n                    if ((excessMatrix[i][pathTailCol] == 0)\n                        && !rowsVisited[i])\n                    {\n                        boolean extending =\n                            extendMatchingOL(\n                                i, \/\/ New tail to continue\n                                pathTailCol \/\/\n                                );\n                        if (extending) {\n                            return true;\n                        }\n                    }\n                }\n\n                return false;\n            }\n        }\n    }","classOrInterfaceJavadocComment":"\n     * ...\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='...'}]}, blockTags=[]}]"}],"methods":[{"methodDeclaration":"public Set<E> getMatching()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<E> edges = new HashSet<E>();\n    for (int i = 0; i < matching.length; ++i) {\n        edges.add(graph.getEdge(firstPartition.get(i), secondPartition.get(matching[i])));\n    }\n    return edges;\n}","methodRange":"(line 104,col 5)-(line 116,col 5)","methodTokenRange":"@Override public Set<E> getMatching()\n    {\n        Set<E> edges = new HashSet<E>();\n\n        for (int i = 0; i < matching.length; ++i) {\n            edges.add(\n                graph.getEdge(\n                    firstPartition.get(i),\n                    secondPartition.get(matching[i])));\n        }\n\n        return edges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getMatching","methodQualifiedSignature":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching.getMatching","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 108,col 22)-(line 108,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching.getMatching()"},{"methodDeclaration":"public double getMatchingWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double weight = 0.;\n    for (E edge : getMatching()) {\n        weight += graph.getEdgeWeight(edge);\n    }\n    return weight;\n}","methodRange":"(line 118,col 5)-(line 127,col 5)","methodTokenRange":"@Override public double getMatchingWeight()\n    {\n        double weight = 0.;\n\n        for (E edge : getMatching()) {\n            weight += graph.getEdgeWeight(edge);\n        }\n\n        return weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[],"methodName":"getMatchingWeight","methodQualifiedSignature":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching.getMatchingWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 120,col 25)-(line 120,col 26)","literalExprId":1,"literalExpr":"0.","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KuhnMunkresMinimalWeightBipartitePerfectMatching.getMatchingWeight()"}],"classJavadoc":"\/**\n * Kuhn-Munkres algorithm (named in honor of Harold Kuhn and James Munkres)\n * solving <i>assignment problem<\/i> also known as <a\n * href=http:\/\/en.wikipedia.org\/wiki\/Hungarian_algorithm>hungarian algorithm<\/a>\n * (in the honor of hungarian mathematicians Dnes K?nig and Jen? Egervry).\n * It's running time O(V^3).\n *\n * <p><i>Assignment problem<\/i> could be set as follows:\n *\n * <p>Given <a href=http:\/\/en.wikipedia.org\/wiki\/Complete_bipartite_graph>\n * complete bipartite graph<\/a> G = (S, T; E), such that |S| = |T|, and each\n * edge has <i>non-negative<\/i> cost <i>c(i, j)<\/i>, find <i>perfect<\/i>\n * matching of <i>minimal cost<\/i>.<\/p>\n *\n * @author Alexey Kudinkin\n *\/\n","className":"KuhnMunkresMinimalWeightBipartitePerfectMatching","fields":[{"fieldRange":"(line 59,col 5)-(line 59,col 44)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final WeightedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeightedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>"},{"fieldRange":"(line 61,col 5)-(line 61,col 51)","fieldName":"firstPartition","fieldJavadocComment":"","fieldTokenRange":"private final List<? extends V> firstPartition;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<? extends V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<? extends V>"},{"fieldRange":"(line 62,col 5)-(line 62,col 52)","fieldName":"secondPartition","fieldJavadocComment":"","fieldTokenRange":"private final List<? extends V> secondPartition;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<? extends V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<? extends V>"},{"fieldRange":"(line 64,col 5)-(line 64,col 34)","fieldName":"matching","fieldJavadocComment":"","fieldTokenRange":"private final int [] matching;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"int[]"}]}],"sourceFileId":183,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.TransitiveReduction","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.TransitiveReduction.TransitiveReduction()","variableDeclarationExprs":[],"constructorRange":"(line 72,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Private Constructor.\n     ","constructorDeclaration":"private TransitiveReduction()","constructorBody":"{\n}","constructorName":"TransitiveReduction","constructorQualifiedName":"org.jgrapht.alg.TransitiveReduction.TransitiveReduction","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"private TransitiveReduction()\n    {\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Private Constructor.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the original matrix to transform into a path matrix","javadocBlockTagName":"matrix","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the original matrix to transform into a path matrix'}]}', name=Optional[matrix]}"}],"methodDeclaration":" static void transformToPathMatrix(BitSet[] matrix)","methodAccessSpecifier":"NONE","methodBody":"{\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix.length; j++) {\n            if (i == j) {\n                continue;\n            }\n            if (matrix[j].get(i)) {\n                for (int k = 0; k < matrix.length; k++) {\n                    if (!matrix[j].get(k)) {\n                        matrix[j].set(k, matrix[i].get(k));\n                    }\n                }\n            }\n        }\n    }\n}","methodRange":"(line 85,col 5)-(line 102,col 5)","methodTokenRange":"static void transformToPathMatrix(BitSet [] matrix)\n    {\n        \/\/ compute path matrix\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix.length; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (matrix[j].get(i)) {\n                    for (int k = 0; k < matrix.length; k++) {\n                        if (!matrix[j].get(k)) {\n                            matrix[j].set(k, matrix[i].get(k));\n                        }\n                    }\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * The matrix passed as input parameter will be transformed into a path\n     * matrix.\n     *\n     * <p>This method is package visible for unit testing, but it is meant as a\n     * private method.<\/p>\n     *\n     * @param matrix the original matrix to transform into a path matrix\n     ","methodParameters":[{"parameterType":"BitSet[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.util.BitSet[]","parameter":"BitSet[] matrix","parameterName":"matrix"}],"methodName":"transformToPathMatrix","methodQualifiedSignature":"org.jgrapht.alg.TransitiveReduction.transformToPathMatrix","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The matrix passed as input parameter will be transformed into a path\nmatrix.\n\n<p>This method is package visible for unit testing, but it is meant as a\nprivate method.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the original matrix to transform into a path matrix'}]}', name=Optional[matrix]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 88,col 22)-(line 88,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 89,col 26)-(line 89,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 94,col 34)-(line 94,col 34)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.TransitiveReduction.transformToPathMatrix(java.util.BitSet[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the path matrix to reduce","javadocBlockTagName":"pathMatrix","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the path matrix to reduce'}]}', name=Optional[pathMatrix]}"}],"methodDeclaration":" static void transitiveReduction(BitSet[] pathMatrix)","methodAccessSpecifier":"NONE","methodBody":"{\n    for (int j = 0; j < pathMatrix.length; j++) {\n        for (int i = 0; i < pathMatrix.length; i++) {\n            if (pathMatrix[i].get(j)) {\n                for (int k = 0; k < pathMatrix.length; k++) {\n                    if (pathMatrix[j].get(k)) {\n                        pathMatrix[i].set(k, false);\n                    }\n                }\n            }\n        }\n    }\n}","methodRange":"(line 113,col 5)-(line 127,col 5)","methodTokenRange":"static void transitiveReduction(BitSet [] pathMatrix)\n    {\n        \/\/ transitively reduce\n        for (int j = 0; j < pathMatrix.length; j++) {\n            for (int i = 0; i < pathMatrix.length; i++) {\n                if (pathMatrix[i].get(j)) {\n                    for (int k = 0; k < pathMatrix.length; k++) {\n                        if (pathMatrix[j].get(k)) {\n                            pathMatrix[i].set(k, false);\n                        }\n                    }\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * The path matrix passed as input parameter will be transformed into a\n     * transitively reduced matrix.\n     *\n     * <p>This method is package visible for unit testing, but it is meant as a\n     * private method.<\/p>\n     *\n     * @param pathMatrix the path matrix to reduce\n     ","methodParameters":[{"parameterType":"BitSet[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.util.BitSet[]","parameter":"BitSet[] pathMatrix","parameterName":"pathMatrix"}],"methodName":"transitiveReduction","methodQualifiedSignature":"org.jgrapht.alg.TransitiveReduction.transitiveReduction","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The path matrix passed as input parameter will be transformed into a\ntransitively reduced matrix.\n\n<p>This method is package visible for unit testing, but it is meant as a\nprivate method.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the path matrix to reduce'}]}', name=Optional[pathMatrix]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 116,col 22)-(line 116,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 117,col 26)-(line 117,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 119,col 34)-(line 119,col 34)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 121,col 50)-(line 121,col 54)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.TransitiveReduction.transitiveReduction(java.util.BitSet[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the directed graph that will be reduced transitively","javadocBlockTagName":"directedGraph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph that will be reduced transitively'}]}', name=Optional[directedGraph]}"}],"methodDeclaration":"public void reduce(final DirectedGraph<V, E> directedGraph)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    final List<V> vertices = new ArrayList<V>(directedGraph.vertexSet());\n    final int n = vertices.size();\n    BitSet[] originalMatrix = new BitSet[n];\n    for (int i = 0; i < originalMatrix.length; i++) {\n        originalMatrix[i] = new BitSet(n);\n    }\n    final Set<E> edges = directedGraph.edgeSet();\n    for (final E edge : edges) {\n        final V v1 = directedGraph.getEdgeSource(edge);\n        final V v2 = directedGraph.getEdgeTarget(edge);\n        final int v_1 = vertices.indexOf(v1);\n        final int v_2 = vertices.indexOf(v2);\n        originalMatrix[v_1].set(v_2);\n    }\n    final BitSet[] pathMatrix = originalMatrix;\n    transformToPathMatrix(pathMatrix);\n    final BitSet[] transitivelyReducedMatrix = pathMatrix;\n    transitiveReduction(transitivelyReducedMatrix);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!transitivelyReducedMatrix[i].get(j)) {\n                directedGraph.removeEdge(directedGraph.getEdge(vertices.get(i), vertices.get(j)));\n            }\n        }\n    }\n}","methodRange":"(line 151,col 5)-(line 200,col 5)","methodTokenRange":"public <V, E> void reduce(final DirectedGraph<V, E> directedGraph)\n    {\n        final List<V> vertices = new ArrayList<V>(directedGraph.vertexSet());\n\n        final int n = vertices.size();\n\n        BitSet [] originalMatrix = new BitSet[n];\n        for (int i = 0; i < originalMatrix.length; i++) {\n            originalMatrix[i] = new BitSet(n);\n        }\n\n        \/\/ initialize matrix with zeros\n        \/\/ 'By default, all bits in the set initially have the value false.'\n        \/\/ cf. http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/BitSet.html\n\n        \/\/ initialize matrix with edges\n        final Set<E> edges = directedGraph.edgeSet();\n        for (final E edge : edges) {\n            final V v1 = directedGraph.getEdgeSource(edge);\n            final V v2 = directedGraph.getEdgeTarget(edge);\n\n            final int v_1 = vertices.indexOf(v1);\n            final int v_2 = vertices.indexOf(v2);\n\n            originalMatrix[v_1].set(v_2);\n        }\n\n        \/\/ create path matrix from original matrix\n        final BitSet [] pathMatrix = originalMatrix;\n\n        transformToPathMatrix(pathMatrix);\n\n        \/\/ create reduced matrix from path matrix\n        final BitSet [] transitivelyReducedMatrix = pathMatrix;\n\n        transitiveReduction(transitivelyReducedMatrix);\n\n        \/\/ remove edges from the DirectedGraph which are not in the reduced\n        \/\/ matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!transitivelyReducedMatrix[i].get(j)) {\n                    directedGraph.removeEdge(\n                        directedGraph.getEdge(\n                            vertices.get(i),\n                            vertices.get(j)));\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * This method will remove all transitive edges from the graph passed as\n     * input parameter.\n     *\n     * <p>You may want to clone the graph before, as transitive edges will be\n     * pitilessly removed.<\/p>\n     *\n     * e.g.\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     DirectedGraph&lt;V, T&gt; soonToBePrunedDirectedGraph;\n     *\n     *     TransitiveReduction.INSTANCE.reduce(soonToBePrunedDirectedGraph);\n     *\n     *     \/\/ pruned !\n     * }\n     * <\/pre>\n     *\n     * @param directedGraph the directed graph that will be reduced transitively\n     ","methodParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"final DirectedGraph<V, E> directedGraph","parameterName":"directedGraph"}],"methodName":"reduce","methodQualifiedSignature":"org.jgrapht.alg.TransitiveReduction.reduce","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This method will remove all transitive edges from the graph passed as\ninput parameter.\n\n<p>You may want to clone the graph before, as transitive edges will be\npitilessly removed.<\/p>\n\ne.g.\n\n<pre>\n{\n    &#64;code\n    DirectedGraph&lt;V, T&gt; soonToBePrunedDirectedGraph;\n\n    TransitiveReduction.INSTANCE.reduce(soonToBePrunedDirectedGraph);\n\n    \/\/ pruned !\n}\n<\/pre>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directed graph that will be reduced transitively'}]}', name=Optional[directedGraph]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 158,col 22)-(line 158,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 22)-(line 190,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 191,col 26)-(line 191,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.TransitiveReduction.reduce(org.jgrapht.DirectedGraph<V, E>)"}],"classJavadoc":"","className":"TransitiveReduction","fields":[{"fieldRange":"(line 66,col 5)-(line 67,col 34)","fieldName":"INSTANCE","fieldJavadocComment":"\n     * Singleton instance.\n     ","fieldTokenRange":"public static final TransitiveReduction INSTANCE =\n        new TransitiveReduction();","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.TransitiveReduction, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new TransitiveReduction()]","fieldType":"TransitiveReduction","fieldJavadoc":"Singleton instance.\n","fieldTypeResolvedDescribed":"org.jgrapht.alg.TransitiveReduction"}]}],"sourceFileId":184,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.EulerianCircuit","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The graph to be checked","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The graph to be checked'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true for Eulerian and false for non-Eulerian","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true for Eulerian and false for non-Eulerian'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isEulerian(UndirectedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n        return false;\n    }\n    Iterator<V> iter = g.vertexSet().iterator();\n    while (iter.hasNext()) {\n        V v = iter.next();\n        if ((g.degreeOf(v) % 2) == 1) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 64,col 5)-(line 81,col 5)","methodTokenRange":"public static <V, E> boolean isEulerian(UndirectedGraph<V, E> g)\n    {\n        \/\/ If the graph is not connected, then no Eulerian circuit exists\n        if (!(new ConnectivityInspector<V, E>(g)).isGraphConnected()) {\n            return false;\n        }\n\n        \/\/ A graph is Eulerian if and only if all vertices have even degree\n        \/\/ So, this code will check for that\n        Iterator<V> iter = g.vertexSet().iterator();\n        while (iter.hasNext()) {\n            V v = iter.next();\n            if ((g.degreeOf(v) % 2) == 1) {\n                return false;\n            }\n        }\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * This method will check whether the graph passed in is Eulerian or not.\n     *\n     * @param g The graph to be checked\n     *\n     * @return true for Eulerian and false for non-Eulerian\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"methodName":"isEulerian","methodQualifiedSignature":"org.jgrapht.alg.EulerianCircuit.isEulerian","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This method will check whether the graph passed in is Eulerian or not.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The graph to be checked'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true for Eulerian and false for non-Eulerian'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 68,col 20)-(line 68,col 24)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 76,col 34)-(line 76,col 34)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 76,col 40)-(line 76,col 40)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 24)-(line 77,col 28)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 80,col 16)-(line 80,col 19)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.EulerianCircuit.isEulerian(org.jgrapht.UndirectedGraph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The graph to find an Eulerian circuit","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The graph to find an Eulerian circuit'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"null if no Eulerian circuit exists, or a list of vertices\nrepresenting the Eulerian circuit if one does exist","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null if no Eulerian circuit exists, or a list of vertices\nrepresenting the Eulerian circuit if one does exist'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<V> getEulerianCircuitVertices(UndirectedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!isEulerian(g)) {\n        return null;\n    }\n    List<V> path = new LinkedList<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    path.add(sg.vertexSet().iterator().next());\n    while (sg.edgeSet().size() > 0) {\n        V v = null;\n        int index = 0;\n        for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n            v = iter.next();\n            if (sg.degreeOf(v) > 0) {\n                break;\n            }\n        }\n        while (sg.degreeOf(v) > 0) {\n            for (Iterator<V> iter = sg.vertexSet().iterator(); iter.hasNext(); ) {\n                V temp = iter.next();\n                if (sg.containsEdge(v, temp)) {\n                    path.add(index, temp);\n                    sg.removeEdge(v, temp);\n                    v = temp;\n                    break;\n                }\n            }\n        }\n    }\n    return path;\n}","methodRange":"(line 92,col 5)-(line 140,col 5)","methodTokenRange":"public static <V, E> List<V> getEulerianCircuitVertices(\n        UndirectedGraph<V, E> g)\n    {\n        \/\/ If the graph is not Eulerian then just return a null since no\n        \/\/ Eulerian circuit exists\n        if (!isEulerian(g)) {\n            return null;\n        }\n\n        \/\/ The circuit will be represented by a linked list\n        List<V> path = new LinkedList<V>();\n        UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n        path.add(sg.vertexSet().iterator().next());\n\n        \/\/ Algorithm for finding an Eulerian circuit Basically this will find an\n        \/\/ arbitrary circuit, then it will find another arbitrary circuit until\n        \/\/ every edge has been traversed\n        while (sg.edgeSet().size() > 0) {\n            V v = null;\n\n            \/\/ Find a vertex which has an edge that hasn't been traversed yet,\n            \/\/ and keep its index position in the circuit list\n            int index = 0;\n            for (Iterator<V> iter = path.iterator(); iter.hasNext(); index++) {\n                v = iter.next();\n                if (sg.degreeOf(v) > 0) {\n                    break;\n                }\n            }\n\n            \/\/ Finds an arbitrary circuit of the current vertex and\n            \/\/ appends this into the circuit list\n            while (sg.degreeOf(v) > 0) {\n                for (\n                    Iterator<V> iter = sg.vertexSet().iterator();\n                    iter.hasNext();)\n                {\n                    V temp = iter.next();\n                    if (sg.containsEdge(v, temp)) {\n                        path.add(index, temp);\n                        sg.removeEdge(v, temp);\n                        v = temp;\n                        break;\n                    }\n                }\n            }\n        }\n        return path;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * This method will return a list of vertices which represents the Eulerian\n     * circuit of the graph.\n     *\n     * @param g The graph to find an Eulerian circuit\n     *\n     * @return null if no Eulerian circuit exists, or a list of vertices\n     * representing the Eulerian circuit if one does exist\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"methodName":"getEulerianCircuitVertices","methodQualifiedSignature":"org.jgrapht.alg.EulerianCircuit.getEulerianCircuitVertices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This method will return a list of vertices which represents the Eulerian\ncircuit of the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The graph to find an Eulerian circuit'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null if no Eulerian circuit exists, or a list of vertices\nrepresenting the Eulerian circuit if one does exist'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[{"literalExprRange":"(line 98,col 20)-(line 98,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 103,col 68)-(line 103,col 71)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 103,col 74)-(line 103,col 77)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 109,col 38)-(line 109,col 38)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 110,col 19)-(line 110,col 22)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 114,col 25)-(line 114,col 25)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 117,col 38)-(line 117,col 38)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 124,col 37)-(line 124,col 37)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.EulerianCircuit.getEulerianCircuitVertices(org.jgrapht.UndirectedGraph<V, E>)"}],"classJavadoc":"\/**\n * This algorithm will check whether a graph is Eulerian (hence it contains an\n * <a href=\"http:\/\/mathworld.wolfram.com\/EulerianCircuit.html\">Eulerian\n * circuit<\/a>). Also, if a graph is Eulerian, the caller can obtain a list of\n * vertices making up the Eulerian circuit. An Eulerian circuit is a circuit\n * which traverses each edge exactly once.\n *\n * @author Andrew Newell\n * @since Dec 21, 2008\n *\/\n","className":"EulerianCircuit","fields":[]}],"sourceFileId":185,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.DirectedNeighborIndex","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.NeighborIndex.*;\n"},{"importId":4,"import":"import org.jgrapht.event.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which a neighbor index is to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a neighbor index is to be created.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.DirectedNeighborIndex(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 71,col 5)-(line 74,col 5)","constructorJavadocComment":"\n     * Creates a neighbor index for the specified directed graph.\n     *\n     * @param g the graph for which a neighbor index is to be created.\n     ","constructorDeclaration":"public DirectedNeighborIndex(DirectedGraph<V, E> g)","constructorBody":"{\n    graph = g;\n}","constructorName":"DirectedNeighborIndex","constructorQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.DirectedNeighborIndex","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public DirectedNeighborIndex(DirectedGraph<V, E> g)\n    {\n        graph = g;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a neighbor index for the specified directed graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a neighbor index is to be created.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose predecessors are desired","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose predecessors are desired'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all unique predecessors of the specified vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all unique predecessors of the specified vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> predecessorsOf(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getPredecessors(v).getNeighbors();\n}","methodRange":"(line 86,col 5)-(line 89,col 5)","methodTokenRange":"public Set<V> predecessorsOf(V v)\n    {\n        return getPredecessors(v).getNeighbors();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the set of vertices which are the predecessors of a specified\n     * vertex. The returned set is backed by the index, and will be updated when\n     * the graph changes as long as the index has been added as a listener to\n     * the graph.\n     *\n     * @param v the vertex whose predecessors are desired\n     *\n     * @return all unique predecessors of the specified vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"predecessorsOf","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.predecessorsOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the set of vertices which are the predecessors of a specified\nvertex. The returned set is backed by the index, and will be updated when\nthe graph changes as long as the index has been added as a listener to\nthe graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose predecessors are desired'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all unique predecessors of the specified vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.predecessorsOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose predecessors are desired","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose predecessors are desired'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all predecessors of the specified vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all predecessors of the specified vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<V> predecessorListOf(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getPredecessors(v).getNeighborList();\n}","methodRange":"(line 103,col 5)-(line 106,col 5)","methodTokenRange":"public List<V> predecessorListOf(V v)\n    {\n        return getPredecessors(v).getNeighborList();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the set of vertices which are the predecessors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of predecessors can not be\n     * efficiently maintained, it is reconstructed on every invocation by\n     * duplicating entries in the neighbor set. It is thus more efficient to use\n     * {@link #predecessorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose predecessors are desired\n     *\n     * @return all predecessors of the specified vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"predecessorListOf","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.predecessorListOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the set of vertices which are the predecessors of a specified\nvertex. If the graph is a multigraph, vertices may appear more than once\nin the returned list. Because a list of predecessors can not be\nefficiently maintained, it is reconstructed on every invocation by\nduplicating entries in the neighbor set. It is thus more efficient to use\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #predecessorsOf(Object)'}, JavadocSnippet{text=' unless duplicate neighbors are required.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose predecessors are desired'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all predecessors of the specified vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.predecessorListOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose successors are desired","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose successors are desired'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all unique successors of the specified vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all unique successors of the specified vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> successorsOf(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getSuccessors(v).getNeighbors();\n}","methodRange":"(line 118,col 5)-(line 121,col 5)","methodTokenRange":"public Set<V> successorsOf(V v)\n    {\n        return getSuccessors(v).getNeighbors();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. The returned set is backed by the index, and will be updated when\n     * the graph changes as long as the index has been added as a listener to\n     * the graph.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all unique successors of the specified vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"successorsOf","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.successorsOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the set of vertices which are the successors of a specified\nvertex. The returned set is backed by the index, and will be updated when\nthe graph changes as long as the index has been added as a listener to\nthe graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose successors are desired'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all unique successors of the specified vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.successorsOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose successors are desired","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose successors are desired'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all successors of the specified vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all successors of the specified vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<V> successorListOf(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getSuccessors(v).getNeighborList();\n}","methodRange":"(line 135,col 5)-(line 138,col 5)","methodTokenRange":"public List<V> successorListOf(V v)\n    {\n        return getSuccessors(v).getNeighborList();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the set of vertices which are the successors of a specified\n     * vertex. If the graph is a multigraph, vertices may appear more than once\n     * in the returned list. Because a list of successors can not be efficiently\n     * maintained, it is reconstructed on every invocation by duplicating\n     * entries in the neighbor set. It is thus more efficient to use {@link\n     * #successorsOf(Object)} unless duplicate neighbors are required.\n     *\n     * @param v the vertex whose successors are desired\n     *\n     * @return all successors of the specified vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"successorListOf","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.successorListOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the set of vertices which are the successors of a specified\nvertex. If the graph is a multigraph, vertices may appear more than once\nin the returned list. Because a list of successors can not be efficiently\nmaintained, it is reconstructed on every invocation by duplicating\nentries in the neighbor set. It is thus more efficient to use '}, JavadocInlineTag{tagName='link', type=LINK, content='\n#successorsOf(Object)'}, JavadocSnippet{text=' unless duplicate neighbors are required.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose successors are desired'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all successors of the specified vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.successorListOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphListener#edgeAdded(GraphEdgeChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeAdded(GraphEdgeChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeAdded(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E edge = e.getEdge();\n    V source = graph.getEdgeSource(edge);\n    V target = graph.getEdgeTarget(edge);\n    if (successorMap.containsKey(source)) {\n        getSuccessors(source).addNeighbor(target);\n    } else {\n        getSuccessors(source);\n    }\n    if (predecessorMap.containsKey(target)) {\n        getPredecessors(target).addNeighbor(source);\n    } else {\n        getPredecessors(target);\n    }\n}","methodRange":"(line 143,col 5)-(line 164,col 5)","methodTokenRange":"@Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n\n        \/\/ if a map does not already contain an entry,\n        \/\/ then skip addNeighbor, since instantiating the map\n        \/\/ will take care of processing the edge (which has already\n        \/\/ been added)\n\n        if (successorMap.containsKey(source)) {\n            getSuccessors(source).addNeighbor(target);\n        } else {\n            getSuccessors(source);\n        }\n        if (predecessorMap.containsKey(target)) {\n            getPredecessors(target).addNeighbor(source);\n        } else {\n            getPredecessors(target);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeAdded","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.edgeAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeAdded(GraphEdgeChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.edgeAdded(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphListener#edgeRemoved(GraphEdgeChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeRemoved(GraphEdgeChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E edge = e.getEdge();\n    V source = e.getEdgeSource();\n    V target = e.getEdgeTarget();\n    if (successorMap.containsKey(source)) {\n        successorMap.get(source).removeNeighbor(target);\n    }\n    if (predecessorMap.containsKey(target)) {\n        predecessorMap.get(target).removeNeighbor(source);\n    }\n}","methodRange":"(line 169,col 5)-(line 180,col 5)","methodTokenRange":"@Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = e.getEdgeSource();\n        V target = e.getEdgeTarget();\n        if (successorMap.containsKey(source)) {\n            successorMap.get(source).removeNeighbor(target);\n        }\n        if (predecessorMap.containsKey(target)) {\n            predecessorMap.get(target).removeNeighbor(source);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeRemoved","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.edgeRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeRemoved(GraphEdgeChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.edgeRemoved(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexSetListener#vertexAdded(GraphVertexChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexAdded(GraphVertexChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexAdded(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 185,col 5)-(line 188,col 5)","methodTokenRange":"@Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n    {\n        \/\/ nothing to cache until there are edges\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexAdded","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.vertexAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexAdded(GraphVertexChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.vertexAdded(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexSetListener#vertexRemoved(GraphVertexChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexRemoved(GraphVertexChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexRemoved(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    predecessorMap.remove(e.getVertex());\n    successorMap.remove(e.getVertex());\n}","methodRange":"(line 193,col 5)-(line 197,col 5)","methodTokenRange":"@Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n    {\n        predecessorMap.remove(e.getVertex());\n        successorMap.remove(e.getVertex());\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexRemoved","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.vertexRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexRemoved(GraphVertexChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.vertexRemoved(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"methodDeclaration":"private Neighbors<V, E> getPredecessors(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Neighbors<V, E> neighbors = predecessorMap.get(v);\n    if (neighbors == null) {\n        neighbors = new Neighbors<V, E>(v, Graphs.predecessorListOf(graph, v));\n        predecessorMap.put(v, neighbors);\n    }\n    return neighbors;\n}","methodRange":"(line 199,col 5)-(line 209,col 5)","methodTokenRange":"private Neighbors<V, E> getPredecessors(V v)\n    {\n        Neighbors<V, E> neighbors = predecessorMap.get(v);\n        if (neighbors == null) {\n            neighbors =\n                new Neighbors<V, E>(v,\n                    Graphs.predecessorListOf(graph, v));\n            predecessorMap.put(v, neighbors);\n        }\n        return neighbors;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getPredecessors","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.getPredecessors","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Neighbors<V, E>","literalExprs":[{"literalExprRange":"(line 202,col 26)-(line 202,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.getPredecessors(V)"},{"methodDeclaration":"private Neighbors<V, E> getSuccessors(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Neighbors<V, E> neighbors = successorMap.get(v);\n    if (neighbors == null) {\n        neighbors = new Neighbors<V, E>(v, Graphs.successorListOf(graph, v));\n        successorMap.put(v, neighbors);\n    }\n    return neighbors;\n}","methodRange":"(line 211,col 5)-(line 221,col 5)","methodTokenRange":"private Neighbors<V, E> getSuccessors(V v)\n    {\n        Neighbors<V, E> neighbors = successorMap.get(v);\n        if (neighbors == null) {\n            neighbors =\n                new Neighbors<V, E>(v,\n                    Graphs.successorListOf(graph, v));\n            successorMap.put(v, neighbors);\n        }\n        return neighbors;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getSuccessors","methodQualifiedSignature":"org.jgrapht.alg.DirectedNeighborIndex.getSuccessors","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Neighbors<V, E>","literalExprs":[{"literalExprRange":"(line 214,col 26)-(line 214,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.DirectedNeighborIndex.getSuccessors(V)"}],"classJavadoc":"\/**\n * Maintains a cache of each vertex's neighbors. While lists of neighbors can be\n * obtained from {@link Graphs}, they are re-calculated at each invocation by\n * walking a vertex's incident edges, which becomes inordinately expensive when\n * performed often.\n *\n * <p>A vertex's neighbors are cached the first time they are asked for (i.e.\n * the index is built on demand). The index will only be updated automatically\n * if it is added to the associated graph as a listener. If it is added as a\n * listener to a graph other than the one it indexes, results are undefined.<\/p>\n *\n * @author Charles Fry\n * @since Dec 13, 2005\n *\/\n","className":"DirectedNeighborIndex","fields":[{"fieldRange":"(line 62,col 5)-(line 62,col 79)","fieldName":"predecessorMap","fieldJavadocComment":"","fieldTokenRange":"Map<V, Neighbors<V, E>> predecessorMap = new HashMap<V, Neighbors<V, E>>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.NeighborIndex.Neighbors, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.NeighborIndex.Neighbors.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.NeighborIndex.Neighbors.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, Neighbors<V, E>>()]","fieldType":"Map<V, Neighbors<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.NeighborIndex.Neighbors<V, E>>"},{"fieldRange":"(line 63,col 5)-(line 63,col 77)","fieldName":"successorMap","fieldJavadocComment":"","fieldTokenRange":"Map<V, Neighbors<V, E>> successorMap = new HashMap<V, Neighbors<V, E>>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.NeighborIndex.Neighbors, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.NeighborIndex.Neighbors.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.NeighborIndex.Neighbors.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, Neighbors<V, E>>()]","fieldType":"Map<V, Neighbors<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.NeighborIndex.Neighbors<V, E>>"},{"fieldRange":"(line 64,col 5)-(line 64,col 38)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"}]}],"sourceFileId":186,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.NaiveLcaFinder","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"org.jgrapht.alg.NaiveLcaFinder.NaiveLcaFinder(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 81,col 5)-(line 84,col 5)","constructorJavadocComment":"\n     * Find the Lowest Common Ancestor of a directed graph.\n     *\n     * <p>Find the LCA, defined as <i>Let G = (V, E) be a DAG, and let x, y  V\n     * . Let G x,y be the subgraph of G induced by the set of all common\n     * ancestors of x and y. Define SLCA (x, y) to be the set of out-degree 0\n     * nodes (leafs) in G x,y . The lowest common ancestors of x and y are the\n     * elements of SLCA (x, y). This naive algorithm simply starts at a and b,\n     * recursing upwards to the root(s) of the DAG. Wherever the recursion paths\n     * cross we have found our LCA.<\/i> from\n     * http:\/\/www.cs.sunysb.edu\/~bender\/pub\/JALG05-daglca.pdf. The algorithm:\n     *\n     * <pre>\n     * 1. Start at each of nodes you wish to find the lca for (a and b)\n     * 2. Create sets aSet containing a, and bSet containing b\n     * 3. If either set intersects with the union of the other sets previous values (i.e. the set of notes visited) then\n     *    that intersection is LCA. if there are multiple intersections then the earliest one added is the LCA.\n     * 4. Repeat from step 3, with aSet now the parents of everything in aSet, and bSet the parents of everything in bSet\n     * 5. If there are no more parents to descend to then there is no LCA\n     * <\/pre>\n     *\n     * The rationale for this working is that in each iteration of the loop we\n     * are considering all the ancestors of a that have a path of length n back\n     * to a, where n is the depth of the recursion. The same is true of b.\n     *\n     * <p>We start by checking if a == b.<br>\n     * if not we look to see if there is any intersection between parents(a) and\n     * (parents(b) union b) (and the same with a and b swapped)<br>\n     * if not we look to see if there is any intersection between\n     * parents(parents(a)) and (parents(parents(b)) union parents(b) union b)\n     * (and the same with a and b swapped)<br>\n     * continues\n     *\n     * <p>This means at the end of recursion n, we know if there is an LCA that\n     * has a path of &lt;=n to a and b. Of course we may have to wait longer if\n     * the path to a is of length n, but the path to b&gt;n. at the first loop\n     * we have a path of 0 length from the nodes we are considering as LCA to\n     * their respective children which we wish to find the LCA for.\n     ","constructorDeclaration":"public NaiveLcaFinder(DirectedGraph<V, E> graph)","constructorBody":"{\n    this.graph = graph;\n}","constructorName":"NaiveLcaFinder","constructorQualifiedName":"org.jgrapht.alg.NaiveLcaFinder.NaiveLcaFinder","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[],"constructorTokenRange":"public NaiveLcaFinder(DirectedGraph<V, E> graph)\n    {\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Find the Lowest Common Ancestor of a directed graph.\n\n<p>Find the LCA, defined as <i>Let G = (V, E) be a DAG, and let x, y  V\n. Let G x,y be the subgraph of G induced by the set of all common\nancestors of x and y. Define SLCA (x, y) to be the set of out-degree 0\nnodes (leafs) in G x,y . The lowest common ancestors of x and y are the\nelements of SLCA (x, y). This naive algorithm simply starts at a and b,\nrecursing upwards to the root(s) of the DAG. Wherever the recursion paths\ncross we have found our LCA.<\/i> from\nhttp:\/\/www.cs.sunysb.edu\/~bender\/pub\/JALG05-daglca.pdf. The algorithm:\n\n<pre>\n1. Start at each of nodes you wish to find the lca for (a and b)\n2. Create sets aSet containing a, and bSet containing b\n3. If either set intersects with the union of the other sets previous values (i.e. the set of notes visited) then\n   that intersection is LCA. if there are multiple intersections then the earliest one added is the LCA.\n4. Repeat from step 3, with aSet now the parents of everything in aSet, and bSet the parents of everything in bSet\n5. If there are no more parents to descend to then there is no LCA\n<\/pre>\n\nThe rationale for this working is that in each iteration of the loop we\nare considering all the ancestors of a that have a path of length n back\nto a, where n is the depth of the recursion. The same is true of b.\n\n<p>We start by checking if a == b.<br>\nif not we look to see if there is any intersection between parents(a) and\n(parents(b) union b) (and the same with a and b swapped)<br>\nif not we look to see if there is any intersection between\nparents(parents(a)) and (parents(parents(b)) union parents(b) union b)\n(and the same with a and b swapped)<br>\ncontinues\n\n<p>This means at the end of recursion n, we know if there is an LCA that\nhas a path of &lt;=n to a and b. Of course we may have to wait longer if\nthe path to a is of length n, but the path to b&gt;n. at the first loop\nwe have a path of 0 length from the nodes we are considering as LCA to\ntheir respective children which we wish to find the LCA for.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first element to find LCA for","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first element to find LCA for'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the other element to find the LCA for","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the other element to find the LCA for'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the first found LCA of a and b, or null if there is no LCA.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the first found LCA of a and b, or null if there is no LCA.'}]}', name=Optional.empty}"}],"methodDeclaration":"public V findLca(V a, V b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return findLca(Collections.singleton(a), Collections.singleton(b), new LinkedHashSet<V>(), new LinkedHashSet<V>());\n}","methodRange":"(line 94,col 5)-(line 101,col 5)","methodTokenRange":"public V findLca(V a, V b)\n    {\n        return findLca(\n            Collections.singleton(a),\n            Collections.singleton(b),\n            new LinkedHashSet<V>(),\n            new LinkedHashSet<V>());\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Return the first found LCA of a and b\n     *\n     * @param a the first element to find LCA for\n     * @param b the other element to find the LCA for\n     *\n     * @return the first found LCA of a and b, or null if there is no LCA.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"findLca","methodQualifiedSignature":"org.jgrapht.alg.NaiveLcaFinder.findLca","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the first found LCA of a and b'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first element to find LCA for'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the other element to find the LCA for'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the first found LCA of a and b, or null if there is no LCA.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NaiveLcaFinder.findLca(V, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first element to find LCA for","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first element to find LCA for'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the other element to find the LCA for","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the other element to find the LCA for'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the set of all LCA of a and b, or empty set if there is no LCA.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the set of all LCA of a and b, or empty set if there is no LCA.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> findLcas(V a, V b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(\"findLcas has not yet been implemented\");\n}","methodRange":"(line 111,col 5)-(line 115,col 5)","methodTokenRange":"public Set<V> findLcas(V a, V b)\n    {\n        throw new UnsupportedOperationException(\n            \"findLcas has not yet been implemented\");\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Return all the LCA of a and b. Currently not implemented\n     *\n     * @param a the first element to find LCA for\n     * @param b the other element to find the LCA for\n     *\n     * @return the set of all LCA of a and b, or empty set if there is no LCA.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V a","parameterName":"a"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V b","parameterName":"b"}],"methodName":"findLcas","methodQualifiedSignature":"org.jgrapht.alg.NaiveLcaFinder.findLcas","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return all the LCA of a and b. Currently not implemented'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first element to find LCA for'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the other element to find the LCA for'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the set of all LCA of a and b, or empty set if there is no LCA.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 114,col 13)-(line 114,col 51)","literalExprId":1,"literalExpr":"\"findLcas has not yet been implemented\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.NaiveLcaFinder.findLcas(V, V)"},{"javadocBlockTags":[],"methodDeclaration":"private V findLca(Set<V> aSet, Set<V> bSet, LinkedHashSet<V> aSeenSet, LinkedHashSet<V> bSeenSet)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if ((aSet.size() == 0) && (bSet.size() == 0)) {\n        return null;\n    }\n    if (!Collections.disjoint(aSet, bSeenSet)) {\n        return overlappingMember(aSet, bSeenSet);\n    }\n    if (!Collections.disjoint(bSet, aSeenSet)) {\n        return overlappingMember(bSet, aSeenSet);\n    }\n    if (!Collections.disjoint(aSet, bSet)) {\n        return overlappingMember(aSet, bSet);\n    }\n    aSeenSet.addAll(aSet);\n    bSeenSet.addAll(bSet);\n    aSet = allParents(aSet);\n    aSet.removeAll(aSeenSet);\n    bSet = allParents(bSet);\n    bSet.removeAll(bSeenSet);\n    return findLca(aSet, bSet, aSeenSet, bSeenSet);\n}","methodRange":"(line 122,col 5)-(line 159,col 5)","methodTokenRange":"private V findLca(\n        Set<V> aSet,\n        Set<V> bSet,\n        LinkedHashSet<V> aSeenSet,\n        LinkedHashSet<V> bSeenSet)\n    {\n        \/\/ if there is no LCA...\n        if ((aSet.size() == 0) && (bSet.size() == 0)) {\n            return null;\n        }\n\n        \/\/ does aSet intersect with bSeenSet\n        if (!Collections.disjoint(aSet, bSeenSet)) {\n            return overlappingMember(aSet, bSeenSet);\n        }\n\n        \/\/ does bSet intersect with aSeenSet\n        if (!Collections.disjoint(bSet, aSeenSet)) {\n            return overlappingMember(bSet, aSeenSet);\n        }\n        if (!Collections.disjoint(aSet, bSet)) {\n            return overlappingMember(aSet, bSet);\n        }\n\n        aSeenSet.addAll(aSet);\n        bSeenSet.addAll(bSet);\n\n        aSet = allParents(aSet);\n\n        \/\/ no point doing the same again (and it can stop us getting stuck in\n        \/\/ an infinite loop)\n        aSet.removeAll(aSeenSet);\n\n        bSet = allParents(bSet);\n        bSet.removeAll(bSeenSet);\n\n        return findLca(aSet, bSet, aSeenSet, bSeenSet);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Recurse through the descendants of aSet and bSet looking for the LCA of a\n     * and b, which are members of sets aSeenSet and bSeenSet respectively,\n     * along with all elements on the paths from every member of aSet and bSet\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> aSet","parameterName":"aSet"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> bSet","parameterName":"bSet"},{"parameterType":"LinkedHashSet<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.LinkedHashSet, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedHashSet.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.LinkedHashSet<V>","parameter":"LinkedHashSet<V> aSeenSet","parameterName":"aSeenSet"},{"parameterType":"LinkedHashSet<V>","parameterId":4,"parameterTypeResolved":"ReferenceType{java.util.LinkedHashSet, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedHashSet.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.LinkedHashSet<V>","parameter":"LinkedHashSet<V> bSeenSet","parameterName":"bSeenSet"}],"methodName":"findLca","methodQualifiedSignature":"org.jgrapht.alg.NaiveLcaFinder.findLca","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Recurse through the descendants of aSet and bSet looking for the LCA of a\nand b, which are members of sets aSeenSet and bSeenSet respectively,\nalong with all elements on the paths from every member of aSet and bSet'}]}, blockTags=[]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 129,col 29)-(line 129,col 29)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 129,col 51)-(line 129,col 51)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 130,col 20)-(line 130,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.NaiveLcaFinder.findLca(java.util.Set<V>, java.util.Set<V>, java.util.LinkedHashSet<V>, java.util.LinkedHashSet<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the set of vertex to find parents of","javadocBlockTagName":"vertexSet","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the set of vertex to find parents of'}]}', name=Optional[vertexSet]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of every parent of every vertex passed in","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of every parent of every vertex passed in'}]}', name=Optional.empty}"}],"methodDeclaration":"private Set<V> allParents(Set<V> vertexSet)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    HashSet<V> result = new HashSet<V>();\n    for (V e : vertexSet) {\n        for (E edge : graph.incomingEdgesOf(e)) {\n            if (graph.getEdgeTarget(edge).equals(e)) {\n                result.add(graph.getEdgeSource(edge));\n            }\n        }\n    }\n    return result;\n}","methodRange":"(line 169,col 5)-(line 180,col 5)","methodTokenRange":"private Set<V> allParents(Set<V> vertexSet)\n    {\n        HashSet<V> result = new HashSet<V>();\n        for (V e : vertexSet) {\n            for (E edge : graph.incomingEdgesOf(e)) {\n                if (graph.getEdgeTarget(edge).equals(e)) {\n                    result.add(graph.getEdgeSource(edge));\n                }\n            }\n        }\n        return result;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Find the immediate parents of every item in the given set, and return a\n     * set containing all those parents\n     *\n     * @param vertexSet the set of vertex to find parents of\n     *\n     * @return a set of every parent of every vertex passed in\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexSet","parameterName":"vertexSet"}],"methodName":"allParents","methodQualifiedSignature":"org.jgrapht.alg.NaiveLcaFinder.allParents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Find the immediate parents of every item in the given set, and return a\nset containing all those parents'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the set of vertex to find parents of'}]}', name=Optional[vertexSet]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of every parent of every vertex passed in'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NaiveLcaFinder.allParents(java.util.Set<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"set containing vertex","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='set containing vertex'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"set containing vertex, which may be ordered to give predictable\nresults","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='set containing vertex, which may be ordered to give predictable\nresults'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the first element of y that is also in x, or null if no such\nelement","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the first element of y that is also in x, or null if no such\nelement'}]}', name=Optional.empty}"}],"methodDeclaration":"private V overlappingMember(Set<V> x, Set<V> y)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    y.retainAll(x);\n    return y.iterator().next();\n}","methodRange":"(line 195,col 5)-(line 199,col 5)","methodTokenRange":"private V overlappingMember(Set<V> x, Set<V> y)\n    {\n        y.retainAll(x);\n        return y.iterator().next();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Return a single vertex that is both in x and y. If there is more than one\n     * then select the first element from the iterator returned from y, after\n     * all the elements of x have been removed. this allows an orderedSet to be\n     * passed in to give predictable results.\n     *\n     * @param x set containing vertex\n     * @param y set containing vertex, which may be ordered to give predictable\n     * results\n     *\n     * @return the first element of y that is also in x, or null if no such\n     * element\n     ","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> x","parameterName":"x"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> y","parameterName":"y"}],"methodName":"overlappingMember","methodQualifiedSignature":"org.jgrapht.alg.NaiveLcaFinder.overlappingMember","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a single vertex that is both in x and y. If there is more than one\nthen select the first element from the iterator returned from y, after\nall the elements of x have been removed. this allows an orderedSet to be\npassed in to give predictable results.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='set containing vertex'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='set containing vertex, which may be ordered to give predictable\nresults'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the first element of y that is also in x, or null if no such\nelement'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NaiveLcaFinder.overlappingMember(java.util.Set<V>, java.util.Set<V>)"}],"classJavadoc":"","className":"NaiveLcaFinder","fields":[{"fieldRange":"(line 40,col 5)-(line 40,col 38)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"}]}],"sourceFileId":187,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.MaximumWeightBipartiteMatching","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"simple undirected weighted bipartite graph to find matching\nin, with positive integer edge weights","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='simple undirected weighted bipartite graph to find matching\nin, with positive integer edge weights'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"first vertex partition of the bipartite graph,\ndisjoint from vertexPartition2","javadocBlockTagName":"vertexPartition1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first vertex partition of the bipartite graph,\ndisjoint from vertexPartition2'}]}', name=Optional[vertexPartition1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second vertex partition of the bipartite graph,\ndisjoint from vertexPartition1","javadocBlockTagName":"vertexPartition2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second vertex partition of the bipartite graph,\ndisjoint from vertexPartition1'}]}', name=Optional[vertexPartition2]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.MaximumWeightBipartiteMatching(org.jgrapht.WeightedGraph<V, E>, java.util.Set<V>, java.util.Set<V>)","variableDeclarationExprs":[],"constructorRange":"(line 78,col 5)-(line 92,col 5)","constructorJavadocComment":"\n     * Creates a new MaximumWeightBipartiteMatching algorithm instance. The\n     * union of vertexPartition1 and vertexParition2 should be equal to the\n     * vertex set of the graph Every edge in the graph must connect a vertex in\n     * vertexPartition1 with a vertex in vertexPartition2\n     *\n     * @param graph simple undirected weighted bipartite graph to find matching\n     * in, with positive integer edge weights\n     * @param vertexPartition1 first vertex partition of the bipartite graph,\n     * disjoint from vertexPartition2\n     * @param vertexPartition2 second vertex partition of the bipartite graph,\n     * disjoint from vertexPartition1\n     ","constructorDeclaration":"public MaximumWeightBipartiteMatching(final WeightedGraph<V, E> graph, Set<V> vertexPartition1, Set<V> vertexPartition2)","constructorBody":"{\n    this.graph = graph;\n    partition1 = vertexPartition1;\n    partition2 = vertexPartition2;\n    vertexWeights = new HashMap<V, Long>();\n    hasVertexBeenProcessed = new HashMap<V, Boolean>();\n    isEdgeMatched = new HashMap<E, Boolean>();\n    initializeVerticesAndEdges();\n}","constructorName":"MaximumWeightBipartiteMatching","constructorQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.MaximumWeightBipartiteMatching","constructorParameters":[{"parameterType":"WeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>","parameter":"final WeightedGraph<V, E> graph","parameterName":"graph"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexPartition1","parameterName":"vertexPartition1"},{"parameterType":"Set<V>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertexPartition2","parameterName":"vertexPartition2"}],"literalExprs":[],"constructorTokenRange":"public MaximumWeightBipartiteMatching(\n        final WeightedGraph<V, E> graph,\n        Set<V> vertexPartition1,\n        Set<V> vertexPartition2)\n    {\n        this.graph = graph;\n        partition1 = vertexPartition1;\n        partition2 = vertexPartition2;\n\n        vertexWeights = new HashMap<V, Long>();\n        hasVertexBeenProcessed = new HashMap<V, Boolean>();\n        isEdgeMatched = new HashMap<E, Boolean>();\n\n        initializeVerticesAndEdges();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new MaximumWeightBipartiteMatching algorithm instance. The\nunion of vertexPartition1 and vertexParition2 should be equal to the\nvertex set of the graph Every edge in the graph must connect a vertex in\nvertexPartition1 with a vertex in vertexPartition2'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='simple undirected weighted bipartite graph to find matching\nin, with positive integer edge weights'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first vertex partition of the bipartite graph,\ndisjoint from vertexPartition2'}]}', name=Optional[vertexPartition1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second vertex partition of the bipartite graph,\ndisjoint from vertexPartition1'}]}', name=Optional[vertexPartition2]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public Set<E> getMatching()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (bipartiteMatching == null) {\n        bipartiteMatching = maximumWeightBipartiteMatching();\n    }\n    return bipartiteMatching;\n}","methodRange":"(line 94,col 5)-(line 100,col 5)","methodTokenRange":"@Override public Set<E> getMatching()\n    {\n        if (bipartiteMatching == null) {\n            bipartiteMatching = maximumWeightBipartiteMatching();\n        }\n        return bipartiteMatching;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getMatching","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.getMatching","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 96,col 34)-(line 96,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.getMatching()"},{"methodDeclaration":"public double getMatchingWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (bipartiteMatching == null) {\n        getMatching();\n    }\n    long weight = 0;\n    for (E edge : bipartiteMatching) {\n        weight += graph.getEdgeWeight(edge);\n    }\n    return weight;\n}","methodRange":"(line 102,col 5)-(line 114,col 5)","methodTokenRange":"@Override public double getMatchingWeight()\n    {\n        if (bipartiteMatching == null) {\n            getMatching();\n        }\n\n        long weight = 0;\n        for (E edge : bipartiteMatching) {\n            weight += graph.getEdgeWeight(edge);\n        }\n\n        return weight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[],"methodName":"getMatchingWeight","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.getMatchingWeight","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 104,col 34)-(line 104,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 108,col 23)-(line 108,col 23)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.getMatchingWeight()"},{"methodDeclaration":"private void initializeVerticesAndEdges()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V vertex : graph.vertexSet()) {\n        if (isTargetVertex(vertex)) {\n            hasVertexBeenProcessed.put(vertex, true);\n            setVertexWeight(vertex, (long) 0);\n        } else {\n            hasVertexBeenProcessed.put(vertex, false);\n            setVertexWeight(vertex, (long) maximumWeightOfEdgeIncidentToVertex(vertex));\n        }\n    }\n    for (E edge : graph.edgeSet()) {\n        isEdgeMatched.put(edge, false);\n    }\n}","methodRange":"(line 116,col 5)-(line 133,col 5)","methodTokenRange":"private void initializeVerticesAndEdges()\n    {\n        for (V vertex : graph.vertexSet()) {\n            if (isTargetVertex(vertex)) {\n                hasVertexBeenProcessed.put(vertex, true);\n                setVertexWeight(vertex, (long) 0);\n            } else {\n                hasVertexBeenProcessed.put(vertex, false);\n                setVertexWeight(\n                    vertex,\n                    (long) maximumWeightOfEdgeIncidentToVertex(vertex));\n            }\n        }\n\n        for (E edge : graph.edgeSet()) {\n            isEdgeMatched.put(edge, false);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"initializeVerticesAndEdges","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.initializeVerticesAndEdges","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 120,col 52)-(line 120,col 55)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 121,col 48)-(line 121,col 48)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 52)-(line 123,col 56)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 131,col 37)-(line 131,col 41)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.initializeVerticesAndEdges()"},{"methodDeclaration":"private long maximumWeightOfEdgeIncidentToVertex(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    long maxWeight = 0;\n    for (E edge : graph.edgesOf(vertex)) {\n        if (graph.getEdgeWeight(edge) > maxWeight) {\n            maxWeight = (long) graph.getEdgeWeight(edge);\n        }\n    }\n    return maxWeight;\n}","methodRange":"(line 135,col 5)-(line 144,col 5)","methodTokenRange":"private long maximumWeightOfEdgeIncidentToVertex(V vertex)\n    {\n        long maxWeight = 0;\n        for (E edge : graph.edgesOf(vertex)) {\n            if (graph.getEdgeWeight(edge) > maxWeight) {\n                maxWeight = (long) graph.getEdgeWeight(edge);\n            }\n        }\n        return maxWeight;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"maximumWeightOfEdgeIncidentToVertex","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.maximumWeightOfEdgeIncidentToVertex","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 137,col 26)-(line 137,col 26)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.maximumWeightOfEdgeIncidentToVertex(V)"},{"methodDeclaration":"private boolean isSourceVertex(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return partition1.contains(vertex);\n}","methodRange":"(line 146,col 5)-(line 149,col 5)","methodTokenRange":"private boolean isSourceVertex(V vertex)\n    {\n        return partition1.contains(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"isSourceVertex","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.isSourceVertex","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.isSourceVertex(V)"},{"methodDeclaration":"private boolean isTargetVertex(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return partition2.contains(vertex);\n}","methodRange":"(line 151,col 5)-(line 154,col 5)","methodTokenRange":"private boolean isTargetVertex(V vertex)\n    {\n        return partition2.contains(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"isTargetVertex","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.isTargetVertex","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.isTargetVertex(V)"},{"methodDeclaration":"private long vertexWeight(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return vertexWeights.get(vertex);\n}","methodRange":"(line 156,col 5)-(line 159,col 5)","methodTokenRange":"private long vertexWeight(V vertex)\n    {\n        return vertexWeights.get(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"vertexWeight","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.vertexWeight","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.vertexWeight(V)"},{"methodDeclaration":"private void setVertexWeight(V vertex, Long weight)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    vertexWeights.put(vertex, weight);\n}","methodRange":"(line 161,col 5)-(line 164,col 5)","methodTokenRange":"private void setVertexWeight(V vertex, Long weight)\n    {\n        vertexWeights.put(vertex, weight);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"Long","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Long","parameter":"Long weight","parameterName":"weight"}],"methodName":"setVertexWeight","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.setVertexWeight","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.setVertexWeight(V, java.lang.Long)"},{"methodDeclaration":"private long reducedWeight(E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (long) (vertexWeight(graph.getEdgeSource(edge)) + vertexWeight(graph.getEdgeTarget(edge)) - graph.getEdgeWeight(edge));\n}","methodRange":"(line 166,col 5)-(line 171,col 5)","methodTokenRange":"private long reducedWeight(E edge)\n    {\n        return (long) (vertexWeight(graph.getEdgeSource(edge))\n            + vertexWeight(graph.getEdgeTarget(edge))\n            - graph.getEdgeWeight(edge));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"reducedWeight","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.reducedWeight","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.reducedWeight(E)"},{"methodDeclaration":"private boolean isVertexMatched(V vertex, Set<E> matchings)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (E edge : matchings) {\n        if (graph.getEdgeSource(edge).equals(vertex) || graph.getEdgeTarget(edge).equals(vertex)) {\n            return true;\n        }\n    }\n    return false;\n}","methodRange":"(line 173,col 5)-(line 183,col 5)","methodTokenRange":"private boolean isVertexMatched(V vertex, Set<E> matchings)\n    {\n        for (E edge : matchings) {\n            if (graph.getEdgeSource(edge).equals(vertex)\n                || graph.getEdgeTarget(edge).equals(vertex))\n            {\n                return true;\n            }\n        }\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"Set<E>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> matchings","parameterName":"matchings"}],"methodName":"isVertexMatched","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.isVertexMatched","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 179,col 24)-(line 179,col 27)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 182,col 16)-(line 182,col 20)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.isVertexMatched(V, java.util.Set<E>)"},{"methodDeclaration":"private void addPathToMatchings(List<E> path, Set<E> matchings)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (int i = 0; i < path.size(); i++) {\n        E edge = path.get(i);\n        if ((i % 2) == 0) {\n            isEdgeMatched.put(edge, true);\n            matchings.add(edge);\n        } else {\n            isEdgeMatched.put(edge, false);\n            matchings.remove(edge);\n        }\n    }\n}","methodRange":"(line 185,col 5)-(line 197,col 5)","methodTokenRange":"private void addPathToMatchings(List<E> path, Set<E> matchings)\n    {\n        for (int i = 0; i < path.size(); i++) {\n            E edge = path.get(i);\n            if ((i % 2) == 0) {\n                isEdgeMatched.put(edge, true);\n                matchings.add(edge);\n            } else {\n                isEdgeMatched.put(edge, false);\n                matchings.remove(edge);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"List<E>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<E>","parameter":"List<E> path","parameterName":"path"},{"parameterType":"Set<E>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<E>","parameter":"Set<E> matchings","parameterName":"matchings"}],"methodName":"addPathToMatchings","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.addPathToMatchings","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 187,col 22)-(line 187,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 189,col 22)-(line 189,col 22)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 189,col 28)-(line 189,col 28)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 41)-(line 190,col 44)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 193,col 41)-(line 193,col 45)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.addPathToMatchings(java.util.List<E>, java.util.Set<E>)"},{"methodDeclaration":"private void adjustVertexWeights(Map<V, List<E>> reachableVertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    long alpha = Long.MAX_VALUE;\n    for (V vertex : reachableVertices.keySet()) {\n        if (isSourceVertex(vertex) && (vertexWeights.get(vertex) < alpha)) {\n            alpha = vertexWeights.get(vertex);\n        }\n    }\n    long beta = Long.MAX_VALUE;\n    for (V vertex : reachableVertices.keySet()) {\n        if (isTargetVertex(vertex)) {\n            continue;\n        }\n        for (E edge : graph.edgesOf(vertex)) {\n            if (hasVertexBeenProcessed.get(Graphs.getOppositeVertex(graph, edge, vertex)) && !reachableVertices.keySet().contains(Graphs.getOppositeVertex(graph, edge, vertex)) && (reducedWeight(edge) < beta)) {\n                beta = reducedWeight(edge);\n            }\n        }\n    }\n    assert ((alpha > 0) && (beta > 0));\n    long minValue = Math.min(alpha, beta);\n    for (V vertex : reachableVertices.keySet()) {\n        if (isSourceVertex(vertex)) {\n            vertexWeights.put(vertex, vertexWeights.get(vertex) - minValue);\n        } else {\n            vertexWeights.put(vertex, vertexWeights.get(vertex) + minValue);\n        }\n    }\n}","methodRange":"(line 199,col 5)-(line 236,col 5)","methodTokenRange":"private void adjustVertexWeights(Map<V, List<E>> reachableVertices)\n    {\n        long alpha = Long.MAX_VALUE;\n        for (V vertex : reachableVertices.keySet()) {\n            if (isSourceVertex(vertex) && (vertexWeights.get(vertex) < alpha)) {\n                alpha = vertexWeights.get(vertex);\n            }\n        }\n\n        long beta = Long.MAX_VALUE;\n        for (V vertex : reachableVertices.keySet()) {\n            if (isTargetVertex(vertex)) {\n                continue;\n            }\n            for (E edge : graph.edgesOf(vertex)) {\n                if (hasVertexBeenProcessed.get(\n                        Graphs.getOppositeVertex(graph, edge, vertex))\n                    && !reachableVertices.keySet().contains(\n                        Graphs.getOppositeVertex(graph, edge, vertex))\n                    && (reducedWeight(edge) < beta))\n                {\n                    beta = reducedWeight(edge);\n                }\n            }\n        }\n\n        assert ((alpha > 0) && (beta > 0));\n\n        long minValue = Math.min(alpha, beta);\n\n        for (V vertex : reachableVertices.keySet()) {\n            if (isSourceVertex(vertex)) {\n                vertexWeights.put(vertex, vertexWeights.get(vertex) - minValue);\n            } else {\n                vertexWeights.put(vertex, vertexWeights.get(vertex) + minValue);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Map<V, List<E>>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.util.List<E>>","parameter":"Map<V, List<E>> reachableVertices","parameterName":"reachableVertices"}],"methodName":"adjustVertexWeights","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.adjustVertexWeights","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 225,col 26)-(line 225,col 26)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 225,col 40)-(line 225,col 40)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.adjustVertexWeights(java.util.Map<V, java.util.List<E>>)"},{"methodDeclaration":"private Map<V, List<E>> verticesReachableByTightAlternatingEdgesFromVertex(V vertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Map<V, List<E>> pathsToVertices = new HashMap<V, List<E>>();\n    pathsToVertices.put(vertex, new ArrayList<E>());\n    findPathsToVerticesFromVertices(Arrays.asList(vertex), false, pathsToVertices);\n    return pathsToVertices;\n}","methodRange":"(line 238,col 5)-(line 248,col 5)","methodTokenRange":"private Map<V, List<E>> verticesReachableByTightAlternatingEdgesFromVertex(\n        V vertex)\n    {\n        Map<V, List<E>> pathsToVertices = new HashMap<V, List<E>>();\n        pathsToVertices.put(vertex, new ArrayList<E>());\n        findPathsToVerticesFromVertices(\n            Arrays.asList(vertex),\n            false,\n            pathsToVertices);\n        return pathsToVertices;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"verticesReachableByTightAlternatingEdgesFromVertex","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.verticesReachableByTightAlternatingEdgesFromVertex","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Map<V, java.util.List<E>>","methodType":"Map<V, List<E>>","literalExprs":[{"literalExprRange":"(line 245,col 13)-(line 245,col 17)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.verticesReachableByTightAlternatingEdgesFromVertex(V)"},{"methodDeclaration":"private void findPathsToVerticesFromVertices(List<V> verticesToProcess, boolean needMatchedEdge, Map<V, List<E>> pathsToVertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (verticesToProcess.size() == 0) {\n        return;\n    }\n    List<V> nextVerticesToProcess = new ArrayList<V>();\n    for (V vertex : verticesToProcess) {\n        for (E edge : graph.edgesOf(vertex)) {\n            V adjacentVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n            if (hasVertexBeenProcessed.get(adjacentVertex) && (reducedWeight(edge) == 0) && !pathsToVertices.keySet().contains(adjacentVertex)) {\n                if ((needMatchedEdge && isEdgeMatched.get(edge)) || (!needMatchedEdge && !isEdgeMatched.get(edge))) {\n                    nextVerticesToProcess.add(adjacentVertex);\n                    List<E> pathToAdjacentVertex = new ArrayList<E>(pathsToVertices.get(vertex));\n                    pathToAdjacentVertex.add(edge);\n                    pathsToVertices.put(adjacentVertex, pathToAdjacentVertex);\n                }\n            }\n        }\n    }\n    findPathsToVerticesFromVertices(nextVerticesToProcess, !needMatchedEdge, pathsToVertices);\n}","methodRange":"(line 250,col 5)-(line 285,col 5)","methodTokenRange":"private void findPathsToVerticesFromVertices(\n        List<V> verticesToProcess,\n        boolean needMatchedEdge,\n        Map<V, List<E>> pathsToVertices)\n    {\n        if (verticesToProcess.size() == 0) {\n            return;\n        }\n        List<V> nextVerticesToProcess = new ArrayList<V>();\n        for (V vertex : verticesToProcess) {\n            for (E edge : graph.edgesOf(vertex)) {\n                V adjacentVertex =\n                    Graphs.getOppositeVertex(graph, edge, vertex);\n                if (hasVertexBeenProcessed.get(adjacentVertex)\n                    && (reducedWeight(edge) == 0)\n                    && !pathsToVertices.keySet().contains(adjacentVertex))\n                {\n                    if ((needMatchedEdge && isEdgeMatched.get(edge))\n                        || (!needMatchedEdge && !isEdgeMatched.get(edge)))\n                    {\n                        nextVerticesToProcess.add(adjacentVertex);\n                        List<E> pathToAdjacentVertex =\n                            new ArrayList<E>(pathsToVertices.get(vertex));\n                        pathToAdjacentVertex.add(edge);\n                        pathsToVertices.put(\n                            adjacentVertex,\n                            pathToAdjacentVertex);\n                    }\n                }\n            }\n        }\n        findPathsToVerticesFromVertices(\n            nextVerticesToProcess,\n            !needMatchedEdge,\n            pathsToVertices);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"List<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> verticesToProcess","parameterName":"verticesToProcess"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean needMatchedEdge","parameterName":"needMatchedEdge"},{"parameterType":"Map<V, List<E>>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.util.List<E>>","parameter":"Map<V, List<E>> pathsToVertices","parameterName":"pathsToVertices"}],"methodName":"findPathsToVerticesFromVertices","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.findPathsToVerticesFromVertices","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 255,col 41)-(line 255,col 41)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 264,col 48)-(line 264,col 48)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.findPathsToVerticesFromVertices(java.util.List<V>, boolean, java.util.Map<V, java.util.List<E>>)"},{"methodDeclaration":"private Set<E> maximumWeightBipartiteMatching()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<E> matchings = new HashSet<E>();\n    for (V vertex : partition1) {\n        hasVertexBeenProcessed.put(vertex, true);\n        while (true) {\n            Map<V, List<E>> reachableVertices = verticesReachableByTightAlternatingEdgesFromVertex(vertex);\n            boolean successful = false;\n            for (V reachableVertex : reachableVertices.keySet()) {\n                if (isSourceVertex(reachableVertex) && (vertexWeight(reachableVertex) == 0)) {\n                    addPathToMatchings(reachableVertices.get(reachableVertex), matchings);\n                    successful = true;\n                    break;\n                }\n                if (isTargetVertex(reachableVertex) && !isVertexMatched(reachableVertex, matchings)) {\n                    addPathToMatchings(reachableVertices.get(reachableVertex), matchings);\n                    successful = true;\n                    break;\n                }\n            }\n            if (successful) {\n                break;\n            }\n            adjustVertexWeights(reachableVertices);\n        }\n    }\n    return matchings;\n}","methodRange":"(line 287,col 5)-(line 323,col 5)","methodTokenRange":"private Set<E> maximumWeightBipartiteMatching()\n    {\n        Set<E> matchings = new HashSet<E>();\n        for (V vertex : partition1) {\n            hasVertexBeenProcessed.put(vertex, true);\n            while (true) {\n                Map<V, List<E>> reachableVertices =\n                    verticesReachableByTightAlternatingEdgesFromVertex(vertex);\n                boolean successful = false;\n                for (V reachableVertex : reachableVertices.keySet()) {\n                    if (isSourceVertex(reachableVertex)\n                        && (vertexWeight(reachableVertex) == 0))\n                    {\n                        addPathToMatchings(\n                            reachableVertices.get(reachableVertex),\n                            matchings);\n                        successful = true;\n                        break;\n                    }\n                    if (isTargetVertex(reachableVertex)\n                        && !isVertexMatched(reachableVertex, matchings))\n                    {\n                        addPathToMatchings(\n                            reachableVertices.get(reachableVertex),\n                            matchings);\n                        successful = true;\n                        break;\n                    }\n                }\n                if (successful) {\n                    break;\n                }\n                adjustVertexWeights(reachableVertices);\n            }\n        }\n        return matchings;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"maximumWeightBipartiteMatching","methodQualifiedSignature":"org.jgrapht.alg.MaximumWeightBipartiteMatching.maximumWeightBipartiteMatching","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 291,col 48)-(line 291,col 51)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 292,col 20)-(line 292,col 23)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 295,col 38)-(line 295,col 42)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 298,col 62)-(line 298,col 62)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 303,col 38)-(line 303,col 41)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 312,col 38)-(line 312,col 41)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.MaximumWeightBipartiteMatching.maximumWeightBipartiteMatching()"}],"classJavadoc":"\/**\n * This class finds a maximum weight matching of a simple undirected weighted\n * bipartite graph. The algorithm runs in O(V|E|^2). The algorithm is described\n * in The LEDA Platform of Combinatorial and Geometric Computing, Cambridge\n * University Press, 1999. https:\/\/people.mpi-inf.mpg.de\/~mehlhorn\/LEDAbook.html\n * Note: the input graph must be bipartite with positive integer edge weights\n *\n * @author Graeme Ahokas\n *\/\n","className":"MaximumWeightBipartiteMatching","fields":[{"fieldRange":"(line 55,col 5)-(line 55,col 44)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private final WeightedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.WeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.WeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.WeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeightedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.WeightedGraph<V, E>"},{"fieldRange":"(line 56,col 5)-(line 56,col 36)","fieldName":"partition1","fieldJavadocComment":"","fieldTokenRange":"private final Set<V> partition1;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 57,col 5)-(line 57,col 36)","fieldName":"partition2","fieldJavadocComment":"","fieldTokenRange":"private final Set<V> partition2;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<V>"},{"fieldRange":"(line 59,col 5)-(line 59,col 39)","fieldName":"vertexWeights","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Long> vertexWeights;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Long>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Long>"},{"fieldRange":"(line 60,col 5)-(line 60,col 51)","fieldName":"hasVertexBeenProcessed","fieldJavadocComment":"","fieldTokenRange":"private Map<V, Boolean> hasVertexBeenProcessed;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, Boolean>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, java.lang.Boolean>"},{"fieldRange":"(line 61,col 5)-(line 61,col 42)","fieldName":"isEdgeMatched","fieldJavadocComment":"","fieldTokenRange":"private Map<E, Boolean> isEdgeMatched;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Boolean, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<E, Boolean>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<E, java.lang.Boolean>"},{"fieldRange":"(line 63,col 5)-(line 63,col 37)","fieldName":"bipartiteMatching","fieldJavadocComment":"","fieldTokenRange":"private Set<E> bipartiteMatching;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<E>"}]}],"sourceFileId":188,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.HamiltonianCycle","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"<V>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<V>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"<E>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<E>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"is the graph to find the optimal tour for.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='is the graph to find the optimal tour for.'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"The optimal tour as a list of vertices.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The optimal tour as a list of vertices.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<V> getApproximateOptimalForCompleteGraph(SimpleWeightedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<V> vertices = new LinkedList<V>(g.vertexSet());\n    if ((vertices.size() * (vertices.size() - 1) \/ 2) != g.edgeSet().size()) {\n        return null;\n    }\n    List<V> tour = new LinkedList<V>();\n    while (tour.size() != g.vertexSet().size()) {\n        boolean firstEdge = true;\n        double minEdgeValue = 0;\n        int minVertexFound = 0;\n        int vertexConnectedTo = 0;\n        for (int i = 0; i < tour.size(); i++) {\n            V v = tour.get(i);\n            for (int j = 0; j < vertices.size(); j++) {\n                double weight = g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                if (firstEdge || (weight < minEdgeValue)) {\n                    firstEdge = false;\n                    minEdgeValue = weight;\n                    minVertexFound = j;\n                    vertexConnectedTo = i;\n                }\n            }\n        }\n        tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n        vertices.remove(minVertexFound);\n    }\n    return tour;\n}","methodRange":"(line 70,col 5)-(line 112,col 5)","methodTokenRange":"public static <V, E> List<V> getApproximateOptimalForCompleteGraph(\n        SimpleWeightedGraph<V, E> g)\n    {\n        List<V> vertices = new LinkedList<V>(g.vertexSet());\n\n        \/\/ If the graph is not complete then return null since this algorithm\n        \/\/ requires the graph be complete\n        if ((vertices.size() * (vertices.size() - 1) \/ 2)\n            != g.edgeSet().size())\n        {\n            return null;\n        }\n\n        List<V> tour = new LinkedList<V>();\n\n        \/\/ Each iteration a new vertex will be added to the tour until all\n        \/\/ vertices have been added\n        while (tour.size() != g.vertexSet().size()) {\n            boolean firstEdge = true;\n            double minEdgeValue = 0;\n            int minVertexFound = 0;\n            int vertexConnectedTo = 0;\n\n            \/\/ A check will be made for the shortest edge to a vertex not within\n            \/\/ the tour and that new vertex will be added to the vertex\n            for (int i = 0; i < tour.size(); i++) {\n                V v = tour.get(i);\n                for (int j = 0; j < vertices.size(); j++) {\n                    double weight =\n                        g.getEdgeWeight(g.getEdge(v, vertices.get(j)));\n                    if (firstEdge || (weight < minEdgeValue)) {\n                        firstEdge = false;\n                        minEdgeValue = weight;\n                        minVertexFound = j;\n                        vertexConnectedTo = i;\n                    }\n                }\n            }\n            tour.add(vertexConnectedTo, vertices.get(minVertexFound));\n            vertices.remove(minVertexFound);\n        }\n        return tour;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * This method will return an approximate minimal traveling salesman tour\n     * (hamiltonian cycle). This algorithm requires that the graph be complete\n     * and the triangle inequality exists (if x,y,z are vertices then\n     * d(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\n     * guarantee a hamiltonian cycle such that the total weight of the cycle is\n     * less than or equal to double the total weight of the optimal hamiltonian\n     * cycle. The optimal solution is NP-complete, so this is a decent\n     * approximation that runs in polynomial time.\n     *\n     * @param <V>\n     * @param <E>\n     * @param g is the graph to find the optimal tour for.\n     *\n     * @return The optimal tour as a list of vertices.\n     ","methodParameters":[{"parameterType":"SimpleWeightedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.graph.SimpleWeightedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.graph.SimpleWeightedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.graph.SimpleWeightedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.graph.SimpleWeightedGraph<V, E>","parameter":"SimpleWeightedGraph<V, E> g","parameterName":"g"}],"methodName":"getApproximateOptimalForCompleteGraph","methodQualifiedSignature":"org.jgrapht.alg.HamiltonianCycle.getApproximateOptimalForCompleteGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This method will return an approximate minimal traveling salesman tour\n(hamiltonian cycle). This algorithm requires that the graph be complete\nand the triangle inequality exists (if x,y,z are vertices then\nd(x,y)+d(y,z) &lt; d(x,z) for all x,y,z) then this algorithm will\nguarantee a hamiltonian cycle such that the total weight of the cycle is\nless than or equal to double the total weight of the optimal hamiltonian\ncycle. The optimal solution is NP-complete, so this is a decent\napproximation that runs in polynomial time.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<V>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[<E>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='is the graph to find the optimal tour for.'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The optimal tour as a list of vertices.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[{"literalExprRange":"(line 77,col 51)-(line 77,col 51)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 56)-(line 77,col 56)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 80,col 20)-(line 80,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 88,col 33)-(line 88,col 36)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 89,col 35)-(line 89,col 35)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 90,col 34)-(line 90,col 34)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 91,col 37)-(line 91,col 37)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 95,col 26)-(line 95,col 26)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 97,col 30)-(line 97,col 30)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 101,col 37)-(line 101,col 41)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.HamiltonianCycle.getApproximateOptimalForCompleteGraph(org.jgrapht.graph.SimpleWeightedGraph<V, E>)"}],"classJavadoc":"\/**\n * This class will deal with finding the optimal or approximately optimal\n * minimum tour (hamiltonian cycle) or commonly known as the <a\n * href=\"http:\/\/mathworld.wolfram.com\/TravelingSalesmanProblem.html\">Traveling\n * Salesman Problem<\/a>.\n *\n * @author Andrew Newell\n *\/\n","className":"HamiltonianCycle","fields":[]}],"sourceFileId":189,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.KShortestPaths","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of paths to be computed.","javadocBlockTagName":"k","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of paths to be computed.'}]}', name=Optional[k]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.KShortestPaths.KShortestPaths(org.jgrapht.Graph<V, E>, V, int)","variableDeclarationExprs":[],"constructorRange":"(line 80,col 5)-(line 83,col 5)","constructorJavadocComment":"\n     * Creates an object to compute ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph\n     * @param startVertex\n     * @param k number of paths to be computed.\n     ","constructorDeclaration":"public KShortestPaths(Graph<V, E> graph, V startVertex, int k)","constructorBody":"{\n    this(graph, startVertex, k, graph.vertexSet().size() - 1);\n}","constructorName":"KShortestPaths","constructorQualifiedName":"org.jgrapht.alg.KShortestPaths.KShortestPaths","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int k","parameterName":"k"}],"literalExprs":[{"literalExprRange":"(line 82,col 64)-(line 82,col 64)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public KShortestPaths(Graph<V, E> graph, V startVertex, int k)\n    {\n        this(graph, startVertex, k, graph.vertexSet().size() - 1);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an object to compute ranking shortest paths between the start\nvertex and others vertices.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of paths to be computed.'}]}', name=Optional[k]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"graph on which shortest paths are searched.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph on which shortest paths are searched.'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"start vertex of the calculated paths.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex of the calculated paths.'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of ranking paths between the start vertex and an end\nvertex.","javadocBlockTagName":"nPaths","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of ranking paths between the start vertex and an end\nvertex.'}]}', name=Optional[nPaths]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum number of edges of the calculated paths.","javadocBlockTagName":"nMaxHops","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges of the calculated paths.'}]}', name=Optional[nMaxHops]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified graph or startVertex is\n<code>null<\/code>.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified graph or startVertex is\n<code>null<\/code>.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if nPaths is negative or 0.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if nPaths is negative or 0.'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if nMaxHops is negative or 0.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if nMaxHops is negative or 0.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.KShortestPaths.KShortestPaths(org.jgrapht.Graph<V, E>, V, int, int)","variableDeclarationExprs":[],"constructorRange":"(line 100,col 5)-(line 112,col 5)","constructorJavadocComment":"\n     * Creates an object to calculate ranking shortest paths between the start\n     * vertex and others vertices.\n     *\n     * @param graph graph on which shortest paths are searched.\n     * @param startVertex start vertex of the calculated paths.\n     * @param nPaths number of ranking paths between the start vertex and an end\n     * vertex.\n     * @param nMaxHops maximum number of edges of the calculated paths.\n     *\n     * @throws NullPointerException if the specified graph or startVertex is\n     * <code>null<\/code>.\n     * @throws IllegalArgumentException if nPaths is negative or 0.\n     * @throws IllegalArgumentException if nMaxHops is negative or 0.\n     ","constructorDeclaration":"public KShortestPaths(Graph<V, E> graph, V startVertex, int nPaths, int nMaxHops)","constructorBody":"{\n    assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.nPaths = nPaths;\n    this.nMaxHops = nMaxHops;\n}","constructorName":"KShortestPaths","constructorQualifiedName":"org.jgrapht.alg.KShortestPaths.KShortestPaths","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int nPaths","parameterName":"nPaths"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int nMaxHops","parameterName":"nMaxHops"}],"literalExprs":[],"constructorTokenRange":"public KShortestPaths(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        assertKShortestPathsFinder(graph, startVertex, nPaths, nMaxHops);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.nPaths = nPaths;\n        this.nMaxHops = nMaxHops;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an object to calculate ranking shortest paths between the start\nvertex and others vertices.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='graph on which shortest paths are searched.'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex of the calculated paths.'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of ranking paths between the start vertex and an end\nvertex.'}]}', name=Optional[nPaths]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum number of edges of the calculated paths.'}]}', name=Optional[nMaxHops]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified graph or startVertex is\n<code>null<\/code>.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if nPaths is negative or 0.'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if nMaxHops is negative or 0.'}]}', name=Optional[IllegalArgumentException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 194,col 5)-(line 244,col 5)","classOrInterfaceTokenRange":"private class PathWrapper\n        implements GraphPath<V, E>\n    {\n        private RankingPathElement<V, E> rankingPathElement;\n\n        private List<E> edgeList;\n\n        PathWrapper(RankingPathElement<V, E> rankingPathElement)\n        {\n            this.rankingPathElement = rankingPathElement;\n        }\n\n        \/\/ implement GraphPath\n        @Override public Graph<V, E> getGraph()\n        {\n            return graph;\n        }\n\n        \/\/ implement GraphPath\n        @Override public V getStartVertex()\n        {\n            return startVertex;\n        }\n\n        \/\/ implement GraphPath\n        @Override public V getEndVertex()\n        {\n            return rankingPathElement.getVertex();\n        }\n\n        \/\/ implement GraphPath\n        @Override public List<E> getEdgeList()\n        {\n            if (edgeList == null) {\n                edgeList = rankingPathElement.createEdgeListPath();\n            }\n            return edgeList;\n        }\n\n        \/\/ implement GraphPath\n        @Override public double getWeight()\n        {\n            return rankingPathElement.getWeight();\n        }\n\n        \/\/ override Object\n        @Override public String toString()\n        {\n            return getEdgeList().toString();\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"target vertex of the calculated paths.","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the calculated paths.'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of paths, or <code>null<\/code> if no path exists between the\nstart vertex and the end vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of paths, or <code>null<\/code> if no path exists between the\nstart vertex and the end vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<GraphPath<V, E>> getPaths(V endVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assertGetPaths(endVertex);\n    KShortestPathsIterator<V, E> iter = new KShortestPathsIterator<V, E>(this.graph, this.startVertex, endVertex, this.nPaths);\n    for (int passNumber = 1; (passNumber <= this.nMaxHops) && iter.hasNext(); passNumber++) {\n        iter.next();\n    }\n    List<RankingPathElement<V, E>> list = iter.getPathElements(endVertex);\n    if (list == null) {\n        return null;\n    }\n    List<GraphPath<V, E>> pathList = new ArrayList<GraphPath<V, E>>();\n    for (RankingPathElement<V, E> element : list) {\n        pathList.add(new PathWrapper(element));\n    }\n    return pathList;\n}","methodRange":"(line 122,col 5)-(line 157,col 5)","methodTokenRange":"public List<GraphPath<V, E>> getPaths(V endVertex)\n    {\n        assertGetPaths(endVertex);\n\n        KShortestPathsIterator<V, E> iter =\n            new KShortestPathsIterator<V, E>(\n                this.graph,\n                this.startVertex,\n                endVertex,\n                this.nPaths);\n\n        \/\/ at the i-th pass the shortest paths with less (or equal) than i edges\n        \/\/ are calculated.\n        for (\n            int passNumber = 1;\n            (passNumber <= this.nMaxHops)\n            && iter.hasNext();\n            passNumber++)\n        {\n            iter.next();\n        }\n\n        List<RankingPathElement<V, E>> list = iter.getPathElements(endVertex);\n\n        if (list == null) {\n            return null;\n        }\n\n        List<GraphPath<V, E>> pathList = new ArrayList<GraphPath<V, E>>();\n\n        for (RankingPathElement<V, E> element : list) {\n            pathList.add(new PathWrapper(element));\n        }\n\n        return pathList;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the k shortest simple paths in increasing order of weight.\n     *\n     * @param endVertex target vertex of the calculated paths.\n     *\n     * @return list of paths, or <code>null<\/code> if no path exists between the\n     * start vertex and the end vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"getPaths","methodQualifiedSignature":"org.jgrapht.alg.KShortestPaths.getPaths","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the k shortest simple paths in increasing order of weight.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='target vertex of the calculated paths.'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of paths, or <code>null<\/code> if no path exists between the\nstart vertex and the end vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<GraphPath<V, E>>","literalExprs":[{"literalExprRange":"(line 136,col 30)-(line 136,col 30)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 21)-(line 146,col 24)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 147,col 20)-(line 147,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KShortestPaths.getPaths(V)"},{"methodDeclaration":"private void assertGetPaths(V endVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (endVertex == null) {\n        throw new NullPointerException(\"endVertex is null\");\n    }\n    if (endVertex.equals(this.startVertex)) {\n        throw new IllegalArgumentException(\"The end vertex is the same as the start vertex!\");\n    }\n    if (!this.graph.vertexSet().contains(endVertex)) {\n        throw new IllegalArgumentException(\"Graph must contain the end vertex!\");\n    }\n}","methodRange":"(line 159,col 5)-(line 172,col 5)","methodTokenRange":"private void assertGetPaths(V endVertex)\n    {\n        if (endVertex == null) {\n            throw new NullPointerException(\"endVertex is null\");\n        }\n        if (endVertex.equals(this.startVertex)) {\n            throw new IllegalArgumentException(\n                \"The end vertex is the same as the start vertex!\");\n        }\n        if (!this.graph.vertexSet().contains(endVertex)) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the end vertex!\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"assertGetPaths","methodQualifiedSignature":"org.jgrapht.alg.KShortestPaths.assertGetPaths","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 161,col 26)-(line 161,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 162,col 44)-(line 162,col 62)","literalExprId":2,"literalExpr":"\"endVertex is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 166,col 17)-(line 166,col 65)","literalExprId":3,"literalExpr":"\"The end vertex is the same as the start vertex!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 170,col 17)-(line 170,col 52)","literalExprId":4,"literalExpr":"\"Graph must contain the end vertex!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KShortestPaths.assertGetPaths(V)"},{"methodDeclaration":"private void assertKShortestPathsFinder(Graph<V, E> graph, V startVertex, int nPaths, int nMaxHops)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (graph == null) {\n        throw new NullPointerException(\"graph is null\");\n    }\n    if (startVertex == null) {\n        throw new NullPointerException(\"startVertex is null\");\n    }\n    if (nPaths <= 0) {\n        throw new NullPointerException(\"nPaths is negative or 0\");\n    }\n    if (nMaxHops <= 0) {\n        throw new NullPointerException(\"nMaxHops is negative or 0\");\n    }\n}","methodRange":"(line 174,col 5)-(line 192,col 5)","methodTokenRange":"private void assertKShortestPathsFinder(\n        Graph<V, E> graph,\n        V startVertex,\n        int nPaths,\n        int nMaxHops)\n    {\n        if (graph == null) {\n            throw new NullPointerException(\"graph is null\");\n        }\n        if (startVertex == null) {\n            throw new NullPointerException(\"startVertex is null\");\n        }\n        if (nPaths <= 0) {\n            throw new NullPointerException(\"nPaths is negative or 0\");\n        }\n        if (nMaxHops <= 0) {\n            throw new NullPointerException(\"nMaxHops is negative or 0\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int nPaths","parameterName":"nPaths"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int nMaxHops","parameterName":"nMaxHops"}],"methodName":"assertKShortestPathsFinder","methodQualifiedSignature":"org.jgrapht.alg.KShortestPaths.assertKShortestPathsFinder","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 180,col 22)-(line 180,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 181,col 44)-(line 181,col 58)","literalExprId":2,"literalExpr":"\"graph is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 183,col 28)-(line 183,col 31)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 184,col 44)-(line 184,col 64)","literalExprId":4,"literalExpr":"\"startVertex is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 186,col 23)-(line 186,col 23)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 187,col 44)-(line 187,col 68)","literalExprId":6,"literalExpr":"\"nPaths is negative or 0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 189,col 25)-(line 189,col 25)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 44)-(line 190,col 70)","literalExprId":8,"literalExpr":"\"nMaxHops is negative or 0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.KShortestPaths.assertKShortestPathsFinder(org.jgrapht.Graph<V, E>, V, int, int)"}],"classJavadoc":"\/**\n * The algorithm determines the k shortest simple paths in increasing order of\n * weight. Weights can be negative (but no negative cycle is allowed), and paths\n * can be constrained by a maximum number of edges. Multigraphs are allowed.\n *\n * <p>The algorithm is a variant of the Bellman-Ford algorithm but instead of\n * only storing the best path it stores the \"k\" best paths at each pass,\n * yielding a complexity of O(k*n*(m^2)) where m is the number of edges and n is\n * the number of vertices.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"KShortestPaths","fields":[{"fieldRange":"(line 64,col 5)-(line 64,col 30)","fieldName":"graph","fieldJavadocComment":"\n     * Graph on which shortest paths are searched.\n     ","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"Graph on which shortest paths are searched.\n","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 66,col 5)-(line 66,col 25)","fieldName":"nMaxHops","fieldJavadocComment":"","fieldTokenRange":"private int nMaxHops;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 68,col 5)-(line 68,col 23)","fieldName":"nPaths","fieldJavadocComment":"","fieldTokenRange":"private int nPaths;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 70,col 5)-(line 70,col 26)","fieldName":"startVertex","fieldJavadocComment":"","fieldTokenRange":"private V startVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":190,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.NeighborIndex","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.event.*;\n"},{"importId":4,"import":"import org.jgrapht.util.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which a neighbor index is to be created.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a neighbor index is to be created.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.NeighborIndex.NeighborIndex(org.jgrapht.Graph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 74,col 5)-(line 78,col 5)","constructorJavadocComment":"\n     * Creates a neighbor index for the specified undirected graph.\n     *\n     * @param g the graph for which a neighbor index is to be created.\n     ","constructorDeclaration":"public NeighborIndex(Graph<V, E> g)","constructorBody":"{\n    graph = g;\n}","constructorName":"NeighborIndex","constructorQualifiedName":"org.jgrapht.alg.NeighborIndex.NeighborIndex","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public NeighborIndex(Graph<V, E> g)\n    {\n        \/\/ no need to distinguish directedgraphs as we don't do traversals\n        graph = g;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a neighbor index for the specified undirected graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which a neighbor index is to be created.'}]}', name=Optional[g]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 184,col 5)-(line 248,col 5)","classOrInterfaceTokenRange":"static class Neighbors<V, E>\n    {\n        private Map<V, ModifiableInteger> neighborCounts =\n            new LinkedHashMap<V, ModifiableInteger>();\n\n        \/\/ TODO could eventually make neighborSet modifiable, resulting\n        \/\/ in edge removals from the graph\n        private Set<V> neighborSet =\n            Collections.unmodifiableSet(\n                neighborCounts.keySet());\n\n        public Neighbors(V v, Collection<V> neighbors)\n        {\n            \/\/ add all current neighbors\n            for (V neighbor : neighbors) {\n                addNeighbor(neighbor);\n            }\n        }\n\n        public void addNeighbor(V v)\n        {\n            ModifiableInteger count = neighborCounts.get(v);\n            if (count == null) {\n                count = new ModifiableInteger(1);\n                neighborCounts.put(v, count);\n            } else {\n                count.increment();\n            }\n        }\n\n        public void removeNeighbor(V v)\n        {\n            ModifiableInteger count = neighborCounts.get(v);\n            if (count == null) {\n                throw new IllegalArgumentException(\n                    \"Attempting to remove a neighbor that wasn't present\");\n            }\n\n            count.decrement();\n            if (count.getValue() == 0) {\n                neighborCounts.remove(v);\n            }\n        }\n\n        public Set<V> getNeighbors()\n        {\n            return neighborSet;\n        }\n\n        public List<V> getNeighborList()\n        {\n            List<V> neighbors = new ArrayList<V>();\n            for (\n                Map.Entry<V, ModifiableInteger> entry\n                : neighborCounts.entrySet())\n            {\n                V v = entry.getKey();\n                int count = entry.getValue().intValue();\n                for (int i = 0; i < count; i++) {\n                    neighbors.add(v);\n                }\n            }\n            return neighbors;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Stores cached neighbors for a single vertex. Includes support for live\n     * neighbor sets and duplicate neighbors.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Stores cached neighbors for a single vertex. Includes support for live\nneighbor sets and duplicate neighbors.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose neighbors are desired","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose neighbors are desired'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all unique neighbors of the specified vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all unique neighbors of the specified vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> neighborsOf(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getNeighbors(v).getNeighbors();\n}","methodRange":"(line 89,col 5)-(line 92,col 5)","methodTokenRange":"public Set<V> neighborsOf(V v)\n    {\n        return getNeighbors(v).getNeighbors();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the set of vertices which are adjacent to a specified vertex. The\n     * returned set is backed by the index, and will be updated when the graph\n     * changes as long as the index has been added as a listener to the graph.\n     *\n     * @param v the vertex whose neighbors are desired\n     *\n     * @return all unique neighbors of the specified vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"neighborsOf","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.neighborsOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the set of vertices which are adjacent to a specified vertex. The\nreturned set is backed by the index, and will be updated when the graph\nchanges as long as the index has been added as a listener to the graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose neighbors are desired'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all unique neighbors of the specified vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.neighborsOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex whose neighbors are desired","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose neighbors are desired'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all neighbors of the specified vertex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all neighbors of the specified vertex'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<V> neighborListOf(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getNeighbors(v).getNeighborList();\n}","methodRange":"(line 106,col 5)-(line 109,col 5)","methodTokenRange":"public List<V> neighborListOf(V v)\n    {\n        return getNeighbors(v).getNeighborList();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns a list of vertices which are adjacent to a specified vertex. If\n     * the graph is a multigraph, vertices may appear more than once in the\n     * returned list. Because a list of neighbors can not be efficiently\n     * maintained, it is reconstructed on every invocation, by duplicating\n     * entries in the neighbor set. It is thus more efficient to use {@link\n     * #neighborsOf(Object)} unless duplicate neighbors are important.\n     *\n     * @param v the vertex whose neighbors are desired\n     *\n     * @return all neighbors of the specified vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"neighborListOf","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.neighborListOf","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of vertices which are adjacent to a specified vertex. If\nthe graph is a multigraph, vertices may appear more than once in the\nreturned list. Because a list of neighbors can not be efficiently\nmaintained, it is reconstructed on every invocation, by duplicating\nentries in the neighbor set. It is thus more efficient to use '}, JavadocInlineTag{tagName='link', type=LINK, content='\n#neighborsOf(Object)'}, JavadocSnippet{text=' unless duplicate neighbors are important.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex whose neighbors are desired'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all neighbors of the specified vertex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.neighborListOf(V)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphListener#edgeAdded(GraphEdgeChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeAdded(GraphEdgeChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeAdded(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E edge = e.getEdge();\n    V source = graph.getEdgeSource(edge);\n    V target = graph.getEdgeTarget(edge);\n    if (neighborMap.containsKey(source)) {\n        getNeighbors(source).addNeighbor(target);\n    } else {\n        getNeighbors(source);\n    }\n    if (neighborMap.containsKey(target)) {\n        getNeighbors(target).addNeighbor(source);\n    } else {\n        getNeighbors(target);\n    }\n}","methodRange":"(line 114,col 5)-(line 135,col 5)","methodTokenRange":"@Override public void edgeAdded(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = graph.getEdgeSource(edge);\n        V target = graph.getEdgeTarget(edge);\n\n        \/\/ if a map does not already contain an entry,\n        \/\/ then skip addNeighbor, since instantiating the map\n        \/\/ will take care of processing the edge (which has already\n        \/\/ been added)\n\n        if (neighborMap.containsKey(source)) {\n            getNeighbors(source).addNeighbor(target);\n        } else {\n            getNeighbors(source);\n        }\n        if (neighborMap.containsKey(target)) {\n            getNeighbors(target).addNeighbor(source);\n        } else {\n            getNeighbors(target);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphListener#edgeAdded(GraphEdgeChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeAdded","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.edgeAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeAdded(GraphEdgeChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.edgeAdded(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"GraphListener#edgeRemoved(GraphEdgeChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeRemoved(GraphEdgeChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    E edge = e.getEdge();\n    V source = e.getEdgeSource();\n    V target = e.getEdgeTarget();\n    if (neighborMap.containsKey(source)) {\n        neighborMap.get(source).removeNeighbor(target);\n    }\n    if (neighborMap.containsKey(target)) {\n        neighborMap.get(target).removeNeighbor(source);\n    }\n}","methodRange":"(line 140,col 5)-(line 151,col 5)","methodTokenRange":"@Override public void edgeRemoved(GraphEdgeChangeEvent<V, E> e)\n    {\n        E edge = e.getEdge();\n        V source = e.getEdgeSource();\n        V target = e.getEdgeTarget();\n        if (neighborMap.containsKey(source)) {\n            neighborMap.get(source).removeNeighbor(target);\n        }\n        if (neighborMap.containsKey(target)) {\n            neighborMap.get(target).removeNeighbor(source);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see GraphListener#edgeRemoved(GraphEdgeChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphEdgeChangeEvent<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphEdgeChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphEdgeChangeEvent.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.event.GraphEdgeChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphEdgeChangeEvent<V, E>","parameter":"GraphEdgeChangeEvent<V, E> e","parameterName":"e"}],"methodName":"edgeRemoved","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.edgeRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='GraphListener#edgeRemoved(GraphEdgeChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.edgeRemoved(org.jgrapht.event.GraphEdgeChangeEvent<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexSetListener#vertexAdded(GraphVertexChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexAdded(GraphVertexChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexAdded(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 156,col 5)-(line 159,col 5)","methodTokenRange":"@Override public void vertexAdded(GraphVertexChangeEvent<V> e)\n    {\n        \/\/ nothing to cache until there are edges\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see VertexSetListener#vertexAdded(GraphVertexChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexAdded","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.vertexAdded","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexAdded(GraphVertexChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.vertexAdded(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"VertexSetListener#vertexRemoved(GraphVertexChangeEvent)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexRemoved(GraphVertexChangeEvent)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void vertexRemoved(GraphVertexChangeEvent<V> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    neighborMap.remove(e.getVertex());\n}","methodRange":"(line 164,col 5)-(line 167,col 5)","methodTokenRange":"@Override public void vertexRemoved(GraphVertexChangeEvent<V> e)\n    {\n        neighborMap.remove(e.getVertex());\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @see VertexSetListener#vertexRemoved(GraphVertexChangeEvent)\n     ","methodParameters":[{"parameterType":"GraphVertexChangeEvent<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.event.GraphVertexChangeEvent, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.event.GraphVertexChangeEvent.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.event.GraphVertexChangeEvent<V>","parameter":"GraphVertexChangeEvent<V> e","parameterName":"e"}],"methodName":"vertexRemoved","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.vertexRemoved","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='VertexSetListener#vertexRemoved(GraphVertexChangeEvent)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.vertexRemoved(org.jgrapht.event.GraphVertexChangeEvent<V>)"},{"methodDeclaration":"private Neighbors<V, E> getNeighbors(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Neighbors<V, E> neighbors = neighborMap.get(v);\n    if (neighbors == null) {\n        neighbors = new Neighbors<V, E>(v, Graphs.neighborListOf(graph, v));\n        neighborMap.put(v, neighbors);\n    }\n    return neighbors;\n}","methodRange":"(line 169,col 5)-(line 178,col 5)","methodTokenRange":"private Neighbors<V, E> getNeighbors(V v)\n    {\n        Neighbors<V, E> neighbors = neighborMap.get(v);\n        if (neighbors == null) {\n            neighbors = new Neighbors<V, E>(v,\n                Graphs.neighborListOf(graph, v));\n            neighborMap.put(v, neighbors);\n        }\n        return neighbors;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.NeighborIndex.Neighbors, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.NeighborIndex.Neighbors.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.NeighborIndex.Neighbors.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"getNeighbors","methodQualifiedSignature":"org.jgrapht.alg.NeighborIndex.getNeighbors","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.NeighborIndex.Neighbors<V, E>","methodType":"Neighbors<V, E>","literalExprs":[{"literalExprRange":"(line 172,col 26)-(line 172,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.NeighborIndex.getNeighbors(V)"}],"classJavadoc":"\/**\n * Maintains a cache of each vertex's neighbors. While lists of neighbors can be\n * obtained from {@link Graphs}, they are re-calculated at each invocation by\n * walking a vertex's incident edges, which becomes inordinately expensive when\n * performed often.\n *\n * <p>Edge direction is ignored when evaluating neighbors; to take edge\n * direction into account when indexing neighbors, use {@link\n * DirectedNeighborIndex}.\n *\n * <p>A vertex's neighbors are cached the first time they are asked for (i.e.\n * the index is built on demand). The index will only be updated automatically\n * if it is added to the associated graph as a listener. If it is added as a\n * listener to a graph other than the one it indexes, results are undefined.<\/p>\n *\n * @author Charles Fry\n * @since Dec 13, 2005\n *\/\n","className":"NeighborIndex","fields":[{"fieldRange":"(line 66,col 5)-(line 66,col 76)","fieldName":"neighborMap","fieldJavadocComment":"","fieldTokenRange":"Map<V, Neighbors<V, E>> neighborMap = new HashMap<V, Neighbors<V, E>>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.NeighborIndex.Neighbors, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.NeighborIndex.Neighbors.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.NeighborIndex.Neighbors.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<V, Neighbors<V, E>>()]","fieldType":"Map<V, Neighbors<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.NeighborIndex.Neighbors<V, E>>"},{"fieldRange":"(line 67,col 5)-(line 67,col 30)","fieldName":"graph","fieldJavadocComment":"","fieldTokenRange":"private Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"}]}],"sourceFileId":191,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.VertexCovers","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.util.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which vertex cover approximation is to be found.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which vertex cover approximation is to be found.'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of vertices which is a vertex cover for the specified\ngraph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of vertices which is a vertex cover for the specified\ngraph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Set<V> find2ApproximationCover(Graph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> cover = new HashSet<V>();\n    Subgraph<V, E, Graph<V, E>> sg = new Subgraph<V, E, Graph<V, E>>(g, null, null);\n    while (sg.edgeSet().size() > 0) {\n        E e = sg.edgeSet().iterator().next();\n        V u = g.getEdgeSource(e);\n        V v = g.getEdgeTarget(e);\n        cover.add(u);\n        cover.add(v);\n        sg.removeVertex(u);\n        sg.removeVertex(v);\n    }\n    return cover;\n}","methodRange":"(line 78,col 5)-(line 107,col 5)","methodTokenRange":"public static <V, E> Set<V> find2ApproximationCover(Graph<V, E> g)\n    {\n        \/\/ C <-- {}\n        Set<V> cover = new HashSet<V>();\n\n        \/\/ G'=(V',E') <-- G(V,E)\n        Subgraph<V, E, Graph<V, E>> sg =\n            new Subgraph<V, E, Graph<V, E>>(\n                g,\n                null,\n                null);\n\n        \/\/ while E' is non-empty\n        while (sg.edgeSet().size() > 0) {\n            \/\/ let (u,v) be an arbitrary edge of E'\n            E e = sg.edgeSet().iterator().next();\n\n            \/\/ C <-- C U {u,v}\n            V u = g.getEdgeSource(e);\n            V v = g.getEdgeTarget(e);\n            cover.add(u);\n            cover.add(v);\n\n            \/\/ remove from E' every edge incident on either u or v\n            sg.removeVertex(u);\n            sg.removeVertex(v);\n        }\n\n        return cover; \/\/ return C\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Finds a 2-approximation for a minimal vertex cover of the specified\n     * graph. The algorithm promises a cover that is at most double the size of\n     * a minimal cover. The algorithm takes O(|E|) time.\n     *\n     * <p>For more details see Jenny Walter, CMPU-240: Lecture notes for\n     * Language Theory and Computation, Fall 2002, Vassar College, <a\n     * href=\"http:\/\/www.cs.vassar.edu\/~walter\/cs241index\/lectures\/PDF\/approx.pdf\">\n     * http:\/\/www.cs.vassar.edu\/~walter\/cs241index\/lectures\/PDF\/approx.pdf<\/a>.\n     * <\/p>\n     *\n     * @param g the graph for which vertex cover approximation is to be found.\n     *\n     * @return a set of vertices which is a vertex cover for the specified\n     * graph.\n     ","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> g","parameterName":"g"}],"methodName":"find2ApproximationCover","methodQualifiedSignature":"org.jgrapht.alg.VertexCovers.find2ApproximationCover","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a 2-approximation for a minimal vertex cover of the specified\ngraph. The algorithm promises a cover that is at most double the size of\na minimal cover. The algorithm takes O(|E|) time.\n\n<p>For more details see Jenny Walter, CMPU-240: Lecture notes for\nLanguage Theory and Computation, Fall 2002, Vassar College, <a\nhref=\"http:\/\/www.cs.vassar.edu\/~walter\/cs241index\/lectures\/PDF\/approx.pdf\">\nhttp:\/\/www.cs.vassar.edu\/~walter\/cs241index\/lectures\/PDF\/approx.pdf<\/a>.\n<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which vertex cover approximation is to be found.'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of vertices which is a vertex cover for the specified\ngraph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 87,col 17)-(line 87,col 20)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 88,col 17)-(line 88,col 20)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 91,col 38)-(line 91,col 38)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.VertexCovers.find2ApproximationCover(org.jgrapht.Graph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph for which vertex cover approximation is to be found.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which vertex cover approximation is to be found.'}]}', name=Optional[g]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a set of vertices which is a vertex cover for the specified\ngraph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of vertices which is a vertex cover for the specified\ngraph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Set<V> findGreedyCover(UndirectedGraph<V, E> g)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> cover = new HashSet<V>();\n    UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n    VertexDegreeComparator<V, E> comp = new VertexDegreeComparator<V, E>(sg);\n    while (sg.edgeSet().size() > 0) {\n        V v = Collections.max(sg.vertexSet(), comp);\n        cover.add(v);\n        sg.removeVertex(v);\n    }\n    return cover;\n}","methodRange":"(line 124,col 5)-(line 149,col 5)","methodTokenRange":"public static <V, E> Set<V> findGreedyCover(UndirectedGraph<V, E> g)\n    {\n        \/\/ C <-- {}\n        Set<V> cover = new HashSet<V>();\n\n        \/\/ G' <-- G\n        UndirectedGraph<V, E> sg = new UndirectedSubgraph<V, E>(g, null, null);\n\n        \/\/ compare vertices in descending order of degree\n        VertexDegreeComparator<V, E> comp =\n            new VertexDegreeComparator<V, E>(sg);\n\n        \/\/ while G' != {}\n        while (sg.edgeSet().size() > 0) {\n            \/\/ v <-- vertex with maximum degree in G'\n            V v = Collections.max(sg.vertexSet(), comp);\n\n            \/\/ C <-- C U {v}\n            cover.add(v);\n\n            \/\/ remove from G' every edge incident on v, and v itself\n            sg.removeVertex(v);\n        }\n\n        return cover;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Finds a greedy approximation for a minimal vertex cover of a specified\n     * graph. At each iteration, the algorithm picks the vertex with the highest\n     * degree and adds it to the cover, until all edges are covered.\n     *\n     * <p>The algorithm works on undirected graphs, but can also work on\n     * directed graphs when their edge-directions are ignored. To ignore edge\n     * directions you can use {@link org.jgrapht.Graphs#undirectedGraph(Graph)}\n     * or {@link org.jgrapht.graph.AsUndirectedGraph}.<\/p>\n     *\n     * @param g the graph for which vertex cover approximation is to be found.\n     *\n     * @return a set of vertices which is a vertex cover for the specified\n     * graph.\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"methodName":"findGreedyCover","methodQualifiedSignature":"org.jgrapht.alg.VertexCovers.findGreedyCover","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds a greedy approximation for a minimal vertex cover of a specified\ngraph. At each iteration, the algorithm picks the vertex with the highest\ndegree and adds it to the cover, until all edges are covered.\n\n<p>The algorithm works on undirected graphs, but can also work on\ndirected graphs when their edge-directions are ignored. To ignore edge\ndirections you can use '}, JavadocInlineTag{tagName='link', type=LINK, content=' org.jgrapht.Graphs#undirectedGraph(Graph)'}, JavadocSnippet{text='\nor '}, JavadocInlineTag{tagName='link', type=LINK, content=' org.jgrapht.graph.AsUndirectedGraph'}, JavadocSnippet{text='.<\/p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph for which vertex cover approximation is to be found.'}]}', name=Optional[g]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a set of vertices which is a vertex cover for the specified\ngraph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 130,col 68)-(line 130,col 71)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 130,col 74)-(line 130,col 77)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 137,col 38)-(line 137,col 38)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.VertexCovers.findGreedyCover(org.jgrapht.UndirectedGraph<V, E>)"}],"classJavadoc":"\/**\n * Algorithms to find a vertex cover for a graph. A vertex cover is a set of\n * vertices that touches all the edges in the graph. The graph's vertex set is a\n * trivial cover. However, a <i>minimal<\/i> vertex set (or at least an\n * approximation for it) is usually desired. Finding a true minimal vertex cover\n * is an NP-Complete problem. For more on the vertex cover problem, see <a\n * href=\"http:\/\/mathworld.wolfram.com\/VertexCover.html\">\n * http:\/\/mathworld.wolfram.com\/VertexCover.html<\/a>\n *\n * @author Linda Buisman\n * @since Nov 6, 2003\n *\/\n","className":"VertexCovers","fields":[]}],"sourceFileId":192,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.CycleDetector","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.traverse.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the DirectedGraph in which to detect cycles","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the DirectedGraph in which to detect cycles'}]}', name=Optional[graph]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.CycleDetector.CycleDetector(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 68,col 5)-(line 71,col 5)","constructorJavadocComment":"\n     * Creates a cycle detector for the specified graph. Currently only directed\n     * graphs are supported.\n     *\n     * @param graph the DirectedGraph in which to detect cycles\n     ","constructorDeclaration":"public CycleDetector(DirectedGraph<V, E> graph)","constructorBody":"{\n    this.graph = graph;\n}","constructorName":"CycleDetector","constructorQualifiedName":"org.jgrapht.alg.CycleDetector.CycleDetector","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> graph","parameterName":"graph"}],"literalExprs":[],"constructorTokenRange":"public CycleDetector(DirectedGraph<V, E> graph)\n    {\n        this.graph = graph;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a cycle detector for the specified graph. Currently only directed\ngraphs are supported.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the DirectedGraph in which to detect cycles'}]}', name=Optional[graph]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 177,col 5)-(line 181,col 5)","classOrInterfaceTokenRange":"private static class CycleDetectedException\n        extends RuntimeException\n    {\n        private static final long serialVersionUID = 3834305137802950712L;\n    }","classOrInterfaceJavadocComment":"\n     * Exception thrown internally when a cycle is detected during a yes\/no\n     * cycle test. Must be caught by top-level detection method.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Exception thrown internally when a cycle is detected during a yes\/no\ncycle test. Must be caught by top-level detection method.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 187,col 5)-(line 258,col 5)","classOrInterfaceTokenRange":"private class ProbeIterator\n        extends DepthFirstIterator<V, E>\n    {\n        private List<V> path;\n        private Set<V> cycleSet;\n        private V root;\n\n        ProbeIterator(Set<V> cycleSet, V startVertex)\n        {\n            super(graph, startVertex);\n            root = startVertex;\n            this.cycleSet = cycleSet;\n            path = new ArrayList<V>();\n        }\n\n        \/**\n         * {@inheritDoc}\n         *\/\n        @Override protected void encounterVertexAgain(V vertex, E edge)\n        {\n            super.encounterVertexAgain(vertex, edge);\n\n            int i;\n\n            if (root != null) {\n                \/\/ For rooted detection, the path must either\n                \/\/ double back to the root, or to a node of a cycle\n                \/\/ which has already been detected.\n                if (vertex.equals(root)) {\n                    i = 0;\n                } else if ((cycleSet != null) && cycleSet.contains(vertex)) {\n                    i = 0;\n                } else {\n                    return;\n                }\n            } else {\n                i = path.indexOf(vertex);\n            }\n\n            if (i > -1) {\n                if (cycleSet == null) {\n                    \/\/ we're doing yes\/no cycle detection\n                    throw new CycleDetectedException();\n                } else {\n                    for (; i < path.size(); ++i) {\n                        cycleSet.add(path.get(i));\n                    }\n                }\n            }\n        }\n\n        \/**\n         * {@inheritDoc}\n         *\/\n        @Override protected V provideNextVertex()\n        {\n            V v = super.provideNextVertex();\n\n            \/\/ backtrack\n            for (int i = path.size() - 1; i >= 0; --i) {\n                if (graph.containsEdge(path.get(i), v)) {\n                    break;\n                }\n\n                path.remove(i);\n            }\n\n            path.add(v);\n\n            return v;\n        }\n    }","classOrInterfaceJavadocComment":"\n     * Version of DFS which maintains a backtracking path used to probe for\n     * cycles.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Version of DFS which maintains a backtracking path used to probe for\ncycles.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the graph contains at least one cycle","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the graph contains at least one cycle'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean detectCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        execute(null, null);\n    } catch (CycleDetectedException ex) {\n        return true;\n    }\n    return false;\n}","methodRange":"(line 78,col 5)-(line 87,col 5)","methodTokenRange":"public boolean detectCycles()\n    {\n        try {\n            execute(null, null);\n        } catch (CycleDetectedException ex) {\n            return true;\n        }\n\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Performs yes\/no cycle detection on the entire graph.\n     *\n     * @return true iff the graph contains at least one cycle\n     ","methodParameters":[],"methodName":"detectCycles","methodQualifiedSignature":"org.jgrapht.alg.CycleDetector.detectCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Performs yes\/no cycle detection on the entire graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the graph contains at least one cycle'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 81,col 21)-(line 81,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 81,col 27)-(line 81,col 30)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 83,col 20)-(line 83,col 23)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 86,col 16)-(line 86,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CycleDetector.detectCycles()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to test","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to test'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if v is on at least one cycle","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if v is on at least one cycle'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean detectCyclesContainingVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        execute(null, v);\n    } catch (CycleDetectedException ex) {\n        return true;\n    }\n    return false;\n}","methodRange":"(line 96,col 5)-(line 105,col 5)","methodTokenRange":"public boolean detectCyclesContainingVertex(V v)\n    {\n        try {\n            execute(null, v);\n        } catch (CycleDetectedException ex) {\n            return true;\n        }\n\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Performs yes\/no cycle detection on an individual vertex.\n     *\n     * @param v the vertex to test\n     *\n     * @return true if v is on at least one cycle\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"detectCyclesContainingVertex","methodQualifiedSignature":"org.jgrapht.alg.CycleDetector.detectCyclesContainingVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Performs yes\/no cycle detection on an individual vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to test'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if v is on at least one cycle'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 99,col 21)-(line 99,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 101,col 20)-(line 101,col 23)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 104,col 16)-(line 104,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CycleDetector.detectCyclesContainingVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"set of all vertices which participate in at least one cycle in\nthis graph","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of all vertices which participate in at least one cycle in\nthis graph'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> findCycles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StrongConnectivityAlgorithm<V, E> inspector = new KosarajuStrongConnectivityInspector<V, E>(graph);\n    List<Set<V>> components = inspector.stronglyConnectedSets();\n    Set<V> set = new HashSet<V>();\n    for (Set<V> component : components) {\n        if (component.size() > 1) {\n            set.addAll(component);\n        } else {\n            V v = component.iterator().next();\n            if (graph.containsEdge(v, v)) {\n                set.add(v);\n            }\n        }\n    }\n    return set;\n}","methodRange":"(line 113,col 5)-(line 140,col 5)","methodTokenRange":"public Set<V> findCycles()\n    {\n        \/\/ ProbeIterator can't be used to handle this case,\n        \/\/ so use StrongConnectivityAlgorithm instead.\n        StrongConnectivityAlgorithm<V, E> inspector =\n            new KosarajuStrongConnectivityInspector<V, E>(graph);\n        List<Set<V>> components = inspector.stronglyConnectedSets();\n\n        \/\/ A vertex participates in a cycle if either of the following is\n        \/\/ true:  (a) it is in a component whose size is greater than 1\n        \/\/ or (b) it is a self-loop\n\n        Set<V> set = new HashSet<V>();\n        for (Set<V> component : components) {\n            if (component.size() > 1) {\n                \/\/ cycle\n                set.addAll(component);\n            } else {\n                V v = component.iterator().next();\n                if (graph.containsEdge(v, v)) {\n                    \/\/ self-loop\n                    set.add(v);\n                }\n            }\n        }\n\n        return set;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Finds the vertex set for the subgraph of all cycles.\n     *\n     * @return set of all vertices which participate in at least one cycle in\n     * this graph\n     ","methodParameters":[],"methodName":"findCycles","methodQualifiedSignature":"org.jgrapht.alg.CycleDetector.findCycles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds the vertex set for the subgraph of all cycles.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of all vertices which participate in at least one cycle in\nthis graph'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[{"literalExprRange":"(line 127,col 36)-(line 127,col 36)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CycleDetector.findCycles()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex to test","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to test'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"set of all vertices reachable from v via at least one cycle","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of all vertices reachable from v via at least one cycle'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<V> findCyclesContainingVertex(V v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<V> set = new HashSet<V>();\n    execute(set, v);\n    return set;\n}","methodRange":"(line 156,col 5)-(line 162,col 5)","methodTokenRange":"public Set<V> findCyclesContainingVertex(V v)\n    {\n        Set<V> set = new HashSet<V>();\n        execute(set, v);\n\n        return set;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Finds the vertex set for the subgraph of all cycles which contain a\n     * particular vertex.\n     *\n     * <p>REVIEW jvs 25-Aug-2006: This implementation is not guaranteed to cover\n     * all cases. If you want to be absolutely certain that you report vertices\n     * from all cycles containing v, it's safer (but less efficient) to use\n     * StrongConnectivityAlgorithm instead and return the strongly connected\n     * component containing v.\n     *\n     * @param v the vertex to test\n     *\n     * @return set of all vertices reachable from v via at least one cycle\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"findCyclesContainingVertex","methodQualifiedSignature":"org.jgrapht.alg.CycleDetector.findCyclesContainingVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Finds the vertex set for the subgraph of all cycles which contain a\nparticular vertex.\n\n<p>REVIEW jvs 25-Aug-2006: This implementation is not guaranteed to cover\nall cases. If you want to be absolutely certain that you report vertices\nfrom all cycles containing v, it's safer (but less efficient) to use\nStrongConnectivityAlgorithm instead and return the strongly connected\ncomponent containing v.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex to test'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='set of all vertices reachable from v via at least one cycle'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<V>","methodType":"Set<V>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.CycleDetector.findCyclesContainingVertex(V)"},{"methodDeclaration":"private void execute(Set<V> s, V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    ProbeIterator iter = new ProbeIterator(s, v);\n    while (iter.hasNext()) {\n        iter.next();\n    }\n}","methodRange":"(line 164,col 5)-(line 171,col 5)","methodTokenRange":"private void execute(Set<V> s, V v)\n    {\n        ProbeIterator iter = new ProbeIterator(s, v);\n\n        while (iter.hasNext()) {\n            iter.next();\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> s","parameterName":"s"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"execute","methodQualifiedSignature":"org.jgrapht.alg.CycleDetector.execute","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.CycleDetector.execute(java.util.Set<V>, V)"}],"classJavadoc":"\/**\n * Performs cycle detection on a graph. The <i>inspected graph<\/i> is specified\n * at construction time and cannot be modified. Currently, the detector supports\n * only directed graphs.\n *\n * @author John V. Sichi\n * @since Sept 16, 2004\n *\/\n","className":"CycleDetector","fields":[{"fieldRange":"(line 60,col 5)-(line 60,col 30)","fieldName":"graph","fieldJavadocComment":"\n     * Graph on which cycle detection is being performed.\n     ","fieldTokenRange":"DirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"Graph on which cycle detection is being performed.\n","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"}]}],"sourceFileId":193,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public double getCostEstimate(V sourceVertex, V targetVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 53,col 5)-(line 53,col 66)","methodTokenRange":"public double getCostEstimate(V sourceVertex, V targetVertex);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * An admissible \"heuristic estimate\" of the distance from x, the\n     * sourceVertex, to the goal (usually denoted h(x)). This is the good guess\n     * function.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sourceVertex","parameterName":"sourceVertex"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V targetVertex","parameterName":"targetVertex"}],"methodName":"getCostEstimate","methodQualifiedSignature":"org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic.getCostEstimate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An admissible \"heuristic estimate\" of the distance from x, the\nsourceVertex, to the goal (usually denoted h(x)). This is the good guess\nfunction.'}]}, blockTags=[]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.AStarAdmissibleHeuristic.getCostEstimate(V, V)"}],"classJavadoc":"\/**\n * Interface for an admissible heuristic used in A* search.\n *\n * @param <V> vertex type\n *\n * @author Joris Kinable\n * @author Jon Robison\n * @author Thomas Breitbart\n *\/\n","className":"AStarAdmissibleHeuristic","fields":[]}],"sourceFileId":194,"packageName":"org.jgrapht.alg.interfaces"},{"sourceFileName":"org.jgrapht.alg.interfaces.MinimumSpanningTree","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"minimum spanning-tree edges set","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree edges set'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getMinimumSpanningTreeEdgeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 50,col 5)-(line 50,col 50)","methodTokenRange":"public Set<E> getMinimumSpanningTreeEdgeSet();","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns edges set constituting the minimum spanning tree\/forest\n     *\n     * @return minimum spanning-tree edges set\n     ","methodParameters":[],"methodName":"getMinimumSpanningTreeEdgeSet","methodQualifiedSignature":"org.jgrapht.alg.interfaces.MinimumSpanningTree.getMinimumSpanningTreeEdgeSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns edges set constituting the minimum spanning tree\/forest'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree edges set'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.MinimumSpanningTree.getMinimumSpanningTreeEdgeSet()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"minimum spanning-tree total weight","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree total weight'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getMinimumSpanningTreeTotalWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 57,col 5)-(line 57,col 54)","methodTokenRange":"public double getMinimumSpanningTreeTotalWeight();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns total weight of the minimum spanning tree\/forest.\n     *\n     * @return minimum spanning-tree total weight\n     ","methodParameters":[],"methodName":"getMinimumSpanningTreeTotalWeight","methodQualifiedSignature":"org.jgrapht.alg.interfaces.MinimumSpanningTree.getMinimumSpanningTreeTotalWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns total weight of the minimum spanning tree\/forest.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='minimum spanning-tree total weight'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.MinimumSpanningTree.getMinimumSpanningTreeTotalWeight()"}],"classJavadoc":"\/**\n * Allows to derive <a href=http:\/\/en.wikipedia.org\/wiki\/Minimum_spanning_tree>\n * minimum spanning tree<\/a> from given undirected connected graph. In the case\n * of disconnected graphs it would rather derive minimum spanning <i>forest<\/i>\n *\n * @param <V> vertex concept type\n * @param <E> edge concept type\n *\/\n","className":"MinimumSpanningTree","fields":[]}],"sourceFileId":195,"packageName":"org.jgrapht.alg.interfaces"},{"sourceFileName":"org.jgrapht.alg.interfaces.WeightedMatchingAlgorithm","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"weight of a matching found","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='weight of a matching found'}]}', name=Optional.empty}"}],"methodDeclaration":"public double getMatchingWeight()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 48,col 5)-(line 48,col 38)","methodTokenRange":"public double getMatchingWeight();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Returns weight of a matching found\n     *\n     * @return weight of a matching found\n     ","methodParameters":[],"methodName":"getMatchingWeight","methodQualifiedSignature":"org.jgrapht.alg.interfaces.WeightedMatchingAlgorithm.getMatchingWeight","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns weight of a matching found'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='weight of a matching found'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.WeightedMatchingAlgorithm.getMatchingWeight()"}],"classJavadoc":"\/**\n * Allows to derive weighted matching from <i>general<\/i> graph\n *\n * @param <V>\n * @param <E>\n *\n * @see MatchingAlgorithm\n *\/\n","className":"WeightedMatchingAlgorithm","fields":[]}],"sourceFileId":196,"packageName":"org.jgrapht.alg.interfaces"},{"sourceFileName":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the graph inspected by this StrongConnectivityAlgorithm","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected by this StrongConnectivityAlgorithm'}]}', name=Optional.empty}"}],"methodDeclaration":"public DirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 55,col 5)-(line 55,col 42)","methodTokenRange":"public DirectedGraph<V, E> getGraph();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the graph inspected by the StrongConnectivityAlgorithm.\n     *\n     * @return the graph inspected by this StrongConnectivityAlgorithm\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the graph inspected by the StrongConnectivityAlgorithm.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the graph inspected by this StrongConnectivityAlgorithm'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.getGraph()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the graph is strongly connected, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isStronglyConnected()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 63,col 5)-(line 63,col 41)","methodTokenRange":"public boolean isStronglyConnected();","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Returns true if the graph of this <code>\n     * StrongConnectivityAlgorithm<\/code> instance is strongly connected.\n     *\n     * @return true if the graph is strongly connected, false otherwise\n     ","methodParameters":[],"methodName":"isStronglyConnected","methodQualifiedSignature":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.isStronglyConnected","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the graph of this <code>\nStrongConnectivityAlgorithm<\/code> instance is strongly connected.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is strongly connected, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.isStronglyConnected()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<Set<V>> stronglyConnectedSets()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 73,col 5)-(line 73,col 48)","methodTokenRange":"public List<Set<V>> stronglyConnectedSets();","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Computes a {@link List} of {@link Set}s, where each set contains vertices\n     * which together form a strongly connected component within the given\n     * graph.\n     *\n     * @return <code>List<\/code> of <code>Set<\/code> s containing the strongly\n     * connected components\n     ","methodParameters":[],"methodName":"stronglyConnectedSets","methodQualifiedSignature":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.stronglyConnectedSets","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes a '}, JavadocInlineTag{tagName='link', type=LINK, content=' List'}, JavadocSnippet{text=' of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Set'}, JavadocSnippet{text='s, where each set contains vertices\nwhich together form a strongly connected component within the given\ngraph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>List<\/code> of <code>Set<\/code> s containing the strongly\nconnected components'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<java.util.Set<V>>","methodType":"List<Set<V>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.stronglyConnectedSets()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a list of subgraphs representing the strongly connected\ncomponents","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 84,col 5)-(line 84,col 69)","methodTokenRange":"public List<DirectedSubgraph<V, E>> stronglyConnectedSubgraphs();","methodReturnTypeResolved":"","methodJavadocComment":"\n     * <p>Computes a list of {@link DirectedSubgraph}s of the given graph. Each\n     * subgraph will represent a strongly connected component and will contain\n     * all vertices of that component. The subgraph will have an edge (u,v) iff\n     * u and v are contained in the strongly connected component.<\/p>\n     *\n     * @return a list of subgraphs representing the strongly connected\n     * components\n     ","methodParameters":[],"methodName":"stronglyConnectedSubgraphs","methodQualifiedSignature":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.stronglyConnectedSubgraphs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<p>Computes a list of '}, JavadocInlineTag{tagName='link', type=LINK, content=' DirectedSubgraph'}, JavadocSnippet{text='s of the given graph. Each\nsubgraph will represent a strongly connected component and will contain\nall vertices of that component. The subgraph will have an edge (u,v) iff\nu and v are contained in the strongly connected component.<\/p>'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a list of subgraphs representing the strongly connected\ncomponents'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"List<DirectedSubgraph<V, E>>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.StrongConnectivityAlgorithm.stronglyConnectedSubgraphs()"}],"classJavadoc":"\/**\n * An interface to the StrongConnectivityInspector algorithm classes. These\n * classes verify whether the graph is strongly connected.\n *\n * @param <V> vertex concept type\n * @param <E> edge concept type\n *\n * @author Sarah Komla-Ebri\n * @since September, 2013\n *\/\n","className":"StrongConnectivityAlgorithm","fields":[]}],"sourceFileId":197,"packageName":"org.jgrapht.alg.interfaces"},{"sourceFileName":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[{"classOrInterfaceRange":"(line 62,col 5)-(line 77,col 5)","classOrInterfaceTokenRange":"interface MaximumFlow<V, E>\n    {\n        \/**\n         * Returns value of the maximum-flow for the given network\n         *\n         * @return value of th maximum-flow\n         *\/\n        public Double getValue();\n\n        \/**\n         * Returns mapping from edge to flow value through this particular edge\n         *\n         * @return maximum flow\n         *\/\n        public Map<E, Double> getFlow();\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 79,col 5)-(line 100,col 5)","classOrInterfaceTokenRange":"class MaximumFlowImpl<V, E>\n        implements MaximumFlow\n    {\n        private Double value;\n        private Map<E, Double> flow;\n\n        public MaximumFlowImpl(Double value, Map<E, Double> flow)\n        {\n            this.value = value;\n            this.flow = Collections.unmodifiableMap(flow);\n        }\n\n        @Override public Double getValue()\n        {\n            return value;\n        }\n\n        @Override public Map<E, Double> getFlow()\n        {\n            return flow;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source of the flow inside the network","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source of the flow inside the network'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"sink of the flow inside the network","javadocBlockTagName":"sink","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='sink of the flow inside the network'}]}', name=Optional[sink]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"maximum flow","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum flow'}]}', name=Optional.empty}"}],"methodDeclaration":" MaximumFlow<V, E> buildMaximumFlow(V source, V sink)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 60,col 5)-(line 60,col 57)","methodTokenRange":"MaximumFlow<V, E> buildMaximumFlow(V source, V sink);","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Builds maximum flow for the supplied network flow, for the supplied\n     * ${source} and ${sink}\n     *\n     * @param source source of the flow inside the network\n     * @param sink sink of the flow inside the network\n     *\n     * @return maximum flow\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sink","parameterName":"sink"}],"methodName":"buildMaximumFlow","methodQualifiedSignature":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.buildMaximumFlow","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds maximum flow for the supplied network flow, for the supplied\n${source} and ${sink}'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source of the flow inside the network'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='sink of the flow inside the network'}]}', name=Optional[sink]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum flow'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow<V, E>","methodType":"MaximumFlow<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.buildMaximumFlow(V, V)"}],"classJavadoc":"\/**\n * Allows to derive <a\n * href=\"https:\/\/en.wikipedia.org\/wiki\/Maximum_flow_problem\">maximum-flow<\/a>\n * from the supplied <a href=\"https:\/\/en.wikipedia.org\/wiki\/Flow_network\">flow\n * network<\/a>\n *\n * @param <V> vertex concept type\n * @param <E> edge concept type\n *\/\n","className":"MaximumFlowAlgorithm","fields":[]}],"sourceFileId":198,"packageName":"org.jgrapht.alg.interfaces"},{"sourceFileName":"org.jgrapht.alg.interfaces.MatchingAlgorithm","imports":[{"importId":1,"import":"import java.util.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public Set<E> getMatching()","methodAccessSpecifier":"PUBLIC","methodBody":"","methodRange":"(line 48,col 5)-(line 48,col 32)","methodTokenRange":"public Set<E> getMatching();","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns set of edges making up the matching\n     ","methodParameters":[],"methodName":"getMatching","methodQualifiedSignature":"org.jgrapht.alg.interfaces.MatchingAlgorithm.getMatching","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns set of edges making up the matching'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.interfaces.MatchingAlgorithm.getMatching()"}],"classJavadoc":"\/**\n * Allows to derive <a\n * href=\"http:\/\/en.wikipedia.org\/wiki\/Matching_(graph_theory)\">matching<\/a> from\n * given graph\n *\n * @param <V> vertex concept type\n * @param <E> edge concept type\n *\/\n","className":"MatchingAlgorithm","fields":[]}],"sourceFileId":199,"packageName":"org.jgrapht.alg.interfaces"},{"sourceFileName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import java.util.Map.*;\n"},{"importId":3,"import":"import org.jgrapht.*;\n"},{"importId":4,"import":"import org.jgrapht.graph.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"The graph to decompose.","javadocBlockTagName":"g","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The graph to decompose.'}]}', name=Optional[g]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.CliqueMinimalSeparatorDecomposition(org.jgrapht.UndirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 118,col 5)-(line 122,col 5)","constructorJavadocComment":"\n     * Setup a clique minimal separator decomposition on undirected graph <code>\n     * g<\/code>. Loops and multiple edges are removed, i.e. the graph is\n     * transformed to a simple graph.\n     *\n     * @param g The graph to decompose.\n     ","constructorDeclaration":"public CliqueMinimalSeparatorDecomposition(UndirectedGraph<V, E> g)","constructorBody":"{\n    this.graph = g;\n    this.fillEdges = new HashSet<E>();\n}","constructorName":"CliqueMinimalSeparatorDecomposition","constructorQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.CliqueMinimalSeparatorDecomposition","constructorParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> g","parameterName":"g"}],"literalExprs":[],"constructorTokenRange":"public CliqueMinimalSeparatorDecomposition(UndirectedGraph<V, E> g)\n    {\n        this.graph = g;\n        this.fillEdges = new HashSet<E>();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Setup a clique minimal separator decomposition on undirected graph <code>\ng<\/code>. Loops and multiple edges are removed, i.e. the graph is\ntransformed to a simple graph.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='The graph to decompose.'}]}', name=Optional[g]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"private void computeMinimalTriangulation()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());\n    for (V v : graph.vertexSet()) {\n        chordalGraph.addVertex(v);\n    }\n    final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\n    int s = -1;\n    generators = new ArrayList<V>();\n    meo = new LinkedList<V>();\n    final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();\n    for (V v : gprime.vertexSet()) {\n        vertexLabels.put(v, 0);\n    }\n    for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {\n        V v = getMaxLabelVertex(vertexLabels);\n        LinkedList<V> Y = new LinkedList<V>(Graphs.neighborListOf(gprime, v));\n        if (vertexLabels.get(v) <= s) {\n            generators.add(v);\n        }\n        s = vertexLabels.get(v);\n        HashSet<V> reached = new HashSet<V>();\n        reached.add(v);\n        HashMap<Integer, HashSet<V>> reach = new HashMap<Integer, HashSet<V>>();\n        for (V y : Y) {\n            reached.add(y);\n            addToReach(vertexLabels.get(y), y, reach);\n        }\n        for (int j = 0; j < graph.vertexSet().size(); j++) {\n            if (!reach.containsKey(j)) {\n                continue;\n            }\n            while (reach.get(j).size() > 0) {\n                V y = reach.get(j).iterator().next();\n                reach.get(j).remove(y);\n                for (V z : Graphs.neighborListOf(gprime, y)) {\n                    if (!reached.contains(z)) {\n                        reached.add(z);\n                        if (vertexLabels.get(z) > j) {\n                            Y.add(z);\n                            E fillEdge = graph.getEdgeFactory().createEdge(v, z);\n                            fillEdges.add(fillEdge);\n                            addToReach(vertexLabels.get(z), z, reach);\n                        } else {\n                            addToReach(j, z, reach);\n                        }\n                    }\n                }\n            }\n        }\n        for (V y : Y) {\n            chordalGraph.addEdge(v, y);\n            vertexLabels.put(y, vertexLabels.get(y) + 1);\n        }\n        meo.addLast(v);\n        gprime.removeVertex(v);\n        vertexLabels.remove(v);\n    }\n}","methodRange":"(line 130,col 5)-(line 211,col 5)","methodTokenRange":"private void computeMinimalTriangulation()\n    {\n        \/\/ initialize chordGraph with same vertices as graph\n        chordalGraph = new SimpleGraph<V, E>(graph.getEdgeFactory());\n        for (V v : graph.vertexSet()) {\n            chordalGraph.addVertex(v);\n        }\n\n        \/\/ initialize g' as subgraph of graph (same vertices and edges)\n        final UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\n        int s = -1;\n        generators = new ArrayList<V>();\n        meo = new LinkedList<V>();\n\n        final Map<V, Integer> vertexLabels = new HashMap<V, Integer>();\n        for (V v : gprime.vertexSet()) {\n            vertexLabels.put(v, 0);\n        }\n        for (int i = 1, n = graph.vertexSet().size(); i <= n; i++) {\n            V v = getMaxLabelVertex(vertexLabels);\n            LinkedList<V> Y =\n                new LinkedList<V>(\n                    Graphs.neighborListOf(gprime, v));\n\n            if (vertexLabels.get(v) <= s) {\n                generators.add(v);\n            }\n\n            s = vertexLabels.get(v);\n\n            \/\/ Mark x reached and all other vertices of gprime unreached\n            HashSet<V> reached = new HashSet<V>();\n            reached.add(v);\n\n            \/\/ mark neighborhood of x reached and add to reach(label(y))\n            HashMap<Integer, HashSet<V>> reach =\n                new HashMap<Integer, HashSet<V>>();\n\n            \/\/ mark y reached and add y to reach\n            for (V y : Y) {\n                reached.add(y);\n                addToReach(vertexLabels.get(y), y, reach);\n            }\n\n            for (int j = 0; j < graph.vertexSet().size(); j++) {\n                if (!reach.containsKey(j)) {\n                    continue;\n                }\n                while (reach.get(j).size() > 0) {\n                    \/\/ remove a vertex y from reach(j)\n                    V y = reach.get(j).iterator().next();\n                    reach.get(j).remove(y);\n\n                    for (V z : Graphs.neighborListOf(gprime, y)) {\n                        if (!reached.contains(z)) {\n                            reached.add(z);\n                            if (vertexLabels.get(z) > j) {\n                                Y.add(z);\n                                E fillEdge =\n                                    graph.getEdgeFactory().createEdge(\n                                        v,\n                                        z);\n                                fillEdges.add(fillEdge);\n                                addToReach(vertexLabels.get(z), z, reach);\n                            } else {\n                                addToReach(j, z, reach);\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (V y : Y) {\n                chordalGraph.addEdge(v, y);\n                vertexLabels.put(y, vertexLabels.get(y) + 1);\n            }\n\n            meo.addLast(v);\n            gprime.removeVertex(v);\n            vertexLabels.remove(v);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Compute the minimal triangulation of the graph. Implementation of\n     * Algorithm MCS-M+ as described in Berry et al. (2010),\n     * DOI:10.3390\/a3020197 <a href=\"http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197\">\n     * http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197<\/a>\n     ","methodParameters":[],"methodName":"computeMinimalTriangulation","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.computeMinimalTriangulation","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compute the minimal triangulation of the graph. Implementation of\nAlgorithm MCS-M+ as described in Berry et al. (2010),\nDOI:10.3390\/a3020197 <a href=\"http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197\">\nhttp:\/\/www.mdpi.com\/1999-4893\/3\/2\/197<\/a>'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 140,col 18)-(line 140,col 18)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 33)-(line 146,col 33)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 148,col 22)-(line 148,col 22)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 174,col 26)-(line 174,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 178,col 46)-(line 178,col 46)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 204,col 59)-(line 204,col 59)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.computeMinimalTriangulation()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"Map that gives a label for each vertex.","javadocBlockTagName":"vertexLabels","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='Map that gives a label for each vertex.'}]}', name=Optional[vertexLabels]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"Vertex with the maximal label.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Vertex with the maximal label.'}]}', name=Optional.empty}"}],"methodDeclaration":"private V getMaxLabelVertex(Map<V, Integer> vertexLabels)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Iterator<Entry<V, Integer>> iterator = vertexLabels.entrySet().iterator();\n    Entry<V, Integer> max = iterator.next();\n    while (iterator.hasNext()) {\n        Entry<V, Integer> e = iterator.next();\n        if (e.getValue() > max.getValue()) {\n            max = e;\n        }\n    }\n    return max.getKey();\n}","methodRange":"(line 220,col 5)-(line 232,col 5)","methodTokenRange":"private V getMaxLabelVertex(Map<V, Integer> vertexLabels)\n    {\n        Iterator<Entry<V, Integer>> iterator =\n            vertexLabels.entrySet().iterator();\n        Entry<V, Integer> max = iterator.next();\n        while (iterator.hasNext()) {\n            Entry<V, Integer> e = iterator.next();\n            if (e.getValue() > max.getValue()) {\n                max = e;\n            }\n        }\n        return max.getKey();\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Get the vertex with the maximal label.\n     *\n     * @param vertexLabels Map that gives a label for each vertex.\n     *\n     * @return Vertex with the maximal label.\n     ","methodParameters":[{"parameterType":"Map<V, Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<V, java.lang.Integer>","parameter":"Map<V, Integer> vertexLabels","parameterName":"vertexLabels"}],"methodName":"getMaxLabelVertex","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getMaxLabelVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the vertex with the maximal label.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='Map that gives a label for each vertex.'}]}', name=Optional[vertexLabels]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Vertex with the maximal label.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getMaxLabelVertex(java.util.Map<V, java.lang.Integer>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex' label","javadocBlockTagName":"k","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex' label'}]}', name=Optional[k]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertex","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex'}]}', name=Optional[v]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the reach structure.","javadocBlockTagName":"r","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reach structure.'}]}', name=Optional[r]}"}],"methodDeclaration":"private void addToReach(Integer k, V v, HashMap<Integer, HashSet<V>> r)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (r.containsKey(k)) {\n        r.get(k).add(v);\n    } else {\n        HashSet<V> set = new HashSet<V>();\n        set.add(v);\n        r.put(k, set);\n    }\n}","methodRange":"(line 241,col 5)-(line 250,col 5)","methodTokenRange":"private void addToReach(Integer k, V v, HashMap<Integer, HashSet<V>> r)\n    {\n        if (r.containsKey(k)) {\n            r.get(k).add(v);\n        } else {\n            HashSet<V> set = new HashSet<V>();\n            set.add(v);\n            r.put(k, set);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Add a vertex to reach.\n     *\n     * @param k vertex' label\n     * @param v the vertex\n     * @param r the reach structure.\n     ","methodParameters":[{"parameterType":"Integer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer k","parameterName":"k"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"},{"parameterType":"HashMap<Integer, HashSet<V>>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.HashMap, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashMap.V=ReferenceType{java.util.HashSet, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashSet.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}, java.util.HashMap.K=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.HashMap<java.lang.Integer, java.util.HashSet<V>>","parameter":"HashMap<Integer, HashSet<V>> r","parameterName":"r"}],"methodName":"addToReach","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.addToReach","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Add a vertex to reach.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex' label'}]}', name=Optional[k]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertex'}]}', name=Optional[v]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the reach structure.'}]}', name=Optional[r]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.addToReach(java.lang.Integer, V, java.util.HashMap<java.lang.Integer, java.util.HashSet<V>>)"},{"javadocBlockTags":[],"methodDeclaration":"private void computeAtoms()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (chordalGraph == null) {\n        computeMinimalTriangulation();\n    }\n    separators = new HashSet<Set<V>>();\n    UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\n    UndirectedGraph<V, E> hprime = copyAsSimpleGraph(chordalGraph);\n    atoms = new HashSet<Set<V>>();\n    Iterator<V> iterator = meo.descendingIterator();\n    while (iterator.hasNext()) {\n        V v = iterator.next();\n        if (generators.contains(v)) {\n            Set<V> separator = new HashSet<V>(Graphs.neighborListOf(hprime, v));\n            if (isClique(graph, separator)) {\n                if (separator.size() > 0) {\n                    if (separators.contains(separator)) {\n                        fullComponentCount.put(separator, fullComponentCount.get(separator) + 1);\n                    } else {\n                        fullComponentCount.put(separator, 2);\n                        separators.add(separator);\n                    }\n                }\n                UndirectedGraph<V, E> tmpGraph = copyAsSimpleGraph(gprime);\n                tmpGraph.removeAllVertices(separator);\n                ConnectivityInspector<V, E> con = new ConnectivityInspector<V, E>(tmpGraph);\n                if (con.isGraphConnected()) {\n                    throw new RuntimeException(\"separator did not separate the graph\");\n                }\n                for (Set<V> component : con.connectedSets()) {\n                    if (component.contains(v)) {\n                        gprime.removeAllVertices(component);\n                        component.addAll(separator);\n                        atoms.add(new HashSet<V>(component));\n                        assert (component.size() > 0);\n                        break;\n                    }\n                }\n            }\n        }\n        hprime.removeVertex(v);\n    }\n    if (gprime.vertexSet().size() > 0) {\n        atoms.add(new HashSet<V>(gprime.vertexSet()));\n    }\n}","methodRange":"(line 258,col 5)-(line 321,col 5)","methodTokenRange":"private void computeAtoms()\n    {\n        if (chordalGraph == null) {\n            computeMinimalTriangulation();\n        }\n\n        separators = new HashSet<Set<V>>();\n\n        \/\/ initialize g' as subgraph of graph (same vertices and edges)\n        UndirectedGraph<V, E> gprime = copyAsSimpleGraph(graph);\n\n        \/\/ initialize h' as subgraph of chordalGraph (same vertices and edges)\n        UndirectedGraph<V, E> hprime = copyAsSimpleGraph(chordalGraph);\n\n        atoms = new HashSet<Set<V>>();\n\n        Iterator<V> iterator = meo.descendingIterator();\n        while (iterator.hasNext()) {\n            V v = iterator.next();\n            if (generators.contains(v)) {\n                Set<V> separator =\n                    new HashSet<V>(Graphs.neighborListOf(\n                            hprime,\n                            v));\n\n                if (isClique(graph, separator)) {\n                    if (separator.size() > 0) {\n                        if (separators.contains(separator)) {\n                            fullComponentCount.put(\n                                separator,\n                                fullComponentCount.get(separator) + 1);\n                        } else {\n                            fullComponentCount.put(separator, 2);\n                            separators.add(separator);\n                        }\n                    }\n                    UndirectedGraph<V, E> tmpGraph = copyAsSimpleGraph(gprime);\n\n                    tmpGraph.removeAllVertices(separator);\n                    ConnectivityInspector<V, E> con =\n                        new ConnectivityInspector<V, E>(tmpGraph);\n                    if (con.isGraphConnected()) {\n                        throw new RuntimeException(\n                            \"separator did not separate the graph\");\n                    }\n                    for (Set<V> component : con.connectedSets()) {\n                        if (component.contains(v)) {\n                            gprime.removeAllVertices(component);\n                            component.addAll(separator);\n                            atoms.add(new HashSet<V>(component));\n                            assert (component.size() > 0);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            hprime.removeVertex(v);\n        }\n\n        if (gprime.vertexSet().size() > 0) {\n            atoms.add(new HashSet<V>(gprime.vertexSet()));\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Compute the unique decomposition of the input graph G (atoms of G).\n     * Implementation of algorithm Atoms as described in Berry et al. (2010),\n     * DOI:10.3390\/a3020197, <a href=\"http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197\">\n     * http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197<\/a>\n     ","methodParameters":[],"methodName":"computeAtoms","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.computeAtoms","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compute the unique decomposition of the input graph G (atoms of G).\nImplementation of algorithm Atoms as described in Berry et al. (2010),\nDOI:10.3390\/a3020197, <a href=\"http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197\">\nhttp:\/\/www.mdpi.com\/1999-4893\/3\/2\/197<\/a>'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 260,col 29)-(line 260,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 284,col 44)-(line 284,col 44)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 288,col 69)-(line 288,col 69)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 290,col 63)-(line 290,col 63)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 301,col 29)-(line 301,col 66)","literalExprId":5,"literalExpr":"\"separator did not separate the graph\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 308,col 56)-(line 308,col 56)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 318,col 41)-(line 318,col 41)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.computeAtoms()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph.'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the vertices to induce the subgraph from.","javadocBlockTagName":"vertices","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to induce the subgraph from.'}]}', name=Optional[vertices]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the induced subgraph is a clique.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the induced subgraph is a clique.'}]}', name=Optional.empty}"}],"methodDeclaration":"private static boolean isClique(UndirectedGraph<V, E> graph, Set<V> vertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V v1 : vertices) {\n        for (V v2 : vertices) {\n            if ((v1 != v2) && (graph.getEdge(v1, v2) == null)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}","methodRange":"(line 332,col 5)-(line 344,col 5)","methodTokenRange":"private static <V, E> boolean isClique(\n        UndirectedGraph<V, E> graph,\n        Set<V> vertices)\n    {\n        for (V v1 : vertices) {\n            for (V v2 : vertices) {\n                if ((v1 != v2) && (graph.getEdge(v1, v2) == null)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Check whether the subgraph of <code>graph<\/code> induced by the given\n     * <code>vertices<\/code> is complete, i.e. a clique.\n     *\n     * @param graph the graph.\n     * @param vertices the vertices to induce the subgraph from.\n     *\n     * @return true if the induced subgraph is a clique.\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"},{"parameterType":"Set<V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Set<V>","parameter":"Set<V> vertices","parameterName":"vertices"}],"methodName":"isClique","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.isClique","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Check whether the subgraph of <code>graph<\/code> induced by the given\n<code>vertices<\/code> is complete, i.e. a clique.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph.'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the vertices to induce the subgraph from.'}]}', name=Optional[vertices]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the induced subgraph is a clique.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 338,col 61)-(line 338,col 64)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 339,col 28)-(line 339,col 32)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 343,col 16)-(line 343,col 19)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.isClique(org.jgrapht.UndirectedGraph<V, E>, java.util.Set<V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to copy.","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to copy.'}]}', name=Optional[graph]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"A copy of the graph projected to a SimpleGraph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A copy of the graph projected to a SimpleGraph.'}]}', name=Optional.empty}"}],"methodDeclaration":"private static UndirectedGraph<V, E> copyAsSimpleGraph(UndirectedGraph<V, E> graph)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    UndirectedGraph<V, E> copy = new SimpleGraph<V, E>(graph.getEdgeFactory());\n    if (graph instanceof SimpleGraph) {\n        Graphs.addGraph(copy, graph);\n    } else {\n        Graphs.addAllVertices(copy, graph.vertexSet());\n        for (E e : graph.edgeSet()) {\n            V v1 = graph.getEdgeSource(e);\n            V v2 = graph.getEdgeTarget(e);\n            if ((v1 != v2) && !copy.containsEdge(e)) {\n                copy.addEdge(v1, v2);\n            }\n        }\n    }\n    return copy;\n}","methodRange":"(line 353,col 5)-(line 374,col 5)","methodTokenRange":"private static <V, E> UndirectedGraph<V, E> copyAsSimpleGraph(\n        UndirectedGraph<V, E> graph)\n    {\n        UndirectedGraph<V, E> copy =\n            new SimpleGraph<V, E>(\n                graph.getEdgeFactory());\n\n        if (graph instanceof SimpleGraph) {\n            Graphs.addGraph(copy, graph);\n        } else {\n            \/\/ project graph to SimpleGraph\n            Graphs.addAllVertices(copy, graph.vertexSet());\n            for (E e : graph.edgeSet()) {\n                V v1 = graph.getEdgeSource(e);\n                V v2 = graph.getEdgeTarget(e);\n                if ((v1 != v2) && !copy.containsEdge(e)) {\n                    copy.addEdge(v1, v2);\n                }\n            }\n        }\n        return copy;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Create a copy of a graph for internal use.\n     *\n     * @param graph the graph to copy.\n     *\n     * @return A copy of the graph projected to a SimpleGraph.\n     ","methodParameters":[{"parameterType":"UndirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>","parameter":"UndirectedGraph<V, E> graph","parameterName":"graph"}],"methodName":"copyAsSimpleGraph","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.copyAsSimpleGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a copy of a graph for internal use.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to copy.'}]}', name=Optional[graph]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A copy of the graph projected to a SimpleGraph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.copyAsSimpleGraph(org.jgrapht.UndirectedGraph<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the graph is chordal, false otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is chordal, false otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isChordal()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (chordalGraph == null) {\n        computeMinimalTriangulation();\n    }\n    return (chordalGraph.edgeSet().size() == graph.edgeSet().size());\n}","methodRange":"(line 381,col 5)-(line 388,col 5)","methodTokenRange":"public boolean isChordal()\n    {\n        if (chordalGraph == null) {\n            computeMinimalTriangulation();\n        }\n\n        return (chordalGraph.edgeSet().size() == graph.edgeSet().size());\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Check if the graph is chordal.\n     *\n     * @return true if the graph is chordal, false otherwise.\n     ","methodParameters":[],"methodName":"isChordal","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.isChordal","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Check if the graph is chordal.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the graph is chordal, false otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 383,col 29)-(line 383,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.isChordal()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Set of fill edges.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Set of fill edges.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<E> getFillEdges()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (fillEdges == null) {\n        computeMinimalTriangulation();\n    }\n    return fillEdges;\n}","methodRange":"(line 395,col 5)-(line 402,col 5)","methodTokenRange":"public Set<E> getFillEdges()\n    {\n        if (fillEdges == null) {\n            computeMinimalTriangulation();\n        }\n\n        return fillEdges;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Get the fill edges generated by the triangulation.\n     *\n     * @return Set of fill edges.\n     ","methodParameters":[],"methodName":"getFillEdges","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getFillEdges","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the fill edges generated by the triangulation.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Set of fill edges.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<E>","methodType":"Set<E>","literalExprs":[{"literalExprRange":"(line 397,col 26)-(line 397,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getFillEdges()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Triangulated graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Triangulated graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public UndirectedGraph<V, E> getMinimalTriangulation()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (chordalGraph == null) {\n        computeMinimalTriangulation();\n    }\n    return chordalGraph;\n}","methodRange":"(line 409,col 5)-(line 416,col 5)","methodTokenRange":"public UndirectedGraph<V, E> getMinimalTriangulation()\n    {\n        if (chordalGraph == null) {\n            computeMinimalTriangulation();\n        }\n\n        return chordalGraph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Get the minimal triangulation of the graph.\n     *\n     * @return Triangulated graph.\n     ","methodParameters":[],"methodName":"getMinimalTriangulation","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getMinimalTriangulation","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the minimal triangulation of the graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Triangulated graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[{"literalExprRange":"(line 411,col 29)-(line 411,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getMinimalTriangulation()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"List of generators.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of generators.'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<V> getGenerators()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (generators == null) {\n        computeMinimalTriangulation();\n    }\n    return generators;\n}","methodRange":"(line 424,col 5)-(line 431,col 5)","methodTokenRange":"public List<V> getGenerators()\n    {\n        if (generators == null) {\n            computeMinimalTriangulation();\n        }\n\n        return generators;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Get the generators of the separators of the triangulated graph, i.e. all\n     * vertices that generate a minimal separator of triangulated graph.\n     *\n     * @return List of generators.\n     ","methodParameters":[],"methodName":"getGenerators","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getGenerators","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the generators of the separators of the triangulated graph, i.e. all\nvertices that generate a minimal separator of triangulated graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='List of generators.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[{"literalExprRange":"(line 426,col 27)-(line 426,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getGenerators()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"The minimal elimination ordering.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The minimal elimination ordering.'}]}', name=Optional.empty}"}],"methodDeclaration":"public LinkedList<V> getMeo()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (meo == null) {\n        computeMinimalTriangulation();\n    }\n    return meo;\n}","methodRange":"(line 438,col 5)-(line 445,col 5)","methodTokenRange":"public LinkedList<V> getMeo()\n    {\n        if (meo == null) {\n            computeMinimalTriangulation();\n        }\n\n        return meo;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Get the minimal elimination ordering produced by the triangulation.\n     *\n     * @return The minimal elimination ordering.\n     ","methodParameters":[],"methodName":"getMeo","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getMeo","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the minimal elimination ordering produced by the triangulation.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='The minimal elimination ordering.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.LinkedList<V>","methodType":"LinkedList<V>","literalExprs":[{"literalExprRange":"(line 440,col 20)-(line 440,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getMeo()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"A map from separators to integers (component count).","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A map from separators to integers (component count).'}]}', name=Optional.empty}"}],"methodDeclaration":"public Map<Set<V>, Integer> getFullComponentCount()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (fullComponentCount == null) {\n        computeAtoms();\n    }\n    return fullComponentCount;\n}","methodRange":"(line 452,col 5)-(line 459,col 5)","methodTokenRange":"public Map<Set<V>, Integer> getFullComponentCount()\n    {\n        if (fullComponentCount == null) {\n            computeAtoms();\n        }\n\n        return fullComponentCount;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n     * Get a map to know for each separator how many components it produces.\n     *\n     * @return A map from separators to integers (component count).\n     ","methodParameters":[],"methodName":"getFullComponentCount","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getFullComponentCount","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get a map to know for each separator how many components it produces.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='A map from separators to integers (component count).'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Map<java.util.Set<V>, java.lang.Integer>","methodType":"Map<Set<V>, Integer>","literalExprs":[{"literalExprRange":"(line 454,col 35)-(line 454,col 38)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getFullComponentCount()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Set of atoms, where each atom is described as the set of its\nvertices.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Set of atoms, where each atom is described as the set of its\nvertices.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<Set<V>> getAtoms()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (atoms == null) {\n        computeAtoms();\n    }\n    return atoms;\n}","methodRange":"(line 467,col 5)-(line 474,col 5)","methodTokenRange":"public Set<Set<V>> getAtoms()\n    {\n        if (atoms == null) {\n            computeAtoms();\n        }\n\n        return atoms;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Get the atoms generated by the decomposition.\n     *\n     * @return Set of atoms, where each atom is described as the set of its\n     * vertices.\n     ","methodParameters":[],"methodName":"getAtoms","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getAtoms","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the atoms generated by the decomposition.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Set of atoms, where each atom is described as the set of its\nvertices.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<java.util.Set<V>>","methodType":"Set<Set<V>>","literalExprs":[{"literalExprRange":"(line 469,col 22)-(line 469,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getAtoms()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Set of separators, where each separator is described as the set\nof its vertices.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Set of separators, where each separator is described as the set\nof its vertices.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Set<Set<V>> getSeparators()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (separators == null) {\n        computeAtoms();\n    }\n    return separators;\n}","methodRange":"(line 482,col 5)-(line 489,col 5)","methodTokenRange":"public Set<Set<V>> getSeparators()\n    {\n        if (separators == null) {\n            computeAtoms();\n        }\n\n        return separators;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"\n     * Get the clique minimal separators.\n     *\n     * @return Set of separators, where each separator is described as the set\n     * of its vertices.\n     ","methodParameters":[],"methodName":"getSeparators","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getSeparators","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the clique minimal separators.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Set of separators, where each separator is described as the set\nof its vertices.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Set<java.util.Set<V>>","methodType":"Set<Set<V>>","literalExprs":[{"literalExprRange":"(line 484,col 27)-(line 484,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getSeparators()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"Original graph.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Original graph.'}]}', name=Optional.empty}"}],"methodDeclaration":"public UndirectedGraph<V, E> getGraph()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return graph;\n}","methodRange":"(line 496,col 5)-(line 499,col 5)","methodTokenRange":"public UndirectedGraph<V, E> getGraph()\n    {\n        return graph;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Get the original graph.\n     *\n     * @return Original graph.\n     ","methodParameters":[],"methodName":"getGraph","methodQualifiedSignature":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getGraph","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the original graph.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='Original graph.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"UndirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.CliqueMinimalSeparatorDecomposition.getGraph()"}],"classJavadoc":"\/**\n * Clique Minimal Separator Decomposition using MCS-M+ and Atoms algorithm as\n * described in Berry et al. An Introduction to Clique Minimal Separator\n * Decomposition (2010), DOI:10.3390\/a3020197, <a\n * href=\"http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197\">\n * http:\/\/www.mdpi.com\/1999-4893\/3\/2\/197<\/a>\n *\n * <p>The Clique Minimal Separator (CMS) Decomposition is a procedure that\n * splits a graph into a set of subgraphs separated by minimal clique\n * separators, adding the separating clique to each component produced by the\n * separation. At the end we have a set of atoms. The CMS decomposition is\n * unique and yields the set of the atoms independent of the order of the\n * decomposition.\n *\n * @author Florian Buenzli (fbuenzli@student.ethz.ch)\n * @author Thomas Tschager (thomas.tschager@inf.ethz.ch)\n * @author Tomas Hruz (tomas.hruz@inf.ethz.ch)\n * @author Philipp Hoppen\n *\/\n","className":"CliqueMinimalSeparatorDecomposition","fields":[{"fieldRange":"(line 72,col 5)-(line 72,col 40)","fieldName":"graph","fieldJavadocComment":"\n     * Source graph to operate on\n     ","fieldTokenRange":"private UndirectedGraph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"Source graph to operate on\n","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 77,col 5)-(line 77,col 47)","fieldName":"chordalGraph","fieldJavadocComment":"\n     * Minimal triangulation of graph\n     ","fieldTokenRange":"private UndirectedGraph<V, E> chordalGraph;","fieldTypeResolved":"ReferenceType{org.jgrapht.UndirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.UndirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.UndirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"UndirectedGraph<V, E>","fieldJavadoc":"Minimal triangulation of graph\n","fieldTypeResolvedDescribed":"org.jgrapht.UndirectedGraph<V, E>"},{"fieldRange":"(line 82,col 5)-(line 82,col 29)","fieldName":"fillEdges","fieldJavadocComment":"\n     * Fill edges\n     ","fieldTokenRange":"private Set<E> fillEdges;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<E>","fieldJavadoc":"Fill edges\n","fieldTypeResolvedDescribed":"java.util.Set<E>"},{"fieldRange":"(line 87,col 5)-(line 87,col 30)","fieldName":"meo","fieldJavadocComment":"\n     * Minimal elimination ordering on the vertices of graph\n     ","fieldTokenRange":"private LinkedList<V> meo;","fieldTypeResolved":"ReferenceType{java.util.LinkedList, typeParametersMap=TypeParametersMap{nameToValue={java.util.LinkedList.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"LinkedList<V>","fieldJavadoc":"Minimal elimination ordering on the vertices of graph\n","fieldTypeResolvedDescribed":"java.util.LinkedList<V>"},{"fieldRange":"(line 93,col 5)-(line 93,col 31)","fieldName":"generators","fieldJavadocComment":"\n     * List of all vertices that generate a minimal separator of <code>\n     * chordGraph<\/code>\n     ","fieldTokenRange":"private List<V> generators;","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"List<V>","fieldJavadoc":"List of all vertices that generate a minimal separator of <code>\nchordGraph<\/code>\n","fieldTypeResolvedDescribed":"java.util.List<V>"},{"fieldRange":"(line 98,col 5)-(line 98,col 35)","fieldName":"separators","fieldJavadocComment":"\n     * Set of clique minimal separators\n     ","fieldTokenRange":"private Set<Set<V>> separators;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<Set<V>>","fieldJavadoc":"Set of clique minimal separators\n","fieldTypeResolvedDescribed":"java.util.Set<java.util.Set<V>>"},{"fieldRange":"(line 103,col 5)-(line 103,col 30)","fieldName":"atoms","fieldJavadocComment":"\n     * The atoms generated by the decomposition\n     ","fieldTokenRange":"private Set<Set<V>> atoms;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Set<Set<V>>","fieldJavadoc":"The atoms generated by the decomposition\n","fieldTypeResolvedDescribed":"java.util.Set<java.util.Set<V>>"},{"fieldRange":"(line 108,col 5)-(line 109,col 39)","fieldName":"fullComponentCount","fieldJavadocComment":"\n     * Map for each separator how many components it produces.\n     ","fieldTokenRange":"private Map<Set<V>, Integer> fullComponentCount =\n        new HashMap<Set<V>, Integer>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<Set<V>, Integer>()]","fieldType":"Map<Set<V>, Integer>","fieldJavadoc":"Map for each separator how many components it produces.\n","fieldTypeResolvedDescribed":"java.util.Map<java.util.Set<V>, java.lang.Integer>"}]}],"sourceFileId":200,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.BellmanFordIterator","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"start vertex.","javadocBlockTagName":"startVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex.'}]}', name=Optional[startVertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"tolerance factor.","javadocBlockTagName":"epsilon","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.BellmanFordIterator(org.jgrapht.Graph<V, E>, V, double)","variableDeclarationExprs":[],"constructorRange":"(line 92,col 5)-(line 102,col 5)","constructorJavadocComment":"\n     * @param graph\n     * @param startVertex start vertex.\n     * @param epsilon tolerance factor.\n     ","constructorDeclaration":"protected BellmanFordIterator(Graph<V, E> graph, V startVertex, double epsilon)","constructorBody":"{\n    assertBellmanFordIterator(graph, startVertex);\n    this.graph = graph;\n    this.startVertex = startVertex;\n    this.epsilon = epsilon;\n}","constructorName":"BellmanFordIterator","constructorQualifiedName":"org.jgrapht.alg.BellmanFordIterator.BellmanFordIterator","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[],"constructorTokenRange":"protected BellmanFordIterator(\n        Graph<V, E> graph,\n        V startVertex,\n        double epsilon)\n    {\n        assertBellmanFordIterator(graph, startVertex);\n\n        this.graph = graph;\n        this.startVertex = startVertex;\n        this.epsilon = epsilon;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='start vertex.'}]}', name=Optional[startVertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance factor.'}]}', name=Optional[epsilon]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex.","javadocBlockTagName":"endVertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public BellmanFordPathElement<V, E> getPathElement(V endVertex)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getSeenData(endVertex);\n}","methodRange":"(line 112,col 5)-(line 115,col 5)","methodTokenRange":"public BellmanFordPathElement<V, E> getPathElement(V endVertex)\n    {\n        return getSeenData(endVertex);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Returns the path element of the shortest path with less than <code>\n     * nMaxHops<\/code> edges between the start vertex and the end vertex.\n     *\n     * @param endVertex end vertex.\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V endVertex","parameterName":"endVertex"}],"methodName":"getPathElement","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.getPathElement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the path element of the shortest path with less than <code>\nnMaxHops<\/code> edges between the start vertex and the end vertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex.'}]}', name=Optional[endVertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"BellmanFordPathElement<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.getPathElement(V)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if at least one path has been improved during\nthe previous pass, <code>false<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if at least one path has been improved during\nthe previous pass, <code>false<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!this.startVertexEncountered) {\n        encounterStartVertex();\n    }\n    return !(this.prevImprovedVertices.isEmpty());\n}","methodRange":"(line 121,col 5)-(line 128,col 5)","methodTokenRange":"@Override public boolean hasNext()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        return !(this.prevImprovedVertices.isEmpty());\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * @return <code>true<\/code> if at least one path has been improved during\n     * the previous pass, <code>false<\/code> otherwise.\n     ","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.hasNext","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if at least one path has been improved during\nthe previous pass, <code>false<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.hasNext()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Iterator#next()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#next()'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<V> next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!this.startVertexEncountered) {\n        encounterStartVertex();\n    }\n    if (hasNext()) {\n        List<V> improvedVertices = new ArrayList<V>();\n        for (int i = this.prevImprovedVertices.size() - 1; i >= 0; i--) {\n            V vertex = this.prevImprovedVertices.get(i);\n            for (Iterator<? extends E> iter = edgesOfIterator(vertex); iter.hasNext(); ) {\n                E edge = iter.next();\n                V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n                if (getPathElement(oppositeVertex) != null) {\n                    boolean relaxed = relaxVertexAgain(oppositeVertex, edge);\n                    if (relaxed) {\n                        improvedVertices.add(oppositeVertex);\n                    }\n                } else {\n                    relaxVertex(oppositeVertex, edge);\n                    improvedVertices.add(oppositeVertex);\n                }\n            }\n        }\n        savePassData(improvedVertices);\n        return improvedVertices;\n    }\n    throw new NoSuchElementException();\n}","methodRange":"(line 136,col 5)-(line 175,col 5)","methodTokenRange":"@Override public List<V> next()\n    {\n        if (!this.startVertexEncountered) {\n            encounterStartVertex();\n        }\n\n        if (hasNext()) {\n            List<V> improvedVertices = new ArrayList<V>();\n            for (int i = this.prevImprovedVertices.size() - 1; i >= 0; i--) {\n                V vertex = this.prevImprovedVertices.get(i);\n                for (\n                    Iterator<? extends E> iter = edgesOfIterator(vertex);\n                    iter.hasNext();)\n                {\n                    E edge = iter.next();\n                    V oppositeVertex =\n                        Graphs.getOppositeVertex(\n                            graph,\n                            edge,\n                            vertex);\n                    if (getPathElement(oppositeVertex) != null) {\n                        boolean relaxed =\n                            relaxVertexAgain(oppositeVertex, edge);\n                        if (relaxed) {\n                            improvedVertices.add(oppositeVertex);\n                        }\n                    } else {\n                        relaxVertex(oppositeVertex, edge);\n                        improvedVertices.add(oppositeVertex);\n                    }\n                }\n            }\n\n            savePassData(improvedVertices);\n\n            return improvedVertices;\n        }\n\n        throw new NoSuchElementException();\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the list <code>Collection<\/code> of vertices whose path has been\n     * improved during the current pass.\n     *\n     * @see java.util.Iterator#next()\n     ","methodParameters":[],"methodName":"next","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.next","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the list <code>Collection<\/code> of vertices whose path has been\nimproved during the current pass.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#next()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<V>","methodType":"List<V>","literalExprs":[{"literalExprRange":"(line 144,col 61)-(line 144,col 61)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 144,col 69)-(line 144,col 69)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 156,col 59)-(line 156,col 62)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.next()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Iterator#remove()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#remove()'}]}', name=Optional.empty}"}],"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException();\n}","methodRange":"(line 182,col 5)-(line 185,col 5)","methodTokenRange":"@Override public void remove()\n    {\n        throw new UnsupportedOperationException();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Unsupported\n     *\n     * @see java.util.Iterator#remove()\n     ","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Unsupported'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Iterator#remove()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.remove()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[edge]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the graph is undirected and the\nedge-weight is negative.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph is undirected and the\nedge-weight is negative.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":"protected void assertValidEdge(E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (this.graph instanceof UndirectedGraph<?, ?>) {\n        if (graph.getEdgeWeight(edge) < 0) {\n            throw new IllegalArgumentException(NEGATIVE_UNDIRECTED_EDGE);\n        }\n    }\n}","methodRange":"(line 193,col 5)-(line 200,col 5)","methodTokenRange":"protected void assertValidEdge(E edge)\n    {\n        if (this.graph instanceof UndirectedGraph<?, ?>) {\n            if (graph.getEdgeWeight(edge) < 0) {\n                throw new IllegalArgumentException(NEGATIVE_UNDIRECTED_EDGE);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * @param edge\n     *\n     * @throws IllegalArgumentException if the graph is undirected and the\n     * edge-weight is negative.\n     ","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"assertValidEdge","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.assertValidEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[edge]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the graph is undirected and the\nedge-weight is negative.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 196,col 45)-(line 196,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.assertValidEdge(E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the cost obtained by concatenation.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the cost obtained by concatenation.'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Graph#getEdgeWeight(E)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(E)'}]}', name=Optional.empty}"}],"methodDeclaration":"protected double calculatePathCost(V vertex, E edge)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n    BellmanFordPathElement<V, E> oppositePrevData = getPrevSeenData(oppositeVertex);\n    double pathCost = graph.getEdgeWeight(edge);\n    if (!oppositePrevData.getVertex().equals(this.startVertex)) {\n        pathCost += oppositePrevData.getCost();\n    }\n    return pathCost;\n}","methodRange":"(line 213,col 5)-(line 230,col 5)","methodTokenRange":"protected double calculatePathCost(V vertex, E edge)\n    {\n        V oppositeVertex = Graphs.getOppositeVertex(graph, edge, vertex);\n\n        \/\/ we get the data of the previous pass.\n        BellmanFordPathElement<V, E> oppositePrevData =\n            getPrevSeenData(oppositeVertex);\n\n        double pathCost = graph.getEdgeWeight(edge);\n\n        if (!oppositePrevData.getVertex().equals(this.startVertex)) {\n            \/\/ if it's not the start vertex, we add the cost of the previous\n            \/\/ pass.\n            pathCost += oppositePrevData.getCost();\n        }\n\n        return pathCost;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n     * Costs taken into account are the weights stored in <code>Edge<\/code>\n     * objects.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return the cost obtained by concatenation.\n     *\n     * @see Graph#getEdgeWeight(E)\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"calculatePathCost","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.calculatePathCost","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Costs taken into account are the weights stored in <code>Edge<\/code>\nobjects.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the cost obtained by concatenation.'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Graph#getEdgeWeight(E)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.calculatePathCost(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected Iterator<E> edgesOfIterator(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (this.graph instanceof DirectedGraph<?, ?>) {\n        return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex).iterator();\n    } else {\n        return this.graph.edgesOf(vertex).iterator();\n    }\n}","methodRange":"(line 240,col 5)-(line 248,col 5)","methodTokenRange":"protected Iterator<E> edgesOfIterator(V vertex)\n    {\n        if (this.graph instanceof DirectedGraph<?, ?>) {\n            return ((DirectedGraph<V, E>) this.graph).outgoingEdgesOf(vertex)\n                .iterator();\n        } else {\n            return this.graph.edgesOf(vertex).iterator();\n        }\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns an iterator to loop over outgoing edges <code>Edge<\/code> of the\n     * vertex.\n     *\n     * @param vertex\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"edgesOfIterator","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.edgesOfIterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an iterator to loop over outgoing edges <code>Edge<\/code> of the\nvertex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<E>","methodType":"Iterator<E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.edgesOfIterator(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has already been seen.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has already been seen.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected BellmanFordPathElement<V, E> getPrevSeenData(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this.prevVertexData.get(vertex);\n}","methodRange":"(line 258,col 5)-(line 261,col 5)","methodTokenRange":"protected BellmanFordPathElement<V, E> getPrevSeenData(V vertex)\n    {\n        return this.prevVertexData.get(vertex);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Access the data stored for a seen vertex in the previous pass.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null<\/code> if no\n     * data was associated with the vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getPrevSeenData","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.getPrevSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Access the data stored for a seen vertex in the previous pass.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has already been seen.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"BellmanFordPathElement<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.getPrevSeenData(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has already been seen.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has already been seen.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected BellmanFordPathElement<V, E> getSeenData(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this.vertexData.get(vertex);\n}","methodRange":"(line 271,col 5)-(line 274,col 5)","methodTokenRange":"protected BellmanFordPathElement<V, E> getSeenData(V vertex)\n    {\n        return this.vertexData.get(vertex);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Access the data stored for a seen vertex in the current pass.\n     *\n     * @param vertex a vertex which has already been seen.\n     *\n     * @return data associated with the seen vertex or <code>null<\/code> if no\n     * data was associated with the vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"getSeenData","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.getSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Access the data stored for a seen vertex in the current pass.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has already been seen.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='data associated with the seen vertex or <code>null<\/code> if no\ndata was associated with the vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"BellmanFordPathElement<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.getSeenData(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"vertex in question.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in question.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<tt>true<\/tt> if vertex has already been seen.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if vertex has already been seen.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected boolean isSeenVertex(V vertex)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this.vertexData.containsKey(vertex);\n}","methodRange":"(line 283,col 5)-(line 286,col 5)","methodTokenRange":"protected boolean isSeenVertex(V vertex)\n    {\n        return this.vertexData.containsKey(vertex);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Determines whether a vertex has been seen yet by this traversal.\n     *\n     * @param vertex vertex in question.\n     *\n     * @return <tt>true<\/tt> if vertex has already been seen.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"methodName":"isSeenVertex","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.isSeenVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determines whether a vertex has been seen yet by this traversal.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='vertex in question.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<tt>true<\/tt> if vertex has already been seen.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.isSeenVertex(V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"data","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[data]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected BellmanFordPathElement<V, E> putPrevSeenData(V vertex, BellmanFordPathElement<V, E> data)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (this.prevVertexData == null) {\n        this.prevVertexData = new HashMap<V, BellmanFordPathElement<V, E>>();\n    }\n    return this.prevVertexData.put(vertex, data);\n}","methodRange":"(line 294,col 5)-(line 304,col 5)","methodTokenRange":"protected BellmanFordPathElement<V, E> putPrevSeenData(\n        V vertex,\n        BellmanFordPathElement<V, E> data)\n    {\n        if (this.prevVertexData == null) {\n            this.prevVertexData =\n                new HashMap<V, BellmanFordPathElement<V, E>>();\n        }\n\n        return this.prevVertexData.put(vertex, data);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * @param vertex\n     * @param data\n     *\n     * @return .\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"BellmanFordPathElement<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.BellmanFordPathElement<V, E>","parameter":"BellmanFordPathElement<V, E> data","parameterName":"data"}],"methodName":"putPrevSeenData","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.putPrevSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[data]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"BellmanFordPathElement<V, E>","literalExprs":[{"literalExprRange":"(line 298,col 36)-(line 298,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.putPrevSeenData(V, org.jgrapht.alg.BellmanFordPathElement<V, E>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has been seen.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has been seen.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"data to be associated with the seen vertex.","javadocBlockTagName":"data","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='data to be associated with the seen vertex.'}]}', name=Optional[data]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"previous value associated with specified vertex or <code>\nnull<\/code> if no data was associated with the vertex.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified vertex or <code>\nnull<\/code> if no data was associated with the vertex.'}]}', name=Optional.empty}"}],"methodDeclaration":"protected BellmanFordPathElement<V, E> putSeenData(V vertex, BellmanFordPathElement<V, E> data)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (this.vertexData == null) {\n        this.vertexData = new HashMap<V, BellmanFordPathElement<V, E>>();\n    }\n    return this.vertexData.put(vertex, data);\n}","methodRange":"(line 316,col 5)-(line 325,col 5)","methodTokenRange":"protected BellmanFordPathElement<V, E> putSeenData(\n        V vertex,\n        BellmanFordPathElement<V, E> data)\n    {\n        if (this.vertexData == null) {\n            this.vertexData = new HashMap<V, BellmanFordPathElement<V, E>>();\n        }\n\n        return this.vertexData.put(vertex, data);\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * Stores iterator-dependent data for a vertex that has been seen during the\n     * current pass.\n     *\n     * @param vertex a vertex which has been seen.\n     * @param data data to be associated with the seen vertex.\n     *\n     * @return previous value associated with specified vertex or <code>\n     * null<\/code> if no data was associated with the vertex.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"BellmanFordPathElement<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.BellmanFordPathElement<V, E>","parameter":"BellmanFordPathElement<V, E> data","parameterName":"data"}],"methodName":"putSeenData","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.putSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Stores iterator-dependent data for a vertex that has been seen during the\ncurrent pass.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has been seen.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='data to be associated with the seen vertex.'}]}', name=Optional[data]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified vertex or <code>\nnull<\/code> if no data was associated with the vertex.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"BellmanFordPathElement<V, E>","literalExprs":[{"literalExprRange":"(line 320,col 32)-(line 320,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.putSeenData(V, org.jgrapht.alg.BellmanFordPathElement<V, E>)"},{"methodDeclaration":"private void assertBellmanFordIterator(Graph<V, E> graph, V startVertex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!(graph.containsVertex(startVertex))) {\n        throw new IllegalArgumentException(\"Graph must contain the start vertex!\");\n    }\n}","methodRange":"(line 327,col 5)-(line 333,col 5)","methodTokenRange":"private void assertBellmanFordIterator(Graph<V, E> graph, V startVertex)\n    {\n        if (!(graph.containsVertex(startVertex))) {\n            throw new IllegalArgumentException(\n                \"Graph must contain the start vertex!\");\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V startVertex","parameterName":"startVertex"}],"methodName":"assertBellmanFordIterator","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.assertBellmanFordIterator","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 331,col 17)-(line 331,col 54)","literalExprId":1,"literalExpr":"\"Graph must contain the start vertex!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.assertBellmanFordIterator(org.jgrapht.Graph<V, E>, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"cost of the created path element.","javadocBlockTagName":"cost","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='cost of the created path element.'}]}', name=Optional[cost]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the new entry.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new entry.'}]}', name=Optional.empty}"}],"methodDeclaration":"private BellmanFordPathElement<V, E> createSeenData(V vertex, E edge, double cost)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    BellmanFordPathElement<V, E> prevPathElement = getPrevSeenData(Graphs.getOppositeVertex(graph, edge, vertex));\n    BellmanFordPathElement<V, E> data = new BellmanFordPathElement<V, E>(graph, prevPathElement, edge, cost, epsilon);\n    return data;\n}","methodRange":"(line 344,col 5)-(line 362,col 5)","methodTokenRange":"private BellmanFordPathElement<V, E> createSeenData(\n        V vertex,\n        E edge,\n        double cost)\n    {\n        BellmanFordPathElement<V, E> prevPathElement =\n            getPrevSeenData(\n                Graphs.getOppositeVertex(graph, edge, vertex));\n\n        BellmanFordPathElement<V, E> data =\n            new BellmanFordPathElement<V, E>(\n                graph,\n                prevPathElement,\n                edge,\n                cost,\n                epsilon);\n\n        return data;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"\n     * The first time we see a vertex, make up a new entry for it.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     * @param cost cost of the created path element.\n     *\n     * @return the new entry.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double cost","parameterName":"cost"}],"methodName":"createSeenData","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.createSeenData","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The first time we see a vertex, make up a new entry for it.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='cost of the created path element.'}]}', name=Optional[cost]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the new entry.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"BellmanFordPathElement<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.createSeenData(V, E, double)"},{"methodDeclaration":"private void encounterStartVertex()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    BellmanFordPathElement<V, E> data = new BellmanFordPathElement<V, E>(this.startVertex, epsilon);\n    this.prevImprovedVertices.add(this.startVertex);\n    putSeenData(this.startVertex, data);\n    putPrevSeenData(this.startVertex, data);\n    this.startVertexEncountered = true;\n}","methodRange":"(line 364,col 5)-(line 378,col 5)","methodTokenRange":"private void encounterStartVertex()\n    {\n        BellmanFordPathElement<V, E> data =\n            new BellmanFordPathElement<V, E>(\n                this.startVertex,\n                epsilon);\n\n        \/\/ first the only vertex considered as improved is the start vertex.\n        this.prevImprovedVertices.add(this.startVertex);\n\n        putSeenData(this.startVertex, data);\n        putPrevSeenData(this.startVertex, data);\n\n        this.startVertexEncountered = true;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"encounterStartVertex","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.encounterStartVertex","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 377,col 39)-(line 377,col 42)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.encounterStartVertex()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"}],"methodDeclaration":"private void relaxVertex(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    assertValidEdge(edge);\n    double shortestPathCost = calculatePathCost(vertex, edge);\n    BellmanFordPathElement<V, E> data = createSeenData(vertex, edge, shortestPathCost);\n    putSeenData(vertex, data);\n}","methodRange":"(line 386,col 5)-(line 397,col 5)","methodTokenRange":"private void relaxVertex(V vertex, E edge)\n    {\n        assertValidEdge(edge);\n\n        double shortestPathCost = calculatePathCost(vertex, edge);\n\n        BellmanFordPathElement<V, E> data =\n            createSeenData(vertex, edge,\n                shortestPathCost);\n\n        putSeenData(vertex, data);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Upates data first time a vertex is reached by a path.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"relaxVertex","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.relaxVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Upates data first time a vertex is reached by a path.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.relaxVertex(V, E)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a vertex which has just been encountered.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the edge via which the vertex was encountered.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>true<\/code> if the cost has been improved, <code>\nfalse<\/code> otherwise.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the cost has been improved, <code>\nfalse<\/code> otherwise.'}]}', name=Optional.empty}"}],"methodDeclaration":"private boolean relaxVertexAgain(V vertex, E edge)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    assertValidEdge(edge);\n    double candidateCost = calculatePathCost(vertex, edge);\n    BellmanFordPathElement<V, E> oppositePrevData = getPrevSeenData(Graphs.getOppositeVertex(graph, edge, vertex));\n    BellmanFordPathElement<V, E> pathElement = getSeenData(vertex);\n    return pathElement.improve(oppositePrevData, edge, candidateCost);\n}","methodRange":"(line 409,col 5)-(line 422,col 5)","methodTokenRange":"private boolean relaxVertexAgain(V vertex, E edge)\n    {\n        assertValidEdge(edge);\n\n        double candidateCost = calculatePathCost(vertex, edge);\n\n        \/\/ we get the data of the previous pass.\n        BellmanFordPathElement<V, E> oppositePrevData =\n            getPrevSeenData(\n                Graphs.getOppositeVertex(graph, edge, vertex));\n\n        BellmanFordPathElement<V, E> pathElement = getSeenData(vertex);\n        return pathElement.improve(oppositePrevData, edge, candidateCost);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Check if the cost of the best path so far reaching the specified vertex\n     * could be improved if the vertex is reached through the specified edge.\n     *\n     * @param vertex a vertex which has just been encountered.\n     * @param edge the edge via which the vertex was encountered.\n     *\n     * @return <code>true<\/code> if the cost has been improved, <code>\n     * false<\/code> otherwise.\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"},{"parameterType":"E","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"methodName":"relaxVertexAgain","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.relaxVertexAgain","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Check if the cost of the best path so far reaching the specified vertex\ncould be improved if the vertex is reached through the specified edge.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a vertex which has just been encountered.'}]}', name=Optional[vertex]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the edge via which the vertex was encountered.'}]}', name=Optional[edge]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>true<\/code> if the cost has been improved, <code>\nfalse<\/code> otherwise.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.relaxVertexAgain(V, E)"},{"methodDeclaration":"private void savePassData(List<V> improvedVertices)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V vertex : improvedVertices) {\n        BellmanFordPathElement<V, E> orig = getSeenData(vertex);\n        BellmanFordPathElement<V, E> clonedData = new BellmanFordPathElement<V, E>(orig);\n        putPrevSeenData(vertex, clonedData);\n    }\n    this.prevImprovedVertices = improvedVertices;\n}","methodRange":"(line 424,col 5)-(line 434,col 5)","methodTokenRange":"private void savePassData(List<V> improvedVertices)\n    {\n        for (V vertex : improvedVertices) {\n            BellmanFordPathElement<V, E> orig = getSeenData(vertex);\n            BellmanFordPathElement<V, E> clonedData =\n                new BellmanFordPathElement<V, E>(orig);\n            putPrevSeenData(vertex, clonedData);\n        }\n\n        this.prevImprovedVertices = improvedVertices;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"List<V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<V>","parameter":"List<V> improvedVertices","parameterName":"improvedVertices"}],"methodName":"savePassData","methodQualifiedSignature":"org.jgrapht.alg.BellmanFordIterator.savePassData","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.BellmanFordIterator.savePassData(java.util.List<V>)"}],"classJavadoc":"\/**\n * Helper class for {@link BellmanFordShortestPath}; not intended for general\n * use.\n *\/\n","className":"BellmanFordIterator","fields":[{"fieldRange":"(line 55,col 5)-(line 57,col 65)","fieldName":"NEGATIVE_UNDIRECTED_EDGE","fieldJavadocComment":"\n     * Error message.\n     ","fieldTokenRange":"protected final static String NEGATIVE_UNDIRECTED_EDGE =\n        \"Negative\"\n        + \"edge-weights are not allowed in an unidrected graph!\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[{"literalExprRange":"(line 56,col 9)-(line 56,col 18)","literalExprId":1,"literalExpr":"\"Negative\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 57,col 11)-(line 57,col 64)","literalExprId":2,"literalExpr":"\"edge-weights are not allowed in an unidrected graph!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"Negative\" + \"edge-weights are not allowed in an unidrected graph!\"]","fieldType":"String","fieldJavadoc":"Error message.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 62,col 5)-(line 62,col 32)","fieldName":"graph","fieldJavadocComment":"\n     * Graph on which shortest paths are searched.\n     ","fieldTokenRange":"protected Graph<V, E> graph;","fieldTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"Graph<V, E>","fieldJavadoc":"Graph on which shortest paths are searched.\n","fieldTypeResolvedDescribed":"org.jgrapht.Graph<V, E>"},{"fieldRange":"(line 67,col 5)-(line 67,col 28)","fieldName":"startVertex","fieldJavadocComment":"\n     * Start vertex.\n     ","fieldTokenRange":"protected V startVertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"Start vertex.\n","fieldTypeResolvedDescribed":"V"},{"fieldRange":"(line 73,col 5)-(line 73,col 62)","fieldName":"prevImprovedVertices","fieldJavadocComment":"\n     * Vertices whose shortest path cost have been improved during the previous\n     * pass.\n     ","fieldTokenRange":"private List<V> prevImprovedVertices = new ArrayList<V>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<V>()]","fieldType":"List<V>","fieldJavadoc":"Vertices whose shortest path cost have been improved during the previous\npass.\n","fieldTypeResolvedDescribed":"java.util.List<V>"},{"fieldRange":"(line 75,col 5)-(line 75,col 64)","fieldName":"prevVertexData","fieldJavadocComment":"","fieldTokenRange":"private Map<V, BellmanFordPathElement<V, E>> prevVertexData;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, BellmanFordPathElement<V, E>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.BellmanFordPathElement<V, E>>"},{"fieldRange":"(line 77,col 5)-(line 77,col 51)","fieldName":"startVertexEncountered","fieldJavadocComment":"","fieldTokenRange":"private boolean startVertexEncountered = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 77,col 46)-(line 77,col 50)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 83,col 5)-(line 83,col 60)","fieldName":"vertexData","fieldJavadocComment":"\n     * Stores the vertices that have been seen during iteration and (optionally)\n     * some additional traversal info regarding each vertex.\n     ","fieldTokenRange":"private Map<V, BellmanFordPathElement<V, E>> vertexData;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(V, bounds=[])}, java.util.Map.V=ReferenceType{org.jgrapht.alg.BellmanFordPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.BellmanFordPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.BellmanFordPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<V, BellmanFordPathElement<V, E>>","fieldJavadoc":"Stores the vertices that have been seen during iteration and (optionally)\nsome additional traversal info regarding each vertex.\n","fieldTypeResolvedDescribed":"java.util.Map<V, org.jgrapht.alg.BellmanFordPathElement<V, E>>"},{"fieldRange":"(line 85,col 5)-(line 85,col 27)","fieldName":"epsilon","fieldJavadocComment":"","fieldTokenRange":"private double epsilon;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":201,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.AbstractPathElement","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"","javadocBlockTagName":"pathElement","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"edge reaching the end vertex of the path element created.","javadocBlockTagName":"edge","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the path element created.'}]}', name=Optional[edge]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.AbstractPathElement(org.jgrapht.Graph<V, E>, org.jgrapht.alg.AbstractPathElement<V, E>, E)","variableDeclarationExprs":[],"constructorRange":"(line 87,col 5)-(line 101,col 5)","constructorJavadocComment":"\n     * Creates a path element by concatenation of an edge to a path element.\n     *\n     * @param pathElement\n     * @param edge edge reaching the end vertex of the path element created.\n     ","constructorDeclaration":"protected AbstractPathElement(Graph<V, E> graph, AbstractPathElement<V, E> pathElement, E edge)","constructorBody":"{\n    this.vertex = Graphs.getOppositeVertex(graph, edge, pathElement.getVertex());\n    this.prevEdge = edge;\n    this.prevPathElement = pathElement;\n    this.nHops = pathElement.getHopCount() + 1;\n}","constructorName":"AbstractPathElement","constructorQualifiedName":"org.jgrapht.alg.AbstractPathElement.AbstractPathElement","constructorParameters":[{"parameterType":"Graph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.Graph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.Graph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.Graph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.Graph<V, E>","parameter":"Graph<V, E> graph","parameterName":"graph"},{"parameterType":"AbstractPathElement<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.AbstractPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.AbstractPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.AbstractPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.AbstractPathElement<V, E>","parameter":"AbstractPathElement<V, E> pathElement","parameterName":"pathElement"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E edge","parameterName":"edge"}],"literalExprs":[{"literalExprRange":"(line 100,col 50)-(line 100,col 50)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"protected AbstractPathElement(\n        Graph<V, E> graph,\n        AbstractPathElement<V, E> pathElement,\n        E edge)\n    {\n        this.vertex =\n            Graphs.getOppositeVertex(\n                graph,\n                edge,\n                pathElement.getVertex());\n        this.prevEdge = edge;\n        this.prevPathElement = pathElement;\n\n        this.nHops = pathElement.getHopCount() + 1;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a path element by concatenation of an edge to a path element.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[]}', name=Optional[pathElement]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='edge reaching the end vertex of the path element created.'}]}', name=Optional[edge]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source to copy from","javadocBlockTagName":"original","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source to copy from'}]}', name=Optional[original]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.AbstractPathElement(org.jgrapht.alg.AbstractPathElement<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 108,col 5)-(line 114,col 5)","constructorJavadocComment":"\n     * Copy constructor.\n     *\n     * @param original source to copy from\n     ","constructorDeclaration":"protected AbstractPathElement(AbstractPathElement<V, E> original)","constructorBody":"{\n    this.nHops = original.nHops;\n    this.prevEdge = original.prevEdge;\n    this.prevPathElement = original.prevPathElement;\n    this.vertex = original.vertex;\n}","constructorName":"AbstractPathElement","constructorQualifiedName":"org.jgrapht.alg.AbstractPathElement.AbstractPathElement","constructorParameters":[{"parameterType":"AbstractPathElement<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.AbstractPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.AbstractPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.AbstractPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.AbstractPathElement<V, E>","parameter":"AbstractPathElement<V, E> original","parameterName":"original"}],"literalExprs":[],"constructorTokenRange":"protected AbstractPathElement(AbstractPathElement<V, E> original)\n    {\n        this.nHops = original.nHops;\n        this.prevEdge = original.prevEdge;\n        this.prevPathElement = original.prevPathElement;\n        this.vertex = original.vertex;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Copy constructor.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source to copy from'}]}', name=Optional[original]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"end vertex of the path element.","javadocBlockTagName":"vertex","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the path element.'}]}', name=Optional[vertex]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.AbstractPathElement(V)","variableDeclarationExprs":[],"constructorRange":"(line 121,col 5)-(line 128,col 5)","constructorJavadocComment":"\n     * Creates an empty path element.\n     *\n     * @param vertex end vertex of the path element.\n     ","constructorDeclaration":"protected AbstractPathElement(V vertex)","constructorBody":"{\n    this.vertex = vertex;\n    this.prevEdge = null;\n    this.prevPathElement = null;\n    this.nHops = 0;\n}","constructorName":"AbstractPathElement","constructorQualifiedName":"org.jgrapht.alg.AbstractPathElement.AbstractPathElement","constructorParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V vertex","parameterName":"vertex"}],"literalExprs":[{"literalExprRange":"(line 124,col 25)-(line 124,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 125,col 32)-(line 125,col 35)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 127,col 22)-(line 127,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"protected AbstractPathElement(V vertex)\n    {\n        this.vertex = vertex;\n        this.prevEdge = null;\n        this.prevPathElement = null;\n\n        this.nHops = 0;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty path element.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='end vertex of the path element.'}]}', name=Optional[vertex]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of <code>Edge<\/code>.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>Edge<\/code>.'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<E> createEdgeListPath()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<E> path = new ArrayList<E>();\n    AbstractPathElement<V, E> pathElement = this;\n    while (pathElement.getPrevEdge() != null) {\n        path.add(pathElement.getPrevEdge());\n        pathElement = pathElement.getPrevPathElement();\n    }\n    Collections.reverse(path);\n    return path;\n}","methodRange":"(line 135,col 5)-(line 150,col 5)","methodTokenRange":"public List<E> createEdgeListPath()\n    {\n        List<E> path = new ArrayList<E>();\n        AbstractPathElement<V, E> pathElement = this;\n\n        \/\/ while start vertex is not reached.\n        while (pathElement.getPrevEdge() != null) {\n            path.add(pathElement.getPrevEdge());\n\n            pathElement = pathElement.getPrevPathElement();\n        }\n\n        Collections.reverse(path);\n\n        return path;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the path as a list of edges.\n     *\n     * @return list of <code>Edge<\/code>.\n     ","methodParameters":[],"methodName":"createEdgeListPath","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.createEdgeListPath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the path as a list of edges.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of <code>Edge<\/code>.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<E>","methodType":"List<E>","literalExprs":[{"literalExprRange":"(line 141,col 45)-(line 141,col 48)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElement.createEdgeListPath()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getHopCount()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.nHops;\n}","methodRange":"(line 157,col 5)-(line 160,col 5)","methodTokenRange":"public int getHopCount()\n    {\n        return this.nHops;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n     * Returns the number of hops (or number of edges) of the path.\n     *\n     * @return .\n     ","methodParameters":[],"methodName":"getHopCount","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.getHopCount","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the number of hops (or number of edges) of the path.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElement.getHopCount()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>null<\/code> if the path is empty.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>null<\/code> if the path is empty.'}]}', name=Optional.empty}"}],"methodDeclaration":"public E getPrevEdge()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.prevEdge;\n}","methodRange":"(line 167,col 5)-(line 170,col 5)","methodTokenRange":"public E getPrevEdge()\n    {\n        return this.prevEdge;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","methodJavadocComment":"\n     * Returns the edge reaching the target vertex of the path.\n     *\n     * @return <code>null<\/code> if the path is empty.\n     ","methodParameters":[],"methodName":"getPrevEdge","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.getPrevEdge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the edge reaching the target vertex of the path.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>null<\/code> if the path is empty.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"E","methodType":"E","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElement.getPrevEdge()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"<code>null<\/code> is the path is empty.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>null<\/code> is the path is empty.'}]}', name=Optional.empty}"}],"methodDeclaration":"public AbstractPathElement<V, E> getPrevPathElement()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.prevPathElement;\n}","methodRange":"(line 177,col 5)-(line 180,col 5)","methodTokenRange":"public AbstractPathElement<V, E> getPrevPathElement()\n    {\n        return this.prevPathElement;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.AbstractPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.AbstractPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.AbstractPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Returns the previous path element.\n     *\n     * @return <code>null<\/code> is the path is empty.\n     ","methodParameters":[],"methodName":"getPrevPathElement","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.getPrevPathElement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the previous path element.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='<code>null<\/code> is the path is empty.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"org.jgrapht.alg.AbstractPathElement<V, E>","methodType":"AbstractPathElement<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElement.getPrevPathElement()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":".","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getVertex()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this.vertex;\n}","methodRange":"(line 187,col 5)-(line 190,col 5)","methodTokenRange":"public V getVertex()\n    {\n        return this.vertex;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns the target vertex of the path.\n     *\n     * @return .\n     ","methodParameters":[],"methodName":"getVertex","methodQualifiedSignature":"org.jgrapht.alg.AbstractPathElement.getVertex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the target vertex of the path.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.AbstractPathElement.getVertex()"}],"classJavadoc":"\/**\n * A new path is created from a path concatenated to an edge. It's like a linked\n * list.<br>\n * The empty path is composed only of one vertex.<br>\n * In this case the path has no previous path element.<br>\n * .\n *\n * <p>NOTE jvs 1-Jan-2008: This is an internal data structure for use in\n * algorithms. For returning paths to callers, use the public {@link GraphPath}\n * interface instead.\n *\n * @author Guillaume Boulmier\n * @since July 5, 2007\n *\/\n","className":"AbstractPathElement","fields":[{"fieldRange":"(line 64,col 5)-(line 64,col 24)","fieldName":"nHops","fieldJavadocComment":"\n     * Number of hops of the path.\n     ","fieldTokenRange":"protected int nHops;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of hops of the path.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 69,col 5)-(line 69,col 25)","fieldName":"prevEdge","fieldJavadocComment":"\n     * Edge reaching the target vertex of the path.\n     ","fieldTokenRange":"protected E prevEdge;","fieldTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"E","fieldJavadoc":"Edge reaching the target vertex of the path.\n","fieldTypeResolvedDescribed":"E"},{"fieldRange":"(line 74,col 5)-(line 74,col 56)","fieldName":"prevPathElement","fieldJavadocComment":"\n     * Previous path element.\n     ","fieldTokenRange":"protected AbstractPathElement<V, E> prevPathElement;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.AbstractPathElement, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.AbstractPathElement.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.AbstractPathElement.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"AbstractPathElement<V, E>","fieldJavadoc":"Previous path element.\n","fieldTypeResolvedDescribed":"org.jgrapht.alg.AbstractPathElement<V, E>"},{"fieldRange":"(line 79,col 5)-(line 79,col 21)","fieldName":"vertex","fieldJavadocComment":"\n     * Target vertex.\n     ","fieldTokenRange":"private V vertex;","fieldTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"V","fieldJavadoc":"Target vertex.\n","fieldTypeResolvedDescribed":"V"}]}],"sourceFileId":202,"packageName":"org.jgrapht.alg"},{"sourceFileName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.util.Extension.*;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"network, where maximum flow will be calculated","javadocBlockTagName":"network","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow(org.jgrapht.DirectedGraph<V, E>)","variableDeclarationExprs":[],"constructorRange":"(line 86,col 5)-(line 89,col 5)","constructorJavadocComment":"\n     * Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n     * <tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n     * <tt>network<\/tt> is weighted, then capacities are weights, otherwise all\n     * capacities are equal to one. Doubles are compared using <tt>\n     * DEFAULT_EPSILON<\/tt> tolerance.\n     *\n     * @param network network, where maximum flow will be calculated\n     ","constructorDeclaration":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network)","constructorBody":"{\n    this(network, DEFAULT_EPSILON);\n}","constructorName":"EdmondsKarpMaximumFlow","constructorQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> network","parameterName":"network"}],"literalExprs":[],"constructorTokenRange":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network)\n    {\n        this(network, DEFAULT_EPSILON);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n<tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n<tt>network<\/tt> is weighted, then capacities are weights, otherwise all\ncapacities are equal to one. Doubles are compared using <tt>\nDEFAULT_EPSILON<\/tt> tolerance.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"network, where maximum flow will be calculated","javadocBlockTagName":"network","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"tolerance for comparing doubles","javadocBlockTagName":"epsilon","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance for comparing doubles'}]}', name=Optional[epsilon]}"}],"constructorQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow(org.jgrapht.DirectedGraph<V, E>, double)","variableDeclarationExprs":[{"variableType":"E","variableName":"e","variableDeclarationExprId":1,"variableDeclarationExpr":"E e","variableDeclarationExprRange":"(line 125,col 14)-(line 125,col 16)","variableTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","variableRange":"(line 125,col 16)-(line 125,col 16)"}],"constructorRange":"(line 100,col 5)-(line 134,col 5)","constructorJavadocComment":"\n     * Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n     * <tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n     * <tt>network<\/tt> is weighted, then capacities are weights, otherwise all\n     * capacities are equal to one.\n     *\n     * @param network network, where maximum flow will be calculated\n     * @param epsilon tolerance for comparing doubles\n     ","constructorDeclaration":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network, double epsilon)","constructorBody":"{\n    this.vertexExtensionsFactory = new ExtensionFactory<VertexExtension>() {\n\n        @Override\n        public VertexExtension create() {\n            return EdmondsKarpMaximumFlow.this.new VertexExtension();\n        }\n    };\n    this.edgeExtensionsFactory = new ExtensionFactory<EdgeExtension>() {\n\n        @Override\n        public EdgeExtension create() {\n            return EdmondsKarpMaximumFlow.this.new EdgeExtension();\n        }\n    };\n    if (network == null) {\n        throw new NullPointerException(\"network is null\");\n    }\n    if (epsilon <= 0) {\n        throw new IllegalArgumentException(\"invalid epsilon (must be positive)\");\n    }\n    for (E e : network.edgeSet()) {\n        if (network.getEdgeWeight(e) < -epsilon) {\n            throw new IllegalArgumentException(\"invalid capacity (must be non-negative)\");\n        }\n    }\n    this.network = network;\n    this.epsilon = epsilon;\n}","constructorName":"EdmondsKarpMaximumFlow","constructorQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdmondsKarpMaximumFlow","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> network","parameterName":"network"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double epsilon","parameterName":"epsilon"}],"literalExprs":[{"literalExprRange":"(line 118,col 24)-(line 118,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 119,col 44)-(line 119,col 60)","literalExprId":2,"literalExpr":"\"network is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 121,col 24)-(line 121,col 24)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 17)-(line 123,col 52)","literalExprId":4,"literalExpr":"\"invalid epsilon (must be positive)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 128,col 21)-(line 128,col 61)","literalExprId":5,"literalExpr":"\"invalid capacity (must be non-negative)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public EdmondsKarpMaximumFlow(DirectedGraph<V, E> network, double epsilon)\n    {\n        this.vertexExtensionsFactory =\n            new ExtensionFactory<VertexExtension>() {\n                @Override public VertexExtension create()\n                {\n                    return EdmondsKarpMaximumFlow.this.new VertexExtension();\n                }\n            };\n\n        this.edgeExtensionsFactory =\n            new ExtensionFactory<EdgeExtension>() {\n                @Override public EdgeExtension create()\n                {\n                    return EdmondsKarpMaximumFlow.this.new EdgeExtension();\n                }\n            };\n\n        if (network == null) {\n            throw new NullPointerException(\"network is null\");\n        }\n        if (epsilon <= 0) {\n            throw new IllegalArgumentException(\n                \"invalid epsilon (must be positive)\");\n        }\n        for (E e : network.edgeSet()) {\n            if (network.getEdgeWeight(e) < -epsilon) {\n                throw new IllegalArgumentException(\n                    \"invalid capacity (must be non-negative)\");\n            }\n        }\n\n        this.network = network;\n        this.epsilon = epsilon;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs <tt>MaximumFlow<\/tt> instance to work with <i>a copy of<\/i>\n<tt>network<\/tt>. Current source and sink are set to <tt>null<\/tt>. If\n<tt>network<\/tt> is weighted, then capacities are weights, otherwise all\ncapacities are equal to one.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='network, where maximum flow will be calculated'}]}', name=Optional[network]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='tolerance for comparing doubles'}]}', name=Optional[epsilon]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 319,col 5)-(line 322,col 5)","classOrInterfaceTokenRange":"class EdgeExtension\n        extends EdgeExtensionBase\n    {\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 324,col 5)-(line 329,col 5)","classOrInterfaceTokenRange":"class VertexExtension\n        extends VertexExtensionBase\n    {\n        boolean visited; \/\/ this mark is used during BFS to mark visited nodes\n        List<EdgeExtension> lastArcs; \/\/ last arc(-s) in the shortest path\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source vertex","javadocBlockTagName":"source","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional[source]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"sink vertex","javadocBlockTagName":"sink","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='sink vertex'}]}', name=Optional[sink]}"}],"methodDeclaration":"public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    super.init(vertexExtensionsFactory, edgeExtensionsFactory);\n    if (!network.containsVertex(source)) {\n        throw new IllegalArgumentException(\"invalid source (null or not from this network)\");\n    }\n    if (!network.containsVertex(sink)) {\n        throw new IllegalArgumentException(\"invalid sink (null or not from this network)\");\n    }\n    if (source.equals(sink)) {\n        throw new IllegalArgumentException(\"source is equal to sink\");\n    }\n    currentSource = extendedVertex(source);\n    currentSink = extendedVertex(sink);\n    Map<E, Double> maxFlow;\n    double maxFlowValue;\n    for (; ; ) {\n        breadthFirstSearch();\n        if (!currentSink.visited) {\n            maxFlow = composeFlow();\n            maxFlowValue = 0.0;\n            for (E e : network.incomingEdgesOf(currentSink.prototype)) {\n                maxFlowValue += maxFlow.get(e);\n            }\n            break;\n        }\n        augmentFlow();\n    }\n    return new MaximumFlowImpl<V, E>(maxFlowValue, maxFlow);\n}","methodRange":"(line 145,col 5)-(line 185,col 5)","methodTokenRange":"public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)\n    {\n        super.init(vertexExtensionsFactory, edgeExtensionsFactory);\n\n        if (!network.containsVertex(source)) {\n            throw new IllegalArgumentException(\n                \"invalid source (null or not from this network)\");\n        }\n        if (!network.containsVertex(sink)) {\n            throw new IllegalArgumentException(\n                \"invalid sink (null or not from this network)\");\n        }\n\n        if (source.equals(sink)) {\n            throw new IllegalArgumentException(\"source is equal to sink\");\n        }\n\n        currentSource = extendedVertex(source);\n        currentSink = extendedVertex(sink);\n\n        Map<E, Double> maxFlow;\n\n        double maxFlowValue;\n\n        for (;;) {\n            breadthFirstSearch();\n\n            if (!currentSink.visited) {\n                maxFlow = composeFlow();\n                maxFlowValue = 0.0;\n                for (E e : network.incomingEdgesOf(currentSink.prototype)) {\n                    maxFlowValue += maxFlow.get(e);\n                }\n                break;\n            }\n\n            augmentFlow();\n        }\n\n        return new MaximumFlowImpl<V, E>(maxFlowValue, maxFlow);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"\n     * Sets current source to <tt>source<\/tt>, current sink to <tt>sink<\/tt>,\n     * then calculates maximum flow from <tt>source<\/tt> to <tt>sink<\/tt>. Note,\n     * that <tt>source<\/tt> and <tt>sink<\/tt> must be vertices of the <tt>\n     * network<\/tt> passed to the constructor, and they must be different.\n     *\n     * @param source source vertex\n     * @param sink sink vertex\n     ","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sink","parameterName":"sink"}],"methodName":"buildMaximumFlow","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.buildMaximumFlow","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets current source to <tt>source<\/tt>, current sink to <tt>sink<\/tt>,\nthen calculates maximum flow from <tt>source<\/tt> to <tt>sink<\/tt>. Note,\nthat <tt>source<\/tt> and <tt>sink<\/tt> must be vertices of the <tt>\nnetwork<\/tt> passed to the constructor, and they must be different.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source vertex'}]}', name=Optional[source]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='sink vertex'}]}', name=Optional[sink]}]}","methodReturnTypeDescribed":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow<V, E>","methodType":"MaximumFlow<V, E>","literalExprs":[{"literalExprRange":"(line 151,col 17)-(line 151,col 64)","literalExprId":1,"literalExpr":"\"invalid source (null or not from this network)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 155,col 17)-(line 155,col 62)","literalExprId":2,"literalExpr":"\"invalid sink (null or not from this network)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 159,col 48)-(line 159,col 72)","literalExprId":3,"literalExpr":"\"source is equal to sink\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 174,col 32)-(line 174,col 34)","literalExprId":4,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.buildMaximumFlow(V, V)"},{"methodDeclaration":"protected VertexExtension extendedVertex(V v)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this.vertexExtended(v);\n}","methodRange":"(line 187,col 5)-(line 190,col 5)","methodTokenRange":"protected VertexExtension extendedVertex(V v)\n    {\n        return this.vertexExtended(v);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"extendedVertex","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.extendedVertex","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension","methodType":"VertexExtension","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.extendedVertex(V)"},{"methodDeclaration":"protected EdgeExtension extendedEdge(E e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return this.edgeExtended(e);\n}","methodRange":"(line 192,col 5)-(line 195,col 5)","methodTokenRange":"protected EdgeExtension extendedEdge(E e)\n    {\n        return this.edgeExtended(e);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"extendedEdge","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.extendedEdge","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdgeExtension","methodType":"EdgeExtension","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.extendedEdge(E)"},{"methodDeclaration":"private void breadthFirstSearch()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (V v : network.vertexSet()) {\n        extendedVertex(v).visited = false;\n        extendedVertex(v).lastArcs = null;\n    }\n    Queue<VertexExtension> queue = new LinkedList<VertexExtension>();\n    queue.offer(currentSource);\n    currentSource.visited = true;\n    currentSource.excess = Double.POSITIVE_INFINITY;\n    currentSink.excess = 0.0;\n    boolean seenSink = false;\n    while (queue.size() != 0) {\n        VertexExtension ux = queue.poll();\n        for (EdgeExtension ex : ux.<EdgeExtension>getOutgoing()) {\n            if ((ex.flow + epsilon) < ex.capacity) {\n                VertexExtension vx = ex.getTarget();\n                if (vx == currentSink) {\n                    vx.visited = true;\n                    if (vx.lastArcs == null) {\n                        vx.lastArcs = new ArrayList<EdgeExtension>();\n                    }\n                    vx.lastArcs.add(ex);\n                    vx.excess += Math.min(ux.excess, ex.capacity - ex.flow);\n                    seenSink = true;\n                } else if (!vx.visited) {\n                    vx.visited = true;\n                    vx.excess = Math.min(ux.excess, ex.capacity - ex.flow);\n                    vx.lastArcs = Collections.singletonList(ex);\n                    if (!seenSink) {\n                        queue.add(vx);\n                    }\n                }\n            }\n        }\n    }\n}","methodRange":"(line 197,col 5)-(line 245,col 5)","methodTokenRange":"private void breadthFirstSearch()\n    {\n        for (V v : network.vertexSet()) {\n            extendedVertex(v).visited = false;\n            extendedVertex(v).lastArcs = null;\n        }\n\n        Queue<VertexExtension> queue = new LinkedList<VertexExtension>();\n        queue.offer(currentSource);\n\n        currentSource.visited = true;\n        currentSource.excess = Double.POSITIVE_INFINITY;\n\n        currentSink.excess = 0.0;\n\n        boolean seenSink = false;\n\n        while (queue.size() != 0) {\n            VertexExtension ux = queue.poll();\n\n            for (EdgeExtension ex : ux.<EdgeExtension>getOutgoing()) {\n                if ((ex.flow + epsilon) < ex.capacity) {\n                    VertexExtension vx = ex.getTarget();\n\n                    if (vx == currentSink) {\n                        vx.visited = true;\n\n                        if (vx.lastArcs == null) {\n                            vx.lastArcs = new ArrayList<EdgeExtension>();\n                        }\n\n                        vx.lastArcs.add(ex);\n                        vx.excess += Math.min(ux.excess, ex.capacity - ex.flow);\n\n                        seenSink = true;\n                    } else if (!vx.visited) {\n                        vx.visited = true;\n                        vx.excess = Math.min(ux.excess, ex.capacity - ex.flow);\n\n                        vx.lastArcs = Collections.singletonList(ex);\n\n                        if (!seenSink) {\n                            queue.add(vx);\n                        }\n                    }\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"breadthFirstSearch","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.breadthFirstSearch","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 200,col 41)-(line 200,col 45)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 201,col 42)-(line 201,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 207,col 33)-(line 207,col 36)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 210,col 30)-(line 210,col 32)","literalExprId":4,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 212,col 28)-(line 212,col 32)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 214,col 32)-(line 214,col 32)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 222,col 38)-(line 222,col 41)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 224,col 44)-(line 224,col 47)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 231,col 36)-(line 231,col 39)","literalExprId":9,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 233,col 38)-(line 233,col 41)","literalExprId":10,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.breadthFirstSearch()"},{"methodDeclaration":"private void augmentFlow()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<VertexExtension> seen = new HashSet<VertexExtension>();\n    for (EdgeExtension ex : currentSink.lastArcs) {\n        double deltaFlow = Math.min(ex.getSource().excess, ex.capacity - ex.flow);\n        if (augmentFlowAlongInternal(deltaFlow, ex.<VertexExtension>getSource(), seen)) {\n            pushFlowThrough(ex, deltaFlow);\n        }\n    }\n}","methodRange":"(line 247,col 5)-(line 263,col 5)","methodTokenRange":"private void augmentFlow()\n    {\n        Set<VertexExtension> seen = new HashSet<VertexExtension>();\n\n        for (EdgeExtension ex : currentSink.lastArcs) {\n            double deltaFlow =\n                Math.min(ex.getSource().excess, ex.capacity - ex.flow);\n\n            if (augmentFlowAlongInternal(\n                    deltaFlow,\n                    ex.<VertexExtension>getSource(),\n                    seen))\n            {\n                pushFlowThrough(ex, deltaFlow);\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"augmentFlow","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.augmentFlow","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.augmentFlow()"},{"methodDeclaration":"private boolean augmentFlowAlongInternal(double deltaFlow, VertexExtension node, Set<VertexExtension> seen)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (node == currentSource) {\n        return true;\n    }\n    if (seen.contains(node)) {\n        return false;\n    }\n    seen.add(node);\n    EdgeExtension prev = node.lastArcs.get(0);\n    if (augmentFlowAlongInternal(deltaFlow, prev.<VertexExtension>getSource(), seen)) {\n        pushFlowThrough(prev, deltaFlow);\n        return true;\n    }\n    return false;\n}","methodRange":"(line 265,col 5)-(line 290,col 5)","methodTokenRange":"private boolean augmentFlowAlongInternal(\n        double deltaFlow,\n        VertexExtension node,\n        Set<VertexExtension> seen)\n    {\n        if (node == currentSource) {\n            return true;\n        }\n        if (seen.contains(node)) {\n            return false;\n        }\n\n        seen.add(node);\n\n        EdgeExtension prev = node.lastArcs.get(0);\n        if (augmentFlowAlongInternal(\n                deltaFlow,\n                prev.<VertexExtension>getSource(),\n                seen))\n        {\n            pushFlowThrough(prev, deltaFlow);\n            return true;\n        }\n\n        return false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double deltaFlow","parameterName":"deltaFlow"},{"parameterType":"VertexExtension","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension","parameter":"VertexExtension node","parameterName":"node"},{"parameterType":"Set<VertexExtension>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Set<org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension>","parameter":"Set<VertexExtension> seen","parameterName":"seen"}],"methodName":"augmentFlowAlongInternal","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.augmentFlowAlongInternal","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 271,col 20)-(line 271,col 23)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 274,col 20)-(line 274,col 24)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 279,col 48)-(line 279,col 48)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 286,col 20)-(line 286,col 23)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 289,col 16)-(line 289,col 20)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.augmentFlowAlongInternal(double, org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, java.util.Set<org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"current source","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current source'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getCurrentSource()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (currentSource == null) ? null : currentSource.prototype;\n}","methodRange":"(line 298,col 5)-(line 301,col 5)","methodTokenRange":"public V getCurrentSource()\n    {\n        return (currentSource == null) ? null : currentSource.prototype;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns current source vertex, or <tt>null<\/tt> if there was no <tt>\n     * calculateMaximumFlow<\/tt> calls.\n     *\n     * @return current source\n     ","methodParameters":[],"methodName":"getCurrentSource","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.getCurrentSource","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns current source vertex, or <tt>null<\/tt> if there was no <tt>\ncalculateMaximumFlow<\/tt> calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current source'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 300,col 34)-(line 300,col 37)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 300,col 42)-(line 300,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.getCurrentSource()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"current sink","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current sink'}]}', name=Optional.empty}"}],"methodDeclaration":"public V getCurrentSink()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (currentSink == null) ? null : currentSink.prototype;\n}","methodRange":"(line 309,col 5)-(line 312,col 5)","methodTokenRange":"public V getCurrentSink()\n    {\n        return (currentSink == null) ? null : currentSink.prototype;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Returns current sink vertex, or <tt>null<\/tt> if there was no <tt>\n     * calculateMaximumFlow<\/tt> calls.\n     *\n     * @return current sink\n     ","methodParameters":[],"methodName":"getCurrentSink","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.getCurrentSink","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns current sink vertex, or <tt>null<\/tt> if there was no <tt>\ncalculateMaximumFlow<\/tt> calls.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current sink'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 311,col 32)-(line 311,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 311,col 40)-(line 311,col 43)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.getCurrentSink()"},{"methodDeclaration":" DirectedGraph<V, E> getNetwork()","methodAccessSpecifier":"NONE","methodBody":"{\n    return network;\n}","methodRange":"(line 314,col 5)-(line 317,col 5)","methodTokenRange":"@Override DirectedGraph<V, E> getNetwork()\n    {\n        return network;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getNetwork","methodQualifiedSignature":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.getNetwork","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.getNetwork()"}],"classJavadoc":"\/**\n * A <a href = \"http:\/\/en.wikipedia.org\/wiki\/Flow_network\">flow network<\/a> is a\n * directed graph where each edge has a capacity and each edge receives a flow.\n * The amount of flow on an edge can not exceed the capacity of the edge (note,\n * that all capacities must be non-negative). A flow must satisfy the\n * restriction that the amount of flow into a vertex equals the amount of flow\n * out of it, except when it is a source, which \"produces\" flow, or sink, which\n * \"consumes\" flow.\n *\n * <p>This class computes maximum flow in a network using <a href =\n * \"http:\/\/en.wikipedia.org\/wiki\/Edmonds-Karp_algorithm\">Edmonds-Karp\n * algorithm<\/a>. Be careful: for large networks this algorithm may consume\n * significant amount of time (its upper-bound complexity is O(VE^2), where V -\n * amount of vertices, E - amount of edges in the network).\n *\n * <p>For more details see Andrew V. Goldberg's <i>Combinatorial Optimization\n * (Lecture Notes)<\/i>.\n *\n * @author Ilya Razensteyn\n *\/\n","className":"EdmondsKarpMaximumFlow","fields":[{"fieldRange":"(line 67,col 5)-(line 67,col 40)","fieldName":"network","fieldJavadocComment":" our network","fieldTokenRange":"private DirectedGraph<V, E> network;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 69,col 5)-(line 69,col 27)","fieldName":"epsilon","fieldJavadocComment":" tolerance (DEFAULT_EPSILON or user-defined)","fieldTokenRange":"private double epsilon;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 71,col 5)-(line 71,col 42)","fieldName":"currentSource","fieldJavadocComment":" current source vertex","fieldTokenRange":"private VertexExtension currentSource;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"VertexExtension","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension"},{"fieldRange":"(line 72,col 5)-(line 72,col 40)","fieldName":"currentSink","fieldJavadocComment":" current sink vertex","fieldTokenRange":"private VertexExtension currentSink;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"VertexExtension","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension"},{"fieldRange":"(line 74,col 5)-(line 74,col 76)","fieldName":"vertexExtensionsFactory","fieldJavadocComment":"","fieldTokenRange":"private final ExtensionFactory<VertexExtension> vertexExtensionsFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ExtensionFactory<VertexExtension>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.VertexExtension>"},{"fieldRange":"(line 75,col 5)-(line 75,col 72)","fieldName":"edgeExtensionsFactory","fieldJavadocComment":"","fieldTokenRange":"private final ExtensionFactory<EdgeExtension> edgeExtensionsFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=ReferenceType{org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ExtensionFactory<EdgeExtension>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<org.jgrapht.alg.flow.EdmondsKarpMaximumFlow.EdgeExtension>"}]}],"sourceFileId":203,"packageName":"org.jgrapht.alg.flow"},{"sourceFileName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.util.*;\n"},{"importId":4,"import":"import org.jgrapht.alg.util.Extension.*;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"PushRelabelMaximumFlow","constructorQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.PushRelabelMaximumFlow","constructorQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.PushRelabelMaximumFlow(org.jgrapht.DirectedGraph<V, E>)","constructorParameters":[{"parameterType":"DirectedGraph<V, E>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> network","parameterName":"network"}],"literalExprs":[],"constructorTokenRange":"public PushRelabelMaximumFlow(DirectedGraph<V, E> network)\n    {\n        this.network = network;\n\n        this.vertexExtensionsFactory =\n            new ExtensionFactory<VertexExtension>() {\n                @Override public VertexExtension create()\n                {\n                    return PushRelabelMaximumFlow.this.new VertexExtension();\n                }\n            };\n\n        this.edgeExtensionsFactory =\n            new ExtensionFactory<EdgeExtension>() {\n                @Override public EdgeExtension create()\n                {\n                    return PushRelabelMaximumFlow.this.new EdgeExtension();\n                }\n            };\n\n        if (DIAGNOSTIC_ENABLED) {\n            this.diagnostic = new PushRelabelDiagnostic();\n        }\n    }","variableDeclarationExprs":[],"constructorRange":"(line 75,col 5)-(line 98,col 5)","constructorJavadocComment":"","constructorDeclaration":"public PushRelabelMaximumFlow(DirectedGraph<V, E> network)","constructorBody":"{\n    this.network = network;\n    this.vertexExtensionsFactory = new ExtensionFactory<VertexExtension>() {\n\n        @Override\n        public VertexExtension create() {\n            return PushRelabelMaximumFlow.this.new VertexExtension();\n        }\n    };\n    this.edgeExtensionsFactory = new ExtensionFactory<EdgeExtension>() {\n\n        @Override\n        public EdgeExtension create() {\n            return PushRelabelMaximumFlow.this.new EdgeExtension();\n        }\n    };\n    if (DIAGNOSTIC_ENABLED) {\n        this.diagnostic = new PushRelabelDiagnostic();\n    }\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 320,col 5)-(line 413,col 5)","classOrInterfaceTokenRange":"private class PushRelabelDiagnostic\n    {\n        \/\/ Discharges\n        Map<Pair<V, V>, Integer> discharges =\n            new HashMap<Pair<V, V>, Integer>();\n        long dischargesCounter = 0;\n\n        \/\/ Relabels\n        Map<Pair<Integer, Integer>, Integer> relabels =\n            new HashMap<Pair<Integer, Integer>, Integer>();\n        long relabelsCounter = 0;\n\n        private void incrementDischarges(EdgeExtension ex)\n        {\n            Pair<V, V> p =\n                Pair.of(ex.getSource().prototype, ex.getTarget().prototype);\n            if (!discharges.containsKey(p)) {\n                discharges.put(p, 0);\n            }\n            discharges.put(p, discharges.get(p) + 1);\n\n            dischargesCounter++;\n        }\n\n        private void incrementRelabels(int from, int to)\n        {\n            Pair<Integer, Integer> p = Pair.of(from, to);\n            if (!relabels.containsKey(p)) {\n                relabels.put(p, 0);\n            }\n            relabels.put(p, relabels.get(p) + 1);\n\n            relabelsCounter++;\n        }\n\n        void dump()\n        {\n            Map<Integer, Integer> labels = new HashMap<Integer, Integer>();\n\n            for (V v : network.vertexSet()) {\n                VertexExtension vx = extendedVertex(v);\n\n                if (!labels.containsKey(vx.label)) {\n                    labels.put(vx.label, 0);\n                }\n\n                labels.put(vx.label, labels.get(vx.label) + 1);\n            }\n\n            System.out.println(\"LABELS  \");\n            System.out.println(\"------  \");\n            System.out.println(labels);\n\n            List<Map.Entry<Pair<Integer, Integer>, Integer>> relabelsSorted =\n                new ArrayList<Map.Entry<Pair<Integer, Integer>, Integer>>(\n                    relabels.entrySet());\n\n            Collections.sort(\n                relabelsSorted,\n                new Comparator<Map.Entry<Pair<Integer, Integer>, Integer>>() {\n                    @Override public int compare(\n                        Map.Entry<Pair<Integer, Integer>, Integer> o1,\n                        Map.Entry<Pair<Integer, Integer>, Integer> o2)\n                    {\n                        return -(o1.getValue() - o2.getValue());\n                    }\n                });\n\n            System.out.println(\"RELABELS    \");\n            System.out.println(\"--------    \");\n            System.out.println(\"    Count:  \" + relabelsCounter);\n            System.out.println(\"            \" + relabelsSorted);\n\n            List<Map.Entry<Pair<V, V>, Integer>> dischargesSorted =\n                new ArrayList<Map.Entry<Pair<V, V>, Integer>>(\n                    discharges.entrySet());\n\n            Collections.sort(\n                dischargesSorted,\n                new Comparator<Map.Entry<Pair<V, V>, Integer>>() {\n                    @Override public int compare(\n                        Map.Entry<Pair<V, V>, Integer> one,\n                        Map.Entry<Pair<V, V>, Integer> other)\n                    {\n                        return -(one.getValue() - other.getValue());\n                    }\n                });\n\n            System.out.println(\"DISCHARGES  \");\n            System.out.println(\"----------  \");\n            System.out.println(\"    Count:  \" + dischargesCounter);\n            System.out.println(\"            \" + dischargesSorted);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 415,col 5)-(line 429,col 5)","classOrInterfaceTokenRange":"public class VertexExtension\n        extends VertexExtensionBase\n    {\n        private int label;\n\n        private boolean hasExcess()\n        {\n            return excess > 0;\n        }\n\n        @Override public String toString()\n        {\n            return prototype.toString() + String.format(\" { LBL: %d } \", label);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 431,col 5)-(line 444,col 5)","classOrInterfaceTokenRange":"public class EdgeExtension\n        extends EdgeExtensionBase\n    {\n        private boolean hasCapacity()\n        {\n            return compareFlowTo(capacity, flow) > 0;\n        }\n\n        @Override public String toString()\n        {\n            return prototype.toString()\n                + String.format(\" { F\/CAP: %f \/ %f } \", flow, capacity);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"methodDeclaration":" void init()","methodAccessSpecifier":"NONE","methodBody":"{\n    super.init(vertexExtensionsFactory, edgeExtensionsFactory);\n    this.labeling = new HashMap<Integer, Integer>();\n    this.flowBack = false;\n}","methodRange":"(line 100,col 5)-(line 106,col 5)","methodTokenRange":"void init()\n    {\n        super.init(vertexExtensionsFactory, edgeExtensionsFactory);\n\n        this.labeling = new HashMap<Integer, Integer>();\n        this.flowBack = false;\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"init","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.init","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 105,col 25)-(line 105,col 29)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.init()"},{"methodDeclaration":" DirectedGraph<V, E> getNetwork()","methodAccessSpecifier":"NONE","methodBody":"{\n    return network;\n}","methodRange":"(line 108,col 5)-(line 111,col 5)","methodTokenRange":"@Override DirectedGraph<V, E> getNetwork()\n    {\n        return network;\n    }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getNetwork","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.getNetwork","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.getNetwork()"},{"methodDeclaration":"public void initialize(VertexExtension source, VertexExtension sink, Queue<VertexExtension> active)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    source.label = network.vertexSet().size();\n    source.excess = Double.POSITIVE_INFINITY;\n    label(source, sink);\n    for (EdgeExtension ex : source.<EdgeExtension>getOutgoing()) {\n        pushFlowThrough(ex, ex.capacity);\n        if (ex.getTarget().prototype != sink.prototype) {\n            active.offer(ex.<VertexExtension>getTarget());\n        }\n    }\n}","methodRange":"(line 113,col 5)-(line 130,col 5)","methodTokenRange":"public void initialize(\n        VertexExtension source,\n        VertexExtension sink,\n        Queue<VertexExtension> active)\n    {\n        source.label = network.vertexSet().size();\n        source.excess = Double.POSITIVE_INFINITY;\n\n        label(source, sink);\n\n        for (EdgeExtension ex : source.<EdgeExtension>getOutgoing()) {\n            pushFlowThrough(ex, ex.capacity);\n\n            if (ex.getTarget().prototype != sink.prototype) {\n                active.offer(ex.<VertexExtension>getTarget());\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"VertexExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","parameter":"VertexExtension source","parameterName":"source"},{"parameterType":"VertexExtension","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","parameter":"VertexExtension sink","parameterName":"sink"},{"parameterType":"Queue<VertexExtension>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Queue, typeParametersMap=TypeParametersMap{nameToValue={java.util.Queue.E=ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Queue<org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension>","parameter":"Queue<VertexExtension> active","parameterName":"active"}],"methodName":"initialize","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.initialize","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.initialize(org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, java.util.Queue<org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension>)"},{"methodDeclaration":"private void label(VertexExtension source, VertexExtension sink)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Set<VertexExtension> seen = new HashSet<VertexExtension>();\n    Queue<VertexExtension> q = new ArrayDeque<VertexExtension>();\n    q.offer(sink);\n    sink.label = 0;\n    seen.add(sink);\n    seen.add(source);\n    while (!q.isEmpty()) {\n        VertexExtension ux = q.poll();\n        for (EdgeExtension ex : ux.<EdgeExtension>getOutgoing()) {\n            VertexExtension vx = ex.getTarget();\n            if (!seen.contains(vx)) {\n                seen.add(vx);\n                vx.label = ux.label + 1;\n                q.add(vx);\n                if (!labeling.containsKey(vx.label)) {\n                    labeling.put(vx.label, 1);\n                } else {\n                    labeling.put(vx.label, labeling.get(vx.label) + 1);\n                }\n            }\n        }\n    }\n    if (DIAGNOSTIC_ENABLED) {\n        System.out.println(\"INIT LABELING \" + labeling);\n    }\n}","methodRange":"(line 132,col 5)-(line 172,col 5)","methodTokenRange":"private void label(VertexExtension source, VertexExtension sink)\n    {\n        Set<VertexExtension> seen = new HashSet<VertexExtension>();\n        Queue<VertexExtension> q = new ArrayDeque<VertexExtension>();\n\n        q.offer(sink);\n\n        sink.label = 0;\n\n        seen.add(sink);\n        seen.add(source);\n\n        while (!q.isEmpty()) {\n            VertexExtension ux = q.poll();\n            for (EdgeExtension ex : ux.<EdgeExtension>getOutgoing()) {\n                VertexExtension vx = ex.getTarget();\n                if (!seen.contains(vx)) {\n                    seen.add(vx);\n\n                    vx.label = ux.label + 1;\n                    q.add(vx);\n\n                    \/\/ NOTA BENE:\n                    \/\/  This is part of label-pruning mechanic which\n                    \/\/  targets to diminish all 'useless' relabels during\n                    \/\/  \"flow-back\" phase of the algorithm pushing excess\n                    \/\/  flow back to the source\n\n                    if (!labeling.containsKey(vx.label)) {\n                        labeling.put(vx.label, 1);\n                    } else {\n                        labeling.put(vx.label, labeling.get(vx.label) + 1);\n                    }\n                }\n            }\n        }\n\n        if (DIAGNOSTIC_ENABLED) {\n            System.out.println(\"INIT LABELING \" + labeling);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"VertexExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","parameter":"VertexExtension source","parameterName":"source"},{"parameterType":"VertexExtension","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","parameter":"VertexExtension sink","parameterName":"sink"}],"methodName":"label","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.label","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 139,col 22)-(line 139,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 43)-(line 151,col 43)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 161,col 48)-(line 161,col 48)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 163,col 73)-(line 163,col 73)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 170,col 32)-(line 170,col 47)","literalExprId":5,"literalExpr":"\"INIT LABELING \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.label(org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension)"},{"methodDeclaration":"public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    init();\n    Queue<VertexExtension> active = new ArrayDeque<VertexExtension>();\n    initialize(extendedVertex(source), extendedVertex(sink), active);\n    while (!active.isEmpty()) {\n        VertexExtension ux = active.poll();\n        for (; ; ) {\n            for (EdgeExtension ex : ux.<EdgeExtension>getOutgoing()) {\n                if (isAdmissible(ex)) {\n                    if ((ex.getTarget().prototype != sink) && (ex.getTarget().prototype != source)) {\n                        active.offer(ex.<VertexExtension>getTarget());\n                    }\n                    if (discharge(ex)) {\n                        break;\n                    }\n                }\n            }\n            if (ux.hasExcess()) {\n                relabel(ux);\n            } else {\n                break;\n            }\n            if (!flowBack && !labeling.containsKey(0) && !labeling.containsKey(1)) {\n                extendedVertex(source).label = Collections.max(labeling.keySet()) + 1;\n                flowBack = true;\n            }\n        }\n    }\n    Map<E, Double> maxFlow = composeFlow();\n    double maxFlowValue = 0.0;\n    for (E e : network.incomingEdgesOf(sink)) {\n        maxFlowValue += maxFlow.get(e);\n    }\n    if (DIAGNOSTIC_ENABLED) {\n        diagnostic.dump();\n    }\n    return new MaximumFlowImpl<V, E>(maxFlowValue, maxFlow);\n}","methodRange":"(line 174,col 5)-(line 237,col 5)","methodTokenRange":"@Override public MaximumFlow<V, E> buildMaximumFlow(V source, V sink)\n    {\n        init();\n\n        Queue<VertexExtension> active = new ArrayDeque<VertexExtension>();\n\n        initialize(extendedVertex(source), extendedVertex(sink), active);\n\n        while (!active.isEmpty()) {\n            VertexExtension ux = active.poll();\n            for (;;) {\n                for (EdgeExtension ex : ux.<EdgeExtension>getOutgoing()) {\n                    if (isAdmissible(ex)) {\n                        if ((ex.getTarget().prototype != sink)\n                            && (ex.getTarget().prototype != source))\n                        {\n                            active.offer(ex.<VertexExtension>getTarget());\n                        }\n\n                        \/\/ Check whether we're rip off the excess\n                        if (discharge(ex)) {\n                            break;\n                        }\n                    }\n                }\n\n                if (ux.hasExcess()) {\n                    relabel(ux);\n                } else {\n                    break;\n                }\n\n                \/\/ Check whether we still have any vertices with the label '1'\n                if (!flowBack\n                    && !labeling.containsKey(0)\n                    && !labeling.containsKey(1))\n                {\n                    \/\/ This supposed to drastically improve performance cutting\n                    \/\/ off the necessity to drive labels of all vertices up to\n                    \/\/ value 'N' one-by-one not entailing eny effective\n                    \/\/ discharge -- at this point there is no vertex with the\n                    \/\/ label <= 1 in the network & therefore no\n                    \/\/ 'discharging-path' to the _sink_ also signalling that\n                    \/\/ we're in the flow-back stage of the algorithm\n                    extendedVertex(source).label =\n                        Collections.max(labeling.keySet()) + 1;\n                    flowBack = true;\n                }\n            }\n        }\n\n        Map<E, Double> maxFlow = composeFlow();\n\n        double maxFlowValue = 0.0;\n        for (E e : network.incomingEdgesOf(sink)) {\n            maxFlowValue += maxFlow.get(e);\n        }\n\n        if (DIAGNOSTIC_ENABLED) {\n            diagnostic.dump();\n        }\n\n        return new MaximumFlowImpl<V, E>(maxFlowValue, maxFlow);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V source","parameterName":"source"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V sink","parameterName":"sink"}],"methodName":"buildMaximumFlow","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.buildMaximumFlow","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.interfaces.MaximumFlowAlgorithm.MaximumFlow<V, E>","methodType":"MaximumFlow<V, E>","literalExprs":[{"literalExprRange":"(line 208,col 46)-(line 208,col 46)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 209,col 46)-(line 209,col 46)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 62)-(line 219,col 62)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 220,col 32)-(line 220,col 35)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 227,col 31)-(line 227,col 33)","literalExprId":5,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.buildMaximumFlow(V, V)"},{"methodDeclaration":"private void relabel(VertexExtension vx)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    assert (vx.hasExcess());\n    int min = Integer.MAX_VALUE;\n    for (EdgeExtension ex : vx.<EdgeExtension>getOutgoing()) {\n        if (ex.hasCapacity()) {\n            VertexExtension ux = ex.getTarget();\n            if (min > ux.label) {\n                min = ux.label;\n            }\n        }\n    }\n    if (DIAGNOSTIC_ENABLED) {\n        diagnostic.incrementRelabels(vx.label, min + 1);\n    }\n    assert (labeling.get(vx.label) > 0);\n    updateLabeling(vx, min + 1);\n    if (min != Integer.MAX_VALUE) {\n        vx.label = min + 1;\n    }\n}","methodRange":"(line 239,col 5)-(line 264,col 5)","methodTokenRange":"private void relabel(VertexExtension vx)\n    {\n        assert (vx.hasExcess());\n\n        int min = Integer.MAX_VALUE;\n        for (EdgeExtension ex : vx.<EdgeExtension>getOutgoing()) {\n            if (ex.hasCapacity()) {\n                VertexExtension ux = ex.getTarget();\n                if (min > ux.label) {\n                    min = ux.label;\n                }\n            }\n        }\n\n        if (DIAGNOSTIC_ENABLED) {\n            diagnostic.incrementRelabels(vx.label, min + 1);\n        }\n\n        assert (labeling.get(vx.label) > 0);\n        updateLabeling(vx, min + 1);\n\n        \/\/ Sanity\n        if (min != Integer.MAX_VALUE) {\n            vx.label = min + 1;\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"VertexExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","parameter":"VertexExtension vx","parameterName":"vx"}],"methodName":"relabel","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.relabel","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 254,col 58)-(line 254,col 58)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 257,col 42)-(line 257,col 42)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 258,col 34)-(line 258,col 34)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 262,col 30)-(line 262,col 30)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.relabel(org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension)"},{"methodDeclaration":"private void updateLabeling(VertexExtension vx, int l)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (labeling.get(vx.label) == 1) {\n        labeling.remove(vx.label);\n    } else {\n        labeling.put(vx.label, labeling.get(vx.label) - 1);\n    }\n    if (!labeling.containsKey(l)) {\n        labeling.put(l, 1);\n    } else {\n        labeling.put(l, labeling.get(l) + 1);\n    }\n}","methodRange":"(line 266,col 5)-(line 279,col 5)","methodTokenRange":"private void updateLabeling(VertexExtension vx, int l)\n    {\n        if (labeling.get(vx.label) == 1) {\n            labeling.remove(vx.label);\n        } else {\n            labeling.put(vx.label, labeling.get(vx.label) - 1);\n        }\n\n        if (!labeling.containsKey(l)) {\n            labeling.put(l, 1);\n        } else {\n            labeling.put(l, labeling.get(l) + 1);\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"VertexExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","parameter":"VertexExtension vx","parameterName":"vx"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int l","parameterName":"l"}],"methodName":"updateLabeling","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.updateLabeling","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 268,col 39)-(line 268,col 39)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 271,col 61)-(line 271,col 61)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 275,col 29)-(line 275,col 29)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 277,col 47)-(line 277,col 47)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.updateLabeling(org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, int)"},{"methodDeclaration":"private boolean discharge(EdgeExtension ex)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    VertexExtension ux = ex.getSource();\n    if (DIAGNOSTIC_ENABLED) {\n        diagnostic.incrementDischarges(ex);\n    }\n    pushFlowThrough(ex, Math.min(ux.excess, ex.capacity - ex.flow));\n    return !ux.hasExcess();\n}","methodRange":"(line 281,col 5)-(line 291,col 5)","methodTokenRange":"private boolean discharge(EdgeExtension ex)\n    {\n        VertexExtension ux = ex.getSource();\n\n        if (DIAGNOSTIC_ENABLED) {\n            diagnostic.incrementDischarges(ex);\n        }\n\n        pushFlowThrough(ex, Math.min(ux.excess, ex.capacity - ex.flow));\n        return !ux.hasExcess();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension","parameter":"EdgeExtension ex","parameterName":"ex"}],"methodName":"discharge","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.discharge","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.discharge(org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension)"},{"methodDeclaration":"protected void pushFlowThrough(EdgeExtension ex, double f)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    ex.getSource().excess -= f;\n    ex.getTarget().excess += f;\n    assert ((ex.getSource().excess >= 0.0) && (ex.getTarget().excess >= 0));\n    super.pushFlowThrough(ex, f);\n}","methodRange":"(line 293,col 5)-(line 301,col 5)","methodTokenRange":"protected void pushFlowThrough(EdgeExtension ex, double f)\n    {\n        ex.getSource().excess -= f;\n        ex.getTarget().excess += f;\n\n        assert ((ex.getSource().excess >= 0.0) && (ex.getTarget().excess >= 0));\n\n        super.pushFlowThrough(ex, f);\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension","parameter":"EdgeExtension ex","parameterName":"ex"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double f","parameterName":"f"}],"methodName":"pushFlowThrough","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.pushFlowThrough","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 298,col 43)-(line 298,col 45)","literalExprId":1,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 298,col 77)-(line 298,col 77)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.pushFlowThrough(org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension, double)"},{"methodDeclaration":"private boolean isAdmissible(EdgeExtension e)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return e.hasCapacity() && (e.<VertexExtension>getSource().label == (e.<VertexExtension>getTarget().label + 1));\n}","methodRange":"(line 303,col 5)-(line 308,col 5)","methodTokenRange":"private boolean isAdmissible(EdgeExtension e)\n    {\n        return e.hasCapacity()\n            && (e.<VertexExtension>getSource().label\n                == (e.<VertexExtension>getTarget().label + 1));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeExtension","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension","parameter":"EdgeExtension e","parameterName":"e"}],"methodName":"isAdmissible","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.isAdmissible","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 307,col 60)-(line 307,col 60)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.isAdmissible(org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension)"},{"methodDeclaration":"private EdgeExtension extendedEdge(E e)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return this.edgeExtended(e);\n}","methodRange":"(line 310,col 5)-(line 313,col 5)","methodTokenRange":"private EdgeExtension extendedEdge(E e)\n    {\n        return this.edgeExtended(e);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"extendedEdge","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.extendedEdge","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension","methodType":"EdgeExtension","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.extendedEdge(E)"},{"methodDeclaration":"private VertexExtension extendedVertex(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return this.vertexExtended(v);\n}","methodRange":"(line 315,col 5)-(line 318,col 5)","methodTokenRange":"private VertexExtension extendedVertex(V v)\n    {\n        return this.vertexExtended(v);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"extendedVertex","methodQualifiedSignature":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.extendedVertex","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension","methodType":"VertexExtension","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.extendedVertex(V)"}],"classJavadoc":"\/**\n * <p><a\n * href=\"https:\/\/en.wikipedia.org\/wiki\/Push%E2%80%93relabel_maximum_flow_algorithm\">\n * Push-relabel maximum flow<\/a> algorithm designed by Andrew V. Goldberg and\n * Robert Tarjan. Current implementation complexity upper-bound is O(V^3). For\n * more details see: <i>\"A new approach to the maximum flow problem\"<\/i> by\n * Andrew V. Goldberg and Robert Tarjan <i>STOC '86: Proceedings of the\n * eighteenth annual ACM symposium on Theory of computing<\/i><\/p>\n *\n * @author Alexey Kudinkin\n *\/\n","className":"PushRelabelMaximumFlow","fields":[{"fieldRange":"(line 60,col 5)-(line 60,col 60)","fieldName":"DIAGNOSTIC_ENABLED","fieldJavadocComment":"","fieldTokenRange":"private static final boolean DIAGNOSTIC_ENABLED = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 60,col 55)-(line 60,col 59)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 62,col 5)-(line 62,col 40)","fieldName":"network","fieldJavadocComment":"","fieldTokenRange":"private DirectedGraph<V, E> network;","fieldTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"DirectedGraph<V, E>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>"},{"fieldRange":"(line 64,col 5)-(line 64,col 76)","fieldName":"vertexExtensionsFactory","fieldJavadocComment":"","fieldTokenRange":"private final ExtensionFactory<VertexExtension> vertexExtensionsFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ExtensionFactory<VertexExtension>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<org.jgrapht.alg.flow.PushRelabelMaximumFlow.VertexExtension>"},{"fieldRange":"(line 65,col 5)-(line 65,col 72)","fieldName":"edgeExtensionsFactory","fieldJavadocComment":"","fieldTokenRange":"private final ExtensionFactory<EdgeExtension> edgeExtensionsFactory;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ExtensionFactory<EdgeExtension>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<org.jgrapht.alg.flow.PushRelabelMaximumFlow.EdgeExtension>"},{"fieldRange":"(line 69,col 5)-(line 69,col 43)","fieldName":"labeling","fieldJavadocComment":"","fieldTokenRange":"private Map<Integer, Integer> labeling;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<Integer, Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<java.lang.Integer, java.lang.Integer>"},{"fieldRange":"(line 71,col 5)-(line 71,col 21)","fieldName":"flowBack","fieldJavadocComment":"","fieldTokenRange":"boolean flowBack;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 73,col 5)-(line 73,col 45)","fieldName":"diagnostic","fieldJavadocComment":"","fieldTokenRange":"private PushRelabelDiagnostic diagnostic;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.flow.PushRelabelMaximumFlow.PushRelabelDiagnostic, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"PushRelabelDiagnostic","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.flow.PushRelabelMaximumFlow.PushRelabelDiagnostic"}]}],"sourceFileId":204,"packageName":"org.jgrapht.alg.flow"},{"sourceFileName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase","imports":[{"importId":1,"import":"import java.util.*;\n"},{"importId":2,"import":"import org.jgrapht.*;\n"},{"importId":3,"import":"import org.jgrapht.alg.interfaces.*;\n"},{"importId":4,"import":"import org.jgrapht.alg.util.*;\n"},{"importId":5,"import":"import org.jgrapht.alg.util.Extension.*;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[{"classOrInterfaceRange":"(line 207,col 5)-(line 221,col 5)","classOrInterfaceTokenRange":"class VertexExtensionBase\n        extends Extension.BaseExtension\n    {\n        private final List<? extends EdgeExtensionBase> outgoing =\n            new ArrayList<EdgeExtensionBase>();\n\n        V prototype;\n\n        double excess;\n\n        public <EE extends EdgeExtensionBase> List<EE> getOutgoing()\n        {\n            return (List<EE>) outgoing;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 223,col 5)-(line 265,col 5)","classOrInterfaceTokenRange":"class EdgeExtensionBase\n        extends Extension.BaseExtension\n    {\n        private VertexExtensionBase source;\n        private VertexExtensionBase target;\n\n        private EdgeExtensionBase inverse;\n\n        E prototype;\n\n        double capacity;\n        double flow;\n\n        public <VE extends VertexExtensionBase> VE getSource()\n        {\n            return (VE) source;\n        }\n\n        public void setSource(VertexExtensionBase source)\n        {\n            this.source = source;\n        }\n\n        public <VE extends VertexExtensionBase> VE getTarget()\n        {\n            return (VE) target;\n        }\n\n        public void setTarget(VertexExtensionBase target)\n        {\n            this.target = target;\n        }\n\n        public <EE extends EdgeExtensionBase> EE getInverse()\n        {\n            return (EE) inverse;\n        }\n\n        public void setInverse(EdgeExtensionBase inverse)\n        {\n            this.inverse = inverse;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"methodDeclaration":" abstract DirectedGraph<V, E> getNetwork()","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 67,col 5)-(line 67,col 46)","methodTokenRange":"abstract DirectedGraph<V, E> getNetwork();","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"getNetwork","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.getNetwork","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DirectedGraph<V, E>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.getNetwork()"},{"methodDeclaration":" void init(ExtensionFactory<VE> vertexExtensionFactory, ExtensionFactory<EE> edgeExtensionFactory)","methodAccessSpecifier":"NONE","methodBody":"{\n    vXs = new Extension<V, VE>(vertexExtensionFactory);\n    eXs = new Extension<E, EE>(edgeExtensionFactory);\n    buildInternal();\n}","methodRange":"(line 69,col 5)-(line 77,col 5)","methodTokenRange":"<VE extends VertexExtensionBase, EE extends EdgeExtensionBase> void init(\n        ExtensionFactory<VE> vertexExtensionFactory,\n        ExtensionFactory<EE> edgeExtensionFactory)\n    {\n        vXs = new Extension<V, VE>(vertexExtensionFactory);\n        eXs = new Extension<E, EE>(edgeExtensionFactory);\n\n        buildInternal();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"ExtensionFactory<VE>","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=TypeVariable {JPTypeParameter(VE, bounds=[VertexExtensionBase])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<VE>","parameter":"ExtensionFactory<VE> vertexExtensionFactory","parameterName":"vertexExtensionFactory"},{"parameterType":"ExtensionFactory<EE>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension.ExtensionFactory, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.ExtensionFactory.E=TypeVariable {JPTypeParameter(EE, bounds=[EdgeExtensionBase])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.util.Extension.ExtensionFactory<EE>","parameter":"ExtensionFactory<EE> edgeExtensionFactory","parameterName":"edgeExtensionFactory"}],"methodName":"init","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.init","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.init(org.jgrapht.alg.util.Extension.ExtensionFactory<VE>, org.jgrapht.alg.util.Extension.ExtensionFactory<EE>)"},{"methodDeclaration":"private void buildInternal()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    DirectedGraph<V, E> n = getNetwork();\n    for (V u : n.vertexSet()) {\n        VertexExtensionBase ux = extendedVertex(u);\n        ux.prototype = u;\n        for (E e : n.outgoingEdgesOf(u)) {\n            V v = n.getEdgeTarget(e);\n            VertexExtensionBase vx = extendedVertex(v);\n            EdgeExtensionBase ex = createEdge(ux, vx, e, n.getEdgeWeight(e));\n            EdgeExtensionBase iex = createInverse(ex, n);\n            ux.getOutgoing().add(ex);\n            if (iex.prototype == null) {\n                vx.getOutgoing().add(iex);\n            }\n        }\n    }\n}","methodRange":"(line 79,col 5)-(line 105,col 5)","methodTokenRange":"private void buildInternal()\n    {\n        DirectedGraph<V, E> n = getNetwork();\n\n        for (V u : n.vertexSet()) {\n            VertexExtensionBase ux = extendedVertex(u);\n\n            ux.prototype = u;\n\n            for (E e : n.outgoingEdgesOf(u)) {\n                V v = n.getEdgeTarget(e);\n\n                VertexExtensionBase vx = extendedVertex(v);\n\n                EdgeExtensionBase ex =\n                    createEdge(ux, vx, e, n.getEdgeWeight(e));\n                EdgeExtensionBase iex = createInverse(ex, n);\n\n                ux.getOutgoing().add(ex);\n\n                \/\/ NB: Any better?\n                if (iex.prototype == null) {\n                    vx.getOutgoing().add(iex);\n                }\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"buildInternal","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.buildInternal","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 100,col 38)-(line 100,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.buildInternal()"},{"methodDeclaration":"private EdgeExtensionBase createEdge(VertexExtensionBase source, VertexExtensionBase target, E e, double weight)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    EdgeExtensionBase ex = extendedEdge(e);\n    ex.source = source;\n    ex.target = target;\n    ex.capacity = weight;\n    ex.prototype = e;\n    return ex;\n}","methodRange":"(line 107,col 5)-(line 121,col 5)","methodTokenRange":"private EdgeExtensionBase createEdge(\n        VertexExtensionBase source,\n        VertexExtensionBase target,\n        E e,\n        double weight)\n    {\n        EdgeExtensionBase ex = extendedEdge(e);\n\n        ex.source = source;\n        ex.target = target;\n        ex.capacity = weight;\n        ex.prototype = e;\n\n        return ex;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"VertexExtensionBase","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase","parameter":"VertexExtensionBase source","parameterName":"source"},{"parameterType":"VertexExtensionBase","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase","parameter":"VertexExtensionBase target","parameterName":"target"},{"parameterType":"E","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"},{"parameterType":"double","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double weight","parameterName":"weight"}],"methodName":"createEdge","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.createEdge","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase","methodType":"EdgeExtensionBase","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.createEdge(org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase, org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase, E, double)"},{"methodDeclaration":"private EdgeExtensionBase createInverse(EdgeExtensionBase ex, DirectedGraph<V, E> n)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    EdgeExtensionBase iex;\n    if (n.containsEdge(ex.target.prototype, ex.source.prototype)) {\n        E ie = n.getEdge(ex.target.prototype, ex.source.prototype);\n        iex = createEdge(ex.target, ex.source, ie, n.getEdgeWeight(ie));\n    } else {\n        iex = eXs.createInstance();\n        iex.source = ex.target;\n        iex.target = ex.source;\n    }\n    ex.inverse = iex;\n    iex.inverse = ex;\n    return iex;\n}","methodRange":"(line 123,col 5)-(line 143,col 5)","methodTokenRange":"private EdgeExtensionBase createInverse(\n        EdgeExtensionBase ex,\n        DirectedGraph<V, E> n)\n    {\n        EdgeExtensionBase iex;\n\n        if (n.containsEdge(ex.target.prototype, ex.source.prototype)) {\n            E ie = n.getEdge(ex.target.prototype, ex.source.prototype);\n            iex = createEdge(ex.target, ex.source, ie, n.getEdgeWeight(ie));\n        } else {\n            iex = eXs.createInstance();\n\n            iex.source = ex.target;\n            iex.target = ex.source;\n        }\n\n        ex.inverse = iex;\n        iex.inverse = ex;\n\n        return iex;\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeExtensionBase","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase","parameter":"EdgeExtensionBase ex","parameterName":"ex"},{"parameterType":"DirectedGraph<V, E>","parameterId":2,"parameterTypeResolved":"ReferenceType{org.jgrapht.DirectedGraph, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.DirectedGraph.V=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.DirectedGraph.E=TypeVariable {JPTypeParameter(E, bounds=[])}}}}","parameterTypeResolvedDescribed":"org.jgrapht.DirectedGraph<V, E>","parameter":"DirectedGraph<V, E> n","parameterName":"n"}],"methodName":"createInverse","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.createInverse","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase","methodType":"EdgeExtensionBase","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.createInverse(org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, org.jgrapht.DirectedGraph<V, E>)"},{"methodDeclaration":"private VertexExtensionBase extendedVertex(V v)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return this.<VertexExtensionBase>vertexExtended(v);\n}","methodRange":"(line 145,col 5)-(line 148,col 5)","methodTokenRange":"private VertexExtensionBase extendedVertex(V v)\n    {\n        return this.<VertexExtensionBase>vertexExtended(v);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"extendedVertex","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.extendedVertex","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase","methodType":"VertexExtensionBase","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.extendedVertex(V)"},{"methodDeclaration":"private EdgeExtensionBase extendedEdge(E e)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return this.<EdgeExtensionBase>edgeExtended(e);\n}","methodRange":"(line 150,col 5)-(line 153,col 5)","methodTokenRange":"private EdgeExtensionBase extendedEdge(E e)\n    {\n        return this.<EdgeExtensionBase>edgeExtended(e);\n    }","methodReturnTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"extendedEdge","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.extendedEdge","methodJavadoc":"","methodReturnTypeDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase","methodType":"EdgeExtensionBase","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.extendedEdge(E)"},{"methodDeclaration":"protected VE vertexExtended(V v)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return (VE) vXs.get(v);\n}","methodRange":"(line 155,col 5)-(line 158,col 5)","methodTokenRange":"protected <VE extends VertexExtensionBase> VE vertexExtended(V v)\n    {\n        return (VE) vXs.get(v);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(VE, bounds=[VertexExtensionBase])}","methodJavadocComment":"","methodParameters":[{"parameterType":"V","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V v","parameterName":"v"}],"methodName":"vertexExtended","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.vertexExtended","methodJavadoc":"","methodReturnTypeDescribed":"VE","methodType":"VE","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.vertexExtended(V)"},{"methodDeclaration":"protected EE edgeExtended(E e)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    return (EE) eXs.get(e);\n}","methodRange":"(line 160,col 5)-(line 163,col 5)","methodTokenRange":"protected <EE extends EdgeExtensionBase> EE edgeExtended(E e)\n    {\n        return (EE) eXs.get(e);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(EE, bounds=[EdgeExtensionBase])}","methodJavadocComment":"","methodParameters":[{"parameterType":"E","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(E, bounds=[])}","parameterTypeResolvedDescribed":"E","parameter":"E e","parameterName":"e"}],"methodName":"edgeExtended","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.edgeExtended","methodJavadoc":"","methodReturnTypeDescribed":"EE","methodType":"EE","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.edgeExtended(E)"},{"methodDeclaration":"protected void pushFlowThrough(EdgeExtensionBase ex, double f)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    EdgeExtensionBase iex = ex.<EdgeExtensionBase>getInverse();\n    assert ((compareFlowTo(ex.flow, 0.0) == 0) || (compareFlowTo(iex.flow, 0.0) == 0));\n    if (compareFlowTo(iex.flow, f) == -1) {\n        double d = f - iex.flow;\n        ex.flow += d;\n        ex.capacity -= iex.flow;\n        iex.flow = 0;\n        iex.capacity += d;\n    } else {\n        ex.capacity -= f;\n        iex.flow -= f;\n    }\n}","methodRange":"(line 165,col 5)-(line 184,col 5)","methodTokenRange":"protected void pushFlowThrough(EdgeExtensionBase ex, double f)\n    {\n        EdgeExtensionBase iex = ex.<EdgeExtensionBase>getInverse();\n\n        assert ((compareFlowTo(ex.flow, 0.0) == 0)\n            || (compareFlowTo(iex.flow, 0.0) == 0));\n\n        if (compareFlowTo(iex.flow, f) == -1) {\n            double d = f - iex.flow;\n\n            ex.flow += d;\n            ex.capacity -= iex.flow;\n\n            iex.flow = 0;\n            iex.capacity += d;\n        } else {\n            ex.capacity -= f;\n            iex.flow -= f;\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"EdgeExtensionBase","parameterId":1,"parameterTypeResolved":"ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase","parameter":"EdgeExtensionBase ex","parameterName":"ex"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double f","parameterName":"f"}],"methodName":"pushFlowThrough","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.pushFlowThrough","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 169,col 41)-(line 169,col 43)","literalExprId":1,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 169,col 49)-(line 169,col 49)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 170,col 41)-(line 170,col 43)","literalExprId":3,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 170,col 49)-(line 170,col 49)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 172,col 44)-(line 172,col 44)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 178,col 24)-(line 178,col 24)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.pushFlowThrough(org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, double)"},{"methodDeclaration":"protected Map<E, Double> composeFlow()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    Map<E, Double> maxFlow = new HashMap<E, Double>();\n    for (E e : getNetwork().edgeSet()) {\n        EdgeExtensionBase ex = extendedEdge(e);\n        maxFlow.put(e, ex.flow);\n    }\n    return maxFlow;\n}","methodRange":"(line 186,col 5)-(line 195,col 5)","methodTokenRange":"protected Map<E, Double> composeFlow()\n    {\n        Map<E, Double> maxFlow = new HashMap<E, Double>();\n        for (E e : getNetwork().edgeSet()) {\n            EdgeExtensionBase ex = extendedEdge(e);\n            maxFlow.put(e, ex.flow);\n        }\n\n        return maxFlow;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(E, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"composeFlow","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.composeFlow","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Map<E, java.lang.Double>","methodType":"Map<E, Double>","literalExprs":[],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.composeFlow()"},{"methodDeclaration":"protected int compareFlowTo(double flow, double val)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    double diff = flow - val;\n    if (Math.abs(diff) < DEFAULT_EPSILON) {\n        return 0;\n    } else {\n        return (diff < 0) ? -1 : 1;\n    }\n}","methodRange":"(line 197,col 5)-(line 205,col 5)","methodTokenRange":"protected int compareFlowTo(double flow, double val)\n    {\n        double diff = flow - val;\n        if (Math.abs(diff) < DEFAULT_EPSILON) {\n            return 0;\n        } else {\n            return (diff < 0) ? -1 : 1;\n        }\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double flow","parameterName":"flow"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double val","parameterName":"val"}],"methodName":"compareFlowTo","methodQualifiedSignature":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.compareFlowTo","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 201,col 20)-(line 201,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 203,col 28)-(line 203,col 28)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 203,col 34)-(line 203,col 34)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 203,col 38)-(line 203,col 38)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.compareFlowTo(double, double)"}],"classJavadoc":"\/**\n * Base class backing algorithms allowing to derive <a\n * href=\"https:\/\/en.wikipedia.org\/wiki\/Maximum_flow_problem\">maximum-flow<\/a>\n * from the supplied <a href=\"https:\/\/en.wikipedia.org\/wiki\/Flow_network\">flow\n * network<\/a>\n *\n * @param <V> vertex concept type\n * @param <E> edge concept type\n *\n * @author Alexey Kudinkin\n *\/\n","className":"MaximumFlowAlgorithmBase","fields":[{"fieldRange":"(line 62,col 5)-(line 62,col 54)","fieldName":"DEFAULT_EPSILON","fieldJavadocComment":"\n     * Default tolerance.\n     ","fieldTokenRange":"public static final double DEFAULT_EPSILON = 1e-9;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 62,col 50)-(line 62,col 53)","literalExprId":1,"literalExpr":"1e-9","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[1e-9]","fieldType":"double","fieldJavadoc":"Default tolerance.\n","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 64,col 5)-(line 64,col 60)","fieldName":"vXs","fieldJavadocComment":"","fieldTokenRange":"private Extension<V, ? extends VertexExtensionBase> vXs;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.T=TypeVariable {JPTypeParameter(V, bounds=[])}, org.jgrapht.alg.util.Extension.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Extension<V, ? extends VertexExtensionBase>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension<V, ? extends org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.VertexExtensionBase>"},{"fieldRange":"(line 65,col 5)-(line 65,col 58)","fieldName":"eXs","fieldJavadocComment":"","fieldTokenRange":"private Extension<E, ? extends EdgeExtensionBase> eXs;","fieldTypeResolved":"ReferenceType{org.jgrapht.alg.util.Extension, typeParametersMap=TypeParametersMap{nameToValue={org.jgrapht.alg.util.Extension.T=TypeVariable {JPTypeParameter(E, bounds=[])}, org.jgrapht.alg.util.Extension.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Extension<E, ? extends EdgeExtensionBase>","fieldJavadoc":"","fieldTypeResolvedDescribed":"org.jgrapht.alg.util.Extension<E, ? extends org.jgrapht.alg.flow.MaximumFlowAlgorithmBase.EdgeExtensionBase>"}]}],"sourceFileId":205,"packageName":"org.jgrapht.alg.flow"}]