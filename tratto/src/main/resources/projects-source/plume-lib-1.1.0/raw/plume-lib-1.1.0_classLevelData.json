[{"sourceFileName":"plume.FileIOException","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.IOException;\n"},{"importId":3,"import":"import java.io.LineNumberReader;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException()","variableDeclarationExprs":[],"constructorRange":"(line 38,col 3)-(line 42,col 3)","constructorJavadocComment":" Create a dummy FileIOException. ","constructorDeclaration":"public FileIOException()","constructorBody":"{\n    super();\n    fileName = null;\n    lineNumber = -1;\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 40,col 16)-(line 40,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 41,col 19)-(line 41,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FileIOException() {\n    super();\n    fileName = null;\n    lineNumber = -1;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a dummy FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 51,col 3)-(line 57,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(Throwable cause)","constructorBody":"{\n    initCause(cause);\n    fileName = null;\n    lineNumber = -1;\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"Throwable","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[{"literalExprRange":"(line 55,col 16)-(line 55,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 56,col 19)-(line 56,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ Throwable cause) {\n    \/\/ The \"super(Throwable)\" constructor exists in Java 6 and later.\n    \/\/ For backward compatibility, use the initCause method instead.\n    initCause(cause);\n    fileName = null;\n    lineNumber = -1;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 64,col 3)-(line 68,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s)","constructorBody":"{\n    super(s);\n    fileName = null;\n    lineNumber = -1;\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"literalExprs":[{"literalExprRange":"(line 66,col 16)-(line 66,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 67,col 19)-(line 67,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ String s) {\n    super(s);\n    fileName = null;\n    lineNumber = -1;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 71,col 3)-(line 78,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, Throwable cause)","constructorBody":"{\n    super(s);\n    initCause(cause);\n    fileName = null;\n    lineNumber = -1;\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"Throwable","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[{"literalExprRange":"(line 76,col 16)-(line 76,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 77,col 19)-(line 77,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ String s, \/*@Nullable*\/ Throwable cause) {\n    \/\/ The \"super(String, Throwable) constructor exists in Java 6 and later.\n    \/\/ For backward compatibility, use the initCause method instead.\n    super(s);\n    initCause(cause);\n    fileName = null;\n    lineNumber = -1;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.lang.String, int)","variableDeclarationExprs":[],"constructorRange":"(line 84,col 3)-(line 88,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, String fileName, int lineNumber)","constructorBody":"{\n    super(s);\n    this.fileName = fileName;\n    this.lineNumber = lineNumber;\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fileName","parameterName":"fileName"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int lineNumber","parameterName":"lineNumber"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ String s, \/*@Nullable*\/ String fileName, int lineNumber) {\n    super(s);\n    this.fileName = fileName;\n    this.lineNumber = lineNumber;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.lang.Throwable, java.lang.String, int)","variableDeclarationExprs":[],"constructorRange":"(line 91,col 3)-(line 102,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, Throwable cause, String fileName, int lineNumber)","constructorBody":"{\n    super(s);\n    initCause(cause);\n    this.fileName = fileName;\n    this.lineNumber = lineNumber;\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"Throwable","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fileName","parameterName":"fileName"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int lineNumber","parameterName":"lineNumber"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ String s,\n      \/*@Nullable*\/ Throwable cause,\n      \/*@Nullable*\/ String fileName,\n      int lineNumber) {\n    \/\/ The \"super(String, Throwable) constructor exists in Java 6 and later.\n    \/\/ For backward compatibility, use the initCause method instead.\n    super(s);\n    initCause(cause);\n    this.fileName = fileName;\n    this.lineNumber = lineNumber;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.io.LineNumberReader, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 112,col 3)-(line 114,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(LineNumberReader reader, Throwable cause)","constructorBody":"{\n    this(reader, (String) null, cause);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"LineNumberReader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"Throwable","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[{"literalExprRange":"(line 113,col 55)-(line 113,col 58)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ LineNumberReader reader, \/*@Nullable*\/ Throwable cause) {\n    this(reader, \/*fileName=*\/ (\/*@Nullable*\/ String) null, cause);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.io.LineNumberReader)","variableDeclarationExprs":[],"constructorRange":"(line 117,col 3)-(line 119,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, LineNumberReader reader)","constructorBody":"{\n    this(s, reader, (String) null);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"LineNumberReader","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"}],"literalExprs":[{"literalExprRange":"(line 118,col 58)-(line 118,col 61)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ String s, \/*@Nullable*\/ LineNumberReader reader) {\n    this(s, reader, \/*fileName=*\/ (\/*@Nullable*\/ String) null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.io.LineNumberReader, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 122,col 3)-(line 127,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, LineNumberReader reader, Throwable cause)","constructorBody":"{\n    this(s, reader, (String) null, cause);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"LineNumberReader","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"Throwable","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[{"literalExprRange":"(line 126,col 58)-(line 126,col 61)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ String s,\n      \/*@Nullable*\/ LineNumberReader reader,\n      \/*@Nullable*\/ Throwable cause) {\n    this(s, reader, \/*fileName=*\/ (\/*@Nullable*\/ String) null, cause);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.io.LineNumberReader, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 134,col 3)-(line 141,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, LineNumberReader reader, String fileName)","constructorBody":"{\n    super(s);\n    this.fileName = fileName;\n    this.lineNumber = getLineNumber(reader);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"LineNumberReader","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fileName","parameterName":"fileName"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ String s,\n      \/*@Nullable*\/ LineNumberReader reader,\n      \/*@Nullable*\/ String fileName) {\n    super(s);\n    this.fileName = fileName;\n    this.lineNumber = getLineNumber(reader);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.io.LineNumberReader, java.lang.String, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 144,col 3)-(line 153,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(LineNumberReader reader, String fileName, Throwable cause)","constructorBody":"{\n    initCause(cause);\n    this.fileName = fileName;\n    this.lineNumber = getLineNumber(reader);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"LineNumberReader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fileName","parameterName":"fileName"},{"parameterType":"Throwable","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ LineNumberReader reader,\n      \/*@Nullable*\/ String fileName,\n      \/*@Nullable*\/ Throwable cause) {\n    \/\/ The \"super(Throwable) constructor exists in Java 6 and later.\n    \/\/ For backward compatibility, use the initCause method instead.\n    initCause(cause);\n    this.fileName = fileName;\n    this.lineNumber = getLineNumber(reader);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.io.LineNumberReader, java.lang.String, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 156,col 3)-(line 167,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, LineNumberReader reader, String fileName, Throwable cause)","constructorBody":"{\n    super(s);\n    initCause(cause);\n    this.fileName = fileName;\n    this.lineNumber = getLineNumber(reader);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"LineNumberReader","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fileName","parameterName":"fileName"},{"parameterType":"Throwable","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ String s,\n      \/*@Nullable*\/ LineNumberReader reader,\n      \/*@Nullable*\/ String fileName,\n      \/*@Nullable*\/ Throwable cause) {\n    \/\/ The \"super(String, Throwable) constructor exists in Java 6 and later.\n    \/\/ For backward compatibility, use the initCause method instead.\n    super(s);\n    initCause(cause);\n    this.fileName = fileName;\n    this.lineNumber = getLineNumber(reader);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.io.LineNumberReader, java.io.File)","variableDeclarationExprs":[],"constructorRange":"(line 174,col 3)-(line 176,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, LineNumberReader reader, File file)","constructorBody":"{\n    this(s, reader, file.getName());\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"LineNumberReader","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"File","parameterId":3,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\/*@Nullable*\/ String s, \/*@Nullable*\/ LineNumberReader reader, File file) {\n    this(s, reader, file.getName());\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.lang.String, java.io.LineNumberReader, java.io.File, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 179,col 3)-(line 185,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(String s, LineNumberReader reader, File file, Throwable cause)","constructorBody":"{\n    this(s, reader, file.getName(), cause);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"LineNumberReader","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"File","parameterId":3,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"Throwable","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ String s,\n      \/*@Nullable*\/ LineNumberReader reader,\n      File file,\n      \/*@Nullable*\/ Throwable cause) {\n    this(s, reader, file.getName(), cause);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FileIOException.FileIOException(java.io.LineNumberReader, java.io.File, java.lang.Throwable)","variableDeclarationExprs":[],"constructorRange":"(line 188,col 3)-(line 195,col 3)","constructorJavadocComment":" Create a FileIOException. ","constructorDeclaration":"public FileIOException(LineNumberReader reader, File file, Throwable cause)","constructorBody":"{\n    initCause(cause);\n    this.fileName = file.getName();\n    this.lineNumber = getLineNumber(reader);\n}","constructorName":"FileIOException","constructorQualifiedName":"plume.FileIOException.FileIOException","constructorParameters":[{"parameterType":"LineNumberReader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"Throwable","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable cause","parameterName":"cause"}],"literalExprs":[],"constructorTokenRange":"public FileIOException(\n      \/*@Nullable*\/ LineNumberReader reader, File file, \/*@Nullable*\/ Throwable cause) {\n    \/\/ The \"super(Throwable) constructor exists in Java 6 and later.\n    \/\/ For backward compatibility, use the initCause method instead.\n    initCause(cause);\n    this.fileName = file.getName();\n    this.lineNumber = getLineNumber(reader);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a FileIOException.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String result = super.toString();\n    if (fileName != null) {\n        result += \" in file \" + fileName;\n    }\n    if (lineNumber != -1) {\n        result += \" at line \" + lineNumber;\n    }\n    return result;\n}","methodRange":"(line 202,col 3)-(line 211,col 3)","methodTokenRange":"public String toString(\/*>>>@GuardSatisfied FileIOException this*\/) {\n    String result = super.toString();\n    if (fileName != null) {\n      result += \" in file \" + fileName;\n    }\n    if (lineNumber != -1) {\n      result += \" at line \" + lineNumber;\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.FileIOException.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 204,col 21)-(line 204,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 205,col 17)-(line 205,col 27)","literalExprId":2,"literalExpr":"\" in file \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 207,col 24)-(line 207,col 24)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 208,col 17)-(line 208,col 27)","literalExprId":4,"literalExpr":"\" at line \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.FileIOException.toString()"},{"methodDeclaration":"private static int getLineNumber(LineNumberReader reader)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (reader != null) {\n        return reader.getLineNumber();\n    } else {\n        return -1;\n    }\n}","methodRange":"(line 217,col 3)-(line 223,col 3)","methodTokenRange":"private static int getLineNumber(\/*@Nullable*\/ LineNumberReader reader) {\n    if (reader != null) {\n      return reader.getLineNumber();\n    } else {\n      return -1;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" still clearer to abstract out.","methodParameters":[{"parameterType":"LineNumberReader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.LineNumberReader","parameter":"LineNumberReader reader","parameterName":"reader"}],"methodName":"getLineNumber","methodQualifiedSignature":"plume.FileIOException.getLineNumber","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 218,col 19)-(line 218,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 221,col 15)-(line 221,col 15)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.FileIOException.getLineNumber(java.io.LineNumberReader)"}],"classJavadoc":"\/**\n * This class extends IOException by also reporting a file name and line\n * number at which the exception occurred.  It requires use of a\n * {@link LineNumberReader}.\n *\/\n","className":"FileIOException","fields":[{"fieldRange":"(line 26,col 3)-(line 26,col 49)","fieldName":"serialVersionUID","fieldJavadocComment":"","fieldTokenRange":"static final long serialVersionUID = 20050923L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 26,col 40)-(line 26,col 48)","literalExprId":1,"literalExpr":"20050923L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[20050923L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 29,col 3)-(line 29,col 45)","fieldName":"fileName","fieldJavadocComment":" The file being read when the IOException ocurred. ","fieldTokenRange":"public final \/*@Nullable*\/ String fileName;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"String","fieldJavadoc":"The file being read when the IOException ocurred.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 31,col 3)-(line 31,col 30)","fieldName":"lineNumber","fieldJavadocComment":" The line being read when the IOException ocurred. ","fieldTokenRange":"public final int lineNumber;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The line being read when the IOException ocurred.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":1,"packageName":"plume"},{"sourceFileName":"plume.MathMDE","imports":[{"importId":1,"import":"import java.util.Arrays;\n"},{"importId":2,"import":"import java.util.Iterator;\n"},{"importId":3,"import":"import java.util.NoSuchElementException;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.MathMDE.MathMDE()","variableDeclarationExprs":[],"constructorRange":"(line 17,col 3)-(line 19,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private MathMDE()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"MathMDE","constructorQualifiedName":"plume.MathMDE.MathMDE","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 18,col 21)-(line 18,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private MathMDE() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 1063,col 3)-(line 1170,col 3)","classOrInterfaceTokenRange":"static final class MissingNumbersIteratorInt implements Iterator<Integer> {\n    \/\/ Exactly one of nums and nums_itor is non-null.\n    int \/*@MonotonicNonNull*\/ [] nums;\n    \/*@MonotonicNonNull*\/ Iterator<Integer> nums_itor;\n    int current_nonmissing;\n    int current_missing;\n    \/\/ Used only if nums != null.\n    int current_index;\n    boolean add_ends;\n\n    \/**\n     * An iterator over all the numbers <b>not<\/b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     *\/\n    MissingNumbersIteratorInt(int[] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { \/\/ avoid modifying parameter\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums = nums;\n    }\n\n    \/\/ The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorInt(Iterator<Integer> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().intValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      current_index = Integer.MIN_VALUE;\n    }\n\n    public boolean hasNext() {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      \/\/ This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          current_index++;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          \/\/ prev_nonmissing is for testing only\n          int prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().intValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorInt: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    public Integer next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Integer result = new Integer(current_missing);\n      current_missing++;\n      return result;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This iterator returns all the numbers *not* in its argument array\n(which must be non-empty)\nbut in the argument's range; that is, bigger than its argument's\nminimum value and smaller than its argument's maximum value.\nThe result contains no duplicates and is in order.\nIf boolean add_ends is set, then the bracketing endpoints are also\nreturned; otherwise, all returned values are between the minimum and\nmaximum of the original values.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1349,col 3)-(line 1456,col 3)","classOrInterfaceTokenRange":"static final class MissingNumbersIteratorLong implements Iterator<Long> {\n    \/\/ Exactly one of nums and nums_itor is non-null.\n    long \/*@MonotonicNonNull*\/ [] nums;\n    \/*@MonotonicNonNull*\/ Iterator<Long> nums_itor;\n    long current_nonmissing;\n    long current_missing;\n    \/\/ Used only if nums != null.\n    int current_index;\n    boolean add_ends;\n\n    \/**\n     * An iterator over all the numbers <b>not<\/b> in its original argument\n     * array, but within its range.\n     * @param nums a non-empty array\n     * @param add_ends if true, include the bracketing endpoints\n     *\/\n    MissingNumbersIteratorLong(long[] nums, boolean add_ends) {\n      this.add_ends = add_ends;\n      { \/\/ avoid modifying parameter\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n      }\n      Arrays.sort(nums);\n      current_index = 0;\n      current_nonmissing = nums[current_index];\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums = nums;\n    }\n\n    \/\/ The argument iterator must return the Integers in sorted order\n    MissingNumbersIteratorLong(Iterator<Long> nums_itor, boolean add_ends) {\n      this.add_ends = add_ends;\n      if (!nums_itor.hasNext()) {\n        throw new Error(\"No elements in nums_itor\");\n      }\n      current_nonmissing = nums_itor.next().longValue();\n      if (add_ends) {\n        current_missing = current_nonmissing - 1;\n      } else {\n        current_missing = current_nonmissing;\n      }\n      this.nums_itor = nums_itor;\n      current_index = Integer.MIN_VALUE;\n    }\n\n    public boolean hasNext() {\n      if (current_missing < current_nonmissing) {\n        return true;\n      }\n      \/\/ This loop (\"while\" instead of \"if\") permits duplicates in nums.\n      while (current_missing == current_nonmissing) {\n        if (nums != null) {\n          current_index++;\n          if (current_index >= nums.length) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          current_nonmissing = nums[current_index];\n        } else if (nums_itor != null) {\n          if (!nums_itor.hasNext()) {\n            if (add_ends) {\n              current_missing++;\n              return true;\n            } else {\n              return false;\n            }\n          }\n          \/\/ prev_nonmissing is for testing only\n          long prev_nonmissing = current_nonmissing;\n          current_nonmissing = nums_itor.next().longValue();\n          if (! (prev_nonmissing < current_nonmissing)) {\n            throw new Error(\"Non-sorted Iterator supplied to MissingNumbersIteratorLong: prev_nonmissing = \" + prev_nonmissing + \", current_nonmissing = \" + current_nonmissing);\n          }\n        } else {\n          throw new Error(\"Can't happen\");\n        }\n        current_missing++;\n        return hasNext();\n      }\n      if (add_ends) {\n        return (current_missing == current_nonmissing + 1);\n      } else {\n        throw new Error(\"Can't happen: \" + current_missing + \" \" + current_nonmissing);\n      }\n    }\n\n    public Long next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      Long result = new Long(current_missing);\n      current_missing++;\n      return result;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * This iterator returns all the numbers *not* in its argument array\n   * (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * If boolean add_ends is set, then the bracketing endpoints are also\n   * returned; otherwise, all returned values are between the minimum and\n   * maximum of the original values.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This iterator returns all the numbers *not* in its argument array\n(which must be non-empty)\nbut in the argument's range; that is, bigger than its argument's\nminimum value and smaller than its argument's maximum value.\nThe result contains no duplicates and is in order.\nIf boolean add_ends is set, then the bracketing endpoints are also\nreturned; otherwise, all returned values are between the minimum and\nmaximum of the original values.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to negate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to negate'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"negative of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='negative of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int negate(int a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return -a;\n}","methodRange":"(line 29,col 3)-(line 31,col 3)","methodTokenRange":"public static int negate(int a) {\n    return -a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a","parameterName":"a"}],"methodName":"negate","methodQualifiedSignature":"plume.MathMDE.negate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Negates its argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to negate'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='negative of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.negate(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to negate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to negate'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"negative of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='negative of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long negate(long a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return -a;\n}","methodRange":"(line 37,col 3)-(line 39,col 3)","methodTokenRange":"public static long negate(long a) {\n    return -a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long a","parameterName":"a"}],"methodName":"negate","methodQualifiedSignature":"plume.MathMDE.negate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Negates its argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to negate'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='negative of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.negate(long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to negate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to negate'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"negative of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='negative of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double negate(double a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return -a;\n}","methodRange":"(line 45,col 3)-(line 47,col 3)","methodTokenRange":"public static double negate(double a) {\n    return -a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":" Negates its argument.\n   * @param a value to negate\n   * @return negative of a\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double a","parameterName":"a"}],"methodName":"negate","methodQualifiedSignature":"plume.MathMDE.negate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Negates its argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to negate'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='negative of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"plume.MathMDE.negate(double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to bitwise-complement","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to bitwise-complement'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"~a, the bitwise complement of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='~a, the bitwise complement of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int bitwiseComplement(int a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ~a;\n}","methodRange":"(line 53,col 3)-(line 55,col 3)","methodTokenRange":"public static int bitwiseComplement(int a) {\n    return ~a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a","parameterName":"a"}],"methodName":"bitwiseComplement","methodQualifiedSignature":"plume.MathMDE.bitwiseComplement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns ~a, the bitwise complement of its argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to bitwise-complement'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='~a, the bitwise complement of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseComplement(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to bitwise-complement","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to bitwise-complement'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"~a, the bitwise complement of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='~a, the bitwise complement of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long bitwiseComplement(long a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ~a;\n}","methodRange":"(line 61,col 3)-(line 63,col 3)","methodTokenRange":"public static long bitwiseComplement(long a) {\n    return ~a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns ~a, the bitwise complement of its argument.\n   * @param a value to bitwise-complement\n   * @return ~a, the bitwise complement of a\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long a","parameterName":"a"}],"methodName":"bitwiseComplement","methodQualifiedSignature":"plume.MathMDE.bitwiseComplement","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns ~a, the bitwise complement of its argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to bitwise-complement'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='~a, the bitwise complement of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseComplement(long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first multiplicand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first multiplicand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second multiplicand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second multiplicand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x * y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x * y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int mul(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x * y;\n}","methodRange":"(line 70,col 3)-(line 72,col 3)","methodTokenRange":"public static int mul(int x, int y) {\n    return x * y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"mul","methodQualifiedSignature":"plume.MathMDE.mul","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Multiplies its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first multiplicand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second multiplicand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x * y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.mul(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first multiplicand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first multiplicand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second multiplicand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second multiplicand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x * y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x * y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long mul(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x * y;\n}","methodRange":"(line 79,col 3)-(line 81,col 3)","methodTokenRange":"public static long mul(long x, long y) {\n    return x * y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"mul","methodQualifiedSignature":"plume.MathMDE.mul","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Multiplies its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first multiplicand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second multiplicand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x * y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.mul(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first multiplicand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first multiplicand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second multiplicand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second multiplicand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x * y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x * y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double mul(double x, double y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x * y;\n}","methodRange":"(line 88,col 3)-(line 90,col 3)","methodTokenRange":"public static double mul(double x, double y) {\n    return x * y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":" Multiplies its arguments.\n   * @param x first multiplicand\n   * @param y second multiplicand\n   * @return x * y\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double x","parameterName":"x"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double y","parameterName":"y"}],"methodName":"mul","methodQualifiedSignature":"plume.MathMDE.mul","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Multiplies its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first multiplicand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second multiplicand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x * y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"plume.MathMDE.mul(double, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"dividend","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='dividend'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"divisor","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='divisor'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x \/ y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x \/ y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int div(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x \/ y;\n}","methodRange":"(line 97,col 3)-(line 99,col 3)","methodTokenRange":"public static int div(int x, int y) {\n    return x \/ y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x \/ y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"div","methodQualifiedSignature":"plume.MathMDE.div","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Divides its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='dividend'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='divisor'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x \/ y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.div(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"dividend","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='dividend'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"divisor","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='divisor'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x \/ y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x \/ y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long div(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x \/ y;\n}","methodRange":"(line 106,col 3)-(line 108,col 3)","methodTokenRange":"public static long div(long x, long y) {\n    return x \/ y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x \/ y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"div","methodQualifiedSignature":"plume.MathMDE.div","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Divides its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='dividend'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='divisor'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x \/ y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.div(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"dividend","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='dividend'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"divisor","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='divisor'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x \/ y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x \/ y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double div(double x, double y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x \/ y;\n}","methodRange":"(line 115,col 3)-(line 117,col 3)","methodTokenRange":"public static double div(double x, double y) {\n    return x \/ y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":" Divides its arguments.\n   * @param x dividend\n   * @param y divisor\n   * @return x \/ y\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double x","parameterName":"x"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double y","parameterName":"y"}],"methodName":"div","methodQualifiedSignature":"plume.MathMDE.div","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Divides its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='dividend'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='divisor'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x \/ y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"plume.MathMDE.div(double, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be modded","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be modded'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"modulus","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x % y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int mod(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x % y;\n}","methodRange":"(line 124,col 3)-(line 126,col 3)","methodTokenRange":"public static int mod(int x, int y) {\n    return x % y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"mod","methodQualifiedSignature":"plume.MathMDE.mod","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x % y, the modulus operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be modded'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.mod(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be modded","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be modded'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"modulus","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x % y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long mod(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x % y;\n}","methodRange":"(line 133,col 3)-(line 135,col 3)","methodTokenRange":"public static long mod(long x, long y) {\n    return x % y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x % y, the modulus operation applied to its arguments.\n   * @param x valued to be modded\n   * @param y modulus\n   * @return x % y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"mod","methodQualifiedSignature":"plume.MathMDE.mod","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x % y, the modulus operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be modded'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.mod(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be left-shifted","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be left-shifted'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"magnitude of the left-shift","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the left-shift'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &lt;&lt; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &lt;&lt; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int lshift(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x << y;\n}","methodRange":"(line 142,col 3)-(line 144,col 3)","methodTokenRange":"public static int lshift(int x, int y) {\n    return x << y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"lshift","methodQualifiedSignature":"plume.MathMDE.lshift","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &lt;&lt; y, the left-shift operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be left-shifted'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the left-shift'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &lt;&lt; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.lshift(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be left-shifted","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be left-shifted'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"magnitude of the left-shift","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the left-shift'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &lt;&lt; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &lt;&lt; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long lshift(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x << y;\n}","methodRange":"(line 151,col 3)-(line 153,col 3)","methodTokenRange":"public static long lshift(long x, long y) {\n    return x << y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x &lt;&lt; y, the left-shift operation applied to its arguments.\n   * @param x valued to be left-shifted\n   * @param y magnitude of the left-shift\n   * @return x &lt;&lt; y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"lshift","methodQualifiedSignature":"plume.MathMDE.lshift","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &lt;&lt; y, the left-shift operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be left-shifted'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the left-shift'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &lt;&lt; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.lshift(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be right-shifted","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"magnitude of the right-shift","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &gt;&gt; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int rshiftSigned(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x >> y;\n}","methodRange":"(line 160,col 3)-(line 162,col 3)","methodTokenRange":"public static int rshiftSigned(int x, int y) {\n    return x >> y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"rshiftSigned","methodQualifiedSignature":"plume.MathMDE.rshiftSigned","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.rshiftSigned(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be right-shifted","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"magnitude of the right-shift","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &gt;&gt; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long rshiftSigned(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x >> y;\n}","methodRange":"(line 169,col 3)-(line 171,col 3)","methodTokenRange":"public static long rshiftSigned(long x , long y) {\n    return x >> y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt; y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"rshiftSigned","methodQualifiedSignature":"plume.MathMDE.rshiftSigned","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.rshiftSigned(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be right-shifted","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"magnitude of the right-shift","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &gt;&gt;&gt; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt;&gt; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int rshiftUnsigned(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x >>> y;\n}","methodRange":"(line 178,col 3)-(line 180,col 3)","methodTokenRange":"public static int rshiftUnsigned(int x, int y) {\n    return x >>> y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"rshiftUnsigned","methodQualifiedSignature":"plume.MathMDE.rshiftUnsigned","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt;&gt; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.rshiftUnsigned(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"valued to be right-shifted","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"magnitude of the right-shift","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &gt;&gt;&gt; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt;&gt; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long rshiftUnsigned(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x >>> y;\n}","methodRange":"(line 187,col 3)-(line 189,col 3)","methodTokenRange":"public static long rshiftUnsigned(long x, long y) {\n    return x >>> y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.\n   * @param x valued to be right-shifted\n   * @param y magnitude of the right-shift\n   * @return x &gt;&gt;&gt; y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"rshiftUnsigned","methodQualifiedSignature":"plume.MathMDE.rshiftUnsigned","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='valued to be right-shifted'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='magnitude of the right-shift'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &gt;&gt;&gt; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.rshiftUnsigned(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &amp; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &amp; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int bitwiseAnd(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x & y;\n}","methodRange":"(line 196,col 3)-(line 198,col 3)","methodTokenRange":"public static int bitwiseAnd(int x, int y) {\n    return x & y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"bitwiseAnd","methodQualifiedSignature":"plume.MathMDE.bitwiseAnd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &amp; y, the bitwise and of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &amp; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseAnd(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x &amp; y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &amp; y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long bitwiseAnd(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x & y;\n}","methodRange":"(line 205,col 3)-(line 207,col 3)","methodTokenRange":"public static long bitwiseAnd(long x, long y) {\n    return x & y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x &amp; y, the bitwise and of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x &amp; y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"bitwiseAnd","methodQualifiedSignature":"plume.MathMDE.bitwiseAnd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x &amp; y, the bitwise and of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x &amp; y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseAnd(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the logical and of x and y; the result is always 0 or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical and of x and y; the result is always 0 or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int logicalAnd(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}","methodRange":"(line 214,col 3)-(line 216,col 3)","methodTokenRange":"public static int logicalAnd(int x, int y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"logicalAnd","methodQualifiedSignature":"plume.MathMDE.logicalAnd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the logical and of its arguments.  The result is always 0 or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical and of x and y; the result is always 0 or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 215,col 17)-(line 215,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 215,col 27)-(line 215,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 215,col 33)-(line 215,col 33)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 215,col 37)-(line 215,col 37)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.logicalAnd(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the logical and of x and y; the result is always 0 or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical and of x and y; the result is always 0 or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long logicalAnd(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((x != 0) && (y != 0)) ? 1 : 0;\n}","methodRange":"(line 223,col 3)-(line 225,col 3)","methodTokenRange":"public static long logicalAnd(long x, long y) {\n    return ((x!=0) && (y!=0)) ? 1 : 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns the logical and of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical and of x and y; the result is always 0 or 1\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"logicalAnd","methodQualifiedSignature":"plume.MathMDE.logicalAnd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the logical and of its arguments.  The result is always 0 or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical and of x and y; the result is always 0 or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 224,col 17)-(line 224,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 27)-(line 224,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 33)-(line 224,col 33)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 37)-(line 224,col 37)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.logicalAnd(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x ^ y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x ^ y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int bitwiseXor(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x ^ y;\n}","methodRange":"(line 232,col 3)-(line 234,col 3)","methodTokenRange":"public static int bitwiseXor(int x, int y) {\n    return x ^ y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"bitwiseXor","methodQualifiedSignature":"plume.MathMDE.bitwiseXor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x ^ y, the bitwise xor of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x ^ y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseXor(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x ^ y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x ^ y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long bitwiseXor(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x ^ y;\n}","methodRange":"(line 241,col 3)-(line 243,col 3)","methodTokenRange":"public static long bitwiseXor(long x, long y) {\n    return x ^ y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x ^ y, the bitwise xor of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x ^ y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"bitwiseXor","methodQualifiedSignature":"plume.MathMDE.bitwiseXor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x ^ y, the bitwise xor of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x ^ y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseXor(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the logical xor of x and y; the result is always 0 or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical xor of x and y; the result is always 0 or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int logicalXor(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}","methodRange":"(line 250,col 3)-(line 252,col 3)","methodTokenRange":"public static int logicalXor(int x, int y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"logicalXor","methodQualifiedSignature":"plume.MathMDE.logicalXor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the logical xor of its arguments.  The result is always 0 or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical xor of x and y; the result is always 0 or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 251,col 17)-(line 251,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 251,col 26)-(line 251,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 251,col 32)-(line 251,col 32)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 251,col 36)-(line 251,col 36)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.logicalXor(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the logical xor of x and y; the result is always 0 or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical xor of x and y; the result is always 0 or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long logicalXor(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((x != 0) ^ (y != 0)) ? 1 : 0;\n}","methodRange":"(line 259,col 3)-(line 261,col 3)","methodTokenRange":"public static long logicalXor(long x, long y) {\n    return ((x!=0) ^ (y!=0)) ? 1 : 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns the logical xor of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical xor of x and y; the result is always 0 or 1\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"logicalXor","methodQualifiedSignature":"plume.MathMDE.logicalXor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the logical xor of its arguments.  The result is always 0 or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical xor of x and y; the result is always 0 or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 260,col 17)-(line 260,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 260,col 26)-(line 260,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 260,col 32)-(line 260,col 32)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 260,col 36)-(line 260,col 36)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.logicalXor(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x | y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x | y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int bitwiseOr(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x | y;\n}","methodRange":"(line 268,col 3)-(line 270,col 3)","methodTokenRange":"public static int bitwiseOr(int x, int y) {\n    return x | y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"bitwiseOr","methodQualifiedSignature":"plume.MathMDE.bitwiseOr","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x | y, the bitwise or of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x | y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseOr(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x | y","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x | y'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long bitwiseOr(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return x | y;\n}","methodRange":"(line 277,col 3)-(line 279,col 3)","methodTokenRange":"public static long bitwiseOr(long x, long y) {\n    return x | y;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns x | y, the bitwise or of its arguments.\n   * @param x first operand\n   * @param y second operand\n   * @return x | y\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"bitwiseOr","methodQualifiedSignature":"plume.MathMDE.bitwiseOr","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns x | y, the bitwise or of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x | y'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.bitwiseOr(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the logical or of x and y; the result is always 0 or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical or of x and y; the result is always 0 or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int logicalOr(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}","methodRange":"(line 286,col 3)-(line 288,col 3)","methodTokenRange":"public static int logicalOr(int x, int y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"logicalOr","methodQualifiedSignature":"plume.MathMDE.logicalOr","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the logical or of its arguments.  The result is always 0 or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical or of x and y; the result is always 0 or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 287,col 17)-(line 287,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 27)-(line 287,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 33)-(line 287,col 33)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 37)-(line 287,col 37)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.logicalOr(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the logical or of x and y; the result is always 0 or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical or of x and y; the result is always 0 or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long logicalOr(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((x != 0) || (y != 0)) ? 1 : 0;\n}","methodRange":"(line 295,col 3)-(line 297,col 3)","methodTokenRange":"public static long logicalOr(long x, long y) {\n    return ((x!=0) || (y!=0)) ? 1 : 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Returns the logical or of its arguments.  The result is always 0 or 1.\n   * @param x first operand\n   * @param y second operand\n   * @return the logical or of x and y; the result is always 0 or 1\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"logicalOr","methodQualifiedSignature":"plume.MathMDE.logicalOr","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the logical or of its arguments.  The result is always 0 or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the logical or of x and y; the result is always 0 or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 296,col 17)-(line 296,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 27)-(line 296,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 33)-(line 296,col 33)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 37)-(line 296,col 37)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.logicalOr(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to have its sign taken","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to have its sign taken'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the sign of a: -1, 0, or 1","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sign of a: -1, 0, or 1'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int sign(int a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == 0) {\n        return 0;\n    } else if (a > 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}","methodRange":"(line 307,col 3)-(line 315,col 3)","methodTokenRange":"public static int sign(int a) {\n    if (a==0) {\n      return 0;\n    } else if (a>0) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns the sign of its argument.  The result is always -1, 0, or 1.\n   * @param a value to have its sign taken\n   * @return the sign of a: -1, 0, or 1\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a","parameterName":"a"}],"methodName":"sign","methodQualifiedSignature":"plume.MathMDE.sign","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the sign of its argument.  The result is always -1, 0, or 1.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to have its sign taken'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sign of a: -1, 0, or 1'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 308,col 12)-(line 308,col 12)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 309,col 14)-(line 309,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 310,col 18)-(line 310,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 311,col 14)-(line 311,col 14)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 313,col 15)-(line 313,col 15)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.sign(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the exponent","javadocBlockTagName":"expt","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the exponent'}]}', name=Optional[expt]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"base to the expt power","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='base to the expt power'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Math#pow(double, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Math#pow(double, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int pow(int base, int expt) throws ArithmeticException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return pow_fast(base, expt);\n}","methodRange":"(line 329,col 3)-(line 331,col 3)","methodTokenRange":"public static int pow(int base, int expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns of value of the first argument raised to the\n   * power of the second argument.  The argument are integers.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int base","parameterName":"base"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int expt","parameterName":"expt"}],"methodName":"pow","methodQualifiedSignature":"plume.MathMDE.pow","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns of value of the first argument raised to the\npower of the second argument.  The argument are integers.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the exponent'}]}', name=Optional[expt]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='base to the expt power'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Math#pow(double, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.MathMDE.pow(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base","javadocBlockTagName":"base","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base'}]}', name=Optional[base]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the exponent","javadocBlockTagName":"expt","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the exponent'}]}', name=Optional[expt]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"base to the expt power","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='base to the expt power'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Math#pow(double, double)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Math#pow(double, double)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long pow(long base, long expt) throws ArithmeticException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return pow_fast(base, expt);\n}","methodRange":"(line 341,col 3)-(line 343,col 3)","methodTokenRange":"public static long pow(long base, long expt) throws ArithmeticException {\n    return pow_fast(base, expt);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n   * Returns of value of the first argument raised to the\n   * power of the second argument.\n   * @param base the base\n   * @param expt the exponent\n   * @return base to the expt power\n   * @see Math#pow(double, double)\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long base","parameterName":"base"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long expt","parameterName":"expt"}],"methodName":"pow","methodQualifiedSignature":"plume.MathMDE.pow","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns of value of the first argument raised to the\npower of the second argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base'}]}', name=Optional[base]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the exponent'}]}', name=Optional[expt]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='base to the expt power'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Math#pow(double, double)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.MathMDE.pow(long, long)"},{"methodDeclaration":"private static int pow_fast(int base, int expt) throws ArithmeticException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (expt < 0) {\n        throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n    int this_square_pow = base;\n    int result = 1;\n    while (expt > 0) {\n        if ((expt & 1) != 0) {\n            result *= this_square_pow;\n        }\n        expt >>= 1;\n        this_square_pow *= this_square_pow;\n    }\n    return result;\n}","methodRange":"(line 345,col 3)-(line 360,col 3)","methodTokenRange":"private static int pow_fast(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int this_square_pow = base;\n    int result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int base","parameterName":"base"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int expt","parameterName":"expt"}],"methodName":"pow_fast","methodQualifiedSignature":"plume.MathMDE.pow_fast","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 346,col 16)-(line 346,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 347,col 37)-(line 347,col 69)","literalExprId":2,"literalExpr":"\"Negative exponent passed to pow\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 351,col 18)-(line 351,col 18)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 17)-(line 352,col 17)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 19)-(line 353,col 19)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 25)-(line 353,col 25)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 16)-(line 356,col 16)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.pow_fast(int, int)"},{"methodDeclaration":"private static long pow_fast(long base, long expt) throws ArithmeticException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (expt < 0) {\n        throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n    long this_square_pow = base;\n    long result = 1;\n    while (expt > 0) {\n        if ((expt & 1) != 0) {\n            result *= this_square_pow;\n        }\n        expt >>= 1;\n        this_square_pow *= this_square_pow;\n    }\n    return result;\n}","methodRange":"(line 362,col 3)-(line 377,col 3)","methodTokenRange":"private static long pow_fast(long base, long expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    long this_square_pow = base;\n    long result = 1;\n    while (expt>0) {\n      if ((expt & 1) != 0) {\n        result *= this_square_pow;\n      }\n      expt >>= 1;\n      this_square_pow *= this_square_pow;\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long base","parameterName":"base"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long expt","parameterName":"expt"}],"methodName":"pow_fast","methodQualifiedSignature":"plume.MathMDE.pow_fast","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 363,col 16)-(line 363,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 364,col 37)-(line 364,col 69)","literalExprId":2,"literalExpr":"\"Negative exponent passed to pow\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 368,col 19)-(line 368,col 19)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 369,col 17)-(line 369,col 17)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 370,col 19)-(line 370,col 19)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 370,col 25)-(line 370,col 25)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 373,col 16)-(line 373,col 16)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.pow_fast(long, long)"},{"methodDeclaration":"private static int pow_slow(int base, int expt) throws ArithmeticException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (expt < 0) {\n        throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n    int result = 1;\n    for (int i = 0; i < expt; i++) {\n        result *= base;\n    }\n    return result;\n}","methodRange":"(line 379,col 3)-(line 389,col 3)","methodTokenRange":"private static int pow_slow(int base, int expt) throws ArithmeticException {\n    if (expt < 0) {\n      throw new ArithmeticException(\"Negative exponent passed to pow\");\n    }\n\n    int result = 1;\n    for (int i=0; i<expt; i++) {\n      result *= base;\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int base","parameterName":"base"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int expt","parameterName":"expt"}],"methodName":"pow_slow","methodQualifiedSignature":"plume.MathMDE.pow_slow","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 380,col 16)-(line 380,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 381,col 37)-(line 381,col 69)","literalExprId":2,"literalExpr":"\"Negative exponent passed to pow\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 384,col 18)-(line 384,col 18)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 385,col 16)-(line 385,col 16)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.pow_slow(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of a and b","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of a and b'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int gcd(int a, int b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        int tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}","methodRange":"(line 400,col 3)-(line 414,col 3)","methodTokenRange":"public static int gcd(int a, int b) {\n\n    \/\/ Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      int tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int b","parameterName":"b"}],"methodName":"gcd","methodQualifiedSignature":"plume.MathMDE.gcd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the greatest common divisor of the two arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of a and b'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 403,col 14)-(line 403,col 14)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 17)-(line 408,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of the elements of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the elements of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int gcd(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        return 0;\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}","methodRange":"(line 420,col 3)-(line 433,col 3)","methodTokenRange":"public static int gcd(int[] a) {\n    \/\/ Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    int result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return the greatest common divisor of the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"gcd","methodQualifiedSignature":"plume.MathMDE.gcd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the greatest common divisor of the elements of int array a.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the elements of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 422,col 21)-(line 422,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 14)-(line 423,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 20)-(line 425,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 16)-(line 426,col 16)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 428,col 22)-(line 428,col 22)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 428,col 39)-(line 428,col 39)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of the differences between the elements of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the differences between the elements of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int gcd_differences(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length < 2) {\n        return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}","methodRange":"(line 441,col 3)-(line 454,col 3)","methodTokenRange":"public static int gcd_differences(int[] a) {\n    \/\/ Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    int result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of int array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"gcd_differences","methodQualifiedSignature":"plume.MathMDE.gcd_differences","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the gcd (greatest common divisor) of the differences\nbetween the elements of int array a.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the differences between the elements of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 443,col 20)-(line 443,col 20)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 444,col 14)-(line 444,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 446,col 20)-(line 446,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 446,col 27)-(line 446,col 27)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 16)-(line 447,col 16)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 448,col 31)-(line 448,col 31)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 22)-(line 449,col 22)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 39)-(line 449,col 39)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd_differences(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of a and b","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of a and b'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long gcd(long a, long b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        long tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}","methodRange":"(line 463,col 3)-(line 477,col 3)","methodTokenRange":"public static long gcd(long a, long b) {\n\n    \/\/ Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      long tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long a","parameterName":"a"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long b","parameterName":"b"}],"methodName":"gcd","methodQualifiedSignature":"plume.MathMDE.gcd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the greatest common divisor of the two arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of a and b'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 466,col 14)-(line 466,col 14)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 471,col 17)-(line 471,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of the elements of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the elements of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long gcd(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        return 0;\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}","methodRange":"(line 483,col 3)-(line 496,col 3)","methodTokenRange":"public static long gcd(long[] a) {\n    \/\/ Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    long result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Return the greatest common divisor of the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"gcd","methodQualifiedSignature":"plume.MathMDE.gcd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the greatest common divisor of the elements of long array a.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the elements of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 485,col 21)-(line 485,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 486,col 14)-(line 486,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 488,col 21)-(line 488,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 489,col 16)-(line 489,col 16)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 22)-(line 491,col 22)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 39)-(line 491,col 39)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of the differences between the elements of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the differences between the elements of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long gcd_differences(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length < 2) {\n        return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}","methodRange":"(line 504,col 3)-(line 517,col 3)","methodTokenRange":"public static long gcd_differences(long[] a) {\n    \/\/ Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    long result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of long array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"gcd_differences","methodQualifiedSignature":"plume.MathMDE.gcd_differences","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the gcd (greatest common divisor) of the differences\nbetween the elements of long array a.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the differences between the elements of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 506,col 20)-(line 506,col 20)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 507,col 14)-(line 507,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 509,col 21)-(line 509,col 21)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 509,col 28)-(line 509,col 28)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 510,col 16)-(line 510,col 16)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 31)-(line 511,col 31)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 512,col 22)-(line 512,col 22)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 512,col 39)-(line 512,col 39)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd_differences(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first operand","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second operand","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of a and b","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of a and b'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double gcd(double a, double b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == Double.POSITIVE_INFINITY || a == Double.NEGATIVE_INFINITY || Double.isNaN(a) || b == Double.POSITIVE_INFINITY || b == Double.NEGATIVE_INFINITY || Double.isNaN(b)) {\n        return Double.NaN;\n    }\n    if (b == 0) {\n        return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n        double tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n    return a;\n}","methodRange":"(line 524,col 3)-(line 547,col 3)","methodTokenRange":"public static double gcd(double a, double b) {\n\n    if (a == Double.POSITIVE_INFINITY\n        || a == Double.NEGATIVE_INFINITY\n        || Double.isNaN(a)\n        || b == Double.POSITIVE_INFINITY\n        || b == Double.NEGATIVE_INFINITY\n        || Double.isNaN(b)) {\n      return Double.NaN;\n    }\n\n    \/\/ Euclid's method\n    if (b == 0) {\n      return (Math.abs(a));\n    }\n    a = Math.abs(a);\n    b = Math.abs(b);\n    while (b != 0) {\n      double tmp = b;\n      b = a % b;\n      a = tmp;\n    }\n    return a;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":" Return the greatest common divisor of the two arguments.\n   * @param a first operand\n   * @param b second operand\n   * @return greatest common divisor of a and b\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double a","parameterName":"a"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double b","parameterName":"b"}],"methodName":"gcd","methodQualifiedSignature":"plume.MathMDE.gcd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the greatest common divisor of the two arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first operand'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second operand'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of a and b'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 536,col 14)-(line 536,col 14)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 541,col 17)-(line 541,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd(double, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of the elements of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the elements of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double gcd(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        return 0;\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = gcd(a[i], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}","methodRange":"(line 553,col 3)-(line 566,col 3)","methodTokenRange":"public static double gcd(double[] a) {\n    \/\/ Euclid's method\n    if (a.length == 0) {\n      return 0;\n    }\n    double result = a[0];\n    for (int i=1; i<a.length; i++) {\n      result = gcd(a[i], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":" Return the greatest common divisor of the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the elements of a\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"gcd","methodQualifiedSignature":"plume.MathMDE.gcd","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the greatest common divisor of the elements of double array a.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the elements of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 555,col 21)-(line 555,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 556,col 14)-(line 556,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 558,col 23)-(line 558,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 559,col 16)-(line 559,col 16)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 561,col 22)-(line 561,col 22)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 561,col 39)-(line 561,col 39)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"greatest common divisor of the differences between the elements of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the differences between the elements of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double gcd_differences(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length < 2) {\n        return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i = 2; i < a.length; i++) {\n        result = gcd(a[i] - a[i - 1], result);\n        if ((result == 1) || (result == 0)) {\n            return result;\n        }\n    }\n    return result;\n}","methodRange":"(line 574,col 3)-(line 587,col 3)","methodTokenRange":"public static double gcd_differences(double[] a) {\n    \/\/ Euclid's method\n    if (a.length < 2) {\n      return 0;\n    }\n    double result = a[1] - a[0];\n    for (int i=2; i<a.length; i++) {\n      result = gcd(a[i] - a[i-1], result);\n      if ((result == 1) || (result == 0)) {\n        return result;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n   * Return the gcd (greatest common divisor) of the differences\n   * between the elements of double array a.\n   * @param a array of operands\n   * @return greatest common divisor of the differences between the elements of a\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"gcd_differences","methodQualifiedSignature":"plume.MathMDE.gcd_differences","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the gcd (greatest common divisor) of the differences\nbetween the elements of double array a.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='greatest common divisor of the differences between the elements of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 576,col 20)-(line 576,col 20)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 577,col 14)-(line 577,col 14)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 579,col 23)-(line 579,col 23)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 579,col 30)-(line 579,col 30)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 580,col 16)-(line 580,col 16)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 581,col 31)-(line 581,col 31)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 582,col 22)-(line 582,col 22)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 582,col 39)-(line 582,col 39)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.gcd_differences(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be modded","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be modded'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"modulus","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x % y, where the result is constrained to be positive","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y, where the result is constrained to be positive'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int mod_positive(int x, int y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}","methodRange":"(line 598,col 3)-(line 604,col 3)","methodTokenRange":"public static int mod_positive(int x, int y) {\n    int result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return z such that (z == x mod y) and (0 &le; z &lt; abs(y)).\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be positive\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int x","parameterName":"x"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int y","parameterName":"y"}],"methodName":"mod_positive","methodQualifiedSignature":"plume.MathMDE.mod_positive","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return z such that (z == x mod y) and (0 &le; z &lt; abs(y)).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be modded'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y, where the result is constrained to be positive'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 600,col 18)-(line 600,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.mod_positive(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] modulus(int[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length < 3) {\n        return null;\n    }\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new int[] { remainder, modulus };\n}","methodRange":"(line 615,col 3)-(line 631,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] modulus(int[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    int remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new int[] { remainder, modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] nums","parameterName":"nums"}],"methodName":"modulus","methodQualifiedSignature":"plume.MathMDE.modulus","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\nThe largest possible modulus is used, and the trivial constraint that all\nintegers are equal to 0 mod 1 is not returned (null is returned instead).\nAlso, return null if the array is less than 3 elements long.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 616,col 23)-(line 616,col 23)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 617,col 14)-(line 617,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 621,col 21)-(line 621,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 621,col 39)-(line 621,col 39)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 622,col 14)-(line 622,col 17)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 625,col 26)-(line 625,col 26)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 626,col 21)-(line 626,col 21)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"iterator of operands","javadocBlockTagName":"itor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#modulus(int[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus(int[])'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] modulus_int(Iterator<Integer> itor)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        int i = itor.next().intValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}","methodRange":"(line 643,col 3)-(line 671,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] modulus_int(Iterator<Integer> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int avalue = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int modulus = Math.abs(avalue - itor.next().intValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      int i = itor.next().intValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new int[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(int[])\n   ","methodParameters":[{"parameterType":"Iterator<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Integer>","parameter":"Iterator<Integer> itor","parameterName":"itor"}],"methodName":"modulus_int","methodQualifiedSignature":"plume.MathMDE.modulus_int","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The iterator produces Integer values.\nThis can be more efficient than modulus(int[]) if the int[] doesn't already\nexist, because this does not necessarily examine every value produced by\nits iterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus(int[])'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 645,col 14)-(line 645,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 649,col 14)-(line 649,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 652,col 20)-(line 652,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 653,col 14)-(line 653,col 17)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 655,col 17)-(line 655,col 17)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 663,col 22)-(line 663,col 22)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 664,col 16)-(line 664,col 19)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 667,col 17)-(line 667,col 17)","literalExprId":8,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 668,col 14)-(line 668,col 17)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus_int(java.util.Iterator<java.lang.Integer>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether endpoints are NOT subject to the strict density requirement","javadocBlockTagName":"nonstrict_ends","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] modulus_strict(int[] nums, boolean nonstrict_ends)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    int first_nonstrict = 0;\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    int modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}","methodRange":"(line 697,col 3)-(line 735,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] modulus_strict(int[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    int first_nonstrict = 0; \/\/ arbitrary initial value\n    int last_nonstrict = 0; \/\/ arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    int modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    int r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] nums","parameterName":"nums"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean nonstrict_ends","parameterName":"nonstrict_ends"}],"methodName":"modulus_strict","methodQualifiedSignature":"plume.MathMDE.modulus_strict","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\nThe largest possible modulus is used, and the trivial constraint that all\nintegers are equal to 0 mod 1 is not returned (null is returned instead).\n<p>\n\nThis \"_strict\" version requires its input to be sorted, and no element\nmay be missing.\n<p>\n\nThis \"_strict\" version differs from the regular modulus by requiring\nthat the argument be dense:  that is, every pair of numbers in the\nargument array is separated by exactly the modulus.\n<p>\n\nThe endpoints can be treated in two different ways:  Either exactly\nlike other numbers in the input, or they can merely be checked for the\ncondition without the strict density requirement.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 698,col 23)-(line 698,col 23)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 699,col 14)-(line 699,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 702,col 23)-(line 702,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 703,col 34)-(line 703,col 34)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 27)-(line 704,col 27)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 26)-(line 705,col 26)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 712,col 36)-(line 712,col 36)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 713,col 14)-(line 713,col 17)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 716,col 36)-(line 716,col 36)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 717,col 20)-(line 717,col 20)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 718,col 14)-(line 718,col 17)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 720,col 28)-(line 720,col 28)","literalExprId":12,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 721,col 28)-(line 721,col 28)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 722,col 16)-(line 722,col 19)","literalExprId":14,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 730,col 16)-(line 730,col 19)","literalExprId":15,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus_strict(int[], boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"iterator of operands","javadocBlockTagName":"itor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether endpoints are NOT subject to the strict density requirement","javadocBlockTagName":"nonstrict_ends","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#modulus_strict(int[], boolean)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus_strict(int[], boolean)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int first_nonstrict = 0;\n    int last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().intValue();\n    }\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().intValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new int[] { r, modulus };\n}","methodRange":"(line 750,col 3)-(line 797,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] modulus_strict_int(Iterator<Integer> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    int first_nonstrict = 0;    \/\/ arbitrary initial value\n    int last_nonstrict = 0;     \/\/ arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().intValue();\n    }\n\n    int prev = itor.next().intValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    int next = itor.next().intValue();\n    int modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().intValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    int r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new int[] { r, modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * The iterator produces Integer values.\n   * This can be more efficient than modulus(int[]) if the int[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(int[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   ","methodParameters":[{"parameterType":"Iterator<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Integer>","parameter":"Iterator<Integer> itor","parameterName":"itor"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean nonstrict_ends","parameterName":"nonstrict_ends"}],"methodName":"modulus_strict_int","methodQualifiedSignature":"plume.MathMDE.modulus_strict_int","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The iterator produces Integer values.\nThis can be more efficient than modulus(int[]) if the int[] doesn't\nalready exist, because this does not necessarily examine every value\nproduced by its iterator.\n<p>\nFor documentation, see '}, JavadocInlineTag{tagName='link', type=LINK, content=' #modulus_strict(int[], boolean)'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus_strict(int[], boolean)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 752,col 14)-(line 752,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 755,col 27)-(line 755,col 27)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 756,col 26)-(line 756,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 763,col 14)-(line 763,col 17)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 767,col 20)-(line 767,col 20)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 768,col 14)-(line 768,col 17)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 770,col 17)-(line 770,col 17)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 780,col 16)-(line 780,col 19)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 784,col 17)-(line 784,col 17)","literalExprId":9,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 785,col 14)-(line 785,col 17)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 792,col 16)-(line 792,col 19)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus_strict_int(java.util.Iterator<java.lang.Integer>, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be modded","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be modded'}]}', name=Optional[x]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"modulus","javadocBlockTagName":"y","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"x % y, where the result is constrained to be positive","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y, where the result is constrained to be positive'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long mod_positive(long x, long y)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = x % y;\n    if (result < 0) {\n        result += Math.abs(y);\n    }\n    return result;\n}","methodRange":"(line 806,col 3)-(line 812,col 3)","methodTokenRange":"public static long mod_positive(long x, long y) {\n    long result = x % y;\n    if (result < 0) {\n      result += Math.abs(y);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Return z such that (z == x mod y) and (0 &le; z &lt; abs(y)).\n   * @param x value to be modded\n   * @param y modulus\n   * @return x % y, where the result is constrained to be positive\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long x","parameterName":"x"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long y","parameterName":"y"}],"methodName":"mod_positive","methodQualifiedSignature":"plume.MathMDE.mod_positive","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return z such that (z == x mod y) and (0 &le; z &lt; abs(y)).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be modded'}]}', name=Optional[x]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='modulus'}]}', name=Optional[y]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='x % y, where the result is constrained to be positive'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 808,col 18)-(line 808,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.mod_positive(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] modulus(long[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length < 3) {\n        return null;\n    }\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n        return null;\n    }\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n        remainder += modulus;\n    }\n    return new long[] { remainder, modulus };\n}","methodRange":"(line 823,col 3)-(line 839,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] modulus(long[] nums) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    long modulus = Math.abs(gcd_differences(nums));\n    if ((modulus == 0) || (modulus == 1)) {\n      return null;\n    }\n\n    long remainder = nums[0] % modulus;\n    if (remainder < 0) {\n      remainder += modulus;\n    }\n\n    return new long[] { remainder, modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * Also, return null if the array is less than 3 elements long.\n   * @param nums array of operands\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] nums","parameterName":"nums"}],"methodName":"modulus","methodQualifiedSignature":"plume.MathMDE.modulus","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\nThe largest possible modulus is used, and the trivial constraint that all\nintegers are equal to 0 mod 1 is not returned (null is returned instead).\nAlso, return null if the array is less than 3 elements long.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 824,col 23)-(line 824,col 23)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 825,col 14)-(line 825,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 829,col 21)-(line 829,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 829,col 39)-(line 829,col 39)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 830,col 14)-(line 830,col 17)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 833,col 27)-(line 833,col 27)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 834,col 21)-(line 834,col 21)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"iterator of operands","javadocBlockTagName":"itor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#modulus(long[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus(long[])'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] modulus_long(Iterator<Long> itor)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        long i = itor.next().longValue();\n        if (i == avalue) {\n            continue;\n        }\n        modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n        count++;\n        if (modulus == 1) {\n            return null;\n        }\n    }\n    if (count < 3) {\n        return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n}","methodRange":"(line 851,col 3)-(line 879,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] modulus_long(Iterator<Long> itor) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long avalue = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long modulus = Math.abs(avalue - itor.next().longValue());\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      long i = itor.next().longValue();\n      if (i == avalue) {\n        continue;\n      }\n      modulus = MathMDE.gcd(modulus, Math.abs(avalue - i));\n      count++;\n      if (modulus == 1) {\n        return null;\n      }\n      }\n    if (count < 3) {\n      return null;\n    }\n    return new long[] { MathMDE.mod_positive(avalue, modulus), modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't already\n   * exist, because this does not necessarily examine every value produced by\n   * its iterator.\n   * @param itor iterator of operands\n   * @return an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus(long[])\n   ","methodParameters":[{"parameterType":"Iterator<Long>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Long>","parameter":"Iterator<Long> itor","parameterName":"itor"}],"methodName":"modulus_long","methodQualifiedSignature":"plume.MathMDE.modulus_long","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The iterator produces Long values.\nThis can be more efficient than modulus(long[]) if the long[] doesn't already\nexist, because this does not necessarily examine every value produced by\nits iterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in itor is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus(long[])'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 853,col 14)-(line 853,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 857,col 14)-(line 857,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 860,col 20)-(line 860,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 861,col 14)-(line 861,col 17)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 863,col 17)-(line 863,col 17)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 871,col 22)-(line 871,col 22)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 872,col 16)-(line 872,col 19)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 875,col 17)-(line 875,col 17)","literalExprId":8,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 876,col 14)-(line 876,col 17)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus_long(java.util.Iterator<java.lang.Long>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether endpoints are NOT subject to the strict density requirement","javadocBlockTagName":"nonstrict_ends","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] modulus_strict(long[] nums, boolean nonstrict_ends)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length < 3) {\n        return null;\n    }\n    int first_index = 0;\n    int last_index = nums.length - 1;\n    long first_nonstrict = 0;\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = nums[first_index];\n        first_index++;\n        last_nonstrict = nums[last_index];\n        last_index--;\n    }\n    if (last_index - first_index < 2) {\n        return null;\n    }\n    long modulus = nums[first_index + 1] - nums[first_index];\n    if (modulus == 1) {\n        return null;\n    }\n    for (int i = first_index + 2; i <= last_index; i++) {\n        if (nums[i] - nums[i - 1] != modulus) {\n            return null;\n        }\n    }\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}","methodRange":"(line 905,col 3)-(line 943,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] modulus_strict(long[] nums, boolean nonstrict_ends) {\n    if (nums.length < 3) {\n      return null;\n    }\n\n    int first_index = 0;\n    int last_index = nums.length-1;\n    long first_nonstrict = 0; \/\/ arbitrary initial value\n    long last_nonstrict = 0; \/\/ arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = nums[first_index];\n      first_index++;\n      last_nonstrict = nums[last_index];\n      last_index--;\n    }\n    if (last_index - first_index < 2) {\n      return null;\n    }\n\n    long modulus = nums[first_index+1] - nums[first_index];\n    if (modulus == 1) {\n      return null;\n    }\n    for (int i=first_index+2; i<=last_index; i++) {\n      if (nums[i] - nums[i-1] != modulus) {\n        return null;\n      }\n    }\n\n    long r = mod_positive(nums[first_index], modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\n   * The largest possible modulus is used, and the trivial constraint that all\n   * integers are equal to 0 mod 1 is not returned (null is returned instead).\n   * <p>\n   *\n   * This \"_strict\" version requires its input to be sorted, and no element\n   * may be missing.\n   * <p>\n   *\n   * This \"_strict\" version differs from the regular modulus by requiring\n   * that the argument be dense:  that is, every pair of numbers in the\n   * argument array is separated by exactly the modulus.\n   * <p>\n   *\n   * The endpoints can be treated in two different ways:  Either exactly\n   * like other numbers in the input, or they can merely be checked for the\n   * condition without the strict density requirement.\n   *\n   * @param nums array of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the array contains fewer than 3 elements\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] nums","parameterName":"nums"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean nonstrict_ends","parameterName":"nonstrict_ends"}],"methodName":"modulus_strict","methodQualifiedSignature":"plume.MathMDE.modulus_strict","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m).\nThe largest possible modulus is used, and the trivial constraint that all\nintegers are equal to 0 mod 1 is not returned (null is returned instead).\n<p>\n\nThis \"_strict\" version requires its input to be sorted, and no element\nmay be missing.\n<p>\n\nThis \"_strict\" version differs from the regular modulus by requiring\nthat the argument be dense:  that is, every pair of numbers in the\nargument array is separated by exactly the modulus.\n<p>\n\nThe endpoints can be treated in two different ways:  Either exactly\nlike other numbers in the input, or they can merely be checked for the\ncondition without the strict density requirement.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the array contains fewer than 3 elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 906,col 23)-(line 906,col 23)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 907,col 14)-(line 907,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 910,col 23)-(line 910,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 911,col 34)-(line 911,col 34)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 912,col 28)-(line 912,col 28)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 913,col 27)-(line 913,col 27)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 920,col 36)-(line 920,col 36)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 921,col 14)-(line 921,col 17)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 924,col 37)-(line 924,col 37)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 925,col 20)-(line 925,col 20)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 926,col 14)-(line 926,col 17)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 928,col 28)-(line 928,col 28)","literalExprId":12,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 929,col 28)-(line 929,col 28)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 930,col 16)-(line 930,col 19)","literalExprId":14,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 938,col 16)-(line 938,col 19)","literalExprId":15,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus_strict(long[], boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"iterator of operands","javadocBlockTagName":"itor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether endpoints are NOT subject to the strict density requirement","javadocBlockTagName":"nonstrict_ends","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#modulus_strict(int[], boolean)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus_strict(int[], boolean)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long first_nonstrict = 0;\n    long last_nonstrict = 0;\n    if (nonstrict_ends) {\n        first_nonstrict = itor.next().longValue();\n    }\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n        return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next - prev;\n    if (modulus == 1) {\n        return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n        prev = next;\n        next = itor.next().longValue();\n        if (nonstrict_ends && (!itor.hasNext())) {\n            last_nonstrict = next;\n            break;\n        }\n        if (next - prev != modulus) {\n            return null;\n        }\n        count++;\n    }\n    if (count < 3) {\n        return null;\n    }\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n        if ((r != mod_positive(first_nonstrict, modulus)) || (r != mod_positive(last_nonstrict, modulus))) {\n            return null;\n        }\n    }\n    return new long[] { r, modulus };\n}","methodRange":"(line 958,col 3)-(line 1005,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] modulus_strict_long(Iterator<Long> itor, boolean nonstrict_ends) {\n    if (!itor.hasNext()) {\n      return null;\n    }\n\n    long first_nonstrict = 0;    \/\/ arbitrary initial value\n    long last_nonstrict = 0;     \/\/ arbitrary initial value\n    if (nonstrict_ends) {\n      first_nonstrict = itor.next().longValue();\n    }\n\n    long prev = itor.next().longValue();\n    if (!itor.hasNext()) {\n      return null;\n    }\n    long next = itor.next().longValue();\n    long modulus = next-prev;\n    if (modulus == 1) {\n      return null;\n    }\n    int count = 2;\n    while (itor.hasNext()) {\n      prev = next;\n      next = itor.next().longValue();\n      if (nonstrict_ends && (! itor.hasNext())) {\n        last_nonstrict = next;\n        break;\n      }\n\n      if (next - prev != modulus) {\n        return null;\n      }\n      count++;\n    }\n    if (count < 3) {\n      return null;\n    }\n\n    long r = MathMDE.mod_positive(next, modulus);\n    if (nonstrict_ends) {\n      if ((r != mod_positive(first_nonstrict, modulus))\n          || (r != mod_positive(last_nonstrict, modulus))) {\n        return null;\n      }\n    }\n\n    return new long[] { r, modulus };\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * The iterator produces Long values.\n   * This can be more efficient than modulus(long[]) if the long[] doesn't\n   * already exist, because this does not necessarily examine every value\n   * produced by its iterator.\n   * <p>\n   * For documentation, see {@link #modulus_strict(long[], boolean)}.\n   * @param itor iterator of operands\n   * @param nonstrict_ends whether endpoints are NOT subject to the strict density requirement\n   * @return an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n   *   or null if no such exists or the iterator contains fewer than 3 elements\n   * @see #modulus_strict(int[], boolean)\n   ","methodParameters":[{"parameterType":"Iterator<Long>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Long>","parameter":"Iterator<Long> itor","parameterName":"itor"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean nonstrict_ends","parameterName":"nonstrict_ends"}],"methodName":"modulus_strict_long","methodQualifiedSignature":"plume.MathMDE.modulus_strict_long","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The iterator produces Long values.\nThis can be more efficient than modulus(long[]) if the long[] doesn't\nalready exist, because this does not necessarily examine every value\nproduced by its iterator.\n<p>\nFor documentation, see '}, JavadocInlineTag{tagName='link', type=LINK, content=' #modulus_strict(long[], boolean)'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='iterator of operands'}]}', name=Optional[itor]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether endpoints are NOT subject to the strict density requirement'}]}', name=Optional[nonstrict_ends]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of two integers (r,m) such that each number in NUMS is equal to r (mod m),\n  or null if no such exists or the iterator contains fewer than 3 elements'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#modulus_strict(int[], boolean)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 960,col 14)-(line 960,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 963,col 28)-(line 963,col 28)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 964,col 27)-(line 964,col 27)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 971,col 14)-(line 971,col 17)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 975,col 20)-(line 975,col 20)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 976,col 14)-(line 976,col 17)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 978,col 17)-(line 978,col 17)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 988,col 16)-(line 988,col 19)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 992,col 17)-(line 992,col 17)","literalExprId":9,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 993,col 14)-(line 993,col 17)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1000,col 16)-(line 1000,col 19)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.modulus_strict_long(java.util.Iterator<java.lang.Long>, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"numbers to be excluded; length &gt; 0","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='numbers to be excluded; length &gt; 0'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the set: [min(nums)..max(nums)] - nums","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the set: [min(nums)..max(nums)] - nums'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] missing_numbers(int[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    {\n        int[] nums_copy = new int[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n    }\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length - 1];\n    int[] result = new int[max - min + 1 - nums.length];\n    int result_index = 0;\n    int val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            result[result_index] = val;\n            result_index++;\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    if (result_index == result.length) {\n        return result;\n    } else {\n        int[] new_result = new int[result_index];\n        System.arraycopy(result, 0, new_result, 0, result_index);\n        return new_result;\n    }\n}","methodRange":"(line 1020,col 3)-(line 1051,col 3)","methodTokenRange":"public static int[] missing_numbers(int[] nums) {\n    { \/\/ avoid modifying parameter\n      int[] nums_copy = new int[nums.length];\n      System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n      nums = nums_copy;\n    }\n    Arrays.sort(nums);\n    int min = nums[0];\n    int max = nums[nums.length-1];\n    int[] result = new int[max - min + 1 - nums.length];\n    int result_index = 0;\n    int val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        result[result_index] = val;\n        result_index++;\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    if (result_index == result.length) {\n      return result;\n    } else {\n      \/\/ There were duplicates in the nums array, so we didn't fill up\n      \/\/ the result array.\n      int[] new_result = new int[result_index];\n      System.arraycopy(result, 0, new_result, 0, result_index);\n      return new_result;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return an array containing all the numbers <b>not<\/b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0\n   * @return the set: [min(nums)..max(nums)] - nums\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] nums","parameterName":"nums"}],"methodName":"missing_numbers","methodQualifiedSignature":"plume.MathMDE.missing_numbers","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array containing all the numbers <b>not<\/b> in its argument\narray (which must be non-empty)\nbut in the argument's range; that is, bigger than its argument's\nminimum value and smaller than its argument's maximum value.\nThe result contains no duplicates and is in order.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='numbers to be excluded; length &gt; 0'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the set: [min(nums)..max(nums)] - nums'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1023,col 30)-(line 1023,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1023,col 44)-(line 1023,col 44)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1027,col 20)-(line 1027,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1028,col 32)-(line 1028,col 32)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1029,col 40)-(line 1029,col 40)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1030,col 24)-(line 1030,col 24)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1032,col 16)-(line 1032,col 16)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1048,col 32)-(line 1048,col 32)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1048,col 47)-(line 1048,col 47)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.missing_numbers(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a (remainder, modulus) pair that fails to match elements of nums","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] nonmodulus_strict(int[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length == 0) {\n        return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}","methodRange":"(line 1179,col 3)-(line 1191,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] nonmodulus_strict(int[] nums) {\n    \/\/ This implementation is particularly inefficient; find a better way to\n    \/\/ compute this.  Perhaps obtain the new modulus numbers incrementally\n    \/\/ instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    int range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] nums","parameterName":"nums"}],"methodName":"nonmodulus_strict","methodQualifiedSignature":"plume.MathMDE.nonmodulus_strict","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a tuple of (r,m) where no number in NUMS is equal to r (mod\nm) but all missing numbers in their range are.  Returns null if the\ninput array has 0 length.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1183,col 24)-(line 1183,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1184,col 14)-(line 1184,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1187,col 17)-(line 1187,col 21)","literalExprId":3,"literalExpr":"65536","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1188,col 14)-(line 1188,col 17)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1190,col 79)-(line 1190,col 82)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_strict(int[])"},{"methodDeclaration":"private static int[] nonmodulus_strict_int_internal(Iterator<Integer> missing)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n        return result;\n    }\n    if (!check_first_and_last_nonmodulus(result, missing_nums)) {\n        return null;\n    }\n    return result;\n}","methodRange":"(line 1193,col 3)-(line 1208,col 3)","methodTokenRange":"private static int \/*@Nullable*\/ [] nonmodulus_strict_int_internal(Iterator<Integer> missing) {\n    \/\/ Must not use regular modulus:  that can produce errors, eg\n    \/\/ nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    \/\/ modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Integer> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Integer>(missing);\n    int[] result = modulus_strict_int(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Iterator<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Integer>","parameter":"Iterator<Integer> missing","parameterName":"missing"}],"methodName":"nonmodulus_strict_int_internal","methodQualifiedSignature":"plume.MathMDE.nonmodulus_strict_int_internal","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1199,col 53)-(line 1199,col 57)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1200,col 19)-(line 1200,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1204,col 14)-(line 1204,col 17)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_strict_int_internal(java.util.Iterator<java.lang.Integer>)"},{"javadocBlockTags":[],"methodDeclaration":"private static boolean check_first_and_last_nonmodulus(int[] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m)) && (r != mod_positive(last, m)));\n}","methodRange":"(line 1211,col 3)-(line 1218,col 3)","methodTokenRange":"private static boolean check_first_and_last_nonmodulus(int[] rm, UtilMDE.RemoveFirstAndLastIterator<Integer> rfali) {\n    int r = rm[0];\n    int m = rm[1];\n    int first = rfali.getFirst().intValue();\n    int last = rfali.getLast().intValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" The first argument is an array containing two elements. ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] rm","parameterName":"rm"},{"parameterType":"UtilMDE.RemoveFirstAndLastIterator<Integer>","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.UtilMDE.RemoveFirstAndLastIterator, typeParametersMap=TypeParametersMap{nameToValue={plume.UtilMDE.RemoveFirstAndLastIterator.T=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"plume.UtilMDE.RemoveFirstAndLastIterator<java.lang.Integer>","parameter":"UtilMDE.RemoveFirstAndLastIterator<Integer> rfali","parameterName":"rfali"}],"methodName":"check_first_and_last_nonmodulus","methodQualifiedSignature":"plume.MathMDE.check_first_and_last_nonmodulus","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The first argument is an array containing two elements.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1212,col 16)-(line 1212,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1213,col 16)-(line 1213,col 16)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.check_first_and_last_nonmodulus(int[], plume.UtilMDE.RemoveFirstAndLastIterator<java.lang.Integer>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a (remainder, modulus) pair that fails to match elements of nums","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] nonmodulus_strict_int(Iterator<Integer> nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n}","methodRange":"(line 1226,col 3)-(line 1228,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] nonmodulus_strict_int(Iterator<Integer> nums) {\n    return nonmodulus_strict_int_internal(new MissingNumbersIteratorInt(nums, true));\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   ","methodParameters":[{"parameterType":"Iterator<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Integer>","parameter":"Iterator<Integer> nums","parameterName":"nums"}],"methodName":"nonmodulus_strict_int","methodQualifiedSignature":"plume.MathMDE.nonmodulus_strict_int","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a tuple of (r,m) where no number in NUMS is equal to r (mod\nm) but all missing numbers in their range are.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1227,col 79)-(line 1227,col 82)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_strict_int(java.util.Iterator<java.lang.Integer>)"},{"methodDeclaration":"public static int[] nonmodulus_nonstrict(int[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = Math.min(nums.length \/ 2, ArraysMDE.element_range(nums) \/ 2);\n    for (int m = 2; m <= max_modulus; m++) {\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            int rem = mod_positive(nums[i], m);\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                if (num_nonmodulus == 0) {\n                    break;\n                }\n            }\n        }\n        if (num_nonmodulus == 1) {\n            return new int[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}","methodRange":"(line 1260,col 3)-(line 1293,col 3)","methodTokenRange":"public static int \/*@Nullable*\/ [] nonmodulus_nonstrict(int[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = Math.min(nums.length\/2, ArraysMDE.element_range(nums)\/2);\n\n    \/\/ System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    \/\/ no real sense checking 2, as common_modulus would have found it, but\n    \/\/ include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      \/\/ System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; \/\/ initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        int rem = mod_positive(nums[i], m);\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          \/\/ System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            \/\/ Quit as soon as we see every remainder instead of processing\n            \/\/ each element of the input list.\n            break;\n          }\n        }\n      }\n      \/\/ System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new int[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":" model was wrong); use nonmodulus_strict instead.","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] nums","parameterName":"nums"}],"methodName":"nonmodulus_nonstrict","methodQualifiedSignature":"plume.MathMDE.nonmodulus_nonstrict","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1261,col 23)-(line 1261,col 23)","literalExprId":1,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1262,col 14)-(line 1262,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1264,col 44)-(line 1264,col 44)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1264,col 77)-(line 1264,col 77)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 16)-(line 1270,col 16)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 18)-(line 1274,col 18)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 30)-(line 1277,col 33)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1280,col 33)-(line 1280,col 33)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1288,col 29)-(line 1288,col 29)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1289,col 58)-(line 1289,col 62)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1292,col 12)-(line 1292,col 15)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_nonstrict(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"numbers to be excluded; length &gt; 0","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='numbers to be excluded; length &gt; 0'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the set: [min(nums)..max(nums)] - nums","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the set: [min(nums)..max(nums)] - nums'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] missing_numbers(long[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    {\n        long[] nums_copy = new long[nums.length];\n        System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n        nums = nums_copy;\n    }\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length - 1];\n    long[] result = new long[((int) (max - min + 1 - nums.length))];\n    int result_index = 0;\n    long val = min;\n    for (int i = 0; i < nums.length; i++) {\n        while (val < nums[i]) {\n            result[result_index] = val;\n            result_index++;\n            val++;\n        }\n        if (val == nums[i]) {\n            val++;\n        }\n    }\n    if (result_index == result.length) {\n        return result;\n    } else {\n        long[] new_result = new long[result_index];\n        System.arraycopy(result, 0, new_result, 0, result_index);\n        return new_result;\n    }\n}","methodRange":"(line 1306,col 3)-(line 1337,col 3)","methodTokenRange":"public static long[] missing_numbers(long[] nums) {\n    { \/\/ avoid modifying parameter\n      long[] nums_copy = new long[nums.length];\n      System.arraycopy(nums, 0, nums_copy, 0, nums.length);\n      nums = nums_copy;\n    }\n    Arrays.sort(nums);\n    long min = nums[0];\n    long max = nums[nums.length-1];\n    long[] result = new long[((int) (max - min + 1 - nums.length))];\n    int result_index = 0;\n    long val = min;\n    for (int i=0; i<nums.length; i++) {\n      while (val < nums[i]) {\n        result[result_index] = val;\n        result_index++;\n        val++;\n      }\n      if (val == nums[i]) {\n        val++;\n      }\n    }\n    if (result_index == result.length) {\n      return result;\n    } else {\n      \/\/ There were duplicates in the nums array, so we didn't fill up\n      \/\/ the result array.\n      long[] new_result = new long[result_index];\n      System.arraycopy(result, 0, new_result, 0, result_index);\n      return new_result;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return an array containing all the numbers <b>not<\/b> in its argument\n   * array (which must be non-empty)\n   * but in the argument's range; that is, bigger than its argument's\n   * minimum value and smaller than its argument's maximum value.\n   * The result contains no duplicates and is in order.\n   * @param nums numbers to be excluded; length &gt; 0\n   * @return the set: [min(nums)..max(nums)] - nums\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] nums","parameterName":"nums"}],"methodName":"missing_numbers","methodQualifiedSignature":"plume.MathMDE.missing_numbers","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array containing all the numbers <b>not<\/b> in its argument\narray (which must be non-empty)\nbut in the argument's range; that is, bigger than its argument's\nminimum value and smaller than its argument's maximum value.\nThe result contains no duplicates and is in order.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='numbers to be excluded; length &gt; 0'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the set: [min(nums)..max(nums)] - nums'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1309,col 30)-(line 1309,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1309,col 44)-(line 1309,col 44)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1313,col 21)-(line 1313,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1314,col 33)-(line 1314,col 33)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1315,col 50)-(line 1315,col 50)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1316,col 24)-(line 1316,col 24)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1318,col 16)-(line 1318,col 16)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1334,col 32)-(line 1334,col 32)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1334,col 47)-(line 1334,col 47)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.missing_numbers(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a (remainder, modulus) pair that fails to match elements of nums","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] nonmodulus_strict(long[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length == 0) {\n        return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n        return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}","methodRange":"(line 1465,col 3)-(line 1477,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] nonmodulus_strict(long[] nums) {\n    \/\/ This implementation is particularly inefficient; find a better way to\n    \/\/ compute this.  Perhaps obtain the new modulus numbers incrementally\n    \/\/ instead of all at once.\n    if (nums.length == 0) {\n      return null;\n    }\n    long range = ArraysMDE.element_range(nums);\n    if (range > 65536) {\n      return null;\n    }\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.  Returns null if the\n   * input array has 0 length.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] nums","parameterName":"nums"}],"methodName":"nonmodulus_strict","methodQualifiedSignature":"plume.MathMDE.nonmodulus_strict","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a tuple of (r,m) where no number in NUMS is equal to r (mod\nm) but all missing numbers in their range are.  Returns null if the\ninput array has 0 length.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1469,col 24)-(line 1469,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1470,col 14)-(line 1470,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1473,col 17)-(line 1473,col 21)","literalExprId":3,"literalExpr":"65536","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1474,col 14)-(line 1474,col 17)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1476,col 81)-(line 1476,col 84)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_strict(long[])"},{"methodDeclaration":"private static long[] nonmodulus_strict_long_internal(Iterator<Long> missing)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n        return result;\n    }\n    if (!check_first_and_last_nonmodulus(result, missing_nums)) {\n        return null;\n    }\n    return result;\n}","methodRange":"(line 1479,col 3)-(line 1494,col 3)","methodTokenRange":"private static long \/*@Nullable*\/ [] nonmodulus_strict_long_internal(Iterator<Long> missing) {\n    \/\/ Must not use regular modulus:  that can produce errors, eg\n    \/\/ nonmodulus_strict({1,2,3,5,6,7,9,11}) => {0,2}.  Thus, use\n    \/\/ modulus_strict.\n    UtilMDE.RemoveFirstAndLastIterator<Long> missing_nums\n      = new UtilMDE.RemoveFirstAndLastIterator<Long>(missing);\n    long[] result = modulus_strict_long(missing_nums, false);\n    if (result == null) {\n      return result;\n    }\n    if (! check_first_and_last_nonmodulus(result, missing_nums)) {\n      return null;\n    }\n\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Iterator<Long>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Long>","parameter":"Iterator<Long> missing","parameterName":"missing"}],"methodName":"nonmodulus_strict_long_internal","methodQualifiedSignature":"plume.MathMDE.nonmodulus_strict_long_internal","methodJavadoc":"","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1485,col 55)-(line 1485,col 59)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1486,col 19)-(line 1486,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1490,col 14)-(line 1490,col 17)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_strict_long_internal(java.util.Iterator<java.lang.Long>)"},{"javadocBlockTags":[],"methodDeclaration":"private static boolean check_first_and_last_nonmodulus(long[] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m)) && (r != mod_positive(last, m)));\n}","methodRange":"(line 1497,col 3)-(line 1504,col 3)","methodTokenRange":"private static boolean check_first_and_last_nonmodulus(long[] rm, UtilMDE.RemoveFirstAndLastIterator<Long> rfali) {\n    long r = rm[0];\n    long m = rm[1];\n    long first = rfali.getFirst().longValue();\n    long last = rfali.getLast().longValue();\n    return ((r != mod_positive(first, m))\n            && (r != mod_positive(last, m)));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" The first argument is an array containing two elements. ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] rm","parameterName":"rm"},{"parameterType":"UtilMDE.RemoveFirstAndLastIterator<Long>","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.UtilMDE.RemoveFirstAndLastIterator, typeParametersMap=TypeParametersMap{nameToValue={plume.UtilMDE.RemoveFirstAndLastIterator.T=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"plume.UtilMDE.RemoveFirstAndLastIterator<java.lang.Long>","parameter":"UtilMDE.RemoveFirstAndLastIterator<Long> rfali","parameterName":"rfali"}],"methodName":"check_first_and_last_nonmodulus","methodQualifiedSignature":"plume.MathMDE.check_first_and_last_nonmodulus","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The first argument is an array containing two elements.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1498,col 17)-(line 1498,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1499,col 17)-(line 1499,col 17)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.check_first_and_last_nonmodulus(long[], plume.UtilMDE.RemoveFirstAndLastIterator<java.lang.Long>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list of operands","javadocBlockTagName":"nums","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a (remainder, modulus) pair that fails to match elements of nums","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] nonmodulus_strict_long(Iterator<Long> nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n}","methodRange":"(line 1512,col 3)-(line 1514,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] nonmodulus_strict_long(Iterator<Long> nums) {\n    return nonmodulus_strict_long_internal(new MissingNumbersIteratorLong(nums, true));\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return a tuple of (r,m) where no number in NUMS is equal to r (mod\n   * m) but all missing numbers in their range are.\n   * @param nums the list of operands\n   * @return a (remainder, modulus) pair that fails to match elements of nums\n   ","methodParameters":[{"parameterType":"Iterator<Long>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Long>","parameter":"Iterator<Long> nums","parameterName":"nums"}],"methodName":"nonmodulus_strict_long","methodQualifiedSignature":"plume.MathMDE.nonmodulus_strict_long","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a tuple of (r,m) where no number in NUMS is equal to r (mod\nm) but all missing numbers in their range are.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of operands'}]}', name=Optional[nums]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a (remainder, modulus) pair that fails to match elements of nums'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1513,col 81)-(line 1513,col 84)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_strict_long(java.util.Iterator<java.lang.Long>)"},{"methodDeclaration":"public static long[] nonmodulus_nonstrict(long[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (nums.length < 4) {\n        return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length \/ 2, ArraysMDE.element_range(nums) \/ 2)));\n    for (int m = 2; m <= max_modulus; m++) {\n        boolean[] has_modulus = new boolean[m];\n        int num_nonmodulus = m;\n        for (int i = 0; i < nums.length; i++) {\n            int rem = ((int) (mod_positive(nums[i], m)));\n            if (!has_modulus[rem]) {\n                has_modulus[rem] = true;\n                num_nonmodulus--;\n                if (num_nonmodulus == 0) {\n                    break;\n                }\n            }\n        }\n        if (num_nonmodulus == 1) {\n            return new long[] { ArraysMDE.indexOf(has_modulus, false), m };\n        }\n    }\n    return null;\n}","methodRange":"(line 1546,col 3)-(line 1579,col 3)","methodTokenRange":"public static long \/*@Nullable*\/ [] nonmodulus_nonstrict(long[] nums) {\n    if (nums.length < 4) {\n      return null;\n    }\n    int max_modulus = ((int) (Math.min(nums.length\/2, ArraysMDE.element_range(nums)\/2)));\n\n    \/\/ System.out.println(\"nums.length=\" + nums.length + \", range=\" + ArraysMDE.element_range(nums) + \", max_modulus=\" + max_modulus);\n\n    \/\/ no real sense checking 2, as common_modulus would have found it, but\n    \/\/ include it to make this function stand on its own\n    for (int m=2; m<=max_modulus; m++) {\n      \/\/ System.out.println(\"Trying m=\" + m);\n      boolean[] has_modulus = new boolean[m]; \/\/ initialized to false?\n      int num_nonmodulus = m;\n      for (int i=0; i<nums.length; i++) {\n        int rem = ((int) (mod_positive(nums[i], m)));\n        if (!has_modulus[rem]) {\n          has_modulus[rem] = true;\n          num_nonmodulus--;\n          \/\/ System.out.println(\"rem=\" + rem + \" for \" + nums[i] + \"; num_nonmodulus=\" + num_nonmodulus);\n          if (num_nonmodulus == 0) {\n            \/\/ Quit as soon as we see every remainder instead of processing\n            \/\/ each element of the input list.\n            break;\n          }\n        }\n      }\n      \/\/ System.out.println(\"For m=\" + m + \", num_nonmodulus=\" + num_nonmodulus);\n      if (num_nonmodulus == 1) {\n        return new long[] {ArraysMDE.indexOf(has_modulus, false), m};\n      }\n    }\n    return null;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":" model was wrong); use nonmodulus_strict instead.","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] nums","parameterName":"nums"}],"methodName":"nonmodulus_nonstrict","methodQualifiedSignature":"plume.MathMDE.nonmodulus_nonstrict","methodJavadoc":"","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1547,col 23)-(line 1547,col 23)","literalExprId":1,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1548,col 14)-(line 1548,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1550,col 52)-(line 1550,col 52)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1550,col 85)-(line 1550,col 85)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1556,col 16)-(line 1556,col 16)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1560,col 18)-(line 1560,col 18)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1563,col 30)-(line 1563,col 33)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1566,col 33)-(line 1566,col 33)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1574,col 29)-(line 1574,col 29)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1575,col 59)-(line 1575,col 63)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1578,col 12)-(line 1578,col 15)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MathMDE.nonmodulus_nonstrict(long[])"}],"classJavadoc":"\/**\n * Mathematical utilities.\n *\/\n","className":"MathMDE","fields":[]}],"sourceFileId":2,"packageName":"plume"},{"sourceFileName":"plume.DeterministicObject","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.DeterministicObject.DeterministicObject()","variableDeclarationExprs":[],"constructorRange":"(line 35,col 3)-(line 35,col 33)","constructorJavadocComment":" Create a DeterministicObject. ","constructorDeclaration":"public DeterministicObject()","constructorBody":"{\n}","constructorName":"DeterministicObject","constructorQualifiedName":"plume.DeterministicObject.DeterministicObject","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public DeterministicObject() {}","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a DeterministicObject.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return uid;\n}","methodRange":"(line 37,col 3)-(line 40,col 3)","methodTokenRange":"@Override\n  public int hashCode(\/*>>>@GuardSatisfied DeterministicObject this*\/) {\n    return uid;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"plume.DeterministicObject.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.DeterministicObject.hashCode()"}],"classJavadoc":"\/**\n * This is a deterministic version of the {@link Object} class.  To remove\n * one source of nondeterminism from your program, do not instantiate the\n * Object class, as in {@code new Object()}; instead do {@code new\n * DeterministicObject()}.\n * <p>\n *\n * This class differs from Object in that it overrides {@link #hashCode()}.\n * Any use of {@code Object.hashCode()} is nondeterministic because the\n * return value of {@code Object.hashCode()} depends on when the garbage\n * collector runs.  That nondeterminism can affect the iteration order of\n * HashMaps and HashSets.\n *\/\n","className":"DeterministicObject","fields":[{"fieldRange":"(line 29,col 3)-(line 29,col 25)","fieldName":"counter","fieldJavadocComment":" The number of objects created so far. ","fieldTokenRange":"static int counter = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 29,col 24)-(line 29,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"int","fieldJavadoc":"The number of objects created so far.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 32,col 3)-(line 32,col 28)","fieldName":"uid","fieldJavadocComment":" The unique ID for this object. ","fieldTokenRange":"final int uid = counter++;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[counter++]","fieldType":"int","fieldJavadoc":"The unique ID for this object.\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":3,"packageName":"plume"},{"sourceFileName":"plume.Digest","imports":[{"importId":1,"import":"import java.io.FileInputStream;\n"},{"importId":2,"import":"import java.io.IOException;\n"},{"importId":3,"import":"import java.security.DigestInputStream;\n"},{"importId":4,"import":"import java.security.MessageDigest;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.Digest.Digest()","variableDeclarationExprs":[],"constructorRange":"(line 17,col 3)-(line 19,col 3)","constructorJavadocComment":" This class is a collecton of methods; it does not represent anything. ","constructorDeclaration":"private Digest()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"Digest","constructorQualifiedName":"plume.Digest.Digest","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 18,col 21)-(line 18,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private Digest() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collecton of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the MessageDigest","javadocBlockTagName":"md","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the MessageDigest'}]}', name=Optional[md]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the message digest","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the message digest'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    md.reset();\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n    while (in.read(buffer) != -1) {\n    }\n    byte[] result = md.digest();\n    in.close();\n    return result;\n}","methodRange":"(line 30,col 3)-(line 48,col 3)","methodTokenRange":"public static byte[] getFileDigest(String filename, MessageDigest md) throws IOException {\n    \/\/ Make sure there is nothing left behind in the MessageDigest\n    md.reset();\n\n    \/\/ Create a stream to read from the file and compute the digest\n    DigestInputStream in = new DigestInputStream(new FileInputStream(filename), md);\n\n    \/\/ Read to the end of the file, discarding everything we read. {\n    \/\/ The DigestInputStream automatically passes all the bytes read to\n    \/\/ the update() method of the MessageDigest\n    while (in.read(buffer) != -1) {\n      \/* do nothing *\/\n    }\n\n    \/\/ Finally, compute and return the digest value.\n    byte[] result = md.digest();\n    in.close();\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","methodJavadocComment":"\n   * This convenience method is used by both create() and verify().  It\n   * reads the contents of a named file and computes a message digest\n   * for it, using the specified MessageDigest object.\n   * @param filename the file to read\n   * @param md the MessageDigest\n   * @return the message digest\n   * @throws IOException if there is a problem reading the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"MessageDigest","parameterId":2,"parameterTypeResolved":"ReferenceType{java.security.MessageDigest, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.security.MessageDigest","parameter":"MessageDigest md","parameterName":"md"}],"methodName":"getFileDigest","methodQualifiedSignature":"plume.Digest.getFileDigest","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This convenience method is used by both create() and verify().  It\nreads the contents of a named file and computes a message digest\nfor it, using the specified MessageDigest object.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the MessageDigest'}]}', name=Optional[md]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the message digest'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"byte[]","methodType":"byte[]","literalExprs":[{"literalExprRange":"(line 40,col 32)-(line 40,col 32)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Digest.getFileDigest(java.lang.String, java.security.MessageDigest)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the bytes to convert to a String","javadocBlockTagName":"bytes","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the bytes to convert to a String'}]}', name=Optional[bytes]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a String representation of the input bytes","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String representation of the input bytes'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String hexEncode(byte[] bytes)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        s.append(digits[(b & 0xf0) >> 4]);\n        s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n}","methodRange":"(line 65,col 3)-(line 73,col 3)","methodTokenRange":"public static String hexEncode(byte[] bytes) {\n    StringBuffer s = new StringBuffer(bytes.length * 2);\n    for (int i = 0; i < bytes.length; i++) {\n      byte b = bytes[i];\n      s.append(digits[(b & 0xf0) >> 4]);\n      s.append(digits[b & 0x0f]);\n    }\n    return s.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * A convenience method to convert an array of bytes to a String.  We do\n   * this simply by converting each byte to two hexadecimal digits.  Something\n   * like Base 64 encoding is more compact, but harder to encode.\n   * @param bytes the bytes to convert to a String\n   * @return a String representation of the input bytes\n   ","methodParameters":[{"parameterType":"byte[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","parameterTypeResolvedDescribed":"byte[]","parameter":"byte[] bytes","parameterName":"bytes"}],"methodName":"hexEncode","methodQualifiedSignature":"plume.Digest.hexEncode","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A convenience method to convert an array of bytes to a String.  We do\nthis simply by converting each byte to two hexadecimal digits.  Something\nlike Base 64 encoding is more compact, but harder to encode.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the bytes to convert to a String'}]}', name=Optional[bytes]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String representation of the input bytes'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 66,col 54)-(line 66,col 54)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 67,col 18)-(line 67,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 69,col 28)-(line 69,col 31)","literalExprId":3,"literalExpr":"0xf0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 69,col 37)-(line 69,col 37)","literalExprId":4,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 70,col 27)-(line 70,col 30)","literalExprId":5,"literalExpr":"0x0f","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Digest.hexEncode(byte[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the String to convert to an array of bytes","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the String to convert to an array of bytes'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the bytes equivalent to the input String","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the bytes equivalent to the input String'}]}', name=Optional.empty}"}],"methodDeclaration":"public static byte[] hexDecode(String s) throws IllegalArgumentException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        int len = s.length();\n        byte[] r = new byte[len \/ 2];\n        for (int i = 0; i < r.length; i++) {\n            int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n            if ((digit1 >= '0') && (digit1 <= '9')) {\n                digit1 -= '0';\n            } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n                digit1 -= 'a' - 10;\n            }\n            if ((digit2 >= '0') && (digit2 <= '9')) {\n                digit2 -= '0';\n            } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n                digit2 -= 'a' - 10;\n            }\n            r[i] = (byte) ((digit1 << 4) + digit2);\n        }\n        return r;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n}","methodRange":"(line 82,col 3)-(line 104,col 3)","methodTokenRange":"public static byte[] hexDecode(String s) throws IllegalArgumentException {\n    try {\n      int len = s.length();\n      byte[] r = new byte[len \/ 2];\n      for (int i = 0; i < r.length; i++) {\n        int digit1 = s.charAt(i * 2), digit2 = s.charAt(i * 2 + 1);\n        if ((digit1 >= '0') && (digit1 <= '9')) {\n          digit1 -= '0';\n        } else if ((digit1 >= 'a') && (digit1 <= 'f')) {\n          digit1 -= 'a' - 10;\n        }\n        if ((digit2 >= '0') && (digit2 <= '9')) {\n          digit2 -= '0';\n        } else if ((digit2 >= 'a') && (digit2 <= 'f')) {\n          digit2 -= 'a' - 10;\n        }\n        r[i] = (byte) ((digit1 << 4) + digit2);\n      }\n      return r;\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"hexDecode(): invalid input\");\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","methodJavadocComment":"\n   * A convenience method to convert from a string\n   * of hexadecimal digits to an array of bytes.\n   * This method is the reverse of {@link #hexEncode(byte[])}.\n   * @param s the String to convert to an array of bytes\n   * @return the bytes equivalent to the input String\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"hexDecode","methodQualifiedSignature":"plume.Digest.hexDecode","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A convenience method to convert from a string\nof hexadecimal digits to an array of bytes.\nThis method is the reverse of '}, JavadocInlineTag{tagName='link', type=LINK, content=' #hexEncode(byte[])'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the String to convert to an array of bytes'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the bytes equivalent to the input String'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"byte[]","methodType":"byte[]","literalExprs":[{"literalExprRange":"(line 85,col 33)-(line 85,col 33)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 86,col 20)-(line 86,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 87,col 35)-(line 87,col 35)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 87,col 61)-(line 87,col 61)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 87,col 65)-(line 87,col 65)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 88,col 24)-(line 88,col 26)","literalExprId":6,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 88,col 43)-(line 88,col 45)","literalExprId":7,"literalExpr":"'9'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 89,col 21)-(line 89,col 23)","literalExprId":8,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 90,col 31)-(line 90,col 33)","literalExprId":9,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 90,col 50)-(line 90,col 52)","literalExprId":10,"literalExpr":"'f'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 91,col 21)-(line 91,col 23)","literalExprId":11,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 91,col 27)-(line 91,col 28)","literalExprId":12,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 93,col 24)-(line 93,col 26)","literalExprId":13,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 93,col 43)-(line 93,col 45)","literalExprId":14,"literalExpr":"'9'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 94,col 21)-(line 94,col 23)","literalExprId":15,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 95,col 31)-(line 95,col 33)","literalExprId":16,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 95,col 50)-(line 95,col 52)","literalExprId":17,"literalExpr":"'f'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 96,col 21)-(line 96,col 23)","literalExprId":18,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 96,col 27)-(line 96,col 28)","literalExprId":19,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 98,col 35)-(line 98,col 35)","literalExprId":20,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 102,col 42)-(line 102,col 69)","literalExprId":21,"literalExpr":"\"hexDecode(): invalid input\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Digest.hexDecode(java.lang.String)"}],"classJavadoc":"\/**\n * Computes a message digest for a file.  The primary entry point into this\n * class is {@link #getFileDigest(String,MessageDigest)}.\n *\/\n","className":"Digest","fields":[{"fieldRange":"(line 51,col 3)-(line 51,col 48)","fieldName":"buffer","fieldJavadocComment":" This static buffer is used by {@link #getFileDigest}. ","fieldTokenRange":"private static byte[] buffer = new byte[4096];","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 51,col 43)-(line 51,col 46)","literalExprId":1,"literalExpr":"4096","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[new byte[4096]]","fieldType":"byte[]","fieldJavadoc":"This static buffer is used by {@link #getFileDigest}.\n","fieldTypeResolvedDescribed":"byte[]"},{"fieldRange":"(line 54,col 3)-(line 56,col 4)","fieldName":"digits","fieldJavadocComment":" This array is used to convert from bytes to hexadecimal numbers. ","fieldTokenRange":"private static final char[] digits = {\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n  };","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 55,col 5)-(line 55,col 7)","literalExprId":1,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 10)-(line 55,col 12)","literalExprId":2,"literalExpr":"'1'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 15)-(line 55,col 17)","literalExprId":3,"literalExpr":"'2'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 20)-(line 55,col 22)","literalExprId":4,"literalExpr":"'3'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 25)-(line 55,col 27)","literalExprId":5,"literalExpr":"'4'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 30)-(line 55,col 32)","literalExprId":6,"literalExpr":"'5'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 35)-(line 55,col 37)","literalExprId":7,"literalExpr":"'6'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 40)-(line 55,col 42)","literalExprId":8,"literalExpr":"'7'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 45)-(line 55,col 47)","literalExprId":9,"literalExpr":"'8'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 50)-(line 55,col 52)","literalExprId":10,"literalExpr":"'9'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 55)-(line 55,col 57)","literalExprId":11,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 60)-(line 55,col 62)","literalExprId":12,"literalExpr":"'b'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 65)-(line 55,col 67)","literalExprId":13,"literalExpr":"'c'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 70)-(line 55,col 72)","literalExprId":14,"literalExpr":"'d'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 75)-(line 55,col 77)","literalExprId":15,"literalExpr":"'e'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 55,col 80)-(line 55,col 82)","literalExprId":16,"literalExpr":"'f'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"fieldInitializer":"Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }]","fieldType":"char[]","fieldJavadoc":"This array is used to convert from bytes to hexadecimal numbers.\n","fieldTypeResolvedDescribed":"char[]"}]}],"sourceFileId":4,"packageName":"plume"},{"sourceFileName":"plume.StringBuilderDelimited","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the delimiter to be put between strings that are\nappended to this","javadocBlockTagName":"delimiter","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the delimiter to be put between strings that are\nappended to this'}]}', name=Optional[delimiter]}"}],"constructorQualifiedSignature":"plume.StringBuilderDelimited.StringBuilderDelimited(java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 35,col 3)-(line 37,col 3)","constructorJavadocComment":" Create a new StringBuilderDelimited.\n   * @param delimiter the delimiter to be put between strings that are\n   * appended to this\n   ","constructorDeclaration":"public StringBuilderDelimited(String delimiter)","constructorBody":"{\n    this.delimiter = delimiter;\n}","constructorName":"StringBuilderDelimited","constructorQualifiedName":"plume.StringBuilderDelimited.StringBuilderDelimited","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delimiter","parameterName":"delimiter"}],"literalExprs":[],"constructorTokenRange":"public StringBuilderDelimited(String delimiter) {\n    this.delimiter = delimiter;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new StringBuilderDelimited.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the delimiter to be put between strings that are\nappended to this'}]}', name=Optional[delimiter]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"private void appendDelimiter()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (empty) {\n        empty = false;\n    } else {\n        delegate.append(delimiter);\n    }\n}","methodRange":"(line 39,col 3)-(line 45,col 3)","methodTokenRange":"private void appendDelimiter(\/*>>>@GuardSatisfied StringBuilderDelimited this*\/) {\n    if (empty) {\n      empty = false;\n    } else {\n      delegate.append(delimiter);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"appendDelimiter","methodQualifiedSignature":"plume.StringBuilderDelimited.appendDelimiter","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 41,col 15)-(line 41,col 19)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.StringBuilderDelimited.appendDelimiter()"},{"methodDeclaration":"public StringBuilderDelimited append(String str)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    appendDelimiter();\n    delegate.append(str);\n    return this;\n}","methodRange":"(line 47,col 3)-(line 51,col 3)","methodTokenRange":"public StringBuilderDelimited append(\/*@Nullable*\/ String str) {\n    appendDelimiter();\n    delegate.append(str);\n    return this;\n  }","methodReturnTypeResolved":"ReferenceType{plume.StringBuilderDelimited, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String str","parameterName":"str"}],"methodName":"append","methodQualifiedSignature":"plume.StringBuilderDelimited.append","methodJavadoc":"","methodReturnTypeDescribed":"plume.StringBuilderDelimited","methodType":"StringBuilderDelimited","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.append(java.lang.String)"},{"methodDeclaration":"public StringBuilderDelimited append(Object o)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    appendDelimiter();\n    delegate.append(o);\n    return this;\n}","methodRange":"(line 53,col 3)-(line 57,col 3)","methodTokenRange":"public StringBuilderDelimited append(\/*@Nullable*\/ Object o) {\n    appendDelimiter();\n    delegate.append(o);\n    return this;\n  }","methodReturnTypeResolved":"ReferenceType{plume.StringBuilderDelimited, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"append","methodQualifiedSignature":"plume.StringBuilderDelimited.append","methodJavadoc":"","methodReturnTypeDescribed":"plume.StringBuilderDelimited","methodType":"StringBuilderDelimited","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.append(java.lang.Object)"},{"methodDeclaration":"public StringBuilderDelimited append(char c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    appendDelimiter();\n    delegate.append(c);\n    return this;\n}","methodRange":"(line 59,col 3)-(line 63,col 3)","methodTokenRange":"public StringBuilderDelimited append(char c) {\n    appendDelimiter();\n    delegate.append(c);\n    return this;\n  }","methodReturnTypeResolved":"ReferenceType{plume.StringBuilderDelimited, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"char","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='char'}","parameterTypeResolvedDescribed":"char","parameter":"char c","parameterName":"c"}],"methodName":"append","methodQualifiedSignature":"plume.StringBuilderDelimited.append","methodJavadoc":"","methodReturnTypeDescribed":"plume.StringBuilderDelimited","methodType":"StringBuilderDelimited","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.append(char)"},{"methodDeclaration":"public StringBuilderDelimited append(CharSequence csq)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    appendDelimiter();\n    delegate.append(csq);\n    return this;\n}","methodRange":"(line 65,col 3)-(line 69,col 3)","methodTokenRange":"public StringBuilderDelimited append(\/*@Nullable*\/ CharSequence csq) {\n    appendDelimiter();\n    delegate.append(csq);\n    return this;\n  }","methodReturnTypeResolved":"ReferenceType{plume.StringBuilderDelimited, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"CharSequence","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.CharSequence","parameter":"CharSequence csq","parameterName":"csq"}],"methodName":"append","methodQualifiedSignature":"plume.StringBuilderDelimited.append","methodJavadoc":"","methodReturnTypeDescribed":"plume.StringBuilderDelimited","methodType":"StringBuilderDelimited","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.append(java.lang.CharSequence)"},{"methodDeclaration":"public StringBuilderDelimited append(CharSequence csq, int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    appendDelimiter();\n    delegate.append(csq, start, end);\n    return this;\n}","methodRange":"(line 71,col 3)-(line 75,col 3)","methodTokenRange":"public StringBuilderDelimited append(\/*@Nullable*\/ CharSequence csq, int start, int end) {\n    appendDelimiter();\n    delegate.append(csq, start, end);\n    return this;\n  }","methodReturnTypeResolved":"ReferenceType{plume.StringBuilderDelimited, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"CharSequence","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.CharSequence","parameter":"CharSequence csq","parameterName":"csq"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"append","methodQualifiedSignature":"plume.StringBuilderDelimited.append","methodJavadoc":"","methodReturnTypeDescribed":"plume.StringBuilderDelimited","methodType":"StringBuilderDelimited","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.append(java.lang.CharSequence, int, int)"},{"methodDeclaration":"public char charAt(int index)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.charAt(index);\n}","methodRange":"(line 77,col 3)-(line 79,col 3)","methodTokenRange":"public char charAt(int index) {\n    return delegate.charAt(index);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='char'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int index","parameterName":"index"}],"methodName":"charAt","methodQualifiedSignature":"plume.StringBuilderDelimited.charAt","methodJavadoc":"","methodReturnTypeDescribed":"char","methodType":"char","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.charAt(int)"},{"methodDeclaration":"public int length()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.length();\n}","methodRange":"(line 82,col 3)-(line 84,col 3)","methodTokenRange":"public int length(\/*>>>@GuardSatisfied StringBuilderDelimited this*\/) {\n    return delegate.length();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"length","methodQualifiedSignature":"plume.StringBuilderDelimited.length","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.length()"},{"methodDeclaration":"public CharSequence subSequence(int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.subSequence(start, end);\n}","methodRange":"(line 86,col 3)-(line 88,col 3)","methodTokenRange":"public CharSequence subSequence(int start, int end) {\n    return delegate.subSequence(start, end);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.CharSequence, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"subSequence","methodQualifiedSignature":"plume.StringBuilderDelimited.subSequence","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.CharSequence","methodType":"CharSequence","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.subSequence(int, int)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return delegate.toString();\n}","methodRange":"(line 91,col 3)-(line 93,col 3)","methodTokenRange":"public String toString(\/*>>>@GuardSatisfied StringBuilderDelimited this*\/) {\n    return delegate.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.StringBuilderDelimited.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.StringBuilderDelimited.toString()"}],"classJavadoc":"\/**\n * Like StringBuilder, but adds a delimiter between each pair of strings\n * that are inserted into the Stringbuilder.  This can simplify the logic of\n * programs and also avoid errors. <p>\n *\n * Does not extend StringBuilder because that would probably break, due to\n * the possibility of calling the wrong version of append.  Also, I don't\n * (yet) want to override all the methods; this simpler version seems\n * sufficient for the time being.\n *\/\n","className":"StringBuilderDelimited","fields":[{"fieldRange":"(line 25,col 3)-(line 25,col 55)","fieldName":"delegate","fieldJavadocComment":" The StringBuilder to which this delegates work. ","fieldTokenRange":"private StringBuilder delegate = new StringBuilder();","fieldTypeResolved":"ReferenceType{java.lang.StringBuilder, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new StringBuilder()]","fieldType":"StringBuilder","fieldJavadoc":"The StringBuilder to which this delegates work.\n","fieldTypeResolvedDescribed":"java.lang.StringBuilder"},{"fieldRange":"(line 27,col 3)-(line 27,col 31)","fieldName":"empty","fieldJavadocComment":" False iff some text has already been appended to this. ","fieldTokenRange":"private boolean empty = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 27,col 27)-(line 27,col 30)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"False iff some text has already been appended to this.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 29,col 3)-(line 29,col 33)","fieldName":"delimiter","fieldJavadocComment":" The delimiter put between strings appended to this. ","fieldTokenRange":"private final String delimiter;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"String","fieldJavadoc":"The delimiter put between strings appended to this.\n","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":5,"packageName":"plume"},{"sourceFileName":"plume.OrderedPairIterator","imports":[{"importId":1,"import":"import java.util.Comparator;\n"},{"importId":2,"import":"import java.util.Iterator;\n"},{"importId":3,"import":"import java.util.NoSuchElementException;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"OrderedPairIterator","constructorQualifiedName":"plume.OrderedPairIterator.OrderedPairIterator","constructorQualifiedSignature":"plume.OrderedPairIterator.OrderedPairIterator(java.util.Iterator<T>, java.util.Iterator<T>)","constructorParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor1","parameterName":"itor1"},{"parameterType":"Iterator<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor2","parameterName":"itor2"}],"literalExprs":[],"constructorTokenRange":"public OrderedPairIterator(Iterator<T> itor1, Iterator<T> itor2) {\n    this.itor1 = itor1;\n    this.itor2 = itor2;\n    setnext1();\n    setnext2();\n  }","variableDeclarationExprs":[],"constructorRange":"(line 45,col 3)-(line 50,col 3)","constructorJavadocComment":" Comparable<T>>, but T is already bound above and can't be changed.","constructorDeclaration":"public OrderedPairIterator(Iterator<T> itor1, Iterator<T> itor2)","constructorBody":"{\n    this.itor1 = itor1;\n    this.itor2 = itor2;\n    setnext1();\n    setnext2();\n}","constructorJavadoc":""},{"constructorName":"OrderedPairIterator","constructorQualifiedName":"plume.OrderedPairIterator.OrderedPairIterator","constructorQualifiedSignature":"plume.OrderedPairIterator.OrderedPairIterator(java.util.Iterator<T>, java.util.Iterator<T>, java.util.Comparator<T>)","constructorParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor1","parameterName":"itor1"},{"parameterType":"Iterator<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor2","parameterName":"itor2"},{"parameterType":"Comparator<T>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<T>","parameter":"Comparator<T> comparator","parameterName":"comparator"}],"literalExprs":[],"constructorTokenRange":"public OrderedPairIterator(Iterator<T> itor1, Iterator<T> itor2, Comparator<T> comparator) {\n    this(itor1, itor2);\n    this.comparator = comparator;\n  }","variableDeclarationExprs":[],"constructorRange":"(line 52,col 3)-(line 55,col 3)","constructorJavadocComment":"","constructorDeclaration":"public OrderedPairIterator(Iterator<T> itor1, Iterator<T> itor2, Comparator<T> comparator)","constructorBody":"{\n    this(itor1, itor2);\n    this.comparator = comparator;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"private void setnext1()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    next1 = itor1.hasNext() ? itor1.next() : null;\n}","methodRange":"(line 58,col 3)-(line 60,col 3)","methodTokenRange":"private void setnext1(\/*>>> @UnknownInitialization @Raw OrderedPairIterator<T> this*\/) {\n    next1 = itor1.hasNext() ? itor1.next() : null;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@RequiresNonNull(\"itor1\")","methodParameters":[],"methodName":"setnext1","methodQualifiedSignature":"plume.OrderedPairIterator.setnext1","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 59,col 46)-(line 59,col 49)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OrderedPairIterator.setnext1()"},{"methodDeclaration":"private void setnext2()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    next2 = itor2.hasNext() ? itor2.next() : null;\n}","methodRange":"(line 63,col 3)-(line 65,col 3)","methodTokenRange":"private void setnext2(\/*>>> @UnknownInitialization @Raw OrderedPairIterator<T> this*\/) {\n    next2 = itor2.hasNext() ? itor2.next() : null;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@RequiresNonNull(\"itor2\")","methodParameters":[],"methodName":"setnext2","methodQualifiedSignature":"plume.OrderedPairIterator.setnext2","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 64,col 46)-(line 64,col 49)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OrderedPairIterator.setnext2()"},{"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((next1 != null) || (next2 != null));\n}","methodRange":"(line 70,col 3)-(line 73,col 3)","methodTokenRange":"@Override\n  public boolean hasNext() {\n    return ((next1 != null) || (next2 != null));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" }","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"plume.OrderedPairIterator.hasNext","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 72,col 23)-(line 72,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 72,col 42)-(line 72,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OrderedPairIterator.hasNext()"},{"javadocBlockTags":[],"methodDeclaration":"private Pair<T, T> return1()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Pair<T, T> result = Pair.<T, T>of(next1, (T) null);\n    setnext1();\n    return result;\n}","methodRange":"(line 75,col 3)-(line 80,col 3)","methodTokenRange":"private Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> return1() {\n    Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> result =\n        Pair.<\/*@Nullable*\/ T, \/*@Nullable*\/ T>of(next1, (\/*@Nullable*\/ T) null);\n    setnext1();\n    return result;\n  }","methodReturnTypeResolved":"","methodJavadocComment":" Return an element of the first iterator, paired with null. ","methodParameters":[],"methodName":"return1","methodQualifiedSignature":"plume.OrderedPairIterator.return1","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an element of the first iterator, paired with null.'}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"Pair<T, T>","literalExprs":[{"literalExprRange":"(line 77,col 76)-(line 77,col 79)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OrderedPairIterator.return1()"},{"javadocBlockTags":[],"methodDeclaration":"private Pair<T, T> return2()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Pair<T, T> result = Pair.<T, T>of((T) null, next2);\n    setnext2();\n    return result;\n}","methodRange":"(line 82,col 3)-(line 87,col 3)","methodTokenRange":"private Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> return2() {\n    Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> result =\n        Pair.<\/*@Nullable*\/ T, \/*@Nullable*\/ T>of((\/*@Nullable*\/ T) null, next2);\n    setnext2();\n    return result;\n  }","methodReturnTypeResolved":"","methodJavadocComment":" Return a pair of null and an element of the second iterator. ","methodParameters":[],"methodName":"return2","methodQualifiedSignature":"plume.OrderedPairIterator.return2","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a pair of null and an element of the second iterator.'}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"Pair<T, T>","literalExprs":[{"literalExprRange":"(line 84,col 69)-(line 84,col 72)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OrderedPairIterator.return2()"},{"javadocBlockTags":[],"methodDeclaration":"private Pair<T, T> returnboth()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Pair<T, T> result = Pair.<T, T>of(next1, next2);\n    setnext1();\n    setnext2();\n    return result;\n}","methodRange":"(line 89,col 3)-(line 95,col 3)","methodTokenRange":"private Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> returnboth() {\n    Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> result =\n        Pair.<\/*@Nullable*\/ T, \/*@Nullable*\/ T>of(next1, next2);\n    setnext1();\n    setnext2();\n    return result;\n  }","methodReturnTypeResolved":"","methodJavadocComment":" Return a pair containing an element from each iterator. ","methodParameters":[],"methodName":"returnboth","methodQualifiedSignature":"plume.OrderedPairIterator.returnboth","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a pair containing an element from each iterator.'}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"Pair<T, T>","literalExprs":[],"methodQualifiedName":"plume.OrderedPairIterator.returnboth()"},{"methodDeclaration":"public Pair<T, T> next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (next1 == null) {\n        if (next2 == null) {\n            throw new NoSuchElementException();\n        } else {\n            return return2();\n        }\n    } else {\n        if (next2 == null) {\n            return return1();\n        } else {\n            int comparison;\n            try {\n                if (comparator == null) {\n                    @SuppressWarnings(\"unchecked\")\n                    Comparable<T> cble1 = (Comparable<T>) next1;\n                    comparison = cble1.compareTo(next2);\n                } else {\n                    comparison = comparator.compare(next1, next2);\n                }\n            } catch (NullPointerException npe) {\n                if (next1 == null && next2 == null) {\n                    comparison = 0;\n                } else if (next1 == null && next2 != null) {\n                    comparison = -1;\n                } else if (next1 != null && next2 == null) {\n                    comparison = 1;\n                } else {\n                    throw new RuntimeException(\"this can't happen \" + next1 + \" \" + next2);\n                }\n            }\n            if (comparison < 0) {\n                return return1();\n            } else if (comparison > 0) {\n                return return2();\n            } else {\n                return returnboth();\n            }\n        }\n    }\n}","methodRange":"(line 97,col 3)-(line 140,col 3)","methodTokenRange":"@Override\n  public Pair<\/*@Nullable*\/ T, \/*@Nullable*\/ T> next() {\n    if (next1 == null) {\n      if (next2 == null) {\n        throw new NoSuchElementException();\n      } else {\n        return return2();\n      }\n    } else {\n      if (next2 == null) {\n        return return1();\n      } else {\n        int comparison;\n        \/\/ Either T extends Comparable<T>, or else a comparator was passed in.\n        try {\n          if (comparator == null) {\n            @SuppressWarnings(\"unchecked\")\n            Comparable<\/*@NonNull*\/ T> cble1 = (Comparable<\/*@NonNull*\/ T>) next1;\n            comparison = cble1.compareTo(next2);\n          } else {\n            comparison = comparator.compare(next1, next2);\n          }\n        } catch (NullPointerException npe) {\n          \/\/ Either one of the arguments is null, or the comparator is buggy\n          if (next1 == null && next2 == null) {\n            comparison = 0;\n          } else if (next1 == null && next2 != null) {\n            comparison = -1;\n          } else if (next1 != null && next2 == null) {\n            comparison = 1;\n          } else {\n            throw new RuntimeException(\"this can't happen \" + next1 + \" \" + next2);\n          }\n        }\n        if (comparison < 0) {\n          return return1();\n        } else if (comparison > 0) {\n          return return2();\n        } else {\n          return returnboth();\n        }\n      }\n    }\n  }","methodReturnTypeResolved":"","methodJavadocComment":"","methodParameters":[],"methodName":"next","methodQualifiedSignature":"plume.OrderedPairIterator.next","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Pair<T, T>","literalExprs":[{"literalExprRange":"(line 99,col 18)-(line 99,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 100,col 20)-(line 100,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 106,col 20)-(line 106,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 112,col 29)-(line 112,col 32)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 113,col 31)-(line 113,col 41)","literalExprId":5,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 121,col 24)-(line 121,col 27)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 121,col 41)-(line 121,col 44)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 122,col 26)-(line 122,col 26)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 31)-(line 123,col 34)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 123,col 48)-(line 123,col 51)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 124,col 27)-(line 124,col 27)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 125,col 31)-(line 125,col 34)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 125,col 48)-(line 125,col 51)","literalExprId":13,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 126,col 26)-(line 126,col 26)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 128,col 40)-(line 128,col 59)","literalExprId":15,"literalExpr":"\"this can't happen \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 128,col 71)-(line 128,col 73)","literalExprId":16,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 131,col 26)-(line 131,col 26)","literalExprId":17,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 133,col 33)-(line 133,col 33)","literalExprId":18,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.OrderedPairIterator.next()"},{"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException();\n}","methodRange":"(line 142,col 3)-(line 145,col 3)","methodTokenRange":"@Override\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"plume.OrderedPairIterator.remove","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.OrderedPairIterator.remove()"}],"classJavadoc":"","className":"OrderedPairIterator","fields":[{"fieldRange":"(line 39,col 3)-(line 39,col 27)","fieldName":"itor1","fieldJavadocComment":"","fieldTokenRange":"Iterator<T> itor1, itor2;","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Iterator<T>","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 40,col 17)-(line 40,col 31)","fieldName":"next1","fieldJavadocComment":"@Nullable","fieldTokenRange":"T next1, next2;","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"T","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 41,col 17)-(line 41,col 49)","fieldName":"comparator","fieldJavadocComment":"@Nullable","fieldTokenRange":"Comparator<? super T> comparator;","fieldTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Comparator<? super T>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Comparator<? super T>"}]}],"sourceFileId":6,"packageName":"plume"},{"sourceFileName":"plume.CountingPrintWriter","imports":[{"importId":1,"import":"import java.io.OutputStream;\n"},{"importId":2,"import":"import java.io.PrintWriter;\n"},{"importId":3,"import":"import java.io.Writer;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an output stream","javadocBlockTagName":"out","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an output stream'}]}', name=Optional[out]}"}],"constructorQualifiedSignature":"plume.CountingPrintWriter.CountingPrintWriter(java.io.OutputStream)","variableDeclarationExprs":[],"constructorRange":"(line 46,col 3)-(line 52,col 3)","constructorJavadocComment":"\n   * Create a new PrintWriter, without automatic line flushing, from\n   * an existing OutputStream. This convenience constructor creates\n   * the necessary intermediate OutputStreamWriter, which will convert\n   * characters into bytes using the default character encoding.\n   *\n   * @param out an output stream\n   ","constructorDeclaration":"public CountingPrintWriter(OutputStream out)","constructorBody":"{\n    super(out);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n}","constructorName":"CountingPrintWriter","constructorQualifiedName":"plume.CountingPrintWriter.CountingPrintWriter","constructorParameters":[{"parameterType":"OutputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.OutputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.OutputStream","parameter":"OutputStream out","parameterName":"out"}],"literalExprs":[{"literalExprRange":"(line 48,col 20)-(line 48,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 49,col 20)-(line 49,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 50,col 20)-(line 50,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 51,col 20)-(line 51,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public CountingPrintWriter(OutputStream out) {\n    super(out);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new PrintWriter, without automatic line flushing, from\nan existing OutputStream. This convenience constructor creates\nthe necessary intermediate OutputStreamWriter, which will convert\ncharacters into bytes using the default character encoding.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an output stream'}]}', name=Optional[out]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an output stream","javadocBlockTagName":"out","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an output stream'}]}', name=Optional[out]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, the println() methods will flush the output buffer","javadocBlockTagName":"autoFlush","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the println() methods will flush the output buffer'}]}', name=Optional[autoFlush]}"}],"constructorQualifiedSignature":"plume.CountingPrintWriter.CountingPrintWriter(java.io.OutputStream, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 63,col 3)-(line 69,col 3)","constructorJavadocComment":"\n   * Create a new PrintWriter from an existing OutputStream. This\n   * convenience constructor creates the necessary intermediate\n   * OutputStreamWriter, which will convert characters into bytes\n   * using the default character encoding.\n   *\n   * @param out an output stream\n   * @param autoFlush if true, the println() methods will flush the output buffer\n   ","constructorDeclaration":"public CountingPrintWriter(OutputStream out, boolean autoFlush)","constructorBody":"{\n    super(out, autoFlush);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n}","constructorName":"CountingPrintWriter","constructorQualifiedName":"plume.CountingPrintWriter.CountingPrintWriter","constructorParameters":[{"parameterType":"OutputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.OutputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.OutputStream","parameter":"OutputStream out","parameterName":"out"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean autoFlush","parameterName":"autoFlush"}],"literalExprs":[{"literalExprRange":"(line 65,col 20)-(line 65,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 66,col 20)-(line 66,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 67,col 20)-(line 67,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 20)-(line 68,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public CountingPrintWriter(OutputStream out, boolean autoFlush) {\n    super(out, autoFlush);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new PrintWriter from an existing OutputStream. This\nconvenience constructor creates the necessary intermediate\nOutputStreamWriter, which will convert characters into bytes\nusing the default character encoding.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an output stream'}]}', name=Optional[out]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the println() methods will flush the output buffer'}]}', name=Optional[autoFlush]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a Writer","javadocBlockTagName":"out","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Writer'}]}', name=Optional[out]}"}],"constructorQualifiedSignature":"plume.CountingPrintWriter.CountingPrintWriter(java.io.Writer)","variableDeclarationExprs":[],"constructorRange":"(line 74,col 3)-(line 80,col 3)","constructorJavadocComment":" Create a new PrintWriter, without automatic line flushing.\n   *  @param out a Writer\n   ","constructorDeclaration":"public CountingPrintWriter(Writer out)","constructorBody":"{\n    super(out);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n}","constructorName":"CountingPrintWriter","constructorQualifiedName":"plume.CountingPrintWriter.CountingPrintWriter","constructorParameters":[{"parameterType":"Writer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Writer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Writer","parameter":"Writer out","parameterName":"out"}],"literalExprs":[{"literalExprRange":"(line 76,col 20)-(line 76,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 77,col 20)-(line 77,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 78,col 20)-(line 78,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 79,col 20)-(line 79,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public CountingPrintWriter(Writer out) {\n    super(out);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new PrintWriter, without automatic line flushing.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Writer'}]}', name=Optional[out]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a writer","javadocBlockTagName":"out","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a writer'}]}', name=Optional[out]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, the println() methods will flush the output buffer","javadocBlockTagName":"autoFlush","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the println() methods will flush the output buffer'}]}', name=Optional[autoFlush]}"}],"constructorQualifiedSignature":"plume.CountingPrintWriter.CountingPrintWriter(java.io.Writer, boolean)","variableDeclarationExprs":[],"constructorRange":"(line 87,col 3)-(line 93,col 3)","constructorJavadocComment":"\n   * Create a new PrintWriter, without automatic line flushing.\n   * @param out a writer\n   * @param autoFlush if true, the println() methods will flush the output buffer\n   ","constructorDeclaration":"public CountingPrintWriter(Writer out, boolean autoFlush)","constructorBody":"{\n    super(out, autoFlush);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n}","constructorName":"CountingPrintWriter","constructorQualifiedName":"plume.CountingPrintWriter.CountingPrintWriter","constructorParameters":[{"parameterType":"Writer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Writer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Writer","parameter":"Writer out","parameterName":"out"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean autoFlush","parameterName":"autoFlush"}],"literalExprs":[{"literalExprRange":"(line 89,col 20)-(line 89,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 90,col 20)-(line 90,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 91,col 20)-(line 91,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 20)-(line 92,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public CountingPrintWriter(Writer out, boolean autoFlush) {\n    super(out, autoFlush);\n    writtenBytes = 0;\n    printedBytes = 0;\n    printedChars = 0;\n    writtenChars = 0;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new PrintWriter, without automatic line flushing.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a writer'}]}', name=Optional[out]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the println() methods will flush the output buffer'}]}', name=Optional[autoFlush]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"bytes in the string, or null","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='bytes in the string, or null'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the String for which to count bytes","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the String for which to count bytes'}]}', name=Optional[s]}"}],"methodDeclaration":"public int countBytes(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (s == null) {\n        return -1;\n    }\n    int numchars = s.length();\n    int numbytes = 0;\n    for (int i = 0; i < numchars; i++) {\n        char c = s.charAt(i);\n        numbytes += countBytes(c);\n    }\n    return numbytes;\n}","methodRange":"(line 103,col 3)-(line 114,col 3)","methodTokenRange":"public int countBytes(String s) {\n    if (s == null) {\n      return -1;\n    }\n    int numchars = s.length();\n    int numbytes = 0;\n    for (int i = 0; i < numchars; i++) {\n      char c = s.charAt(i);\n      numbytes += countBytes(c);\n    }\n    return numbytes;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the number of bytes contained in a string.\n   * If s is null, returns -1\n   * @return bytes in the string, or null\n   * @param s the String for which to count bytes\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"countBytes","methodQualifiedSignature":"plume.CountingPrintWriter.countBytes","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the number of bytes contained in a string.\nIf s is null, returns -1'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='bytes in the string, or null'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the String for which to count bytes'}]}', name=Optional[s]}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 104,col 14)-(line 104,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 105,col 15)-(line 105,col 15)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 20)-(line 108,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 109,col 18)-(line 109,col 18)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.countBytes(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a character","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a character'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of bytes used to represent c","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of bytes used to represent c'}]}', name=Optional.empty}"}],"methodDeclaration":"public int countBytes(char c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if ((c >= 0x0001) && (c <= 0x007F)) {\n        return 1;\n    } else if (c > 0x07FF) {\n        return 3;\n    } else {\n        return 2;\n    }\n}","methodRange":"(line 121,col 3)-(line 129,col 3)","methodTokenRange":"public int countBytes(char c) {\n    if ((c >= 0x0001) && (c <= 0x007F)) {\n      return 1;\n    } else if (c > 0x07FF) {\n      return 3;\n    } else {\n      return 2;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the number of bytes used to represent a character.\n   * @param c a character\n   * @return number of bytes used to represent c\n   ","methodParameters":[{"parameterType":"char","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='char'}","parameterTypeResolvedDescribed":"char","parameter":"char c","parameterName":"c"}],"methodName":"countBytes","methodQualifiedSignature":"plume.CountingPrintWriter.countBytes","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the number of bytes used to represent a character.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a character'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of bytes used to represent c'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 122,col 15)-(line 122,col 20)","literalExprId":1,"literalExpr":"0x0001","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 122,col 32)-(line 122,col 37)","literalExprId":2,"literalExpr":"0x007F","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 123,col 14)-(line 123,col 14)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 124,col 20)-(line 124,col 25)","literalExprId":4,"literalExpr":"0x07FF","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 125,col 14)-(line 125,col 14)","literalExprId":5,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 127,col 14)-(line 127,col 14)","literalExprId":6,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.countBytes(char)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of bytes printed so far","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of bytes printed so far'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getNumberOfPrintedBytes()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return printedBytes;\n}","methodRange":"(line 138,col 3)-(line 140,col 3)","methodTokenRange":"public int getNumberOfPrintedBytes() {\n    return printedBytes;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the total number of bytes printed using any of the\n   * 'print' or 'println' methods of this CountingPrintBuffer.\n   * @return number of bytes printed so far\n   ","methodParameters":[],"methodName":"getNumberOfPrintedBytes","methodQualifiedSignature":"plume.CountingPrintWriter.getNumberOfPrintedBytes","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the total number of bytes printed using any of the\n'print' or 'println' methods of this CountingPrintBuffer.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of bytes printed so far'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.getNumberOfPrintedBytes()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of bytes written so far","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of bytes written so far'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getNumberOfWrittenBytes()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return writtenBytes;\n}","methodRange":"(line 147,col 3)-(line 149,col 3)","methodTokenRange":"public int getNumberOfWrittenBytes() {\n    return writtenBytes;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the total number of bytes printed using any of the\n   * 'write' methods of this CountingPrintBuffer.\n   * @return number of bytes written so far\n   ","methodParameters":[],"methodName":"getNumberOfWrittenBytes","methodQualifiedSignature":"plume.CountingPrintWriter.getNumberOfWrittenBytes","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the total number of bytes printed using any of the\n'write' methods of this CountingPrintBuffer.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of bytes written so far'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.getNumberOfWrittenBytes()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of characters printed so far","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of characters printed so far'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getNumberOfPrintedChars()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return printedChars;\n}","methodRange":"(line 156,col 3)-(line 158,col 3)","methodTokenRange":"public int getNumberOfPrintedChars() {\n    return printedChars;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the total number of characters printed using any\n   * of the 'print' or 'println' methods of this CountingPrintBuffer.\n   * @return number of characters printed so far\n   ","methodParameters":[],"methodName":"getNumberOfPrintedChars","methodQualifiedSignature":"plume.CountingPrintWriter.getNumberOfPrintedChars","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the total number of characters printed using any\nof the 'print' or 'println' methods of this CountingPrintBuffer.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of characters printed so far'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.getNumberOfPrintedChars()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to be printed, or null","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to be printed, or null'}]}', name=Optional[s]}"}],"methodDeclaration":"public void print(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (s == null) {\n        printedBytes += countBytes(\"null\");\n        printedChars += 4;\n    } else {\n        printedBytes += countBytes(s);\n        printedChars += s.length();\n    }\n    super.print(s);\n}","methodRange":"(line 179,col 3)-(line 188,col 3)","methodTokenRange":"public void print(\/*@Nullable*\/ String s) {\n    if (s == null) {\n      printedBytes += countBytes(\"null\");\n      printedChars += 4;\n    } else {\n      printedBytes += countBytes(s);\n      printedChars += s.length();\n    }\n    super.print(s);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a string. If the argument is null then the string \"null\" is\n   * printed. Otherwise, the string's characters are converted into\n   * bytes according to the platform's default character encoding, and\n   * these bytes are written in exactly the manner of the write(int)\n   * method.\n   * @param s the string to be printed, or null\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a string. If the argument is null then the string \"null\" is\nprinted. Otherwise, the string's characters are converted into\nbytes according to the platform's default character encoding, and\nthese bytes are written in exactly the manner of the write(int)\nmethod.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to be printed, or null'}]}', name=Optional[s]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 180,col 14)-(line 180,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 181,col 34)-(line 181,col 39)","literalExprId":2,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 182,col 23)-(line 182,col 23)","literalExprId":3,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.print(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the boolean to be printed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the boolean to be printed'}]}', name=Optional[b]}"}],"methodDeclaration":"public void print(boolean b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s = String.valueOf(b);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(b);\n}","methodRange":"(line 197,col 3)-(line 202,col 3)","methodTokenRange":"public void print(boolean b) {\n    String s = String.valueOf(b);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(b);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a boolean value. The string produced by\n   * String.valueOf(boolean) is translated into bytes according to the\n   * platform's default character encoding, and these bytes are\n   * written in exactly the manner of the write(int) method.\n   * @param b the boolean to be printed\n   ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean b","parameterName":"b"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a boolean value. The string produced by\nString.valueOf(boolean) is translated into bytes according to the\nplatform's default character encoding, and these bytes are\nwritten in exactly the manner of the write(int) method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the boolean to be printed'}]}', name=Optional[b]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the char to be printed","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the char to be printed'}]}', name=Optional[c]}"}],"methodDeclaration":"public void print(char c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    printedBytes += countBytes(c);\n    printedChars++;\n}","methodRange":"(line 211,col 3)-(line 214,col 3)","methodTokenRange":"public void print(char c) {\n    printedBytes += countBytes(c);\n    printedChars++;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a character. The character is translated into one or more\n   * bytes according to the platform's default character encoding, and\n   * these bytes are written in exactly the manner of the write(int)\n   * method.\n   * @param c the char to be printed\n   ","methodParameters":[{"parameterType":"char","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='char'}","parameterTypeResolvedDescribed":"char","parameter":"char c","parameterName":"c"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a character. The character is translated into one or more\nbytes according to the platform's default character encoding, and\nthese bytes are written in exactly the manner of the write(int)\nmethod.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the char to be printed'}]}', name=Optional[c]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(char)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the char[] to be printed","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the char[] to be printed'}]}', name=Optional[s]}"}],"methodDeclaration":"public void print(char[] s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < s.length; i++) {\n        printedBytes += countBytes(s[i]);\n    }\n    printedChars += s.length;\n    super.print(s);\n}","methodRange":"(line 223,col 3)-(line 229,col 3)","methodTokenRange":"public void print(char[] s) {\n    for (int i = 0; i < s.length; i++) {\n      printedBytes += countBytes(s[i]);\n    }\n    printedChars += s.length;\n    super.print(s);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print an array of characters. The characters are converted into\n   * bytes according to the platform's default character encoding, and\n   * these bytes are written in exactly the manner of the write(int)\n   * method.\n   * @param s the char[] to be printed\n   ","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] s","parameterName":"s"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print an array of characters. The characters are converted into\nbytes according to the platform's default character encoding, and\nthese bytes are written in exactly the manner of the write(int)\nmethod.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the char[] to be printed'}]}', name=Optional[s]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 224,col 18)-(line 224,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.print(char[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the double to be printed","javadocBlockTagName":"d","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the double to be printed'}]}', name=Optional[d]}"}],"methodDeclaration":"public void print(double d)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s = String.valueOf(d);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(d);\n}","methodRange":"(line 238,col 3)-(line 243,col 3)","methodTokenRange":"public void print(double d) {\n    String s = String.valueOf(d);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(d);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a double-precision floating-point number. The string\n   * produced by String.valueOf(double) is translated into bytes\n   * according to the platform's default character encoding, and these\n   * bytes are written in exactly the manner of the write(int) method.\n   * @param d the double to be printed\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d","parameterName":"d"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a double-precision floating-point number. The string\nproduced by String.valueOf(double) is translated into bytes\naccording to the platform's default character encoding, and these\nbytes are written in exactly the manner of the write(int) method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the double to be printed'}]}', name=Optional[d]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the float to be printed","javadocBlockTagName":"f","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the float to be printed'}]}', name=Optional[f]}"}],"methodDeclaration":"public void print(float f)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s = String.valueOf(f);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(f);\n}","methodRange":"(line 252,col 3)-(line 257,col 3)","methodTokenRange":"public void print(float f) {\n    String s = String.valueOf(f);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(f);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a floating-point number. The string produced by\n   * String.valueOf(float) is translated into bytes according to the\n   * platform's default character encoding, and these bytes are\n   * written in exactly the manner of the write(int) method.\n   * @param f the float to be printed\n   ","methodParameters":[{"parameterType":"float","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='float'}","parameterTypeResolvedDescribed":"float","parameter":"float f","parameterName":"f"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a floating-point number. The string produced by\nString.valueOf(float) is translated into bytes according to the\nplatform's default character encoding, and these bytes are\nwritten in exactly the manner of the write(int) method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the float to be printed'}]}', name=Optional[f]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(float)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the int to be printed","javadocBlockTagName":"i","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the int to be printed'}]}', name=Optional[i]}"}],"methodDeclaration":"public void print(int i)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s = String.valueOf(i);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(i);\n}","methodRange":"(line 266,col 3)-(line 271,col 3)","methodTokenRange":"public void print(int i) {\n    String s = String.valueOf(i);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(i);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   *  Print an integer. The string produced by String.valueOf(int) is\n   *  translated into bytes according to the platform's default\n   *  character encoding, and these bytes are written in exactly the\n   *  manner of the write(int) method.\n   * @param i the int to be printed\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int i","parameterName":"i"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Print an integer. The string produced by String.valueOf(int) is\n translated into bytes according to the platform's default\n character encoding, and these bytes are written in exactly the\n manner of the write(int) method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the int to be printed'}]}', name=Optional[i]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(int)"},{"javadocBlockTags":[],"methodDeclaration":"public void resetAll()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    resetPrintedByteCounter();\n    resetPrintedCharCounter();\n    resetWrittenByteCounter();\n    resetWrittenCharCounter();\n}","methodRange":"(line 274,col 3)-(line 279,col 3)","methodTokenRange":"public void resetAll() {\n    resetPrintedByteCounter();\n    resetPrintedCharCounter();\n    resetWrittenByteCounter();\n    resetWrittenCharCounter();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"  Resets all the byte and char counters. ","methodParameters":[],"methodName":"resetAll","methodQualifiedSignature":"plume.CountingPrintWriter.resetAll","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Resets all the byte and char counters.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.resetAll()"},{"javadocBlockTags":[],"methodDeclaration":"public void resetPrintedByteCounter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    printedBytes = 0;\n}","methodRange":"(line 281,col 3)-(line 283,col 3)","methodTokenRange":"public void resetPrintedByteCounter() {\n    printedBytes = 0;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"  Resets printedByte counter. ","methodParameters":[],"methodName":"resetPrintedByteCounter","methodQualifiedSignature":"plume.CountingPrintWriter.resetPrintedByteCounter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Resets printedByte counter.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 282,col 20)-(line 282,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.resetPrintedByteCounter()"},{"javadocBlockTags":[],"methodDeclaration":"public void resetPrintedCharCounter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    printedChars = 0;\n}","methodRange":"(line 285,col 3)-(line 287,col 3)","methodTokenRange":"public void resetPrintedCharCounter() {\n    printedChars = 0;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"  Resets printedChar counter. ","methodParameters":[],"methodName":"resetPrintedCharCounter","methodQualifiedSignature":"plume.CountingPrintWriter.resetPrintedCharCounter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Resets printedChar counter.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 286,col 20)-(line 286,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.resetPrintedCharCounter()"},{"javadocBlockTags":[],"methodDeclaration":"public void resetWrittenByteCounter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    writtenBytes = 0;\n}","methodRange":"(line 289,col 3)-(line 291,col 3)","methodTokenRange":"public void resetWrittenByteCounter() {\n    writtenBytes = 0;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"  Resets writtenByte counter. ","methodParameters":[],"methodName":"resetWrittenByteCounter","methodQualifiedSignature":"plume.CountingPrintWriter.resetWrittenByteCounter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Resets writtenByte counter.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 290,col 20)-(line 290,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.resetWrittenByteCounter()"},{"javadocBlockTags":[],"methodDeclaration":"public void resetWrittenCharCounter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    writtenChars = 0;\n}","methodRange":"(line 293,col 3)-(line 295,col 3)","methodTokenRange":"public void resetWrittenCharCounter() {\n    writtenChars = 0;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"  Resets writtenChar counter. ","methodParameters":[],"methodName":"resetWrittenCharCounter","methodQualifiedSignature":"plume.CountingPrintWriter.resetWrittenCharCounter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Resets writtenChar counter.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 294,col 20)-(line 294,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.resetWrittenCharCounter()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the long to be printed","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the long to be printed'}]}', name=Optional[l]}"}],"methodDeclaration":"public void print(long l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s = String.valueOf(l);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(l);\n}","methodRange":"(line 304,col 3)-(line 309,col 3)","methodTokenRange":"public void print(long l) {\n    String s = String.valueOf(l);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(l);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   *  Print a long integer. The string produced by\n   *  String.valueOf(long) is translated into bytes according to the\n   *  platform's default character encoding, and these bytes are\n   *  written in exactly the manner of the write(int) method.\n   * @param l the long to be printed\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long l","parameterName":"l"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text=' Print a long integer. The string produced by\n String.valueOf(long) is translated into bytes according to the\n platform's default character encoding, and these bytes are\n written in exactly the manner of the write(int) method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the long to be printed'}]}', name=Optional[l]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the object to be printed","javadocBlockTagName":"obj","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to be printed'}]}', name=Optional[obj]}"}],"methodDeclaration":"public void print(Object obj)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s = String.valueOf(obj);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(obj);\n}","methodRange":"(line 318,col 3)-(line 323,col 3)","methodTokenRange":"public void print(\/*@Nullable*\/ Object obj) {\n    String s = String.valueOf(obj);\n    printedBytes += countBytes(s);\n    printedChars += s.length();\n    super.print(obj);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print an object. The string produced by the\n   * String.valueOf(Object) method is translated into bytes according\n   * to the platform's default character encoding, and these bytes are\n   * written in exactly the manner of the write(int) method.\n   * @param obj the object to be printed\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"print","methodQualifiedSignature":"plume.CountingPrintWriter.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print an object. The string produced by the\nString.valueOf(Object) method is translated into bytes according\nto the platform's default character encoding, and these bytes are\nwritten in exactly the manner of the write(int) method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to be printed'}]}', name=Optional[obj]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.print(java.lang.Object)"},{"javadocBlockTags":[],"methodDeclaration":"public void println()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    printedBytes += countBytes(lineSep);\n    printedChars += lineSep.length();\n    super.println();\n}","methodRange":"(line 337,col 3)-(line 341,col 3)","methodTokenRange":"public void println() {\n    printedBytes += countBytes(lineSep);\n    printedChars += lineSep.length();\n    super.println();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Terminate the current line by writing the line separator\n   * string.  The line separator string is defined by the system\n   * property line.separator, and is not necessarily a single newline\n   * character ('\\n').\n   * <p>\n   * When incrementing the byte count of PrintWriter, also accounts for the\n   * bytes needed to represent the line separator string.\n   ","methodParameters":[],"methodName":"println","methodQualifiedSignature":"plume.CountingPrintWriter.println","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Terminate the current line by writing the line separator\nstring.  The line separator string is defined by the system\nproperty line.separator, and is not necessarily a single newline\ncharacter ('\\n').\n<p>\nWhen incrementing the byte count of PrintWriter, also accounts for the\nbytes needed to represent the line separator string.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.println()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to be printed","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to be printed'}]}', name=Optional[s]}"}],"methodDeclaration":"public void println(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    print(s);\n    println();\n}","methodRange":"(line 348,col 3)-(line 351,col 3)","methodTokenRange":"public void println(\/*@Nullable*\/ String s) {\n    print(s);\n    println();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a String and then terminate the line. This method behaves\n   * as though it invokes print(String) and then println().\n   * @param s the string to be printed\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"println","methodQualifiedSignature":"plume.CountingPrintWriter.println","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a String and then terminate the line. This method behaves\nas though it invokes print(String) and then println().'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to be printed'}]}', name=Optional[s]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.println(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the char[] to be printed","javadocBlockTagName":"buf","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the char[] to be printed'}]}', name=Optional[buf]}"}],"methodDeclaration":"public void write(char[] buf)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < buf.length; i++) {\n        writtenBytes += countBytes(buf[i]);\n    }\n    writtenChars += buf.length;\n    super.write(buf);\n}","methodRange":"(line 358,col 3)-(line 364,col 3)","methodTokenRange":"public void write(char[] buf) {\n    for (int i = 0; i < buf.length; i++) {\n      writtenBytes += countBytes(buf[i]);\n    }\n    writtenChars += buf.length;\n    super.write(buf);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Write an array of characters. This method cannot be inherited\n   * from the Writer class because it must suppress I\/O exceptions.\n   * @param buf the char[] to be printed\n   ","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] buf","parameterName":"buf"}],"methodName":"write","methodQualifiedSignature":"plume.CountingPrintWriter.write","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Write an array of characters. This method cannot be inherited\nfrom the Writer class because it must suppress I\/O exceptions.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the char[] to be printed'}]}', name=Optional[buf]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 359,col 18)-(line 359,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.CountingPrintWriter.write(char[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"character array","javadocBlockTagName":"buf","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character array'}]}', name=Optional[buf]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"offset from which to start writing characters","javadocBlockTagName":"off","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='offset from which to start writing characters'}]}', name=Optional[off]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of characters to write","javadocBlockTagName":"len","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of characters to write'}]}', name=Optional[len]}"}],"methodDeclaration":"public void write(char[] buf, int off, int len)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = off; i < off + len; i++) {\n        writtenBytes += countBytes(buf[i]);\n    }\n    writtenChars += len;\n    super.write(buf, off, len);\n}","methodRange":"(line 373,col 3)-(line 379,col 3)","methodTokenRange":"public void write(char[] buf, int off, int len) {\n    for (int i = off; i < off + len; i++) {\n      writtenBytes += countBytes(buf[i]);\n    }\n    writtenChars += len;\n    super.write(buf, off, len);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Write a portion of a character array.\n   *\n   * @param buf character array\n   * @param off offset from which to start writing characters\n   * @param len number of characters to write\n   ","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] buf","parameterName":"buf"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int off","parameterName":"off"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int len","parameterName":"len"}],"methodName":"write","methodQualifiedSignature":"plume.CountingPrintWriter.write","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Write a portion of a character array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character array'}]}', name=Optional[buf]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='offset from which to start writing characters'}]}', name=Optional[off]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of characters to write'}]}', name=Optional[len]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.write(char[], int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to be printed","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to be printed'}]}', name=Optional[s]}"}],"methodDeclaration":"public void write(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    writtenBytes += countBytes(s);\n    writtenChars += s.length();\n    super.write(s);\n}","methodRange":"(line 385,col 3)-(line 389,col 3)","methodTokenRange":"public void write(String s) {\n    writtenBytes += countBytes(s);\n    writtenChars += s.length();\n    super.write(s);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Write a string.\n   * @param s the string to be printed\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"write","methodQualifiedSignature":"plume.CountingPrintWriter.write","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Write a string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to be printed'}]}', name=Optional[s]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.write(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to be printed","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to be printed'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"offset from which to start writing characters","javadocBlockTagName":"off","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='offset from which to start writing characters'}]}', name=Optional[off]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of characters to write","javadocBlockTagName":"len","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of characters to write'}]}', name=Optional[len]}"}],"methodDeclaration":"public void write(String s, int off, int len)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    writtenBytes += countBytes(s.substring(off, len));\n    writtenChars += len;\n    super.write(s, off, len);\n}","methodRange":"(line 398,col 3)-(line 402,col 3)","methodTokenRange":"public void write(String s, int off, int len) {\n    writtenBytes += countBytes(s.substring(off, len));\n    writtenChars += len;\n    super.write(s, off, len);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Write a portion of a string.\n   *\n   * @param s string to be printed\n   * @param off offset from which to start writing characters\n   * @param len number of characters to write\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int off","parameterName":"off"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int len","parameterName":"len"}],"methodName":"write","methodQualifiedSignature":"plume.CountingPrintWriter.write","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Write a portion of a string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to be printed'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='offset from which to start writing characters'}]}', name=Optional[off]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of characters to write'}]}', name=Optional[len]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.CountingPrintWriter.write(java.lang.String, int, int)"}],"classJavadoc":"\/**\n * <p> Prints formatted representations of objects to a text-output\n * stream counting the number of bytes and characters printed. <\/p>\n *\n * <p> Methods in this class never throw I\/O exceptions. The client may\n * inquire as to whether any errors have occurred by invoking\n * checkError(). <\/p>\n *\/\n","className":"CountingPrintWriter","fields":[{"fieldRange":"(line 28,col 3)-(line 28,col 27)","fieldName":"writtenBytes","fieldJavadocComment":" Number of written bytes using 'write' methods. ","fieldTokenRange":"private int writtenBytes;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of written bytes using 'write' methods.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 30,col 3)-(line 30,col 27)","fieldName":"printedBytes","fieldJavadocComment":" Number of printed bytes using 'print' and 'println' methods. ","fieldTokenRange":"private int printedBytes;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of printed bytes using 'print' and 'println' methods.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 32,col 3)-(line 32,col 27)","fieldName":"writtenChars","fieldJavadocComment":" Number of written chars using write methods. ","fieldTokenRange":"private int writtenChars;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of written chars using write methods.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 34,col 3)-(line 34,col 27)","fieldName":"printedChars","fieldJavadocComment":" Number of printed chars using 'print' and 'println' methods. ","fieldTokenRange":"private int printedChars;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"Number of printed chars using 'print' and 'println' methods.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 326,col 3)-(line 326,col 77)","fieldName":"lineSep","fieldJavadocComment":" The system-specific line separator. ","fieldTokenRange":"private static final String lineSep = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 326,col 60)-(line 326,col 75)","literalExprId":1,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"The system-specific line separator.\n","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":7,"packageName":"plume"},{"sourceFileName":"plume.MultiVersionControl","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.FileFilter;\n"},{"importId":3,"import":"import java.io.FileReader;\n"},{"importId":4,"import":"import java.io.IOException;\n"},{"importId":5,"import":"import java.io.InputStream;\n"},{"importId":6,"import":"import java.util.ArrayList;\n"},{"importId":7,"import":"import java.util.Arrays;\n"},{"importId":8,"import":"import java.util.Comparator;\n"},{"importId":9,"import":"import java.util.LinkedHashSet;\n"},{"importId":10,"import":"import java.util.List;\n"},{"importId":11,"import":"import java.util.Set;\n"},{"importId":12,"import":"import java.util.regex.Matcher;\n"},{"importId":13,"import":"import java.util.regex.Pattern;\n"},{"importId":14,"import":"import org.ini4j.Ini;\n"},{"importId":15,"import":"import org.tmatesoft.svn.core.SVNException;\n"},{"importId":16,"import":"import org.tmatesoft.svn.core.SVNURL;\n"},{"importId":17,"import":"import org.tmatesoft.svn.core.auth.ISVNAuthenticationManager;\n"},{"importId":18,"import":"import org.tmatesoft.svn.core.internal.io.dav.DAVRepositoryFactory;\n"},{"importId":19,"import":"import org.tmatesoft.svn.core.internal.io.fs.FSRepositoryFactory;\n"},{"importId":20,"import":"import org.tmatesoft.svn.core.internal.io.svn.SVNRepositoryFactoryImpl;\n"},{"importId":21,"import":"import org.tmatesoft.svn.core.wc.SVNInfo;\n"},{"importId":22,"import":"import org.tmatesoft.svn.core.wc.SVNRevision;\n"},{"importId":23,"import":"import org.tmatesoft.svn.core.wc.SVNWCClient;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"MultiVersionControl","constructorQualifiedName":"plume.MultiVersionControl.MultiVersionControl","constructorQualifiedSignature":"plume.MultiVersionControl.MultiVersionControl()","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 422,col 21)-(line 422,col 30)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"@SuppressWarnings(\"nullness\") \/\/ initialization warning in unused constructor\n  private MultiVersionControl() {}","variableDeclarationExprs":[],"constructorRange":"(line 422,col 3)-(line 423,col 34)","constructorJavadocComment":" OptionsDoclet requires a nullary constructor (but a private one is OK).","constructorDeclaration":"private MultiVersionControl()","constructorBody":"{\n}","constructorJavadoc":""},{"constructorName":"MultiVersionControl","constructorQualifiedName":"plume.MultiVersionControl.MultiVersionControl","constructorQualifiedSignature":"plume.MultiVersionControl.MultiVersionControl(java.lang.String[])","constructorParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"literalExprs":[],"constructorTokenRange":"public MultiVersionControl(String[] args) {\n    parseArgs(args);\n  }","variableDeclarationExprs":[],"constructorRange":"(line 425,col 3)-(line 427,col 3)","constructorJavadocComment":"","constructorDeclaration":"public MultiVersionControl(String[] args)","constructorBody":"{\n    parseArgs(args);\n}","constructorJavadoc":""}],"classOrInterface":[{"classOrInterfaceRange":"(line 512,col 3)-(line 616,col 3)","classOrInterfaceTokenRange":"static class Checkout {\n    RepoType repoType;\n    \/** Local directory. *\/\n    \/\/ actually the parent directory?\n    File directory;\n    \/**\n     * Non-null for CVS and SVN.\n     * May be null for distributed version control systems (Bzr, Git, Hg).\n     * For distributed systems, refers to the parent repository from which\n     * this was cloned, not the one here in this directory.\n     * <p>\n     * Most operations don't need this.  it is needed for checkout, though.\n     *\/\n    \/*@Nullable*\/ String repository;\n    \/**\n     * Null if no module, just whole thing.\n     * Non-null for CVS and, optionally, for SVN.\n     * Null for distributed version control systems (Bzr, Git, Hg).\n     *\/\n    \/*@Nullable*\/ String module;\n\n    Checkout(RepoType repoType, File directory) {\n      this(repoType, directory, null, null);\n    }\n\n    Checkout(\n        RepoType repoType,\n        File directory,\n        \/*@Nullable*\/ String repository,\n        \/*@Nullable*\/ String module) {\n      \/\/ Directory might not exist if we are running the checkout command.\n      \/\/ If it exists, it must be a directory.\n      assert (directory.exists() ? directory.isDirectory() : true)\n          : \"Not a directory: \" + directory;\n      this.repoType = repoType;\n      this.directory = directory;\n      this.repository = repository;\n      this.module = module;\n      \/\/ These asserts come at the end so that the error message can be better.\n      switch (repoType) {\n        case BZR:\n          assertSubdirExists(directory, \".bzr\");\n          assert module == null;\n          break;\n        case CVS:\n          assertSubdirExists(directory, \"CVS\");\n          assert module != null : \"No module for CVS checkout at: \" + directory;\n          break;\n        case GIT:\n          assertSubdirExists(directory, \".git\");\n          assert module == null;\n          break;\n        case HG:\n          assertSubdirExists(directory, \".hg\");\n          assert module == null;\n          break;\n        case SVN:\n          assertSubdirExists(directory, \".svn\");\n          assert module == null;\n          break;\n        default:\n          assert false;\n      }\n    }\n\n    \/** If the directory exists, then the subdirectory must exist too. *\/\n    private static void assertSubdirExists(File directory, String subdirName) {\n      if (directory.exists() && !new File(directory, subdirName).isDirectory()) {\n        System.err.printf(\n            \"Directory %s exists but %s subdirectory does not exist%n\", directory, subdirName);\n        System.exit(2);\n      }\n    }\n\n    @Override\n    @SuppressWarnings(\"interning\")\n    \/*@Pure*\/\n    public boolean equals(\n        \/*>>>@GuardSatisfied Checkout this,*\/\n        \/*@GuardSatisfied*\/ \/*@Nullable*\/ Object other) {\n      if (!(other instanceof Checkout)) {\n        return false;\n      }\n      Checkout c2 = (Checkout) other;\n      return ((repoType == c2.repoType)\n          && directory.equals(c2.directory)\n          && ((repository == null) ? (c2.repository == null) : repository.equals(c2.repository))\n          && ((module == null) ? (c2.module == null) : module.equals(c2.module)));\n    }\n\n    @Override\n    \/*@Pure*\/\n    public int hashCode(\/*>>>@GuardSatisfied Checkout this*\/) {\n      return (repoType.hashCode()\n          + directory.hashCode()\n          + (repository == null ? 0 : repository.hashCode())\n          + (module == null ? 0 : module.hashCode()));\n    }\n\n    @Override\n    \/*@SideEffectFree*\/\n    public String toString(\/*>>>@GuardSatisfied Checkout this*\/) {\n      return repoType + \" \" + directory + \" \" + repository + \" \" + module;\n    }\n  }","classOrInterfaceJavadocComment":" TODO: have subclasses of Checkout for the different varieties, perhaps.","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 823,col 3)-(line 833,col 3)","classOrInterfaceTokenRange":"static class IsDirectoryFilter implements FileFilter {\n    public boolean accept(File pathname) {\n      try {\n        return pathname.isDirectory() && pathname.getPath().equals(pathname.getCanonicalPath());\n      } catch (IOException e) {\n        System.err.printf(\"Exception in IsDirectoryFilter.accept(%s): %s%n\", pathname, e);\n        throw new Error(e);\n        \/\/ return false;\n      }\n    }\n  }","classOrInterfaceJavadocComment":" Accept only directories that are not symbolic links. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Accept only directories that are not symbolic links.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1059,col 3)-(line 1071,col 3)","classOrInterfaceTokenRange":"private static class Replacer {\n    \/*@Regex*\/ String regexp;\n    String replacement;\n\n    public Replacer(\/*@Regex*\/ String regexp, String replacement) {\n      this.regexp = regexp;\n      this.replacement = replacement;\n    }\n\n    public String replaceAll(String s) {\n      return s.replaceAll(regexp, replacement);\n    }\n  }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 1706,col 3)-(line 1710,col 3)","classOrInterfaceTokenRange":"static class StreamOfNewlines extends InputStream {\n    public int read() {\n      return (int) '\\n';\n    }\n  }","classOrInterfaceJavadocComment":"\n   * A stream of newlines.  Used for processes that want input, when we\n   * don't want to give them input but don't want them to simply hang. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A stream of newlines.  Used for processes that want input, when we\ndon't want to give them input but don't want them to simply hang.'}]}, blockTags=[]}]"}],"methods":[{"methodDeclaration":"private static String expandTilde(String path)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return path.replaceFirst(\"^~\", home);\n}","methodRange":"(line 362,col 3)-(line 364,col 3)","methodTokenRange":"private static String expandTilde(String path) {\n    return path.replaceFirst(\"^~\", home);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Replace \"~\" by the expansion of \"$HOME\".","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String path","parameterName":"path"}],"methodName":"expandTilde","methodQualifiedSignature":"plume.MultiVersionControl.expandTilde","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 363,col 30)-(line 363,col 33)","literalExprId":1,"literalExpr":"\"^~\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.expandTilde(java.lang.String)"},{"methodDeclaration":"public static void main(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    setupSVNKIT();\n    MultiVersionControl mvc = new MultiVersionControl(args);\n    Set<Checkout> checkouts = new LinkedHashSet<Checkout>();\n    try {\n        readCheckouts(new File(mvc.checkouts), checkouts);\n    } catch (IOException e) {\n        System.err.println(\"Problem reading file \" + mvc.checkouts + \": \" + e.getMessage());\n    }\n    if (mvc.search) {\n        for (String adir : mvc.ignore_dir) {\n            File afile = new File(expandTilde(adir));\n            if (!afile.exists()) {\n                System.err.printf(\"Warning: Directory to ignore while searching for checkouts does not exist:%n  %s%n\", adir);\n            } else if (!afile.isDirectory()) {\n                System.err.printf(\"Warning: Directory to ignore while searching for checkouts is not a directory:%n  %s%n\", adir);\n            } else {\n                mvc.ignoreDirs.add(afile);\n            }\n        }\n        for (String adir : mvc.dir) {\n            adir = expandTilde(adir);\n            if (debug) {\n                System.out.println(\"Searching for checkouts under \" + adir);\n            }\n            if (!new File(adir).isDirectory()) {\n                System.err.printf(\"Directory in which to search for checkouts is not a directory: %s%n\", adir);\n                System.exit(2);\n            }\n            findCheckouts(new File(adir), checkouts, mvc.ignoreDirs);\n        }\n    }\n    if (debug) {\n        System.out.println(\"Processing checkouts read from \" + checkouts);\n    }\n    mvc.process(checkouts);\n}","methodRange":"(line 366,col 3)-(line 413,col 3)","methodTokenRange":"public static void main(String[] args) {\n    setupSVNKIT();\n    MultiVersionControl mvc = new MultiVersionControl(args);\n\n    Set<Checkout> checkouts = new LinkedHashSet<Checkout>();\n\n    try {\n      readCheckouts(new File(mvc.checkouts), checkouts);\n    } catch (IOException e) {\n      System.err.println(\"Problem reading file \" + mvc.checkouts + \": \" + e.getMessage());\n    }\n\n    if (mvc.search) {\n      \/\/ Postprocess command-line arguments\n      for (String adir : mvc.ignore_dir) {\n        File afile = new File(expandTilde(adir));\n        if (!afile.exists()) {\n          System.err.printf(\n              \"Warning: Directory to ignore while searching for checkouts does not exist:%n  %s%n\",\n              adir);\n        } else if (!afile.isDirectory()) {\n          System.err.printf(\n              \"Warning: Directory to ignore while searching for checkouts is not a directory:%n  %s%n\",\n              adir);\n        } else {\n          mvc.ignoreDirs.add(afile);\n        }\n      }\n\n      for (String adir : mvc.dir) {\n        adir = expandTilde(adir);\n        if (debug) {\n          System.out.println(\"Searching for checkouts under \" + adir);\n        }\n        if (!new File(adir).isDirectory()) {\n          System.err.printf(\n              \"Directory in which to search for checkouts is not a directory: %s%n\", adir);\n          System.exit(2);\n        }\n        findCheckouts(new File(adir), checkouts, mvc.ignoreDirs);\n      }\n    }\n\n    if (debug) {\n      System.out.println(\"Processing checkouts read from \" + checkouts);\n    }\n    mvc.process(checkouts);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.MultiVersionControl.main","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 375,col 26)-(line 375,col 48)","literalExprId":1,"literalExpr":"\"Problem reading file \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 375,col 68)-(line 375,col 71)","literalExprId":2,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 384,col 15)-(line 384,col 98)","literalExprId":3,"literalExpr":"\"Warning: Directory to ignore while searching for checkouts does not exist:%n  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 388,col 15)-(line 388,col 102)","literalExprId":4,"literalExpr":"\"Warning: Directory to ignore while searching for checkouts is not a directory:%n  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 398,col 30)-(line 398,col 61)","literalExprId":5,"literalExpr":"\"Searching for checkouts under \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 402,col 15)-(line 402,col 83)","literalExprId":6,"literalExpr":"\"Directory in which to search for checkouts is not a directory: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 403,col 23)-(line 403,col 23)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 410,col 26)-(line 410,col 58)","literalExprId":8,"literalExpr":"\"Processing checkouts read from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.main(java.lang.String[])"},{"methodDeclaration":"private static void setupSVNKIT()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    DAVRepositoryFactory.setup();\n    SVNRepositoryFactoryImpl.setup();\n    FSRepositoryFactory.setup();\n}","methodRange":"(line 415,col 3)-(line 419,col 3)","methodTokenRange":"private static void setupSVNKIT() {\n    DAVRepositoryFactory.setup();\n    SVNRepositoryFactoryImpl.setup();\n    FSRepositoryFactory.setup();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"setupSVNKIT","methodQualifiedSignature":"plume.MultiVersionControl.setupSVNKIT","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.MultiVersionControl.setupSVNKIT()"},{"methodDeclaration":"public void parseArgs(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"initialization\")\n    Options options = new Options(\"mvc [options] {checkout,status,update,list}\", this);\n    String[] remaining_args = options.parse_or_usage(args);\n    if (remaining_args.length != 1) {\n        options.print_usage(\"Please supply exactly one argument (found %d)%n%s\", remaining_args.length, UtilMDE.join(remaining_args, \" \"));\n        System.exit(1);\n    }\n    String action_string = remaining_args[0];\n    if (\"checkout\".startsWith(action_string)) {\n        action = CLONE;\n    } else if (\"clone\".startsWith(action_string)) {\n        action = CLONE;\n    } else if (\"list\".startsWith(action_string)) {\n        action = LIST;\n    } else if (\"pull\".startsWith(action_string)) {\n        action = PULL;\n    } else if (\"status\".startsWith(action_string)) {\n        action = STATUS;\n    } else if (\"update\".startsWith(action_string)) {\n        action = PULL;\n    } else {\n        options.print_usage(\"Unrecognized action \\\"%s\\\"\", action_string);\n        System.exit(1);\n    }\n    checkouts = expandTilde(checkouts);\n    if (dir.isEmpty()) {\n        dir.add(home);\n    }\n    if (action == CLONE) {\n        search = false;\n        show = true;\n        timeout = timeout * 10;\n        boolean explicit_run_dry = false;\n        for (String arg : args) {\n            if (arg.startsWith(\"--dry-run\") || arg.startsWith(\"--dry_run\")) {\n                explicit_run_dry = true;\n            }\n        }\n        if (!explicit_run_dry) {\n            if (!quiet) {\n                System.out.println(\"No --dry-run argument, so using --dry-run=true; override with --dry-run=false\");\n            }\n            dry_run = true;\n        }\n    }\n    if (dry_run) {\n        show = true;\n        redo_existing = true;\n    }\n    if (debug) {\n        show = true;\n    }\n}","methodRange":"(line 431,col 3)-(line 501,col 3)","methodTokenRange":"public void parseArgs(\n      \/*>>> @UnknownInitialization @Raw MultiVersionControl this,*\/ String[] args) {\n    @SuppressWarnings(\n        \"initialization\") \/\/ \"new MyClass(underInitialization)\" yields @UnderInitialization even when @Initialized would be safe\n    \/*@Initialized*\/ Options options =\n        new Options(\"mvc [options] {checkout,status,update,list}\", this);\n    String[] remaining_args = options.parse_or_usage(args);\n    if (remaining_args.length != 1) {\n      options.print_usage(\n          \"Please supply exactly one argument (found %d)%n%s\",\n          remaining_args.length,\n          UtilMDE.join(remaining_args, \" \"));\n      System.exit(1);\n    }\n    String action_string = remaining_args[0];\n    if (\"checkout\".startsWith(action_string)) {\n      action = CLONE;\n    } else if (\"clone\".startsWith(action_string)) {\n      action = CLONE;\n    } else if (\"list\".startsWith(action_string)) {\n      action = LIST;\n    } else if (\"pull\".startsWith(action_string)) {\n      action = PULL;\n    } else if (\"status\".startsWith(action_string)) {\n      action = STATUS;\n    } else if (\"update\".startsWith(action_string)) {\n      action = PULL;\n    } else {\n      options.print_usage(\"Unrecognized action \\\"%s\\\"\", action_string);\n      System.exit(1);\n    }\n\n    \/\/ clean up options\n\n    checkouts = expandTilde(checkouts);\n\n    if (dir.isEmpty()) {\n      dir.add(home);\n    }\n\n    if (action == CLONE) {\n      search = false;\n      show = true;\n      \/\/ Checkouts can be much slower than other operations.\n      timeout = timeout * 10;\n\n      \/\/ Set dry_run to true unless it was explicitly specified\n      boolean explicit_run_dry = false;\n      for (String arg : args) {\n        if (arg.startsWith(\"--dry-run\") || arg.startsWith(\"--dry_run\")) {\n          explicit_run_dry = true;\n        }\n      }\n      if (!explicit_run_dry) {\n        if (!quiet) {\n          System.out.println(\n              \"No --dry-run argument, so using --dry-run=true; override with --dry-run=false\");\n        }\n        dry_run = true;\n      }\n    }\n\n    if (dry_run) {\n      show = true;\n      redo_existing = true;\n    }\n\n    if (debug) {\n      show = true;\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@EnsuresNonNull(\"action\")","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"parseArgs","methodQualifiedSignature":"plume.MultiVersionControl.parseArgs","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 434,col 9)-(line 434,col 24)","literalExprId":1,"literalExpr":"\"initialization\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 436,col 21)-(line 436,col 65)","literalExprId":2,"literalExpr":"\"mvc [options] {checkout,status,update,list}\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 438,col 34)-(line 438,col 34)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 440,col 11)-(line 440,col 61)","literalExprId":4,"literalExpr":"\"Please supply exactly one argument (found %d)%n%s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 442,col 40)-(line 442,col 42)","literalExprId":5,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 443,col 19)-(line 443,col 19)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 445,col 43)-(line 445,col 43)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 446,col 9)-(line 446,col 18)","literalExprId":8,"literalExpr":"\"checkout\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 448,col 16)-(line 448,col 22)","literalExprId":9,"literalExpr":"\"clone\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 450,col 16)-(line 450,col 21)","literalExprId":10,"literalExpr":"\"list\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 452,col 16)-(line 452,col 21)","literalExprId":11,"literalExpr":"\"pull\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 454,col 16)-(line 454,col 23)","literalExprId":12,"literalExpr":"\"status\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 456,col 16)-(line 456,col 23)","literalExprId":13,"literalExpr":"\"update\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 459,col 27)-(line 459,col 54)","literalExprId":14,"literalExpr":"\"Unrecognized action \\\"%s\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 460,col 19)-(line 460,col 19)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 472,col 16)-(line 472,col 20)","literalExprId":16,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 473,col 14)-(line 473,col 17)","literalExprId":17,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 475,col 27)-(line 475,col 28)","literalExprId":18,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 478,col 34)-(line 478,col 38)","literalExprId":19,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 480,col 28)-(line 480,col 38)","literalExprId":20,"literalExpr":"\"--dry-run\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 480,col 59)-(line 480,col 69)","literalExprId":21,"literalExpr":"\"--dry_run\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 481,col 30)-(line 481,col 33)","literalExprId":22,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 487,col 15)-(line 487,col 93)","literalExprId":23,"literalExpr":"\"No --dry-run argument, so using --dry-run=true; override with --dry-run=false\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 489,col 19)-(line 489,col 22)","literalExprId":24,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 494,col 14)-(line 494,col 17)","literalExprId":25,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 495,col 23)-(line 495,col 26)","literalExprId":26,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 499,col 14)-(line 499,col 17)","literalExprId":27,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.parseArgs(java.lang.String[])"},{"javadocBlockTags":[],"methodDeclaration":" static void readCheckouts(File file, Set<Checkout> checkouts) throws IOException","methodAccessSpecifier":"NONE","methodBody":"{\n    RepoType currentType = RepoType.BZR;\n    String currentRoot = null;\n    boolean currentRootIsRepos = false;\n    EntryReader er = new EntryReader(file);\n    for (String line : er) {\n        if (debug) {\n            System.out.println(\"line: \" + line);\n        }\n        line = line.trim();\n        if (line.equals(\"\") || line.startsWith(\"#\")) {\n            continue;\n        }\n        String[] splitTwo = line.split(\"[ \\t]+\");\n        if (debug) {\n            System.out.println(\"split length: \" + splitTwo.length);\n        }\n        if (splitTwo.length == 2) {\n            String word1 = splitTwo[0];\n            String word2 = splitTwo[1];\n            if (word1.equals(\"BZRROOT:\") || word1.equals(\"BZRREPOS:\")) {\n                currentType = RepoType.BZR;\n                currentRoot = word2;\n                currentRootIsRepos = word1.equals(\"BZRREPOS:\");\n                continue;\n            } else if (word1.equals(\"CVSROOT:\")) {\n                currentType = RepoType.CVS;\n                currentRoot = word2;\n                currentRootIsRepos = false;\n                if (currentRoot.startsWith(\":ext:\")) {\n                    String[] rootWords = currentRoot.split(\":\");\n                    String possibleRoot = rootWords[rootWords.length - 1];\n                    if (new File(possibleRoot).isDirectory()) {\n                        currentRoot = possibleRoot;\n                    }\n                }\n                continue;\n            } else if (word1.equals(\"HGROOT:\") || word1.equals(\"HGREPOS:\")) {\n                currentType = RepoType.HG;\n                currentRoot = word2;\n                currentRootIsRepos = word1.equals(\"HGREPOS:\");\n                continue;\n            } else if (word1.equals(\"GITROOT:\") || word1.equals(\"GITREPOS:\")) {\n                currentType = RepoType.GIT;\n                currentRoot = word2;\n                currentRootIsRepos = word1.equals(\"GITREPOS:\");\n                continue;\n            } else if (word1.equals(\"SVNROOT:\") || word1.equals(\"SVNREPOS:\")) {\n                currentType = RepoType.SVN;\n                currentRoot = word2;\n                currentRootIsRepos = word1.equals(\"SVNREPOS:\");\n                continue;\n            }\n        }\n        if (currentRoot == null) {\n            System.err.printf(\"need root before directory at line %d of file %s%n\", er.getLineNumber(), er.getFileName());\n            System.exit(1);\n        }\n        String dirname;\n        String root = currentRoot;\n        if (root.endsWith(\"\/\")) {\n            root = root.substring(0, root.length() - 1);\n        }\n        String module = null;\n        int spacePos = line.lastIndexOf(' ');\n        if (spacePos == -1) {\n            dirname = line;\n        } else {\n            dirname = line.substring(0, spacePos);\n            module = line.substring(spacePos + 1);\n        }\n        File dir = new File(expandTilde(dirname));\n        if (module == null) {\n            module = dir.getName();\n        }\n        if (currentType != RepoType.CVS) {\n            if (!currentRootIsRepos) {\n                root = root + \"\/\" + module;\n            }\n            module = null;\n        }\n        Checkout checkout = new Checkout(currentType, dir, root, module);\n        checkouts.add(checkout);\n    }\n}","methodRange":"(line 626,col 3)-(line 724,col 3)","methodTokenRange":"static void readCheckouts(File file, Set<Checkout> checkouts) throws IOException {\n    RepoType currentType = RepoType.BZR; \/\/ arbitrary choice\n    String currentRoot = null;\n    boolean currentRootIsRepos = false;\n\n    EntryReader er = new EntryReader(file);\n    for (String line : er) {\n      if (debug) {\n        System.out.println(\"line: \" + line);\n      }\n      line = line.trim();\n      \/\/ Skip comments and blank lines\n      if (line.equals(\"\") || line.startsWith(\"#\")) {\n        continue;\n      }\n\n      String[] splitTwo = line.split(\"[ \\t]+\");\n      if (debug) {\n        System.out.println(\"split length: \" + splitTwo.length);\n      }\n      if (splitTwo.length == 2) {\n        String word1 = splitTwo[0];\n        String word2 = splitTwo[1];\n        if (word1.equals(\"BZRROOT:\") || word1.equals(\"BZRREPOS:\")) {\n          currentType = RepoType.BZR;\n          currentRoot = word2;\n          currentRootIsRepos = word1.equals(\"BZRREPOS:\");\n          continue;\n        } else if (word1.equals(\"CVSROOT:\")) {\n          currentType = RepoType.CVS;\n          currentRoot = word2;\n          currentRootIsRepos = false;\n          \/\/ If the CVSROOT is remote, try to make it local.\n          if (currentRoot.startsWith(\":ext:\")) {\n            String[] rootWords = currentRoot.split(\":\");\n            String possibleRoot = rootWords[rootWords.length - 1];\n            if (new File(possibleRoot).isDirectory()) {\n              currentRoot = possibleRoot;\n            }\n          }\n          continue;\n        } else if (word1.equals(\"HGROOT:\") || word1.equals(\"HGREPOS:\")) {\n          currentType = RepoType.HG;\n          currentRoot = word2;\n          currentRootIsRepos = word1.equals(\"HGREPOS:\");\n          continue;\n        } else if (word1.equals(\"GITROOT:\") || word1.equals(\"GITREPOS:\")) {\n          currentType = RepoType.GIT;\n          currentRoot = word2;\n          currentRootIsRepos = word1.equals(\"GITREPOS:\");\n          continue;\n        } else if (word1.equals(\"SVNROOT:\") || word1.equals(\"SVNREPOS:\")) {\n          currentType = RepoType.SVN;\n          currentRoot = word2;\n          currentRootIsRepos = word1.equals(\"SVNREPOS:\");\n          continue;\n        }\n      }\n\n      if (currentRoot == null) {\n        System.err.printf(\n            \"need root before directory at line %d of file %s%n\",\n            er.getLineNumber(),\n            er.getFileName());\n        System.exit(1);\n      }\n\n      String dirname;\n      String root = currentRoot;\n      if (root.endsWith(\"\/\")) {\n        root = root.substring(0, root.length() - 1);\n      }\n      String module = null;\n\n      int spacePos = line.lastIndexOf(' ');\n      if (spacePos == -1) {\n        dirname = line;\n      } else {\n        dirname = line.substring(0, spacePos);\n        module = line.substring(spacePos + 1);\n      }\n\n      \/\/ The directory may not yet exist if we are doing a checkout.\n      File dir = new File(expandTilde(dirname));\n\n      if (module == null) {\n        module = dir.getName();\n      }\n      if (currentType != RepoType.CVS) {\n        if (!currentRootIsRepos) {\n          root = root + \"\/\" + module;\n        }\n        module = null;\n      }\n\n      Checkout checkout = new Checkout(currentType, dir, root, module);\n      checkouts.add(checkout);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Read checkouts from the file (in .mvc-checkouts format), and add\n   * them to the set.\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"Set<Checkout>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Set<plume.MultiVersionControl.Checkout>","parameter":"Set<Checkout> checkouts","parameterName":"checkouts"}],"methodName":"readCheckouts","methodQualifiedSignature":"plume.MultiVersionControl.readCheckouts","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Read checkouts from the file (in .mvc-checkouts format), and add\nthem to the set.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 628,col 26)-(line 628,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 629,col 34)-(line 629,col 38)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 634,col 28)-(line 634,col 35)","literalExprId":3,"literalExpr":"\"line: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 638,col 23)-(line 638,col 24)","literalExprId":4,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 638,col 46)-(line 638,col 48)","literalExprId":5,"literalExpr":"\"#\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 642,col 38)-(line 642,col 45)","literalExprId":6,"literalExpr":"\"[ \\t]+\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 644,col 28)-(line 644,col 43)","literalExprId":7,"literalExpr":"\"split length: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 646,col 30)-(line 646,col 30)","literalExprId":8,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 647,col 33)-(line 647,col 33)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 648,col 33)-(line 648,col 33)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 649,col 26)-(line 649,col 35)","literalExprId":11,"literalExpr":"\"BZRROOT:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 649,col 54)-(line 649,col 64)","literalExprId":12,"literalExpr":"\"BZRREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 652,col 45)-(line 652,col 55)","literalExprId":13,"literalExpr":"\"BZRREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 654,col 33)-(line 654,col 42)","literalExprId":14,"literalExpr":"\"CVSROOT:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 657,col 32)-(line 657,col 36)","literalExprId":15,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 659,col 38)-(line 659,col 44)","literalExprId":16,"literalExpr":"\":ext:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 660,col 52)-(line 660,col 54)","literalExprId":17,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 661,col 64)-(line 661,col 64)","literalExprId":18,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 667,col 33)-(line 667,col 41)","literalExprId":19,"literalExpr":"\"HGROOT:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 667,col 60)-(line 667,col 69)","literalExprId":20,"literalExpr":"\"HGREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 670,col 45)-(line 670,col 54)","literalExprId":21,"literalExpr":"\"HGREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 672,col 33)-(line 672,col 42)","literalExprId":22,"literalExpr":"\"GITROOT:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 672,col 61)-(line 672,col 71)","literalExprId":23,"literalExpr":"\"GITREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 675,col 45)-(line 675,col 55)","literalExprId":24,"literalExpr":"\"GITREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 677,col 33)-(line 677,col 42)","literalExprId":25,"literalExpr":"\"SVNROOT:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 677,col 61)-(line 677,col 71)","literalExprId":26,"literalExpr":"\"SVNREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 680,col 45)-(line 680,col 55)","literalExprId":27,"literalExpr":"\"SVNREPOS:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 685,col 26)-(line 685,col 29)","literalExprId":28,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 687,col 13)-(line 687,col 64)","literalExprId":29,"literalExpr":"\"need root before directory at line %d of file %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 690,col 21)-(line 690,col 21)","literalExprId":30,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 695,col 25)-(line 695,col 27)","literalExprId":31,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 696,col 31)-(line 696,col 31)","literalExprId":32,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 696,col 50)-(line 696,col 50)","literalExprId":33,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 698,col 23)-(line 698,col 26)","literalExprId":34,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 700,col 39)-(line 700,col 41)","literalExprId":35,"literalExpr":"' '","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 701,col 24)-(line 701,col 24)","literalExprId":36,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 34)-(line 704,col 34)","literalExprId":37,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 44)-(line 705,col 44)","literalExprId":38,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 711,col 21)-(line 711,col 24)","literalExprId":39,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 716,col 25)-(line 716,col 27)","literalExprId":40,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 718,col 18)-(line 718,col 21)","literalExprId":41,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.readCheckouts(java.io.File, java.util.Set<plume.MultiVersionControl.Checkout>)"},{"javadocBlockTags":[],"methodDeclaration":"private static void findCheckouts(File dir, Set<Checkout> checkouts, List<File> ignoreDirs)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!dir.isDirectory()) {\n        return;\n    }\n    if (ignoreDirs.contains(dir)) {\n        return;\n    }\n    String dirName = dir.getName().toString();\n    File parent = dir.getParentFile();\n    if (parent != null) {\n        if (dirName.equals(\".bzr\")) {\n            checkouts.add(new Checkout(RepoType.BZR, parent, null, null));\n            return;\n        } else if (dirName.equals(\"CVS\")) {\n            addCheckoutCvs(dir, parent, checkouts);\n            return;\n        } else if (dirName.equals(\".hg\")) {\n            checkouts.add(dirToCheckoutHg(dir, parent));\n            return;\n        } else if (dirName.equals(\".svn\")) {\n            Checkout c = dirToCheckoutSvn(parent);\n            if (c != null) {\n                checkouts.add(c);\n            }\n            return;\n        }\n    }\n    @SuppressWarnings(\"nullness\")\n    File[] childdirs = dir.listFiles(idf);\n    if (childdirs == null) {\n        System.err.printf(\"childdirs is null (permission or other I\/O problem?) for %s%n\", dir.toString());\n        return;\n    }\n    Arrays.sort(childdirs, new Comparator<File>() {\n\n        @Override\n        public int compare(File o1, File o2) {\n            return o1.getName().compareTo(o2.getName());\n        }\n    });\n    for (File childdir : childdirs) {\n        findCheckouts(childdir, checkouts, ignoreDirs);\n    }\n}","methodRange":"(line 763,col 3)-(line 820,col 3)","methodTokenRange":"private static void findCheckouts(File dir, Set<Checkout> checkouts, List<File> ignoreDirs) {\n    if (!dir.isDirectory()) {\n      \/\/ This should never happen, unless the directory is deleted between\n      \/\/ the call to findCheckouts and the test of isDirectory.\n      return;\n    }\n    if (ignoreDirs.contains(dir)) {\n      return;\n    }\n\n    String dirName = dir.getName().toString();\n    File parent = dir.getParentFile();\n    if (parent != null) {\n      \/\/ The \"return\" statements below cause the code not to look for\n      \/\/ checkouts inside version control directories.  (But it does look\n      \/\/ for checkouts inside other checkouts.)  If someone checks in (say)\n      \/\/ a .svn file into a Mercurial repository, then removes it, the .svn\n      \/\/ file remains in the repository even if not in the working copy.\n      \/\/ That .svn file will cause an exception in dirToCheckoutSvn,\n      \/\/ because it is not associated with a working copy.\n      if (dirName.equals(\".bzr\")) {\n        checkouts.add(new Checkout(RepoType.BZR, parent, null, null));\n        return;\n      } else if (dirName.equals(\"CVS\")) {\n        addCheckoutCvs(dir, parent, checkouts);\n        return;\n      } else if (dirName.equals(\".hg\")) {\n        checkouts.add(dirToCheckoutHg(dir, parent));\n        return;\n      } else if (dirName.equals(\".svn\")) {\n        Checkout c = dirToCheckoutSvn(parent);\n        if (c != null) {\n          checkouts.add(c);\n        }\n        return;\n      }\n    }\n\n    @SuppressWarnings(\n        \"nullness\") \/\/ dependent: listFiles => non-null because dir is a directory, and we don't know that checkouts.add etc do not affect dir\n    File \/*@NonNull*\/ [] childdirs = dir.listFiles(idf);\n    if (childdirs == null) {\n      System.err.printf(\n          \"childdirs is null (permission or other I\/O problem?) for %s%n\", dir.toString());\n      return;\n    }\n    Arrays.sort(\n        childdirs,\n        new Comparator<File>() {\n          @Override\n          public int compare(File o1, File o2) {\n            return o1.getName().compareTo(o2.getName());\n          }\n        });\n    for (File childdir : childdirs) {\n      findCheckouts(childdir, checkouts, ignoreDirs);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Find all checkouts at or under the given directory (or, as a special\n   * case, also its parent -- could rewrite to avoid that case), and adds\n   * them to checkouts.  Works by checking whether dir or any of its\n   * descendants is a version control directory.\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"},{"parameterType":"Set<Checkout>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Set<plume.MultiVersionControl.Checkout>","parameter":"Set<Checkout> checkouts","parameterName":"checkouts"},{"parameterType":"List<File>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.io.File>","parameter":"List<File> ignoreDirs","parameterName":"ignoreDirs"}],"methodName":"findCheckouts","methodQualifiedSignature":"plume.MultiVersionControl.findCheckouts","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Find all checkouts at or under the given directory (or, as a special\ncase, also its parent -- could rewrite to avoid that case), and adds\nthem to checkouts.  Works by checking whether dir or any of its\ndescendants is a version control directory.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 775,col 19)-(line 775,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 783,col 26)-(line 783,col 31)","literalExprId":2,"literalExpr":"\".bzr\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 784,col 58)-(line 784,col 61)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 784,col 64)-(line 784,col 67)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 786,col 33)-(line 786,col 37)","literalExprId":5,"literalExpr":"\"CVS\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 789,col 33)-(line 789,col 37)","literalExprId":6,"literalExpr":"\".hg\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 792,col 33)-(line 792,col 38)","literalExprId":7,"literalExpr":"\".svn\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 794,col 18)-(line 794,col 21)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 802,col 9)-(line 802,col 18)","literalExprId":9,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 804,col 22)-(line 804,col 25)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 806,col 11)-(line 806,col 73)","literalExprId":11,"literalExpr":"\"childdirs is null (permission or other I\/O problem?) for %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.findCheckouts(java.io.File, java.util.Set<plume.MultiVersionControl.Checkout>, java.util.List<java.io.File>)"},{"javadocBlockTags":[],"methodDeclaration":" static void addCheckoutCvs(File cvsDir, File dir, Set<Checkout> checkouts)","methodAccessSpecifier":"NONE","methodBody":"{\n    assert cvsDir.getName().toString().equals(\"CVS\") : cvsDir.getName();\n    File repositoryFile = new File(cvsDir, \"Repository\");\n    File rootFile = new File(cvsDir, \"Root\");\n    if (!(repositoryFile.exists() && rootFile.exists())) {\n        return;\n    }\n    String pathInRepo = UtilMDE.readFile(repositoryFile).trim();\n    String repoRoot = UtilMDE.readFile(rootFile).trim();\n    File repoFileRoot = new File(pathInRepo);\n    while (repoFileRoot.getParentFile() != null) {\n        @SuppressWarnings(\"nullness\")\n        File newRepoFileRoot = repoFileRoot.getParentFile();\n        repoFileRoot = newRepoFileRoot;\n    }\n    Pair<File, File> stripped = removeCommonSuffixDirs(dir, new File(pathInRepo), repoFileRoot, \"CVS\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of path in repo (%s)\", dir, pathInRepo);\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout;\n    if (stripped.b != null) {\n        pathInRepoAtCheckout = stripped.b.toString();\n    } else {\n        pathInRepoAtCheckout = cDir.getName();\n    }\n    checkouts.add(new Checkout(RepoType.CVS, cDir, repoRoot, pathInRepoAtCheckout));\n}","methodRange":"(line 842,col 3)-(line 876,col 3)","methodTokenRange":"static void addCheckoutCvs(File cvsDir, File dir, Set<Checkout> checkouts) {\n    assert cvsDir.getName().toString().equals(\"CVS\") : cvsDir.getName();\n    \/\/ relative path within repository\n    File repositoryFile = new File(cvsDir, \"Repository\");\n    File rootFile = new File(cvsDir, \"Root\");\n    if (!(repositoryFile.exists() && rootFile.exists())) {\n      \/\/ apparently it wasn't a version control directory\n      return;\n    }\n    String pathInRepo = UtilMDE.readFile(repositoryFile).trim();\n    String repoRoot = UtilMDE.readFile(rootFile).trim();\n    \/*@NonNull*\/ File repoFileRoot = new File(pathInRepo);\n    while (repoFileRoot.getParentFile() != null) {\n      @SuppressWarnings(\"nullness\") \/\/ just checked that parent is non-null\n      \/*@NonNull*\/ File newRepoFileRoot = repoFileRoot.getParentFile();\n      repoFileRoot = newRepoFileRoot;\n    }\n\n    \/\/ strip common suffix off of local dir and repo url\n    Pair<\/*@Nullable*\/ File, \/*@Nullable*\/ File> stripped =\n        removeCommonSuffixDirs(dir, new File(pathInRepo), repoFileRoot, \"CVS\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n      System.out.printf(\"dir (%s) is parent of path in repo (%s)\", dir, pathInRepo);\n      System.exit(1);\n    }\n    String pathInRepoAtCheckout;\n    if (stripped.b != null) {\n      pathInRepoAtCheckout = stripped.b.toString();\n    } else {\n      pathInRepoAtCheckout = cDir.getName();\n    }\n\n    checkouts.add(new Checkout(RepoType.CVS, cDir, repoRoot, pathInRepoAtCheckout));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Given a directory named \"CVS\", create a corresponding Checkout object\n   * for its parent, and add it to the given set.  (Google Web Toolkit does\n   * that, for example.)\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File cvsDir","parameterName":"cvsDir"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"},{"parameterType":"Set<Checkout>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Set<plume.MultiVersionControl.Checkout>","parameter":"Set<Checkout> checkouts","parameterName":"checkouts"}],"methodName":"addCheckoutCvs","methodQualifiedSignature":"plume.MultiVersionControl.addCheckoutCvs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a directory named \"CVS\", create a corresponding Checkout object\nfor its parent, and add it to the given set.  (Google Web Toolkit does\nthat, for example.)'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 843,col 47)-(line 843,col 51)","literalExprId":1,"literalExpr":"\"CVS\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 845,col 44)-(line 845,col 55)","literalExprId":2,"literalExpr":"\"Repository\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 846,col 38)-(line 846,col 43)","literalExprId":3,"literalExpr":"\"Root\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 854,col 44)-(line 854,col 47)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 855,col 25)-(line 855,col 34)","literalExprId":5,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 862,col 73)-(line 862,col 77)","literalExprId":6,"literalExpr":"\"CVS\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 864,col 17)-(line 864,col 20)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 865,col 25)-(line 865,col 65)","literalExprId":8,"literalExpr":"\"dir (%s) is parent of path in repo (%s)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 866,col 19)-(line 866,col 19)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 869,col 23)-(line 869,col 26)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.addCheckoutCvs(java.io.File, java.io.File, java.util.Set<plume.MultiVersionControl.Checkout>)"},{"javadocBlockTags":[],"methodDeclaration":" static Checkout dirToCheckoutHg(File hgDir, File dir)","methodAccessSpecifier":"NONE","methodBody":"{\n    String repository = null;\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    if (hgrcFile.exists()) {\n        try {\n            ini = new Ini(new FileReader(hgrcFile));\n        } catch (IOException e) {\n            throw new Error(\"Problem reading file \" + hgrcFile);\n        }\n        Ini.Section pathsSection = ini.get(\"paths\");\n        if (pathsSection != null) {\n            repository = pathsSection.get(\"default\");\n            if (repository != null && repository.endsWith(\"\/\")) {\n                repository = repository.substring(0, repository.length() - 1);\n            }\n        }\n    }\n    return new Checkout(RepoType.HG, dir, repository, null);\n}","methodRange":"(line 882,col 3)-(line 905,col 3)","methodTokenRange":"static Checkout dirToCheckoutHg(File hgDir, File dir) {\n    String repository = null;\n\n    File hgrcFile = new File(hgDir, \"hgrc\");\n    Ini ini;\n    \/\/ There also exist Hg commands that will do this same thing.\n    if (hgrcFile.exists()) {\n      try {\n        ini = new Ini(new FileReader(hgrcFile));\n      } catch (IOException e) {\n        throw new Error(\"Problem reading file \" + hgrcFile);\n      }\n\n      Ini.Section pathsSection = ini.get(\"paths\");\n      if (pathsSection != null) {\n        repository = pathsSection.get(\"default\");\n        if (repository != null && repository.endsWith(\"\/\")) {\n          repository = repository.substring(0, repository.length() - 1);\n        }\n      }\n    }\n\n    return new Checkout(RepoType.HG, dir, repository, null);\n  }","methodReturnTypeResolved":"ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Given a directory named \".hg\" , create a corresponding Checkout object\n   * for its parent.\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File hgDir","parameterName":"hgDir"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"}],"methodName":"dirToCheckoutHg","methodQualifiedSignature":"plume.MultiVersionControl.dirToCheckoutHg","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a directory named \".hg\" , create a corresponding Checkout object\nfor its parent.'}]}, blockTags=[]}","methodReturnTypeDescribed":"plume.MultiVersionControl.Checkout","methodType":"Checkout","literalExprs":[{"literalExprRange":"(line 883,col 25)-(line 883,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 885,col 37)-(line 885,col 42)","literalExprId":2,"literalExpr":"\"hgrc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 892,col 25)-(line 892,col 47)","literalExprId":3,"literalExpr":"\"Problem reading file \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 895,col 42)-(line 895,col 48)","literalExprId":4,"literalExpr":"\"paths\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 896,col 27)-(line 896,col 30)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 897,col 39)-(line 897,col 47)","literalExprId":6,"literalExpr":"\"default\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 898,col 27)-(line 898,col 30)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 898,col 55)-(line 898,col 57)","literalExprId":8,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 899,col 45)-(line 899,col 45)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 899,col 70)-(line 899,col 70)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 904,col 55)-(line 904,col 58)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.dirToCheckoutHg(java.io.File, java.io.File)"},{"javadocBlockTags":[],"methodDeclaration":" static Checkout dirToCheckoutGit(File gitDir, File dir)","methodAccessSpecifier":"NONE","methodBody":"{\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n    return new Checkout(RepoType.GIT, dir, repository, null);\n}","methodRange":"(line 911,col 3)-(line 915,col 3)","methodTokenRange":"static Checkout dirToCheckoutGit(File gitDir, File dir) {\n    String repository = UtilMDE.backticks(\"git\", \"config\", \"remote.origin.url\");\n\n    return new Checkout(RepoType.GIT, dir, repository, null);\n  }","methodReturnTypeResolved":"ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Given a directory named \".git\" , create a corresponding Checkout object\n   * for its parent.\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File gitDir","parameterName":"gitDir"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"}],"methodName":"dirToCheckoutGit","methodQualifiedSignature":"plume.MultiVersionControl.dirToCheckoutGit","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a directory named \".git\" , create a corresponding Checkout object\nfor its parent.'}]}, blockTags=[]}","methodReturnTypeDescribed":"plume.MultiVersionControl.Checkout","methodType":"Checkout","literalExprs":[{"literalExprRange":"(line 912,col 43)-(line 912,col 47)","literalExprId":1,"literalExpr":"\"git\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 912,col 50)-(line 912,col 57)","literalExprId":2,"literalExpr":"\"config\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 912,col 60)-(line 912,col 78)","literalExprId":3,"literalExpr":"\"remote.origin.url\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 914,col 56)-(line 914,col 59)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.dirToCheckoutGit(java.io.File, java.io.File)"},{"javadocBlockTags":[],"methodDeclaration":" static Checkout dirToCheckoutSvn(File dir)","methodAccessSpecifier":"NONE","methodBody":"{\n    @SuppressWarnings(\"nullness\")\n    SVNWCClient wcClient = new SVNWCClient((ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n        info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n        System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n        if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n            System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n        }\n        return null;\n    }\n    SVNURL url = info.getURL();\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n        System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n        System.err.println(\"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n        System.err.println(\"  repoUrl = \" + url);\n        System.exit(2);\n    }\n    if (debug) {\n        System.out.println();\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"     dir = \" + dir.toString());\n    }\n    Pair<File, File> stripped = removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n        System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    if (stripped.b == null) {\n        System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n        System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n        url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n        throw new Error(e);\n    }\n    if (debug) {\n        System.out.println(\"stripped: \" + stripped);\n        System.out.println(\"repoRoot = \" + repoRoot);\n        System.out.println(\" repoUrl = \" + url);\n        System.out.println(\"    cDir = \" + cDir.toString());\n    }\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n}","methodRange":"(line 922,col 3)-(line 1008,col 3)","methodTokenRange":"static \/*@Nullable*\/ Checkout dirToCheckoutSvn(File dir) {\n\n    \/\/ For SVN, do\n    \/\/   svn info\n    \/\/ and grep out these lines:\n    \/\/   URL: svn+ssh:\/\/login.csail.mit.edu\/afs\/csail\/group\/pag\/projects\/reCrash\/repository\/trunk\/www\n    \/\/   Repository Root: svn+ssh:\/\/login.csail.mit.edu\/afs\/csail\/group\/pag\/projects\/reCrash\/repository\n\n    \/\/ Use SVNKit?\n    \/\/ Con: introduces dependency on external library.\n    \/\/ Pro: no need to re-implement or to call external process (which\n    \/\/   might be slow for large checkouts).\n\n    @SuppressWarnings(\"nullness\") \/\/ unannotated library: SVNKit\n    SVNWCClient wcClient = new SVNWCClient((\/*@Nullable*\/ ISVNAuthenticationManager) null, null);\n    SVNInfo info;\n    try {\n      info = wcClient.doInfo(new File(dir.toString()), SVNRevision.WORKING);\n    } catch (SVNException e) {\n      \/\/ throw new Error(\"Problem in dirToCheckoutSvn(\" + dir + \"): \", e);\n      System.err.println(\"Problem in dirToCheckoutSvn(\" + dir + \"): \" + e.getMessage());\n      if (e.getMessage() != null && e.getMessage().contains(\"This client is too old\")) {\n        System.err.println(\"plume-lib needs a newer version of SVNKit.\");\n      }\n      return null;\n    }\n    \/\/ getFile is null when operating on a working copy, as I am\n    \/\/ String relativeFile = info.getPath(); \/\/ relative to repository root -- can use to determine root of checkout\n    \/\/ getFile is just the (absolute) local file name for local items -- same as \"dir\"\n    \/\/ File relativeFile = info.getFile();\n    SVNURL url = info.getURL();\n    \/\/ This can be null (example: dir \/afs\/csail.mit.edu\/u\/m\/mernst\/.snapshot\/class\/6170\/2006-spring\/3dphysics).  I don't know under what circumstances.\n    SVNURL repoRoot = info.getRepositoryRootURL();\n    if (repoRoot == null) {\n      System.err.println(\"Problem:  old svn working copy in \" + dir.toString());\n      System.err.println(\n          \"Check it out again to get a 'Repository Root' entry in the svn info output.\");\n      System.err.println(\"  repoUrl = \" + url);\n      System.exit(2);\n    }\n    if (debug) {\n      System.out.println();\n      System.out.println(\"repoRoot = \" + repoRoot);\n      System.out.println(\" repoUrl = \" + url);\n      System.out.println(\"     dir = \" + dir.toString());\n    }\n\n    \/\/ Strip common suffix off of local dir and repo url.\n    Pair<\/*@Nullable*\/ File, \/*@Nullable*\/ File> stripped =\n        removeCommonSuffixDirs(dir, new File(url.getPath()), new File(repoRoot.getPath()), \".svn\");\n    File cDir = stripped.a;\n    if (cDir == null) {\n      System.out.printf(\"dir (%s) is parent of repository URL (%s)\", dir, url.getPath());\n      System.exit(1);\n    }\n    if (stripped.b == null) {\n      System.out.printf(\"dir (%s) is child of repository URL (%s)\", dir, url.getPath());\n      System.exit(1);\n    }\n    String pathInRepoAtCheckout = stripped.b.toString();\n    try {\n      url = url.setPath(pathInRepoAtCheckout, false);\n    } catch (SVNException e) {\n      throw new Error(e);\n    }\n\n    if (debug) {\n      System.out.println(\"stripped: \" + stripped);\n      System.out.println(\"repoRoot = \" + repoRoot);\n      System.out.println(\" repoUrl = \" + url);\n      System.out.println(\"    cDir = \" + cDir.toString());\n    }\n\n    assert url.toString().startsWith(repoRoot.toString()) : \"repoRoot=\" + repoRoot + \", url=\" + url;\n    return new Checkout(RepoType.SVN, cDir, url.toString(), null);\n\n    \/\/\/ Old implementation\n    \/\/ String module = url.toString().substring(repoRoot.toString().length());\n    \/\/ if (module.startsWith(\"\/\")) {\n    \/\/   module = module.substring(1);\n    \/\/ }\n    \/\/ if (module.equals(\"\")) {\n    \/\/   module = null;\n    \/\/ }\n    \/\/ return new Checkout(RepoType.SVN, cDir, repoRoot.toString(), module);\n\n  }","methodReturnTypeResolved":"ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Given a directory that contains a .svn subdirectory, create a\n   * corresponding Checkout object.\n   * Returns null if this is not possible.\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"}],"methodName":"dirToCheckoutSvn","methodQualifiedSignature":"plume.MultiVersionControl.dirToCheckoutSvn","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a directory that contains a .svn subdirectory, create a\ncorresponding Checkout object.\nReturns null if this is not possible.'}]}, blockTags=[]}","methodReturnTypeDescribed":"plume.MultiVersionControl.Checkout","methodType":"Checkout","literalExprs":[{"literalExprRange":"(line 935,col 23)-(line 935,col 32)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 936,col 86)-(line 936,col 89)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 936,col 92)-(line 936,col 95)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 942,col 26)-(line 942,col 55)","literalExprId":4,"literalExpr":"\"Problem in dirToCheckoutSvn(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 942,col 65)-(line 942,col 69)","literalExprId":5,"literalExpr":"\"): \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 943,col 29)-(line 943,col 32)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 943,col 61)-(line 943,col 84)","literalExprId":7,"literalExpr":"\"This client is too old\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 944,col 28)-(line 944,col 71)","literalExprId":8,"literalExpr":"\"plume-lib needs a newer version of SVNKit.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 946,col 14)-(line 946,col 17)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 955,col 21)-(line 955,col 24)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 956,col 26)-(line 956,col 61)","literalExprId":11,"literalExpr":"\"Problem:  old svn working copy in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 958,col 11)-(line 958,col 87)","literalExprId":12,"literalExpr":"\"Check it out again to get a 'Repository Root' entry in the svn info output.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 959,col 26)-(line 959,col 39)","literalExprId":13,"literalExpr":"\"  repoUrl = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 960,col 19)-(line 960,col 19)","literalExprId":14,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 964,col 26)-(line 964,col 38)","literalExprId":15,"literalExpr":"\"repoRoot = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 965,col 26)-(line 965,col 38)","literalExprId":16,"literalExpr":"\" repoUrl = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 966,col 26)-(line 966,col 38)","literalExprId":17,"literalExpr":"\"     dir = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 971,col 92)-(line 971,col 97)","literalExprId":18,"literalExpr":"\".svn\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 973,col 17)-(line 973,col 20)","literalExprId":19,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 974,col 25)-(line 974,col 67)","literalExprId":20,"literalExpr":"\"dir (%s) is parent of repository URL (%s)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 975,col 19)-(line 975,col 19)","literalExprId":21,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 977,col 23)-(line 977,col 26)","literalExprId":22,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 978,col 25)-(line 978,col 66)","literalExprId":23,"literalExpr":"\"dir (%s) is child of repository URL (%s)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 979,col 19)-(line 979,col 19)","literalExprId":24,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 983,col 47)-(line 983,col 51)","literalExprId":25,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 989,col 26)-(line 989,col 37)","literalExprId":26,"literalExpr":"\"stripped: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 990,col 26)-(line 990,col 38)","literalExprId":27,"literalExpr":"\"repoRoot = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 991,col 26)-(line 991,col 38)","literalExprId":28,"literalExpr":"\" repoUrl = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 992,col 26)-(line 992,col 38)","literalExprId":29,"literalExpr":"\"    cDir = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 995,col 61)-(line 995,col 71)","literalExprId":30,"literalExpr":"\"repoRoot=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 995,col 86)-(line 995,col 93)","literalExprId":31,"literalExpr":"\", url=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 996,col 61)-(line 996,col 64)","literalExprId":32,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.dirToCheckoutSvn(java.io.File)"},{"javadocBlockTags":[],"methodDeclaration":" static Pair<File, File> removeCommonSuffixDirs(File p1, File p2, File p2_limit, String p1_contains)","methodAccessSpecifier":"NONE","methodBody":"{\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null && r2 != null && (p2_limit == null || !r2.equals(p2_limit)) && r1.getName().equals(r2.getName())) {\n        if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n            break;\n        }\n        r1 = r1.getParentFile();\n        r2 = r2.getParentFile();\n    }\n    if (debug) {\n        System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n}","methodRange":"(line 1017,col 3)-(line 1039,col 3)","methodTokenRange":"static Pair<\/*@Nullable*\/ File, \/*@Nullable*\/ File> removeCommonSuffixDirs(\n      File p1, File p2, File p2_limit, String p1_contains) {\n    if (debug) {\n      System.out.printf(\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\", p1, p2, p2_limit, p1_contains);\n    }\n    \/\/ new names for results, because we will be side-effecting them\n    File r1 = p1;\n    File r2 = p2;\n    while (r1 != null\n        && r2 != null\n        && (p2_limit == null || !r2.equals(p2_limit))\n        && r1.getName().equals(r2.getName())) {\n      if (p1_contains != null && !new File(r1.getParentFile(), p1_contains).isDirectory()) {\n        break;\n      }\n      r1 = r1.getParentFile();\n      r2 = r2.getParentFile();\n    }\n    if (debug) {\n      System.out.printf(\"removeCommonSuffixDirs => %s %s%n\", r1, r2);\n    }\n    return Pair.of(r1, r2);\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * Strip identical elements off the end of both paths, and then return\n   * what is left of each.  Returned elements can be null!  If p2_limit is\n   * non-null, then it should be a parent of p2, and the stripping stops\n   * when p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\n   * contain a subdirectory of that name.\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File p1","parameterName":"p1"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File p2","parameterName":"p2"},{"parameterType":"File","parameterId":3,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File p2_limit","parameterName":"p2_limit"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String p1_contains","parameterName":"p1_contains"}],"methodName":"removeCommonSuffixDirs","methodQualifiedSignature":"plume.MultiVersionControl.removeCommonSuffixDirs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Strip identical elements off the end of both paths, and then return\nwhat is left of each.  Returned elements can be null!  If p2_limit is\nnon-null, then it should be a parent of p2, and the stripping stops\nwhen p2 becomes p2_limit.  If p1_contains is non-null, then p1 must\ncontain a subdirectory of that name.'}]}, blockTags=[]}","methodReturnTypeDescribed":"","methodType":"Pair<File, File>","literalExprs":[{"literalExprRange":"(line 1020,col 25)-(line 1020,col 66)","literalExprId":1,"literalExpr":"\"removeCommonSuffixDirs(%s, %s, %s, %s)%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1025,col 18)-(line 1025,col 21)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1026,col 18)-(line 1026,col 21)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1027,col 25)-(line 1027,col 28)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1029,col 26)-(line 1029,col 29)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1036,col 25)-(line 1036,col 59)","literalExprId":6,"literalExpr":"\"removeCommonSuffixDirs => %s %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.removeCommonSuffixDirs(java.io.File, java.io.File, java.io.File, java.lang.String)"},{"javadocBlockTags":[],"methodDeclaration":"private void addArg(ProcessBuilder pb, String arg)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<String> command = pb.command();\n    command.add(arg);\n    pb.command(command);\n}","methodRange":"(line 1046,col 3)-(line 1050,col 3)","methodTokenRange":"private void addArg(ProcessBuilder pb, String arg) {\n    List<String> command = pb.command();\n    command.add(arg);\n    pb.command(command);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Change pb's command by adding the given argument at the end. ","methodParameters":[{"parameterType":"ProcessBuilder","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.ProcessBuilder, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.ProcessBuilder","parameter":"ProcessBuilder pb","parameterName":"pb"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg","parameterName":"arg"}],"methodName":"addArg","methodQualifiedSignature":"plume.MultiVersionControl.addArg","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Change pb's command by adding the given argument at the end.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.MultiVersionControl.addArg(java.lang.ProcessBuilder, java.lang.String)"},{"javadocBlockTags":[],"methodDeclaration":"private void addArgs(ProcessBuilder pb, List<String> args)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    List<String> command = pb.command();\n    command.addAll(args);\n    pb.command(command);\n}","methodRange":"(line 1053,col 3)-(line 1057,col 3)","methodTokenRange":"private void addArgs(ProcessBuilder pb, List<String> args) {\n    List<String> command = pb.command();\n    command.addAll(args);\n    pb.command(command);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Change pb's command by adding the given arguments at the end. ","methodParameters":[{"parameterType":"ProcessBuilder","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.ProcessBuilder, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.ProcessBuilder","parameter":"ProcessBuilder pb","parameterName":"pb"},{"parameterType":"List<String>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.String>","parameter":"List<String> args","parameterName":"args"}],"methodName":"addArgs","methodQualifiedSignature":"plume.MultiVersionControl.addArgs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Change pb's command by adding the given arguments at the end.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.MultiVersionControl.addArgs(java.lang.ProcessBuilder, java.util.List<java.lang.String>)"},{"methodDeclaration":"public void process(Set<Checkout> checkouts)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ProcessBuilder pb = new ProcessBuilder(\"\");\n    ProcessBuilder pb2 = new ProcessBuilder(new ArrayList<String>());\n    ProcessBuilder pb3 = new ProcessBuilder(new ArrayList<String>());\n    pb.redirectErrorStream(true);\n    pb2.redirectErrorStream(true);\n    pb3.redirectErrorStream(true);\n    CLONELOOP: for (Checkout c : checkouts) {\n        if (debug) {\n            System.out.println(c);\n        }\n        File dir = c.directory;\n        List<Replacer> replacers = new ArrayList<Replacer>();\n        List<Replacer> replacers3 = new ArrayList<Replacer>();\n        switch(c.repoType) {\n            case BZR:\n                break;\n            case CVS:\n                replacers.add(new Replacer(\"(^|\\\\n)([?]) \", \"$1$2 \" + dir + \"\/\"));\n                break;\n            case GIT:\n                replacers.add(new Replacer(\"(^|\\\\n)fatal:\", \"$1fatal in \" + dir + \":\"));\n                replacers.add(new Replacer(\"(^|\\\\n)warning:\", \"$1warning in \" + dir + \":\"));\n                replacers.add(new Replacer(\"(^|\\\\n)(There is no tracking information for the current branch\\\\.)\", \"$1\" + dir + \": $2\"));\n                replacers.add(new Replacer(\"(^|\\\\n)(Your configuration specifies to merge)\", dir + \": $1$2\"));\n                break;\n            case HG:\n                replacers.add(new Replacer(\"(^|\\\\n)real URL is .*\\\\n\", \"$1\"));\n                replacers.add(new Replacer(\"(^|\\\\n)(abort: .*)\", \"$1$2: \" + dir));\n                replacers.add(new Replacer(\"(^|\\\\n)([MARC!?I]) \", \"$1$2 \" + dir + \"\/\"));\n                replacers.add(new Replacer(\"(^|\\\\n)(\\\\*\\\\*\\\\* failed to import extension .*: No module named demandload\\\\n)\", \"$1\"));\n                replacers.add(new Replacer(\"(^|\\\\n)warning: .* certificate not verified \\\\(check web.cacerts config setting\\\\)\\\\n\", \"$1\"));\n                replacers.add(new Replacer(\"(^|\\\\n)warning: .* certificate not verified \\\\(check web.cacerts config setting\\\\)\\\\n\", \"$1\"));\n                replacers.add(new Replacer(\"(^|\\\\n)((comparing with default-push\\\\n)?abort: repository default(-push)? not found!: .*\\\\n)\", \"$1\"));\n                break;\n            case SVN:\n                replacers.add(new Replacer(\"(svn: Network connection closed unexpectedly)\", \"$1 for \" + dir));\n                replacers.add(new Replacer(\"(svn: Repository) (UUID)\", \"$1 \" + dir + \" $2\"));\n                replacers.add(new Replacer(\"(svn: E155037: Previous operation has not finished; run 'cleanup' if it was interrupted)\", \"$1; for \" + dir));\n                break;\n            default:\n                assert false;\n        }\n        replacers.add(new Replacer(\"(remote: )?Warning: untrusted X11 forwarding setup failed: xauth key data not generated\\r*\\n(remote: )?Warning: No xauth data; using fake authentication data for X11 forwarding\\\\.\\r*\\n\", \"\"));\n        replacers.add(new Replacer(\"(working copy ')\", \"$1\" + dir));\n        pb.command(\"echo\", \"command\", \"not\", \"set\");\n        pb.directory(dir);\n        pb2.command(new ArrayList<String>());\n        pb2.directory(dir);\n        pb3.command(new ArrayList<String>());\n        pb3.directory(dir);\n        boolean show_normal_output = false;\n        switch(action) {\n            case LIST:\n                System.out.println(c);\n                continue CLONELOOP;\n            case CLONE:\n                pb.directory(dir.getParentFile());\n                String dirbase = dir.getName();\n                if (c.repository == null) {\n                    System.out.printf(\"Skipping checkout with unknown repository:%n  %s%n\", dir);\n                    continue CLONELOOP;\n                }\n                switch(c.repoType) {\n                    case BZR:\n                        System.out.println(\"bzr handling not yet implemented: skipping \" + c.directory);\n                        break;\n                    case CVS:\n                        assert c.module != null : \"@AssumeAssertion(nullness): dependent type CVS\";\n                        pb.command(cvs_executable, \"-d\", c.repository, \"checkout\", \"-P\", \"-ko\", c.module);\n                        addArgs(pb, cvs_arg);\n                        break;\n                    case GIT:\n                        pb.command(git_executable, \"clone\", c.repository, dirbase);\n                        addArgs(pb, git_arg);\n                        break;\n                    case HG:\n                        pb.command(hg_executable, \"clone\", c.repository, dirbase);\n                        addArgs(pb, hg_arg);\n                        if (insecure) {\n                            addArg(pb, \"--insecure\");\n                        }\n                        break;\n                    case SVN:\n                        if (c.module != null) {\n                            pb.command(svn_executable, \"checkout\", c.repository, c.module);\n                        } else {\n                            pb.command(svn_executable, \"checkout\", c.repository);\n                        }\n                        addArgs(pb, svn_arg);\n                        break;\n                    default:\n                        assert false;\n                }\n                break;\n            case STATUS:\n                show_normal_output = true;\n                switch(c.repoType) {\n                    case BZR:\n                        System.out.println(\"bzr handling not yet implemented: skipping \" + c.directory);\n                        break;\n                    case CVS:\n                        assert c.repository != null;\n                        pb.command(cvs_executable, \"-q\", \"diff\", \"-b\", \"--brief\", \"-N\");\n                        addArgs(pb, cvs_arg);\n                        String removeRegexp = (\"\\n=+\" + \"\\nRCS file: .*\" + \"(\\nretrieving revision .*)?\" + \"\\ndiff .*\" + \"(\\nFiles .* and .* differ)?\");\n                        replacers.add(new Replacer(removeRegexp, \"\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)Index: \", \"$1\" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(cvs \\\\[diff aborted)(\\\\]:)\", \"$1$2 in \" + dir + \"$3\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(Permission denied)\", \"$1$2 in \" + dir));\n                        replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: )(cannot find revision control)\", \"$1$2 in \" + dir + \": $3\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: cannot find )\", \"$1$2\" + dir));\n                        replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: in directory )\", \"$1$2\" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: ignoring )\", \"$1$2\" + dir + \"\/\"));\n                        break;\n                    case GIT:\n                        pb.command(git_executable, \"status\");\n                        addArgs(pb, git_arg);\n                        addArg(pb, \"--porcelain\");\n                        replacers.add(new Replacer(\"(^|\\\\n)On branch master\\\\nYour branch is up-to-date with 'origin\/master'.\\\\n\\\\n?\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)nothing to commit,? working directory clean\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)no changes added to commit \\\\(use \\\"git add\\\" and\/or \\\"git commit -a\\\"\\\\)\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)nothing added to commit but untracked files present \\\\(use \\\"git add\\\" to track\\\\)\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)nothing to commit \\\\(use -u to show untracked files\\\\)\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)#\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)# On branch master\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)nothing to commit \\\\(working directory clean\\\\)\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)# Changed but not updated:\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)#   \\\\(use \\\"git add <file>...\\\" to update what will be committed\\\\)\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)#   \\\\(use \\\"git checkout -- <file>...\\\" to discard changes in working directory\\\\)\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)# Untracked files:\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)#   \\\\(use \\\"git add <file>...\\\" to include in what will be committed\\\\)\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(#\\tmodified:   )\", \"$1\" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(#\\t)\", \"$1untracked: \" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)# Your branch is ahead of .*\\\\n\", \"$1unpushed changesets: \" + pb.directory() + \"\\n\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)([?][?]) \", \"$1$2 \" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)([ACDMRU][ ACDMRTU]|[ ACDMRU][ACDMRTU]) \", \"$1$2 \" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)# Your branch is behind .*\\\\n\", \"$1unpushed changesets: \" + pb.directory() + \"\\n\"));\n                        pb2.command(git_executable, \"log\", \"--branches\", \"--not\", \"--remotes\");\n                        addArgs(pb2, git_arg);\n                        replacers.add(new Replacer(\"^commit .*(.*\\\\n)+\", \"unpushed commits: \" + pb2.directory() + \"\\n\"));\n                        break;\n                    case HG:\n                        pb.command(hg_executable, \"status\");\n                        addArgs(pb, hg_arg);\n                        if (debug) {\n                            System.out.printf(\"invalidCertificate(%s) => %s%n\", c.directory, invalidCertificate(c.directory));\n                        }\n                        if (invalidCertificate(c.directory)) {\n                            pb2.command(hg_executable, \"outgoing\", \"-l\", \"1\", \"--config\", \"web.cacerts=\");\n                        } else {\n                            pb2.command(hg_executable, \"outgoing\", \"-l\", \"1\");\n                        }\n                        addArgs(pb2, hg_arg);\n                        if (insecure) {\n                            addArg(pb2, \"--insecure\");\n                        }\n                        replacers.add(new Replacer(\"^comparing with .*\\\\nsearching for changes\\\\nchangeset[^\\001]*\", \"unpushed changesets: \" + pb.directory() + \"\\n\"));\n                        replacers.add(new Replacer(\"^\\\\n?comparing with .*\\\\nsearching for changes\\\\nno changes found\\n\", \"\"));\n                        pb3.command(hg_executable, \"shelve\", \"-l\");\n                        addArgs(pb3, hg_arg);\n                        replacers3.add(new Replacer(\"^hg: unknown command 'shelve'\\\\n(.*\\\\n)+\", \"\"));\n                        replacers3.add(new Replacer(\"^(.*\\\\n)+\", \"shelved changes: \" + pb.directory() + \"\\n\"));\n                        break;\n                    case SVN:\n                        replacers.add(new Replacer(\"(^|\\\\n)([ACDIMRX?!~ ][CM ][L ][+ ][$ ]) *\", \"$1$2 \" + dir + \"\/\"));\n                        pb.command(svn_executable, \"status\");\n                        addArgs(pb, svn_arg);\n                        break;\n                    default:\n                        assert false;\n                }\n                break;\n            case PULL:\n                switch(c.repoType) {\n                    case BZR:\n                        System.out.println(\"bzr handling not yet implemented: skipping \" + c.directory);\n                        break;\n                    case CVS:\n                        replacers.add(new Replacer(\"(^|\\\\n)(cvs update: ((in|skipping) directory|conflicts found in )) +\", \"$1$2 \" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)(Merging differences between 1.16 and 1.17 into )\", \"$1$2 \" + dir + \"\/\"));\n                        assert c.repository != null;\n                        pb.command(cvs_executable, \"-Q\", \"update\", \"-d\");\n                        addArgs(pb, cvs_arg);\n                        replacers.add(new Replacer(\"(cvs update: move away )\", \"$1\" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(cvs \\\\[update aborted)(\\\\])\", \"$1 in \" + dir + \"$2\"));\n                        break;\n                    case GIT:\n                        replacers.add(new Replacer(\"(^|\\\\n)Already up-to-date\\\\.\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)error:\", \"$1error in \" + dir + \":\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)Please, commit your changes or stash them before you can merge.\\\\nAborting\\\\n\", \"$1\"));\n                        replacers.add(new Replacer(\"((^|\\\\n)CONFLICT \\\\(content\\\\): Merge conflict in )\", \"$1\" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)([ACDMRU]\\t)\", \"$1$2\" + dir + \"\/\"));\n                        pb.command(git_executable, \"pull\", \"-q\");\n                        addArgs(pb, git_arg);\n                        pb2.command(git_executable, \"fetch\", \"-p\");\n                        break;\n                    case HG:\n                        replacers.add(new Replacer(\"(^|\\\\n)([?!AMR] ) +\", \"$1$2 \" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(^|\\\\n)abort: \", \"$1\"));\n                        pb.command(hg_executable, \"-q\", \"update\");\n                        addArgs(pb, hg_arg);\n                        if (invalidCertificate(c.directory)) {\n                            pb2.command(hg_executable, \"-q\", \"fetch\", \"--config\", \"web.cacerts=\");\n                        } else {\n                            pb2.command(hg_executable, \"-q\", \"fetch\");\n                        }\n                        addArgs(pb2, hg_arg);\n                        if (insecure) {\n                            addArg(pb2, \"--insecure\");\n                        }\n                        break;\n                    case SVN:\n                        replacers.add(new Replacer(\"(^|\\\\n)([?!AMR] ) +\", \"$1$2 \" + dir + \"\/\"));\n                        replacers.add(new Replacer(\"(svn: Failed to add file ')(.*')\", \"$1\" + dir + \"\/$2\"));\n                        assert c.repository != null;\n                        pb.command(svn_executable, \"-q\", \"update\");\n                        addArgs(pb, svn_arg);\n                        break;\n                    default:\n                        assert false;\n                }\n                break;\n            default:\n                assert false;\n        }\n        if (debug) {\n            System.out.println(dir + \":\");\n        }\n        if (dir.exists()) {\n            if (action == CLONE && !redo_existing && !quiet) {\n                System.out.println(\"Skipping checkout (dir already exists): \" + dir);\n                continue;\n            }\n        } else {\n            File parent = dir.getParentFile();\n            if (parent == null) {\n                System.err.printf(\"Directory %s does not exist, and it has no parent%n\", dir);\n                continue;\n            }\n            switch(action) {\n                case CLONE:\n                    if (!parent.exists()) {\n                        if (show) {\n                            if (!dry_run) {\n                                System.out.printf(\"Parent directory %s does not exist%s%n\", parent, (dry_run ? \"\" : \" (creating)\"));\n                            } else {\n                                System.out.printf(\"  mkdir -p %s%n\", parent);\n                            }\n                        }\n                        if (!dry_run) {\n                            if (!parent.mkdirs()) {\n                                System.err.println(\"Could not create directory: \" + parent);\n                                System.exit(1);\n                            }\n                        }\n                    }\n                    break;\n                case STATUS:\n                case PULL:\n                    if (!quiet) {\n                        System.out.println(\"Cannot find directory: \" + dir);\n                    }\n                    continue CLONELOOP;\n                case LIST:\n                default:\n                    assert false;\n            }\n        }\n        if (print_directory) {\n            System.out.println(dir + \" :\");\n        }\n        perform_command(pb, replacers, show_normal_output);\n        if (pb2.command().size() > 0) {\n            perform_command(pb2, replacers, show_normal_output);\n        }\n        if (pb3.command().size() > 0) {\n            perform_command(pb3, replacers3, show_normal_output);\n        }\n    }\n}","methodRange":"(line 1073,col 3)-(line 1515,col 3)","methodTokenRange":"public void process(Set<Checkout> checkouts) {\n    \/\/ Always run at least one command, but sometimes up to three.\n    ProcessBuilder pb = new ProcessBuilder(\"\");\n    ProcessBuilder pb2 = new ProcessBuilder(new ArrayList<String>());\n    ProcessBuilder pb3 = new ProcessBuilder(new ArrayList<String>());\n    pb.redirectErrorStream(true);\n    pb2.redirectErrorStream(true);\n    pb3.redirectErrorStream(true);\n    \/\/ I really want to be able to redirect output to a Reader, but that\n    \/\/ isn't possible.  I have to send it to a file.\n    \/\/ I can't just use the InputStream directly, because if the process is\n    \/\/ killed because of a timeout, the stream is inaccessible.\n\n    CLONELOOP:\n    for (Checkout c : checkouts) {\n      if (debug) {\n        System.out.println(c);\n      }\n      File dir = c.directory;\n\n      List<Replacer> replacers = new ArrayList<Replacer>();\n      List<Replacer> replacers3 = new ArrayList<Replacer>();\n\n      switch (c.repoType) {\n        case BZR:\n          break;\n        case CVS:\n          replacers.add(new Replacer(\"(^|\\\\n)([?]) \", \"$1$2 \" + dir + \"\/\"));\n          break;\n        case GIT:\n          replacers.add(new Replacer(\"(^|\\\\n)fatal:\", \"$1fatal in \" + dir + \":\"));\n          replacers.add(new Replacer(\"(^|\\\\n)warning:\", \"$1warning in \" + dir + \":\"));\n          replacers.add(\n              new Replacer(\n                  \"(^|\\\\n)(There is no tracking information for the current branch\\\\.)\",\n                  \"$1\" + dir + \": $2\"));\n          replacers.add(\n              new Replacer(\"(^|\\\\n)(Your configuration specifies to merge)\", dir + \": $1$2\"));\n          break;\n        case HG:\n          \/\/ \"real URL\" is for bitbucket.org.  (Should be early in list.)\n          replacers.add(new Replacer(\"(^|\\\\n)real URL is .*\\\\n\", \"$1\"));\n          replacers.add(new Replacer(\"(^|\\\\n)(abort: .*)\", \"$1$2: \" + dir));\n          replacers.add(new Replacer(\"(^|\\\\n)([MARC!?I]) \", \"$1$2 \" + dir + \"\/\"));\n          replacers.add(\n              new Replacer(\n                  \"(^|\\\\n)(\\\\*\\\\*\\\\* failed to import extension .*: No module named demandload\\\\n)\",\n                  \"$1\"));\n          \/\/ Hack, should be replaced when googlecode certificate problems are fixed.\n          replacers.add(\n              new Replacer(\n                  \"(^|\\\\n)warning: .* certificate not verified \\\\(check web.cacerts config setting\\\\)\\\\n\",\n                  \"$1\"));\n          \/\/ May appear twice in output with overlapping matches, so repeat the replacer\n          replacers.add(\n              new Replacer(\n                  \"(^|\\\\n)warning: .* certificate not verified \\\\(check web.cacerts config setting\\\\)\\\\n\",\n                  \"$1\"));\n          \/\/ Does this mask too many errors?\n          replacers.add(\n              new Replacer(\n                  \"(^|\\\\n)((comparing with default-push\\\\n)?abort: repository default(-push)? not found!: .*\\\\n)\",\n                  \"$1\"));\n          break;\n        case SVN:\n          replacers.add(\n              new Replacer(\"(svn: Network connection closed unexpectedly)\", \"$1 for \" + dir));\n          replacers.add(new Replacer(\"(svn: Repository) (UUID)\", \"$1 \" + dir + \" $2\"));\n          replacers.add(\n              new Replacer(\n                  \"(svn: E155037: Previous operation has not finished; run 'cleanup' if it was interrupted)\",\n                  \"$1; for \" + dir));\n          break;\n        default:\n          assert false;\n      }\n      \/\/ The \\r* is necessary here; (somtimes?) there are two carriage returns.\n      replacers.add(\n          new Replacer(\n              \"(remote: )?Warning: untrusted X11 forwarding setup failed: xauth key data not generated\\r*\\n(remote: )?Warning: No xauth data; using fake authentication data for X11 forwarding\\\\.\\r*\\n\",\n              \"\"));\n      replacers.add(new Replacer(\"(working copy ')\", \"$1\" + dir));\n\n      pb.command(\"echo\", \"command\", \"not\", \"set\");\n      pb.directory(dir);\n      pb2.command(new ArrayList<String>());\n      pb2.directory(dir);\n      pb3.command(new ArrayList<String>());\n      pb3.directory(dir);\n      boolean show_normal_output = false;\n      \/\/ Set pb.command() to be the command to be executed.\n      switch (action) {\n        case LIST:\n          System.out.println(c);\n          continue CLONELOOP;\n        case CLONE:\n          pb.directory(dir.getParentFile());\n          String dirbase = dir.getName();\n          if (c.repository == null) {\n            System.out.printf(\"Skipping checkout with unknown repository:%n  %s%n\", dir);\n            continue CLONELOOP;\n          }\n          switch (c.repoType) {\n            case BZR:\n              System.out.println(\"bzr handling not yet implemented: skipping \" + c.directory);\n              break;\n            case CVS:\n              assert c.module != null : \"@AssumeAssertion(nullness): dependent type CVS\";\n              pb.command(\n                  cvs_executable,\n                  \"-d\",\n                  c.repository,\n                  \"checkout\",\n                  \"-P\", \/\/ prune empty directories\n                  \"-ko\", \/\/ no keyword substitution\n                  c.module);\n              addArgs(pb, cvs_arg);\n              break;\n            case GIT:\n              pb.command(git_executable, \"clone\", c.repository, dirbase);\n              addArgs(pb, git_arg);\n              break;\n            case HG:\n              pb.command(hg_executable, \"clone\", c.repository, dirbase);\n              addArgs(pb, hg_arg);\n              if (insecure) {\n                addArg(pb, \"--insecure\");\n              }\n              break;\n            case SVN:\n              if (c.module != null) {\n                pb.command(svn_executable, \"checkout\", c.repository, c.module);\n              } else {\n                pb.command(svn_executable, \"checkout\", c.repository);\n              }\n              addArgs(pb, svn_arg);\n              break;\n            default:\n              assert false;\n          }\n          break;\n        case STATUS:\n          \/\/ I need a replacer for other version control systems, to add\n          \/\/ directory names.\n          show_normal_output = true;\n          switch (c.repoType) {\n            case BZR:\n              System.out.println(\"bzr handling not yet implemented: skipping \" + c.directory);\n              break;\n            case CVS:\n              assert c.repository != null;\n              pb.command(\n                  cvs_executable,\n                  \"-q\",\n                  \/\/ Including \"-d REPOS\" seems to give errors when a\n                  \/\/ subdirectory is in a different CVS repository.\n                  \/\/ \"-d\", c.repository,\n                  \"diff\",\n                  \"-b\", \/\/ compress whitespace\n                  \"--brief\", \/\/ report only whether files differ, not details\n                  \"-N\"); \/\/ report new files\n              addArgs(pb, cvs_arg);\n              \/\/         # For the last perl command, this also works:\n              \/\/         #   perl -p -e 'chomp(\\$cwd = `pwd`); s\/^Index: \/\\$cwd\\\\\/\/'\";\n              \/\/         # but the one we use is briefer and uses the abbreviated directory name.\n              \/\/         $filter = \"grep -v \\\"unrecognized keyword 'UseNewInfoFmtStrings'\\\" | grep \\\"^Index:\\\" | perl -p -e 's|^Index: |$dir\\\\\/|'\";\n              String removeRegexp =\n                  (\"\\n=+\"\n                      + \"\\nRCS file: .*\" \/\/ no trailing ,v for newly-created files\n                      + \"(\\nretrieving revision .*)?\" \/\/ no output for newly-created files\n                      + \"\\ndiff .*\"\n                      + \"(\\nFiles .* and .* differ)?\" \/\/ no output if only whitespace differences\n                  );\n              replacers.add(new Replacer(removeRegexp, \"\"));\n              replacers.add(new Replacer(\"(^|\\\\n)Index: \", \"$1\" + dir + \"\/\"));\n              replacers.add(\n                  new Replacer(\"(^|\\\\n)(cvs \\\\[diff aborted)(\\\\]:)\", \"$1$2 in \" + dir + \"$3\"));\n              replacers.add(new Replacer(\"(^|\\\\n)(Permission denied)\", \"$1$2 in \" + dir));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)(cvs diff: )(cannot find revision control)\",\n                      \"$1$2 in \" + dir + \": $3\"));\n              replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: cannot find )\", \"$1$2\" + dir));\n              replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: in directory )\", \"$1$2\" + dir + \"\/\"));\n              replacers.add(new Replacer(\"(^|\\\\n)(cvs diff: ignoring )\", \"$1$2\" + dir + \"\/\"));\n              break;\n            case GIT:\n              pb.command(git_executable, \"status\");\n              addArgs(pb, git_arg);\n              \/\/ Why was I using this option??\n              \/\/ addArg(pb, \"--untracked-files=no\");\n              addArg(pb, \"--porcelain\"); \/\/ experimenting with porcelain output\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)On branch master\\\\nYour branch is up-to-date with 'origin\/master'.\\\\n\\\\n?\",\n                      \"$1\"));\n              replacers.add(\n                  new Replacer(\"(^|\\\\n)nothing to commit,? working directory clean\\\\n\", \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)no changes added to commit \\\\(use \\\"git add\\\" and\/or \\\"git commit -a\\\"\\\\)\\\\n\",\n                      \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)nothing added to commit but untracked files present \\\\(use \\\"git add\\\" to track\\\\)\\\\n\",\n                      \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)nothing to commit \\\\(use -u to show untracked files\\\\)\\n\", \"$1\"));\n\n              replacers.add(new Replacer(\"(^|\\\\n)#\\\\n\", \"$1\"));\n              replacers.add(new Replacer(\"(^|\\\\n)# On branch master\\\\n\", \"$1\"));\n              replacers.add(\n                  new Replacer(\"(^|\\\\n)nothing to commit \\\\(working directory clean\\\\)\\\\n\", \"$1\"));\n              replacers.add(new Replacer(\"(^|\\\\n)# Changed but not updated:\\\\n\", \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)#   \\\\(use \\\"git add <file>...\\\" to update what will be committed\\\\)\\\\n\",\n                      \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)#   \\\\(use \\\"git checkout -- <file>...\\\" to discard changes in working directory\\\\)\\\\n\",\n                      \"$1\"));\n              replacers.add(new Replacer(\"(^|\\\\n)# Untracked files:\\\\n\", \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)#   \\\\(use \\\"git add <file>...\\\" to include in what will be committed\\\\)\\\\n\",\n                      \"$1\"));\n\n              replacers.add(new Replacer(\"(^|\\\\n)(#\\tmodified:   )\", \"$1\" + dir + \"\/\"));\n              \/\/ This must come after the above, since it matches a prefix of the above\n              replacers.add(new Replacer(\"(^|\\\\n)(#\\t)\", \"$1untracked: \" + dir + \"\/\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)# Your branch is ahead of .*\\\\n\",\n                      \"$1unpushed changesets: \" + pb.directory() + \"\\n\"));\n              replacers.add(new Replacer(\"(^|\\\\n)([?][?]) \", \"$1$2 \" + dir + \"\/\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)([ACDMRU][ ACDMRTU]|[ ACDMRU][ACDMRTU]) \", \"$1$2 \" + dir + \"\/\"));\n\n              \/\/ Useful info, but don't bother to report it, for consistency with other VCSes\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)# Your branch is behind .*\\\\n\",\n                      \"$1unpushed changesets: \" + pb.directory() + \"\\n\"));\n\n              \/\/ Could remove all other output, but this could suppress messages\n              \/\/ replacers.add(new Replacer(\"(^|\\\\n)#.*\\\\n\", \"$1\"));\n\n              \/\/ Necessary because \"git status --porcelain\" does not report:\n              \/\/   # Your branch is ahead of 'origin\/master' by 1 commit.\n              \/\/ If you have pushed but not pulled, then this will report\n              pb2.command(git_executable, \"log\", \"--branches\", \"--not\", \"--remotes\");\n              addArgs(pb2, git_arg);\n              replacers.add(\n                  new Replacer(\n                      \"^commit .*(.*\\\\n)+\", \"unpushed commits: \" + pb2.directory() + \"\\n\"));\n\n              \/\/ TODO: look for stashes\n\n              break;\n            case HG:\n              pb.command(hg_executable, \"status\");\n              addArgs(pb, hg_arg);\n              if (debug) {\n                System.out.printf(\n                    \"invalidCertificate(%s) => %s%n\", c.directory, invalidCertificate(c.directory));\n              }\n              if (invalidCertificate(c.directory)) {\n                pb2.command(hg_executable, \"outgoing\", \"-l\", \"1\", \"--config\", \"web.cacerts=\");\n              } else {\n                pb2.command(hg_executable, \"outgoing\", \"-l\", \"1\");\n              }\n              addArgs(pb2, hg_arg);\n              if (insecure) {\n                addArg(pb2, \"--insecure\");\n              }\n              \/\/ The third line is either \"no changes found\" or \"changeset\".\n              replacers.add(\n                  new Replacer(\n                      \"^comparing with .*\\\\nsearching for changes\\\\nchangeset[^\\001]*\",\n                      \"unpushed changesets: \" + pb.directory() + \"\\n\"));\n              replacers.add(\n                  new Replacer(\n                      \"^\\\\n?comparing with .*\\\\nsearching for changes\\\\nno changes found\\n\", \"\"));\n              \/\/ TODO:  Shelve is an optional extension, and so this should make no report if it is not installed.\n              pb3.command(hg_executable, \"shelve\", \"-l\");\n              addArgs(pb3, hg_arg);\n              replacers3.add(new Replacer(\"^hg: unknown command 'shelve'\\\\n(.*\\\\n)+\", \"\"));\n              replacers3.add(\n                  new Replacer(\"^(.*\\\\n)+\", \"shelved changes: \" + pb.directory() + \"\\n\"));\n              break;\n            case SVN:\n              \/\/ Handle some changes.\n              \/\/ \"svn status\" also outputs an eighth column, only if you pass the --show-updates switch: [* ]\n              replacers.add(\n                  new Replacer(\"(^|\\\\n)([ACDIMRX?!~ ][CM ][L ][+ ][$ ]) *\", \"$1$2 \" + dir + \"\/\"));\n              pb.command(svn_executable, \"status\");\n              addArgs(pb, svn_arg);\n              break;\n            default:\n              assert false;\n          }\n          break;\n        case PULL:\n          switch (c.repoType) {\n            case BZR:\n              System.out.println(\"bzr handling not yet implemented: skipping \" + c.directory);\n              break;\n            case CVS:\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)(cvs update: ((in|skipping) directory|conflicts found in )) +\",\n                      \"$1$2 \" + dir + \"\/\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)(Merging differences between 1.16 and 1.17 into )\",\n                      \"$1$2 \" + dir + \"\/\"));\n              assert c.repository != null;\n              pb.command(\n                  cvs_executable,\n                  \/\/ Including -d causes problems with CVS repositories\n                  \/\/ that are embedded inside other repositories.\n                  \/\/ \"-d\", c.repository,\n                  \"-Q\",\n                  \"update\",\n                  \"-d\");\n              addArgs(pb, cvs_arg);\n              \/\/         $filter = \"grep -v \\\"config: unrecognized keyword 'UseNewInfoFmtStrings'\\\"\";\n              replacers.add(new Replacer(\"(cvs update: move away )\", \"$1\" + dir + \"\/\"));\n              replacers.add(new Replacer(\"(cvs \\\\[update aborted)(\\\\])\", \"$1 in \" + dir + \"$2\"));\n              break;\n            case GIT:\n              replacers.add(new Replacer(\"(^|\\\\n)Already up-to-date\\\\.\\\\n\", \"$1\"));\n              replacers.add(new Replacer(\"(^|\\\\n)error:\", \"$1error in \" + dir + \":\"));\n              replacers.add(\n                  new Replacer(\n                      \"(^|\\\\n)Please, commit your changes or stash them before you can merge.\\\\nAborting\\\\n\",\n                      \"$1\"));\n              replacers.add(\n                  new Replacer(\n                      \"((^|\\\\n)CONFLICT \\\\(content\\\\): Merge conflict in )\", \"$1\" + dir + \"\/\"));\n              replacers.add(new Replacer(\"(^|\\\\n)([ACDMRU]\\t)\", \"$1$2\" + dir + \"\/\"));\n              pb.command(git_executable, \"pull\", \"-q\");\n              addArgs(pb, git_arg);\n              \/\/ prune branches; alternately can do \"git remote prune origin\"; \"git gc\" does not do this.\n              pb2.command(git_executable, \"fetch\", \"-p\");\n              break;\n            case HG:\n              replacers.add(new Replacer(\"(^|\\\\n)([?!AMR] ) +\", \"$1$2 \" + dir + \"\/\"));\n              replacers.add(new Replacer(\"(^|\\\\n)abort: \", \"$1\"));\n              pb.command(hg_executable, \"-q\", \"update\");\n              addArgs(pb, hg_arg);\n              if (invalidCertificate(c.directory)) {\n                pb2.command(hg_executable, \"-q\", \"fetch\", \"--config\", \"web.cacerts=\");\n              } else {\n                pb2.command(hg_executable, \"-q\", \"fetch\");\n              }\n              addArgs(pb2, hg_arg);\n              if (insecure) {\n                addArg(pb2, \"--insecure\");\n              }\n              break;\n            case SVN:\n              replacers.add(new Replacer(\"(^|\\\\n)([?!AMR] ) +\", \"$1$2 \" + dir + \"\/\"));\n              replacers.add(new Replacer(\"(svn: Failed to add file ')(.*')\", \"$1\" + dir + \"\/$2\"));\n              assert c.repository != null;\n              pb.command(svn_executable, \"-q\", \"update\");\n              addArgs(pb, svn_arg);\n              \/\/         $filter = \"grep -v \\\"Killed by signal 15.\\\"\";\n              break;\n            default:\n              assert false;\n          }\n          break;\n        default:\n          assert false;\n      }\n\n      \/\/ Check that the directory exists (OK if it doesn't for checkout).\n      if (debug) {\n        System.out.println(dir + \":\");\n      }\n      if (dir.exists()) {\n        if (action == CLONE && !redo_existing && !quiet) {\n          System.out.println(\"Skipping checkout (dir already exists): \" + dir);\n          continue;\n        }\n      } else {\n        \/\/ Directory does not exist\n        File parent = dir.getParentFile();\n        if (parent == null) {\n          \/\/ This happens when dir is the root directory.\n          \/\/ It doesn't happen merely when the parent doesn't yet exist.\n          System.err.printf(\"Directory %s does not exist, and it has no parent%n\", dir);\n          continue;\n        }\n        switch (action) {\n          case CLONE:\n            if (!parent.exists()) {\n              if (show) {\n                if (!dry_run) {\n                  System.out.printf(\n                      \"Parent directory %s does not exist%s%n\",\n                      parent,\n                      (dry_run ? \"\" : \" (creating)\"));\n                } else {\n                  System.out.printf(\"  mkdir -p %s%n\", parent);\n                }\n              }\n              if (!dry_run) {\n                if (!parent.mkdirs()) {\n                  System.err.println(\"Could not create directory: \" + parent);\n                  System.exit(1);\n                }\n              }\n            }\n            break;\n          case STATUS:\n          case PULL:\n            if (!quiet) {\n              System.out.println(\"Cannot find directory: \" + dir);\n            }\n            continue CLONELOOP;\n          case LIST:\n          default:\n            assert false;\n        }\n      }\n\n      if (print_directory) {\n        System.out.println(dir + \" :\");\n      }\n      perform_command(pb, replacers, show_normal_output);\n      if (pb2.command().size() > 0) {\n        perform_command(pb2, replacers, show_normal_output);\n      }\n      if (pb3.command().size() > 0) {\n        perform_command(pb3, replacers3, show_normal_output);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Set<Checkout>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{plume.MultiVersionControl.Checkout, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Set<plume.MultiVersionControl.Checkout>","parameter":"Set<Checkout> checkouts","parameterName":"checkouts"}],"methodName":"process","methodQualifiedSignature":"plume.MultiVersionControl.process","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1075,col 44)-(line 1075,col 45)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1078,col 28)-(line 1078,col 31)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1079,col 29)-(line 1079,col 32)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1080,col 29)-(line 1080,col 32)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1100,col 38)-(line 1100,col 52)","literalExprId":5,"literalExpr":"\"(^|\\\\n)([?]) \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1100,col 55)-(line 1100,col 61)","literalExprId":6,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1100,col 71)-(line 1100,col 73)","literalExprId":7,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1103,col 38)-(line 1103,col 52)","literalExprId":8,"literalExpr":"\"(^|\\\\n)fatal:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1103,col 55)-(line 1103,col 67)","literalExprId":9,"literalExpr":"\"$1fatal in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1103,col 77)-(line 1103,col 79)","literalExprId":10,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1104,col 38)-(line 1104,col 54)","literalExprId":11,"literalExpr":"\"(^|\\\\n)warning:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1104,col 57)-(line 1104,col 71)","literalExprId":12,"literalExpr":"\"$1warning in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1104,col 81)-(line 1104,col 83)","literalExprId":13,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1107,col 19)-(line 1107,col 87)","literalExprId":14,"literalExpr":"\"(^|\\\\n)(There is no tracking information for the current branch\\\\.)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1108,col 19)-(line 1108,col 22)","literalExprId":15,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1108,col 32)-(line 1108,col 37)","literalExprId":16,"literalExpr":"\": $2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1110,col 28)-(line 1110,col 75)","literalExprId":17,"literalExpr":"\"(^|\\\\n)(Your configuration specifies to merge)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1110,col 84)-(line 1110,col 91)","literalExprId":18,"literalExpr":"\": $1$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1114,col 38)-(line 1114,col 63)","literalExprId":19,"literalExpr":"\"(^|\\\\n)real URL is .*\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1114,col 66)-(line 1114,col 69)","literalExprId":20,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1115,col 38)-(line 1115,col 57)","literalExprId":21,"literalExpr":"\"(^|\\\\n)(abort: .*)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1115,col 60)-(line 1115,col 67)","literalExprId":22,"literalExpr":"\"$1$2: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1116,col 38)-(line 1116,col 58)","literalExprId":23,"literalExpr":"\"(^|\\\\n)([MARC!?I]) \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1116,col 61)-(line 1116,col 67)","literalExprId":24,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1116,col 77)-(line 1116,col 79)","literalExprId":25,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1119,col 19)-(line 1119,col 99)","literalExprId":26,"literalExpr":"\"(^|\\\\n)(\\\\*\\\\*\\\\* failed to import extension .*: No module named demandload\\\\n)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1120,col 19)-(line 1120,col 22)","literalExprId":27,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1124,col 19)-(line 1124,col 105)","literalExprId":28,"literalExpr":"\"(^|\\\\n)warning: .* certificate not verified \\\\(check web.cacerts config setting\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1125,col 19)-(line 1125,col 22)","literalExprId":29,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1129,col 19)-(line 1129,col 105)","literalExprId":30,"literalExpr":"\"(^|\\\\n)warning: .* certificate not verified \\\\(check web.cacerts config setting\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1130,col 19)-(line 1130,col 22)","literalExprId":31,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1134,col 19)-(line 1134,col 113)","literalExprId":32,"literalExpr":"\"(^|\\\\n)((comparing with default-push\\\\n)?abort: repository default(-push)? not found!: .*\\\\n)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1135,col 19)-(line 1135,col 22)","literalExprId":33,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1139,col 28)-(line 1139,col 74)","literalExprId":34,"literalExpr":"\"(svn: Network connection closed unexpectedly)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1139,col 77)-(line 1139,col 85)","literalExprId":35,"literalExpr":"\"$1 for \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1140,col 38)-(line 1140,col 63)","literalExprId":36,"literalExpr":"\"(svn: Repository) (UUID)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1140,col 66)-(line 1140,col 70)","literalExprId":37,"literalExpr":"\"$1 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1140,col 80)-(line 1140,col 84)","literalExprId":38,"literalExpr":"\" $2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1143,col 19)-(line 1143,col 108)","literalExprId":39,"literalExpr":"\"(svn: E155037: Previous operation has not finished; run 'cleanup' if it was interrupted)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1144,col 19)-(line 1144,col 28)","literalExprId":40,"literalExpr":"\"$1; for \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1147,col 18)-(line 1147,col 22)","literalExprId":41,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1152,col 15)-(line 1152,col 200)","literalExprId":42,"literalExpr":"\"(remote: )?Warning: untrusted X11 forwarding setup failed: xauth key data not generated\\r*\\n(remote: )?Warning: No xauth data; using fake authentication data for X11 forwarding\\\\.\\r*\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1153,col 15)-(line 1153,col 16)","literalExprId":43,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1154,col 34)-(line 1154,col 51)","literalExprId":44,"literalExpr":"\"(working copy ')\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1154,col 54)-(line 1154,col 57)","literalExprId":45,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1156,col 18)-(line 1156,col 23)","literalExprId":46,"literalExpr":"\"echo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1156,col 26)-(line 1156,col 34)","literalExprId":47,"literalExpr":"\"command\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1156,col 37)-(line 1156,col 41)","literalExprId":48,"literalExpr":"\"not\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1156,col 44)-(line 1156,col 48)","literalExprId":49,"literalExpr":"\"set\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1162,col 36)-(line 1162,col 40)","literalExprId":50,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1171,col 31)-(line 1171,col 34)","literalExprId":51,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1172,col 31)-(line 1172,col 82)","literalExprId":52,"literalExpr":"\"Skipping checkout with unknown repository:%n  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1177,col 34)-(line 1177,col 78)","literalExprId":53,"literalExpr":"\"bzr handling not yet implemented: skipping \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1180,col 34)-(line 1180,col 37)","literalExprId":54,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1180,col 41)-(line 1180,col 88)","literalExprId":55,"literalExpr":"\"@AssumeAssertion(nullness): dependent type CVS\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1183,col 19)-(line 1183,col 22)","literalExprId":56,"literalExpr":"\"-d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1185,col 19)-(line 1185,col 28)","literalExprId":57,"literalExpr":"\"checkout\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1186,col 19)-(line 1186,col 22)","literalExprId":58,"literalExpr":"\"-P\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1187,col 19)-(line 1187,col 23)","literalExprId":59,"literalExpr":"\"-ko\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1192,col 42)-(line 1192,col 48)","literalExprId":60,"literalExpr":"\"clone\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1196,col 41)-(line 1196,col 47)","literalExprId":61,"literalExpr":"\"clone\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1199,col 28)-(line 1199,col 39)","literalExprId":62,"literalExpr":"\"--insecure\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1203,col 31)-(line 1203,col 34)","literalExprId":63,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1204,col 44)-(line 1204,col 53)","literalExprId":64,"literalExpr":"\"checkout\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1206,col 44)-(line 1206,col 53)","literalExprId":65,"literalExpr":"\"checkout\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1211,col 22)-(line 1211,col 26)","literalExprId":66,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1217,col 32)-(line 1217,col 35)","literalExprId":67,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1220,col 34)-(line 1220,col 78)","literalExprId":68,"literalExpr":"\"bzr handling not yet implemented: skipping \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1223,col 38)-(line 1223,col 41)","literalExprId":69,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1226,col 19)-(line 1226,col 22)","literalExprId":70,"literalExpr":"\"-q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1230,col 19)-(line 1230,col 24)","literalExprId":71,"literalExpr":"\"diff\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1231,col 19)-(line 1231,col 22)","literalExprId":72,"literalExpr":"\"-b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1232,col 19)-(line 1232,col 27)","literalExprId":73,"literalExpr":"\"--brief\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1233,col 19)-(line 1233,col 22)","literalExprId":74,"literalExpr":"\"-N\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1240,col 20)-(line 1240,col 25)","literalExprId":75,"literalExpr":"\"\\n=+\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1241,col 25)-(line 1241,col 40)","literalExprId":76,"literalExpr":"\"\\nRCS file: .*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1242,col 25)-(line 1242,col 53)","literalExprId":77,"literalExpr":"\"(\\nretrieving revision .*)?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1243,col 25)-(line 1243,col 35)","literalExprId":78,"literalExpr":"\"\\ndiff .*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1244,col 25)-(line 1244,col 53)","literalExprId":79,"literalExpr":"\"(\\nFiles .* and .* differ)?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1246,col 56)-(line 1246,col 57)","literalExprId":80,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1247,col 42)-(line 1247,col 57)","literalExprId":81,"literalExpr":"\"(^|\\\\n)Index: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1247,col 60)-(line 1247,col 63)","literalExprId":82,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1247,col 73)-(line 1247,col 75)","literalExprId":83,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1249,col 32)-(line 1249,col 67)","literalExprId":84,"literalExpr":"\"(^|\\\\n)(cvs \\\\[diff aborted)(\\\\]:)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1249,col 70)-(line 1249,col 79)","literalExprId":85,"literalExpr":"\"$1$2 in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1249,col 89)-(line 1249,col 92)","literalExprId":86,"literalExpr":"\"$3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1250,col 42)-(line 1250,col 69)","literalExprId":87,"literalExpr":"\"(^|\\\\n)(Permission denied)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1250,col 72)-(line 1250,col 81)","literalExprId":88,"literalExpr":"\"$1$2 in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1253,col 23)-(line 1253,col 73)","literalExprId":89,"literalExpr":"\"(^|\\\\n)(cvs diff: )(cannot find revision control)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1254,col 23)-(line 1254,col 32)","literalExprId":90,"literalExpr":"\"$1$2 in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1254,col 42)-(line 1254,col 47)","literalExprId":91,"literalExpr":"\": $3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1255,col 42)-(line 1255,col 74)","literalExprId":92,"literalExpr":"\"(^|\\\\n)(cvs diff: cannot find )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1255,col 77)-(line 1255,col 82)","literalExprId":93,"literalExpr":"\"$1$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1256,col 42)-(line 1256,col 75)","literalExprId":94,"literalExpr":"\"(^|\\\\n)(cvs diff: in directory )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1256,col 78)-(line 1256,col 83)","literalExprId":95,"literalExpr":"\"$1$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1256,col 93)-(line 1256,col 95)","literalExprId":96,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1257,col 42)-(line 1257,col 71)","literalExprId":97,"literalExpr":"\"(^|\\\\n)(cvs diff: ignoring )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1257,col 74)-(line 1257,col 79)","literalExprId":98,"literalExpr":"\"$1$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1257,col 89)-(line 1257,col 91)","literalExprId":99,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1260,col 42)-(line 1260,col 49)","literalExprId":100,"literalExpr":"\"status\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1264,col 26)-(line 1264,col 38)","literalExprId":101,"literalExpr":"\"--porcelain\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1267,col 23)-(line 1267,col 104)","literalExprId":102,"literalExpr":"\"(^|\\\\n)On branch master\\\\nYour branch is up-to-date with 'origin\/master'.\\\\n\\\\n?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1268,col 23)-(line 1268,col 26)","literalExprId":103,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1270,col 32)-(line 1270,col 86)","literalExprId":104,"literalExpr":"\"(^|\\\\n)nothing to commit,? working directory clean\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1270,col 89)-(line 1270,col 92)","literalExprId":105,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1273,col 23)-(line 1273,col 107)","literalExprId":106,"literalExpr":"\"(^|\\\\n)no changes added to commit \\\\(use \\\"git add\\\" and\/or \\\"git commit -a\\\"\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1274,col 23)-(line 1274,col 26)","literalExprId":107,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1277,col 23)-(line 1277,col 116)","literalExprId":108,"literalExpr":"\"(^|\\\\n)nothing added to commit but untracked files present \\\\(use \\\"git add\\\" to track\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1278,col 23)-(line 1278,col 26)","literalExprId":109,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1281,col 23)-(line 1281,col 87)","literalExprId":110,"literalExpr":"\"(^|\\\\n)nothing to commit \\\\(use -u to show untracked files\\\\)\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1281,col 90)-(line 1281,col 93)","literalExprId":111,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1283,col 42)-(line 1283,col 54)","literalExprId":112,"literalExpr":"\"(^|\\\\n)#\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1283,col 57)-(line 1283,col 60)","literalExprId":113,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1284,col 42)-(line 1284,col 71)","literalExprId":114,"literalExpr":"\"(^|\\\\n)# On branch master\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1284,col 74)-(line 1284,col 77)","literalExprId":115,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1286,col 32)-(line 1286,col 90)","literalExprId":116,"literalExpr":"\"(^|\\\\n)nothing to commit \\\\(working directory clean\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1286,col 93)-(line 1286,col 96)","literalExprId":117,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1287,col 42)-(line 1287,col 79)","literalExprId":118,"literalExpr":"\"(^|\\\\n)# Changed but not updated:\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1287,col 82)-(line 1287,col 85)","literalExprId":119,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1290,col 23)-(line 1290,col 102)","literalExprId":120,"literalExpr":"\"(^|\\\\n)#   \\\\(use \\\"git add <file>...\\\" to update what will be committed\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1291,col 23)-(line 1291,col 26)","literalExprId":121,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1294,col 23)-(line 1294,col 117)","literalExprId":122,"literalExpr":"\"(^|\\\\n)#   \\\\(use \\\"git checkout -- <file>...\\\" to discard changes in working directory\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1295,col 23)-(line 1295,col 26)","literalExprId":123,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1296,col 42)-(line 1296,col 71)","literalExprId":124,"literalExpr":"\"(^|\\\\n)# Untracked files:\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1296,col 74)-(line 1296,col 77)","literalExprId":125,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1299,col 23)-(line 1299,col 106)","literalExprId":126,"literalExpr":"\"(^|\\\\n)#   \\\\(use \\\"git add <file>...\\\" to include in what will be committed\\\\)\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1300,col 23)-(line 1300,col 26)","literalExprId":127,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1302,col 42)-(line 1302,col 67)","literalExprId":128,"literalExpr":"\"(^|\\\\n)(#\\tmodified:   )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1302,col 70)-(line 1302,col 73)","literalExprId":129,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1302,col 83)-(line 1302,col 85)","literalExprId":130,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1304,col 42)-(line 1304,col 55)","literalExprId":131,"literalExpr":"\"(^|\\\\n)(#\\t)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1304,col 58)-(line 1304,col 72)","literalExprId":132,"literalExpr":"\"$1untracked: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1304,col 82)-(line 1304,col 84)","literalExprId":133,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1307,col 23)-(line 1307,col 62)","literalExprId":134,"literalExpr":"\"(^|\\\\n)# Your branch is ahead of .*\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1308,col 23)-(line 1308,col 47)","literalExprId":135,"literalExpr":"\"$1unpushed changesets: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1308,col 68)-(line 1308,col 71)","literalExprId":136,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1309,col 42)-(line 1309,col 59)","literalExprId":137,"literalExpr":"\"(^|\\\\n)([?][?]) \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1309,col 62)-(line 1309,col 68)","literalExprId":138,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1309,col 78)-(line 1309,col 80)","literalExprId":139,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1312,col 23)-(line 1312,col 71)","literalExprId":140,"literalExpr":"\"(^|\\\\n)([ACDMRU][ ACDMRTU]|[ ACDMRU][ACDMRTU]) \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1312,col 74)-(line 1312,col 80)","literalExprId":141,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1312,col 90)-(line 1312,col 92)","literalExprId":142,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1317,col 23)-(line 1317,col 60)","literalExprId":143,"literalExpr":"\"(^|\\\\n)# Your branch is behind .*\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1318,col 23)-(line 1318,col 47)","literalExprId":144,"literalExpr":"\"$1unpushed changesets: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1318,col 68)-(line 1318,col 71)","literalExprId":145,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1326,col 43)-(line 1326,col 47)","literalExprId":146,"literalExpr":"\"log\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1326,col 50)-(line 1326,col 61)","literalExprId":147,"literalExpr":"\"--branches\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1326,col 64)-(line 1326,col 70)","literalExprId":148,"literalExpr":"\"--not\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1326,col 73)-(line 1326,col 83)","literalExprId":149,"literalExpr":"\"--remotes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1330,col 23)-(line 1330,col 42)","literalExprId":150,"literalExpr":"\"^commit .*(.*\\\\n)+\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1330,col 45)-(line 1330,col 64)","literalExprId":151,"literalExpr":"\"unpushed commits: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1330,col 86)-(line 1330,col 89)","literalExprId":152,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1336,col 41)-(line 1336,col 48)","literalExprId":153,"literalExpr":"\"status\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1340,col 21)-(line 1340,col 52)","literalExprId":154,"literalExpr":"\"invalidCertificate(%s) => %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1343,col 44)-(line 1343,col 53)","literalExprId":155,"literalExpr":"\"outgoing\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1343,col 56)-(line 1343,col 59)","literalExprId":156,"literalExpr":"\"-l\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1343,col 62)-(line 1343,col 64)","literalExprId":157,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1343,col 67)-(line 1343,col 76)","literalExprId":158,"literalExpr":"\"--config\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1343,col 79)-(line 1343,col 92)","literalExprId":159,"literalExpr":"\"web.cacerts=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1345,col 44)-(line 1345,col 53)","literalExprId":160,"literalExpr":"\"outgoing\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1345,col 56)-(line 1345,col 59)","literalExprId":161,"literalExpr":"\"-l\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1345,col 62)-(line 1345,col 64)","literalExprId":162,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1349,col 29)-(line 1349,col 40)","literalExprId":163,"literalExpr":"\"--insecure\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1354,col 23)-(line 1354,col 86)","literalExprId":164,"literalExpr":"\"^comparing with .*\\\\nsearching for changes\\\\nchangeset[^\\001]*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1355,col 23)-(line 1355,col 45)","literalExprId":165,"literalExpr":"\"unpushed changesets: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1355,col 66)-(line 1355,col 69)","literalExprId":166,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1358,col 23)-(line 1358,col 91)","literalExprId":167,"literalExpr":"\"^\\\\n?comparing with .*\\\\nsearching for changes\\\\nno changes found\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1358,col 94)-(line 1358,col 95)","literalExprId":168,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1360,col 42)-(line 1360,col 49)","literalExprId":169,"literalExpr":"\"shelve\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1360,col 52)-(line 1360,col 55)","literalExprId":170,"literalExpr":"\"-l\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1362,col 43)-(line 1362,col 84)","literalExprId":171,"literalExpr":"\"^hg: unknown command 'shelve'\\\\n(.*\\\\n)+\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1362,col 87)-(line 1362,col 88)","literalExprId":172,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1364,col 32)-(line 1364,col 42)","literalExprId":173,"literalExpr":"\"^(.*\\\\n)+\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1364,col 45)-(line 1364,col 63)","literalExprId":174,"literalExpr":"\"shelved changes: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1364,col 84)-(line 1364,col 87)","literalExprId":175,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1370,col 32)-(line 1370,col 74)","literalExprId":176,"literalExpr":"\"(^|\\\\n)([ACDIMRX?!~ ][CM ][L ][+ ][$ ]) *\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1370,col 77)-(line 1370,col 83)","literalExprId":177,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1370,col 93)-(line 1370,col 95)","literalExprId":178,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1371,col 42)-(line 1371,col 49)","literalExprId":179,"literalExpr":"\"status\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1375,col 22)-(line 1375,col 26)","literalExprId":180,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1381,col 34)-(line 1381,col 78)","literalExprId":181,"literalExpr":"\"bzr handling not yet implemented: skipping \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1386,col 23)-(line 1386,col 92)","literalExprId":182,"literalExpr":"\"(^|\\\\n)(cvs update: ((in|skipping) directory|conflicts found in )) +\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1387,col 23)-(line 1387,col 29)","literalExprId":183,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1387,col 39)-(line 1387,col 41)","literalExprId":184,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1390,col 23)-(line 1390,col 80)","literalExprId":185,"literalExpr":"\"(^|\\\\n)(Merging differences between 1.16 and 1.17 into )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1391,col 23)-(line 1391,col 29)","literalExprId":186,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1391,col 39)-(line 1391,col 41)","literalExprId":187,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1392,col 38)-(line 1392,col 41)","literalExprId":188,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1398,col 19)-(line 1398,col 22)","literalExprId":189,"literalExpr":"\"-Q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1399,col 19)-(line 1399,col 26)","literalExprId":190,"literalExpr":"\"update\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1400,col 19)-(line 1400,col 22)","literalExprId":191,"literalExpr":"\"-d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1403,col 42)-(line 1403,col 67)","literalExprId":192,"literalExpr":"\"(cvs update: move away )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1403,col 70)-(line 1403,col 73)","literalExprId":193,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1403,col 83)-(line 1403,col 85)","literalExprId":194,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1404,col 42)-(line 1404,col 71)","literalExprId":195,"literalExpr":"\"(cvs \\\\[update aborted)(\\\\])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1404,col 74)-(line 1404,col 81)","literalExprId":196,"literalExpr":"\"$1 in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1404,col 91)-(line 1404,col 94)","literalExprId":197,"literalExpr":"\"$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1407,col 42)-(line 1407,col 74)","literalExprId":198,"literalExpr":"\"(^|\\\\n)Already up-to-date\\\\.\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1407,col 77)-(line 1407,col 80)","literalExprId":199,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1408,col 42)-(line 1408,col 56)","literalExprId":200,"literalExpr":"\"(^|\\\\n)error:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1408,col 59)-(line 1408,col 71)","literalExprId":201,"literalExpr":"\"$1error in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1408,col 81)-(line 1408,col 83)","literalExprId":202,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1411,col 23)-(line 1411,col 108)","literalExprId":203,"literalExpr":"\"(^|\\\\n)Please, commit your changes or stash them before you can merge.\\\\nAborting\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1412,col 23)-(line 1412,col 26)","literalExprId":204,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1415,col 23)-(line 1415,col 75)","literalExprId":205,"literalExpr":"\"((^|\\\\n)CONFLICT \\\\(content\\\\): Merge conflict in )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1415,col 78)-(line 1415,col 81)","literalExprId":206,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1415,col 91)-(line 1415,col 93)","literalExprId":207,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1416,col 42)-(line 1416,col 62)","literalExprId":208,"literalExpr":"\"(^|\\\\n)([ACDMRU]\\t)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1416,col 65)-(line 1416,col 70)","literalExprId":209,"literalExpr":"\"$1$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1416,col 80)-(line 1416,col 82)","literalExprId":210,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1417,col 42)-(line 1417,col 47)","literalExprId":211,"literalExpr":"\"pull\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1417,col 50)-(line 1417,col 53)","literalExprId":212,"literalExpr":"\"-q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1420,col 43)-(line 1420,col 49)","literalExprId":213,"literalExpr":"\"fetch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1420,col 52)-(line 1420,col 55)","literalExprId":214,"literalExpr":"\"-p\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1423,col 42)-(line 1423,col 62)","literalExprId":215,"literalExpr":"\"(^|\\\\n)([?!AMR] ) +\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1423,col 65)-(line 1423,col 71)","literalExprId":216,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1423,col 81)-(line 1423,col 83)","literalExprId":217,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1424,col 42)-(line 1424,col 57)","literalExprId":218,"literalExpr":"\"(^|\\\\n)abort: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1424,col 60)-(line 1424,col 63)","literalExprId":219,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1425,col 41)-(line 1425,col 44)","literalExprId":220,"literalExpr":"\"-q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1425,col 47)-(line 1425,col 54)","literalExprId":221,"literalExpr":"\"update\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1428,col 44)-(line 1428,col 47)","literalExprId":222,"literalExpr":"\"-q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1428,col 50)-(line 1428,col 56)","literalExprId":223,"literalExpr":"\"fetch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1428,col 59)-(line 1428,col 68)","literalExprId":224,"literalExpr":"\"--config\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1428,col 71)-(line 1428,col 84)","literalExprId":225,"literalExpr":"\"web.cacerts=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1430,col 44)-(line 1430,col 47)","literalExprId":226,"literalExpr":"\"-q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1430,col 50)-(line 1430,col 56)","literalExprId":227,"literalExpr":"\"fetch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1434,col 29)-(line 1434,col 40)","literalExprId":228,"literalExpr":"\"--insecure\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1438,col 42)-(line 1438,col 62)","literalExprId":229,"literalExpr":"\"(^|\\\\n)([?!AMR] ) +\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1438,col 65)-(line 1438,col 71)","literalExprId":230,"literalExpr":"\"$1$2 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1438,col 81)-(line 1438,col 83)","literalExprId":231,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1439,col 42)-(line 1439,col 75)","literalExprId":232,"literalExpr":"\"(svn: Failed to add file ')(.*')\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1439,col 78)-(line 1439,col 81)","literalExprId":233,"literalExpr":"\"$1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1439,col 91)-(line 1439,col 95)","literalExprId":234,"literalExpr":"\"\/$2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1440,col 38)-(line 1440,col 41)","literalExprId":235,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1441,col 42)-(line 1441,col 45)","literalExprId":236,"literalExpr":"\"-q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1441,col 48)-(line 1441,col 55)","literalExprId":237,"literalExpr":"\"update\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1446,col 22)-(line 1446,col 26)","literalExprId":238,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1450,col 18)-(line 1450,col 22)","literalExprId":239,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1455,col 34)-(line 1455,col 36)","literalExprId":240,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1459,col 30)-(line 1459,col 71)","literalExprId":241,"literalExpr":"\"Skipping checkout (dir already exists): \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1465,col 23)-(line 1465,col 26)","literalExprId":242,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1468,col 29)-(line 1468,col 81)","literalExprId":243,"literalExpr":"\"Directory %s does not exist, and it has no parent%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1477,col 23)-(line 1477,col 62)","literalExprId":244,"literalExpr":"\"Parent directory %s does not exist%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1479,col 34)-(line 1479,col 35)","literalExprId":245,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1479,col 39)-(line 1479,col 51)","literalExprId":246,"literalExpr":"\" (creating)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1481,col 37)-(line 1481,col 53)","literalExprId":247,"literalExpr":"\"  mkdir -p %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1486,col 38)-(line 1486,col 67)","literalExprId":248,"literalExpr":"\"Could not create directory: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1487,col 31)-(line 1487,col 31)","literalExprId":249,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1495,col 34)-(line 1495,col 58)","literalExprId":250,"literalExpr":"\"Cannot find directory: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1500,col 20)-(line 1500,col 24)","literalExprId":251,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1505,col 34)-(line 1505,col 37)","literalExprId":252,"literalExpr":"\" :\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1508,col 34)-(line 1508,col 34)","literalExprId":253,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1511,col 34)-(line 1511,col 34)","literalExprId":254,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.process(java.util.Set<plume.MultiVersionControl.Checkout>)"},{"methodDeclaration":"private String defaultPath(File dir)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    File hgrc = new File(new File(dir, \".hg\"), \"hgrc\");\n    try (EntryReader er = new EntryReader(hgrc, \"^#.*\", null)) {\n        for (String line : er) {\n            Matcher m = defaultPattern.matcher(line);\n            if (m.matches()) {\n                return m.group(1);\n            }\n        }\n    } catch (IOException e) {\n        return null;\n    }\n    return null;\n}","methodRange":"(line 1526,col 3)-(line 1540,col 3)","methodTokenRange":"private \/*@Nullable*\/ String defaultPath(File dir) {\n    File hgrc = new File(new File(dir, \".hg\"), \"hgrc\");\n    try (EntryReader er = new EntryReader(hgrc, \"^#.*\", null)) {\n      for (String line : er) {\n        Matcher m = defaultPattern.matcher(line);\n        if (m.matches()) {\n          return m.group(1);\n        }\n      }\n    } catch (IOException e) {\n      \/\/ System.out.printf(\"IOException: \" + e);\n      return null;\n    }\n    return null;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" calling \"hg showconfig\".  This hack is good enough for now.","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"}],"methodName":"defaultPath","methodQualifiedSignature":"plume.MultiVersionControl.defaultPath","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1527,col 40)-(line 1527,col 44)","literalExprId":1,"literalExpr":"\".hg\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1527,col 48)-(line 1527,col 53)","literalExprId":2,"literalExpr":"\"hgrc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1528,col 49)-(line 1528,col 54)","literalExprId":3,"literalExpr":"\"^#.*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1528,col 57)-(line 1528,col 60)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1532,col 26)-(line 1532,col 26)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1537,col 14)-(line 1537,col 17)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1539,col 12)-(line 1539,col 15)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.defaultPath(java.io.File)"},{"methodDeclaration":"private boolean invalidCertificate(File dir)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    String defaultPath = defaultPath(dir);\n    if (debug) {\n        System.out.printf(\"defaultPath=%s for %s%n\", defaultPath, dir);\n    }\n    if (defaultPath == null) {\n        return false;\n    }\n    return (defaultPath.startsWith(\"https:\/\/hg.codespot.com\/\") || invalidCertificatePattern.matcher(defaultPath).matches());\n}","methodRange":"(line 1545,col 3)-(line 1555,col 3)","methodTokenRange":"private boolean invalidCertificate(File dir) {\n    String defaultPath = defaultPath(dir);\n    if (debug) {\n      System.out.printf(\"defaultPath=%s for %s%n\", defaultPath, dir);\n    }\n    if (defaultPath == null) {\n      return false;\n    }\n    return (defaultPath.startsWith(\"https:\/\/hg.codespot.com\/\")\n        || invalidCertificatePattern.matcher(defaultPath).matches());\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"}],"methodName":"invalidCertificate","methodQualifiedSignature":"plume.MultiVersionControl.invalidCertificate","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1548,col 25)-(line 1548,col 49)","literalExprId":1,"literalExpr":"\"defaultPath=%s for %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1550,col 24)-(line 1550,col 27)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1551,col 14)-(line 1551,col 18)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1553,col 36)-(line 1553,col 61)","literalExprId":4,"literalExpr":"\"https:\/\/hg.codespot.com\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.invalidCertificate(java.io.File)"},{"methodDeclaration":" void perform_command(ProcessBuilder pb, List<Replacer> replacers, boolean show_normal_output)","methodAccessSpecifier":"NONE","methodBody":"{\n    if (show) {\n        System.out.println(command(pb));\n    }\n    if (dry_run) {\n        return;\n    }\n    try {\n        TimeLimitProcess p = new TimeLimitProcess(pb.start(), timeout * 1000, true);\n        p.waitFor();\n        Thread.sleep(10);\n        if (p.timed_out()) {\n            System.out.printf(\"Timed out (limit: %ss):%n\", timeout);\n            System.out.println(command(pb));\n        }\n        if (show_normal_output || p.exitValue() != 0 || debug_replacers || debug_process_output) {\n            String output = UtilMDE.streamString(p.getInputStream());\n            if (debug_replacers || debug_process_output) {\n                System.out.println(\"preoutput=<<<\" + output + \">>>\");\n            }\n            for (Replacer r : replacers) {\n                if (debug_replacers) {\n                    System.out.println(\"midoutput_pre[\" + r.regexp + \"]=<<<\" + output + \">>>\");\n                }\n                output = r.replaceAll(output);\n                if (debug_replacers) {\n                    System.out.println(\"midoutput_post[\" + r.regexp + \"]=<<<\" + output + \">>>\");\n                }\n            }\n            if (debug_replacers || debug_process_output) {\n                System.out.println(\"postoutput=<<<\" + output + \">>>\");\n            }\n            if (debug_replacers) {\n                for (int i = 0; i < Math.min(100, output.length()); i++) {\n                    System.out.println(i + \": \" + (int) output.charAt(i) + \"\\n        \\\"\" + output.charAt(i) + \"\\\"\");\n                }\n            }\n            System.out.print(output);\n        }\n    } catch (IOException e) {\n        throw new Error(e);\n    } catch (InterruptedException e) {\n        throw new Error(e);\n    }\n}","methodRange":"(line 1560,col 3)-(line 1639,col 3)","methodTokenRange":"void perform_command(ProcessBuilder pb, List<Replacer> replacers, boolean show_normal_output) {\n    \/\/\/ The redirectOutput method only exists in Java 1.7.  Sigh.\n    \/\/\/ The workaround is to make TimeLimitProcess buffer its output.\n    \/\/ File tempFile;\n    \/\/ try {\n    \/\/   tempFile = File.createTempFile(\"mvc\", null);\n    \/\/ } catch (IOException e) {\n    \/\/   throw new Error(\"File.createTempFile can't create temporary file.\", e);\n    \/\/ }\n    \/\/ tempFile.deleteOnExit();\n    \/\/ pb.redirectOutput(tempFile);\n\n    if (show) {\n      System.out.println(command(pb));\n    }\n    if (dry_run) {\n      return;\n    }\n    try {\n      \/\/ Perform the command\n\n      \/\/ For debugging\n      \/\/  my $command_cwd_sanitized = $command_cwd;\n      \/\/  $command_cwd_sanitized =~ s\/\\\/\/_\/g;\n      \/\/  $tmpfile = \"\/tmp\/cmd-output-$$-$command_cwd_sanitized\";\n      \/\/ my $command_redirected = \"$command > $tmpfile 2>&1\";\n      TimeLimitProcess p = new TimeLimitProcess(pb.start(), timeout * 1000, true);\n      p.waitFor();\n      \/\/ For reasons that are mysterious to me, this is necessary in order to\n      \/\/ reliably capture the process's output.  I don't know why.  Calling\n      \/\/ waitFor on the result of pb.start() didn't help -- only this did.\n      Thread.sleep(10);\n      if (p.timed_out()) {\n        System.out.printf(\"Timed out (limit: %ss):%n\", timeout);\n        System.out.println(command(pb));\n        \/\/ Don't return; also show the output\n      }\n\n      \/\/ Under what conditions should the output be printed?\n      \/\/  * for status, always\n      \/\/  * whenever the process exited non-normally\n      \/\/  * when debugging\n      \/\/  * other circumstances?\n      \/\/ Try printing always, to better understand this question.\n      if (show_normal_output || p.exitValue() != 0 || debug_replacers || debug_process_output) {\n        \/\/ Filter then print the output.\n        \/\/ String output = UtilMDE.readerContents(new BufferedReader(new InputStreamReader(p.getInputStream())));\n        \/\/ String output = UtilMDE.streamString(p.getInputStream());\n        String output = UtilMDE.streamString(p.getInputStream());\n        if (debug_replacers || debug_process_output) {\n          System.out.println(\"preoutput=<<<\" + output + \">>>\");\n        }\n        for (Replacer r : replacers) {\n          if (debug_replacers) {\n            System.out.println(\"midoutput_pre[\" + r.regexp + \"]=<<<\" + output + \">>>\");\n          }\n          \/\/ Don't loop, because some regexps will continue to match repeatedly\n          output = r.replaceAll(output);\n          if (debug_replacers) {\n            System.out.println(\"midoutput_post[\" + r.regexp + \"]=<<<\" + output + \">>>\");\n          }\n        }\n        if (debug_replacers || debug_process_output) {\n          System.out.println(\"postoutput=<<<\" + output + \">>>\");\n        }\n        if (debug_replacers) {\n          for (int i = 0; i < Math.min(100, output.length()); i++) {\n            System.out.println(\n                i + \": \" + (int) output.charAt(i) + \"\\n        \\\"\" + output.charAt(i) + \"\\\"\");\n          }\n        }\n        System.out.print(output);\n      }\n\n    } catch (IOException e) {\n      throw new Error(e);\n    } catch (InterruptedException e) {\n      throw new Error(e);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" process completed erroneously.","methodParameters":[{"parameterType":"ProcessBuilder","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.ProcessBuilder, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.ProcessBuilder","parameter":"ProcessBuilder pb","parameterName":"pb"},{"parameterType":"List<Replacer>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.MultiVersionControl.Replacer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<plume.MultiVersionControl.Replacer>","parameter":"List<Replacer> replacers","parameterName":"replacers"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean show_normal_output","parameterName":"show_normal_output"}],"methodName":"perform_command","methodQualifiedSignature":"plume.MultiVersionControl.perform_command","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1586,col 71)-(line 1586,col 74)","literalExprId":1,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1586,col 77)-(line 1586,col 80)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1591,col 20)-(line 1591,col 21)","literalExprId":3,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1593,col 27)-(line 1593,col 53)","literalExprId":4,"literalExpr":"\"Timed out (limit: %ss):%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1604,col 50)-(line 1604,col 50)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1610,col 30)-(line 1610,col 44)","literalExprId":6,"literalExpr":"\"preoutput=<<<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1610,col 57)-(line 1610,col 61)","literalExprId":7,"literalExpr":"\">>>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1614,col 32)-(line 1614,col 47)","literalExprId":8,"literalExpr":"\"midoutput_pre[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1614,col 62)-(line 1614,col 68)","literalExprId":9,"literalExpr":"\"]=<<<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1614,col 81)-(line 1614,col 85)","literalExprId":10,"literalExpr":"\">>>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1619,col 32)-(line 1619,col 48)","literalExprId":11,"literalExpr":"\"midoutput_post[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1619,col 63)-(line 1619,col 69)","literalExprId":12,"literalExpr":"\"]=<<<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1619,col 82)-(line 1619,col 86)","literalExprId":13,"literalExpr":"\">>>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1623,col 30)-(line 1623,col 45)","literalExprId":14,"literalExpr":"\"postoutput=<<<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1623,col 58)-(line 1623,col 62)","literalExprId":15,"literalExpr":"\">>>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1626,col 24)-(line 1626,col 24)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1626,col 40)-(line 1626,col 42)","literalExprId":17,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1628,col 21)-(line 1628,col 24)","literalExprId":18,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1628,col 53)-(line 1628,col 66)","literalExprId":19,"literalExpr":"\"\\n        \\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1628,col 89)-(line 1628,col 92)","literalExprId":20,"literalExpr":"\"\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.perform_command(java.lang.ProcessBuilder, java.util.List<plume.MultiVersionControl.Replacer>, boolean)"},{"methodDeclaration":" String command(ProcessBuilder pb)","methodAccessSpecifier":"NONE","methodBody":"{\n    return \"  cd \" + pb.directory() + \"\\n  \" + UtilMDE.join(pb.command(), \" \");\n}","methodRange":"(line 1641,col 3)-(line 1643,col 3)","methodTokenRange":"String command(ProcessBuilder pb) {\n    return \"  cd \" + pb.directory() + \"\\n  \" + UtilMDE.join(pb.command(), \" \");\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"ProcessBuilder","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.ProcessBuilder, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.ProcessBuilder","parameter":"ProcessBuilder pb","parameterName":"pb"}],"methodName":"command","methodQualifiedSignature":"plume.MultiVersionControl.command","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1642,col 12)-(line 1642,col 18)","literalExprId":1,"literalExpr":"\"  cd \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1642,col 39)-(line 1642,col 44)","literalExprId":2,"literalExpr":"\"\\n  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1642,col 75)-(line 1642,col 77)","literalExprId":3,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.MultiVersionControl.command(java.lang.ProcessBuilder)"}],"classJavadoc":"","className":"MultiVersionControl","fields":[{"fieldRange":"(line 251,col 3)-(line 252,col 62)","fieldName":"home","fieldJavadocComment":"","fieldTokenRange":"@Option(value = \"User home directory\", noDocDefault = true)\n  public static String home = System.getProperty(\"user.home\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 251,col 19)-(line 251,col 39)","literalExprId":1,"literalExpr":"\"User home directory\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 251,col 57)-(line 251,col 60)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 252,col 50)-(line 252,col 60)","literalExprId":3,"literalExpr":"\"user.home\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"user.home\")]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 258,col 3)-(line 259,col 47)","fieldName":"checkouts","fieldJavadocComment":"\n   * File with list of checkouts.  Set it to \/dev\/null to suppress reading.\n   * Defaults to <code>$HOME\/.mvc-checkouts<\/code>.\n   ","fieldTokenRange":"@Option(\"File with list of checkouts.  Set it to \/dev\/null to suppress reading.\")\n  public String checkouts = \"~\/.mvc-checkouts\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 258,col 11)-(line 258,col 82)","literalExprId":1,"literalExpr":"\"File with list of checkouts.  Set it to \/dev\/null to suppress reading.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 259,col 29)-(line 259,col 46)","literalExprId":2,"literalExpr":"\"~\/.mvc-checkouts\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"~\/.mvc-checkouts\"]","fieldType":"String","fieldJavadoc":"File with list of checkouts.  Set it to \/dev\/null to suppress reading.\nDefaults to <code>$HOME\/.mvc-checkouts<\/code>.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 261,col 3)-(line 262,col 52)","fieldName":"dir","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Directory under which to search for checkouts; default=home dir\")\n  public List<String> dir = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 261,col 11)-(line 261,col 75)","literalExprId":1,"literalExpr":"\"Directory under which to search for checkouts; default=home dir\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 264,col 3)-(line 265,col 59)","fieldName":"ignore_dir","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Directory under which to NOT search for checkouts\")\n  public List<String> ignore_dir = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 264,col 11)-(line 264,col 61)","literalExprId":1,"literalExpr":"\"Directory under which to NOT search for checkouts\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 267,col 3)-(line 267,col 56)","fieldName":"ignoreDirs","fieldJavadocComment":"","fieldTokenRange":"private List<File> ignoreDirs = new ArrayList<File>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<File>()]","fieldType":"List<File>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.io.File>"},{"fieldRange":"(line 270,col 3)-(line 271,col 32)","fieldName":"search","fieldJavadocComment":" Default is false because searching whole directory structure is slow.","fieldTokenRange":"@Option(\"Search for all checkouts, not just those listed in a file\")\n  public boolean search = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 270,col 11)-(line 270,col 69)","literalExprId":1,"literalExpr":"\"Search for all checkouts, not just those listed in a file\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 271,col 27)-(line 271,col 31)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 275,col 3)-(line 276,col 30)","fieldName":"show","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Display commands as they are executed\")\n  public boolean show = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 275,col 11)-(line 275,col 49)","literalExprId":1,"literalExpr":"\"Display commands as they are executed\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 276,col 25)-(line 276,col 29)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 278,col 3)-(line 279,col 41)","fieldName":"print_directory","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Print the directory before executing commands\")\n  public boolean print_directory = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 278,col 11)-(line 278,col 57)","literalExprId":1,"literalExpr":"\"Print the directory before executing commands\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 279,col 36)-(line 279,col 40)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 281,col 3)-(line 282,col 33)","fieldName":"dry_run","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Do not execute commands; just print them.  Implies --show --redo-existing\")\n  public boolean dry_run = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 281,col 11)-(line 281,col 85)","literalExprId":1,"literalExpr":"\"Do not execute commands; just print them.  Implies --show --redo-existing\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 282,col 28)-(line 282,col 32)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 285,col 3)-(line 286,col 39)","fieldName":"redo_existing","fieldJavadocComment":"  Default is for checkout command to skip existing directories. ","fieldTokenRange":"@Option(\"Redo existing checkouts; relevant only to checkout command\")\n  public boolean redo_existing = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 285,col 11)-(line 285,col 70)","literalExprId":1,"literalExpr":"\"Redo existing checkouts; relevant only to checkout command\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 286,col 34)-(line 286,col 38)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":" Default is for checkout command to skip existing directories.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 293,col 3)-(line 294,col 27)","fieldName":"timeout","fieldJavadocComment":"\n   * Terminating the process can leave the repository in a bad state, so\n   * set this rather high for safety.  Also, the timeout needs to account\n   * for the time to run hooks (that might recompile or run tests).\n   ","fieldTokenRange":"@Option(\"Timeout for each command, in seconds\")\n  public int timeout = 600;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 293,col 11)-(line 293,col 48)","literalExprId":1,"literalExpr":"\"Timeout for each command, in seconds\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 294,col 24)-(line 294,col 26)","literalExprId":2,"literalExpr":"600","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[600]","fieldType":"int","fieldJavadoc":"Terminating the process can leave the repository in a bad state, so\nset this rather high for safety.  Also, the timeout needs to account\nfor the time to run hooks (that might recompile or run tests).\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 296,col 3)-(line 297,col 30)","fieldName":"quiet","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-q Run quietly (e.g., no output about missing directories)\")\n  public boolean quiet = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 296,col 11)-(line 296,col 70)","literalExprId":1,"literalExpr":"\"-q Run quietly (e.g., no output about missing directories)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 297,col 26)-(line 297,col 29)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 305,col 3)-(line 306,col 39)","fieldName":"cvs_executable","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Path to the cvs program\")\n  public String cvs_executable = \"cvs\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 305,col 11)-(line 305,col 35)","literalExprId":1,"literalExpr":"\"Path to the cvs program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 306,col 34)-(line 306,col 38)","literalExprId":2,"literalExpr":"\"cvs\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"cvs\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 308,col 3)-(line 309,col 39)","fieldName":"git_executable","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Path to the git program\")\n  public String git_executable = \"git\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 308,col 11)-(line 308,col 35)","literalExprId":1,"literalExpr":"\"Path to the git program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 309,col 34)-(line 309,col 38)","literalExprId":2,"literalExpr":"\"git\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"git\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 311,col 3)-(line 312,col 37)","fieldName":"hg_executable","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Path to the hg program\")\n  public String hg_executable = \"hg\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 311,col 11)-(line 311,col 34)","literalExprId":1,"literalExpr":"\"Path to the hg program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 312,col 33)-(line 312,col 36)","literalExprId":2,"literalExpr":"\"hg\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"hg\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 314,col 3)-(line 315,col 39)","fieldName":"svn_executable","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Path to the svn program\")\n  public String svn_executable = \"svn\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 314,col 11)-(line 314,col 35)","literalExprId":1,"literalExpr":"\"Path to the svn program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 315,col 34)-(line 315,col 38)","literalExprId":2,"literalExpr":"\"svn\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"svn\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 317,col 3)-(line 318,col 34)","fieldName":"insecure","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Pass --insecure argument to hg (and likewise for other programs)\")\n  public boolean insecure = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 317,col 11)-(line 317,col 76)","literalExprId":1,"literalExpr":"\"Pass --insecure argument to hg (and likewise for other programs)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 318,col 29)-(line 318,col 33)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 324,col 3)-(line 325,col 56)","fieldName":"cvs_arg","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Extra argument to pass to the cvs program\")\n  public List<String> cvs_arg = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 324,col 11)-(line 324,col 53)","literalExprId":1,"literalExpr":"\"Extra argument to pass to the cvs program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 327,col 3)-(line 328,col 56)","fieldName":"git_arg","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Extra argument to pass  to the git program\")\n  public List<String> git_arg = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 327,col 11)-(line 327,col 54)","literalExprId":1,"literalExpr":"\"Extra argument to pass  to the git program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 330,col 3)-(line 331,col 55)","fieldName":"hg_arg","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Extra argument to pass  to the hg program\")\n  public List<String> hg_arg = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 330,col 11)-(line 330,col 53)","literalExprId":1,"literalExpr":"\"Extra argument to pass  to the hg program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 333,col 3)-(line 334,col 56)","fieldName":"svn_arg","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Extra argument to pass  to the svn program\")\n  public List<String> svn_arg = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 333,col 11)-(line 333,col 54)","literalExprId":1,"literalExpr":"\"Extra argument to pass  to the svn program\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 338,col 3)-(line 339,col 38)","fieldName":"debug","fieldJavadocComment":" This variable is static because it is used in static methods.","fieldTokenRange":"@Option(\"Print debugging output\")\n  public static boolean debug = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 338,col 11)-(line 338,col 34)","literalExprId":1,"literalExpr":"\"Print debugging output\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 339,col 33)-(line 339,col 37)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 341,col 3)-(line 342,col 41)","fieldName":"debug_replacers","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Debug 'replacers' that filter command output\")\n  public boolean debug_replacers = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 341,col 11)-(line 341,col 56)","literalExprId":1,"literalExpr":"\"Debug 'replacers' that filter command output\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 342,col 36)-(line 342,col 40)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 344,col 3)-(line 345,col 46)","fieldName":"debug_process_output","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Lightweight debugging of 'replacers' that filter command output\")\n  public boolean debug_process_output = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 344,col 11)-(line 344,col 75)","literalExprId":1,"literalExpr":"\"Lightweight debugging of 'replacers' that filter command output\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 345,col 41)-(line 345,col 45)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 354,col 3)-(line 354,col 45)","fieldName":"CLONE","fieldJavadocComment":" Shorter variants","fieldTokenRange":"private static Action CLONE = Action.CLONE;","fieldTypeResolved":"ReferenceType{plume.MultiVersionControl.Action, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Action.CLONE]","fieldType":"Action","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.MultiVersionControl.Action"},{"fieldRange":"(line 355,col 3)-(line 355,col 47)","fieldName":"STATUS","fieldJavadocComment":"","fieldTokenRange":"private static Action STATUS = Action.STATUS;","fieldTypeResolved":"ReferenceType{plume.MultiVersionControl.Action, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Action.STATUS]","fieldType":"Action","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.MultiVersionControl.Action"},{"fieldRange":"(line 356,col 3)-(line 356,col 43)","fieldName":"PULL","fieldJavadocComment":"","fieldTokenRange":"private static Action PULL = Action.PULL;","fieldTypeResolved":"ReferenceType{plume.MultiVersionControl.Action, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Action.PULL]","fieldType":"Action","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.MultiVersionControl.Action"},{"fieldRange":"(line 357,col 3)-(line 357,col 43)","fieldName":"LIST","fieldJavadocComment":"","fieldTokenRange":"private static Action LIST = Action.LIST;","fieldTypeResolved":"ReferenceType{plume.MultiVersionControl.Action, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Action.LIST]","fieldType":"Action","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.MultiVersionControl.Action"},{"fieldRange":"(line 359,col 3)-(line 359,col 24)","fieldName":"action","fieldJavadocComment":"","fieldTokenRange":"private Action action;","fieldTypeResolved":"ReferenceType{plume.MultiVersionControl.Action, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Action","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.MultiVersionControl.Action"},{"fieldRange":"(line 835,col 3)-(line 835,col 57)","fieldName":"idf","fieldJavadocComment":"","fieldTokenRange":"static IsDirectoryFilter idf = new IsDirectoryFilter();","fieldTypeResolved":"ReferenceType{plume.MultiVersionControl.IsDirectoryFilter, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new IsDirectoryFilter()]","fieldType":"IsDirectoryFilter","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.MultiVersionControl.IsDirectoryFilter"},{"fieldRange":"(line 1517,col 3)-(line 1517,col 94)","fieldName":"defaultPattern","fieldJavadocComment":"","fieldTokenRange":"private \/*@Regex(1)*\/ Pattern defaultPattern = Pattern.compile(\"^default[ \\t]*=[ \\t]*(.*)\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 1517,col 66)-(line 1517,col 92)","literalExprId":1,"literalExpr":"\"^default[ \\t]*=[ \\t]*(.*)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"^default[ \\t]*=[ \\t]*(.*)\")]","fieldType":"Pattern","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 1542,col 3)-(line 1543,col 71)","fieldName":"invalidCertificatePattern","fieldJavadocComment":"","fieldTokenRange":"private Pattern invalidCertificatePattern =\n      Pattern.compile(\"^https:\/\/[^.]*[.][^.]*[.]googlecode[.]com\/hg$\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 1543,col 23)-(line 1543,col 69)","literalExprId":1,"literalExpr":"\"^https:\/\/[^.]*[.][^.]*[.]googlecode[.]com\/hg$\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"^https:\/\/[^.]*[.][^.]*[.]googlecode[.]com\/hg$\")]","fieldType":"Pattern","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.regex.Pattern"}]}],"sourceFileId":8,"packageName":"plume"},{"sourceFileName":"plume.WeakIdentityHashMap","imports":[{"importId":1,"import":"import java.util.Iterator;\n"},{"importId":2,"import":"import java.util.Map;\n"},{"importId":3,"import":"import java.util.AbstractMap;\n"},{"importId":4,"import":"import java.util.HashMap;\n"},{"importId":5,"import":"import java.util.Set;\n"},{"importId":6,"import":"import java.util.AbstractSet;\n"},{"importId":7,"import":"import java.util.NoSuchElementException;\n"},{"importId":8,"import":"import java.util.Collection;\n"},{"importId":9,"import":"import java.util.AbstractCollection;\n"},{"importId":10,"import":"import java.util.ConcurrentModificationException;\n"},{"importId":11,"import":"import java.util.ArrayList;\n"},{"importId":12,"import":"import java.lang.ref.WeakReference;\n"},{"importId":13,"import":"import java.lang.ref.ReferenceQueue;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the initial capacity of the\n     <code>WeakIdentityHashMap<\/code>","javadocBlockTagName":"initialCapacity","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n     <code>WeakIdentityHashMap<\/code>'}]}', name=Optional[initialCapacity]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the load factor of the\n     <code>WeakIdentityHashMap<\/code>","javadocBlockTagName":"loadFactor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the load factor of the\n     <code>WeakIdentityHashMap<\/code>'}]}', name=Optional[loadFactor]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If the initial capacity is negative,\n     or if the load factor is nonpositive.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is negative,\n     or if the load factor is nonpositive.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"plume.WeakIdentityHashMap.WeakIdentityHashMap(int, float)","variableDeclarationExprs":[{"variableType":"int","variableName":"capacity","variableDeclarationExprId":1,"variableDeclarationExpr":"int capacity = 1","variableDeclarationExprRange":"(line 209,col 9)-(line 209,col 24)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 209,col 13)-(line 209,col 24)"},{"variableType":"Entry<K, V>[]","variableName":"tmpTable","variableDeclarationExprId":2,"variableDeclarationExpr":"@SuppressWarnings(\"unchecked\")\nEntry<K, V>[] tmpTable = (Entry<K, V>[]) new Entry[capacity]","variableDeclarationExprRange":"(line 212,col 9)-(line 213,col 66)","variableTypeResolved":"ResolvedArrayType{ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","variableRange":"(line 213,col 22)-(line 213,col 66)"}],"constructorRange":"(line 199,col 5)-(line 217,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakIdentityHashMap<\/code> with the\n     * given initial capacity and the given load factor.\n     *\n     * @param  initialCapacity the initial capacity of the\n     *      <code>WeakIdentityHashMap<\/code>\n     * @param  loadFactor      the load factor of the\n     *      <code>WeakIdentityHashMap<\/code>\n     * @throws IllegalArgumentException  If the initial capacity is negative,\n     *      or if the load factor is nonpositive.\n     ","constructorDeclaration":"public WeakIdentityHashMap(int initialCapacity, float loadFactor)","constructorBody":"{\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Initial Capacity: \" + initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load factor: \" + loadFactor);\n    int capacity = 1;\n    while (capacity < initialCapacity) capacity <<= 1;\n    @SuppressWarnings(\"unchecked\")\n    Entry<K, V>[] tmpTable = (Entry<K, V>[]) new Entry[capacity];\n    table = tmpTable;\n    this.loadFactor = loadFactor;\n    threshold = (int) (capacity * loadFactor);\n}","constructorName":"WeakIdentityHashMap","constructorQualifiedName":"plume.WeakIdentityHashMap.WeakIdentityHashMap","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int initialCapacity","parameterName":"initialCapacity"},{"parameterType":"float","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='float'}","parameterTypeResolvedDescribed":"float","parameter":"float loadFactor","parameterName":"loadFactor"}],"literalExprs":[{"literalExprRange":"(line 200,col 31)-(line 200,col 31)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 201,col 48)-(line 201,col 75)","literalExprId":2,"literalExpr":"\"Illegal Initial Capacity: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 206,col 27)-(line 206,col 27)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 207,col 48)-(line 207,col 70)","literalExprId":4,"literalExpr":"\"Illegal Load factor: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 24)-(line 209,col 24)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 211,col 26)-(line 211,col 26)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 212,col 27)-(line 212,col 37)","literalExprId":7,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public WeakIdentityHashMap(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal Initial Capacity: \"+\n                                               initialCapacity);\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal Load factor: \"+\n                                               loadFactor);\n        int capacity = 1;\n        while (capacity < initialCapacity)\n            capacity <<= 1;\n        @SuppressWarnings(\"unchecked\")\n        Entry<K,V>[] tmpTable = (Entry<K,V>[]) new Entry[capacity];\n        table = tmpTable;\n        this.loadFactor = loadFactor;\n        threshold = (int)(capacity * loadFactor);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakIdentityHashMap<\/code> with the\ngiven initial capacity and the given load factor.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n     <code>WeakIdentityHashMap<\/code>'}]}', name=Optional[initialCapacity]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the load factor of the\n     <code>WeakIdentityHashMap<\/code>'}]}', name=Optional[loadFactor]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is negative,\n     or if the load factor is nonpositive.'}]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the initial capacity of the\n     <code>WeakIdentityHashMap<\/code>","javadocBlockTagName":"initialCapacity","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n     <code>WeakIdentityHashMap<\/code>'}]}', name=Optional[initialCapacity]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If the initial capacity is negative.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is negative.'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"plume.WeakIdentityHashMap.WeakIdentityHashMap(int)","variableDeclarationExprs":[],"constructorRange":"(line 228,col 5)-(line 230,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakIdentityHashMap<\/code> with the\n     * given initial capacity and the default load factor, which is\n     * <code>0.75<\/code>.\n     *\n     * @param  initialCapacity the initial capacity of the\n     *      <code>WeakIdentityHashMap<\/code>\n     * @throws IllegalArgumentException  If the initial capacity is negative.\n     ","constructorDeclaration":"public WeakIdentityHashMap(int initialCapacity)","constructorBody":"{\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}","constructorName":"WeakIdentityHashMap","constructorQualifiedName":"plume.WeakIdentityHashMap.WeakIdentityHashMap","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int initialCapacity","parameterName":"initialCapacity"}],"literalExprs":[],"constructorTokenRange":"public WeakIdentityHashMap(int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakIdentityHashMap<\/code> with the\ngiven initial capacity and the default load factor, which is\n<code>0.75<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n     <code>WeakIdentityHashMap<\/code>'}]}', name=Optional[initialCapacity]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is negative.'}]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.WeakIdentityHashMap.WeakIdentityHashMap()","variableDeclarationExprs":[{"variableType":"Entry<K, V>[]","variableName":"tmpTable","variableDeclarationExprId":1,"variableDeclarationExpr":"@SuppressWarnings(\"unchecked\")\nEntry<K, V>[] tmpTable = (Entry<K, V>[]) new Entry[DEFAULT_INITIAL_CAPACITY]","variableDeclarationExprRange":"(line 240,col 9)-(line 241,col 82)","variableTypeResolved":"ResolvedArrayType{ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","variableRange":"(line 241,col 22)-(line 241,col 82)"}],"constructorRange":"(line 237,col 5)-(line 243,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakIdentityHashMap<\/code> with the\n     * default initial capacity (16) and the default load factor\n     * (0.75).\n     ","constructorDeclaration":"public WeakIdentityHashMap()","constructorBody":"{\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    threshold = DEFAULT_INITIAL_CAPACITY;\n    @SuppressWarnings(\"unchecked\")\n    Entry<K, V>[] tmpTable = (Entry<K, V>[]) new Entry[DEFAULT_INITIAL_CAPACITY];\n    table = tmpTable;\n}","constructorName":"WeakIdentityHashMap","constructorQualifiedName":"plume.WeakIdentityHashMap.WeakIdentityHashMap","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 240,col 27)-(line 240,col 37)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public WeakIdentityHashMap() {\n        this.loadFactor = DEFAULT_LOAD_FACTOR;\n        threshold = DEFAULT_INITIAL_CAPACITY;\n        @SuppressWarnings(\"unchecked\")\n        Entry<K,V>[] tmpTable = (Entry<K,V>[]) new Entry[DEFAULT_INITIAL_CAPACITY];\n        table = tmpTable;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakIdentityHashMap<\/code> with the\ndefault initial capacity (16) and the default load factor\n(0.75).'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the map whose mappings are to be placed in this map.","javadocBlockTagName":"t","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the map whose mappings are to be placed in this map.'}]}', name=Optional[t]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified map is null.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified map is null.'}]}', name=Optional[NullPointerException]}"},{"javadocBlockType":"SINCE","javadocBlockTagContent":"1.3","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='1.3'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.WeakIdentityHashMap.WeakIdentityHashMap(java.util.Map<? extends K, ? extends V>)","variableDeclarationExprs":[],"constructorRange":"(line 256,col 5)-(line 260,col 5)","constructorJavadocComment":"\n     * Constructs a new <code>WeakIdentityHashMap<\/code> with the same\n     * mappings as the specified <code>Map<\/code>.  The\n     * <code>WeakIdentityHashMap<\/code> is created with default load\n     * factor, which is <code>0.75<\/code> and an initial capacity\n     * sufficient to hold the mappings in the specified <code>Map<\/code>.\n     *\n     * @param   t the map whose mappings are to be placed in this map.\n     * @throws  NullPointerException if the specified map is null.\n     * @since\t1.3\n     ","constructorDeclaration":"public WeakIdentityHashMap(Map<? extends K, ? extends V> t)","constructorBody":"{\n    this(Math.max((int) (t.size() \/ DEFAULT_LOAD_FACTOR) + 1, 16), DEFAULT_LOAD_FACTOR);\n    putAll(t);\n}","constructorName":"WeakIdentityHashMap","constructorQualifiedName":"plume.WeakIdentityHashMap.WeakIdentityHashMap","constructorParameters":[{"parameterType":"Map<? extends K, ? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(K, bounds=[])}}, java.util.Map.V=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Map<? extends K, ? extends V>","parameter":"Map<? extends K, ? extends V> t","parameterName":"t"}],"literalExprs":[{"literalExprRange":"(line 257,col 64)-(line 257,col 64)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 257,col 67)-(line 257,col 68)","literalExprId":2,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public WeakIdentityHashMap(Map<? extends K, ? extends V> t) {\n        this(Math.max((int) (t.size() \/ DEFAULT_LOAD_FACTOR) + 1, 16),\n             DEFAULT_LOAD_FACTOR);\n        putAll(t);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new <code>WeakIdentityHashMap<\/code> with the same\nmappings as the specified <code>Map<\/code>.  The\n<code>WeakIdentityHashMap<\/code> is created with default load\nfactor, which is <code>0.75<\/code> and an initial capacity\nsufficient to hold the mappings in the specified <code>Map<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the map whose mappings are to be placed in this map.'}]}', name=Optional[t]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified map is null.'}]}', name=Optional[NullPointerException]}, JavadocBlockTag{type=SINCE, content='JavadocDescription{elements=[JavadocSnippet{text='1.3'}]}', name=Optional.empty}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 702,col 5)-(line 765,col 5)","classOrInterfaceTokenRange":"private static class Entry<K,V> extends WeakReference<K> implements Map.Entry<K,V> {\n        private V value;\n        private final int hash;\n        private \/*@Nullable*\/ Entry<K,V> next;\n\n        \/**\n         * Create new entry.\n         *\/\n        Entry(K key, V value,\n\t      ReferenceQueue<K> queue,\n              int hash, Entry<K,V> next) {\n            super(key, queue);\n            this.value = value;\n            this.hash  = hash;\n            this.next  = next;\n        }\n\n        \/*@Pure*\/\n        public K getKey() {\n            return WeakIdentityHashMap.<K>unmaskNull(get());\n        }\n\n        \/*@Pure*\/\n        public V getValue() {\n            return value;\n        }\n\n        public V setValue(V newValue) {\n\t    V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        @SuppressWarnings(\"purity\") \/\/ side effects on local state\n        \/*@Pure*\/\n        public boolean equals(\/*@Nullable*\/ Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<K,V> e = (Map.Entry<K,V>)o;\n            Object k1 = getKey();\n            Object k2 = e.getKey();\n            if (eq (k1, k2)) {\n                Object v1 = getValue();\n                Object v2 = e.getValue();\n                if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                    return true;\n            }\n            return false;\n        }\n\n        @SuppressWarnings(\"purity\") \/\/ side effects on local state\n        \/*@Pure*\/\n        public int hashCode() {\n            Object k = getKey();\n            Object v = getValue();\n            return  ((k==null ? 0 : hasher (k)) ^\n                     (v==null ? 0 : v.hashCode()));\n        }\n\n        \/*@SideEffectFree*\/\n        public String toString() {\n            return getKey() + \"=\" + getValue();\n        }\n    }","classOrInterfaceJavadocComment":"\n     * The entries in this hash table extend WeakReference, using its main ref\n     * field as the key.\n     ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The entries in this hash table extend WeakReference, using its main ref\nfield as the key.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 767,col 5)-(line 836,col 5)","classOrInterfaceTokenRange":"private abstract class HashIterator<T> implements Iterator<T> {\n        int index;\n        \/*@Nullable*\/ Entry<K,V> entry = null;\n        \/*@Nullable*\/ Entry<K,V> lastReturned = null;\n        int expectedModCount = modCount;\n\n        \/**\n         * Strong reference needed to avoid disappearance of key\n         * between hasNext and next\n         *\/\n        \/*@Nullable*\/ Object nextKey = null;\n\n        \/**\n         * Strong reference needed to avoid disappearance of key\n         * between nextEntry() and any use of the entry\n         *\/\n\t\/*@Nullable*\/ Object currentKey = null;\n\n        HashIterator() {\n            index = (size() != 0 ? table.length : 0);\n        }\n\n        public boolean hasNext() {\n            \/*@Nullable*\/ Entry<K,V>[] t = table;\n\n            while (nextKey == null) {\n                Entry<K,V> e = entry;\n                int i = index;\n                while (e == null && i > 0)\n                    e = t[--i];\n                entry = e;\n                index = i;\n                if (e == null) {\n                    currentKey = null;\n                    return false;\n                }\n                nextKey = e.get(); \/\/ hold on to key in strong ref\n                if (nextKey == null)\n                    entry = entry.next;\n            }\n            return true;\n        }\n\n        \/** The common parts of next() across different types of iterators *\/\n        protected Entry<K,V> nextEntry() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n            if (nextKey == null && !hasNext())\n                throw new NoSuchElementException();\n\n            lastReturned = entry;\n            entry = entry.next;\n            currentKey = nextKey;\n            nextKey = null;\n            return lastReturned;\n        }\n\n        public void remove() {\n            if (lastReturned == null)\n                throw new IllegalStateException();\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n\n            WeakIdentityHashMap.this.remove(currentKey);\n            expectedModCount = modCount;\n            lastReturned = null;\n            currentKey = null;\n        }\n\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 838,col 5)-(line 842,col 5)","classOrInterfaceTokenRange":"private class ValueIterator extends HashIterator<V> {\n        public V next() {\n            return nextEntry().value;\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 844,col 5)-(line 848,col 5)","classOrInterfaceTokenRange":"private class KeyIterator extends HashIterator<K> {\n        public K next() {\n            return nextEntry().getKey();\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 850,col 5)-(line 854,col 5)","classOrInterfaceTokenRange":"private class EntryIterator extends HashIterator<Map.Entry<K,V>> {\n        public Map.Entry<K,V> next() {\n            return nextEntry();\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 878,col 5)-(line 919,col 5)","classOrInterfaceTokenRange":"private class KeySet extends AbstractSet<K> {\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        \/*@Pure*\/\n        public int size() {\n            return WeakIdentityHashMap.this.size();\n        }\n\n        \/*@Pure*\/\n        public boolean contains(\/*@Nullable*\/ Object o) {\n            return containsKey(o);\n        }\n\n        public boolean remove(\/*@Nullable*\/ Object o) {\n            if (containsKey(o)) {\n                WeakIdentityHashMap.this.remove(o);\n                return true;\n            }\n            else\n                return false;\n        }\n\n        public void clear() {\n            WeakIdentityHashMap.this.clear();\n        }\n\n        public Object[] toArray() {\n            Collection<K> c = new ArrayList<K>(size());\n            for (Iterator<K> i = iterator(); i.hasNext(); )\n                c.add(i.next());\n            return c.toArray();\n        }\n\n        public <T> T[] toArray(T[] a) {\n            Collection<K> c = new ArrayList<K>(size());\n            for (Iterator<K> i = iterator(); i.hasNext(); )\n                c.add(i.next());\n            return c.toArray(a);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 940,col 5)-(line 972,col 5)","classOrInterfaceTokenRange":"private class Values extends AbstractCollection<V> {\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        \/*@Pure*\/\n        public int size() {\n            return WeakIdentityHashMap.this.size();\n        }\n\n        \/*@Pure*\/\n        public boolean contains(\/*@Nullable*\/ Object o) {\n            return containsValue(o);\n        }\n\n        public void clear() {\n            WeakIdentityHashMap.this.clear();\n        }\n\n        public Object[] toArray() {\n            Collection<V> c = new ArrayList<V>(size());\n            for (Iterator<V> i = iterator(); i.hasNext(); )\n                c.add(i.next());\n            return c.toArray();\n        }\n\n        public <T> T[] toArray(T[] a) {\n            Collection<V> c = new ArrayList<V>(size());\n            for (Iterator<V> i = iterator(); i.hasNext(); )\n                c.add(i.next());\n            return c.toArray(a);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 993,col 5)-(line 1034,col 5)","classOrInterfaceTokenRange":"private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n        public Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n\n        \/*@Pure*\/\n        public boolean contains(\/*@Nullable*\/ Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<K,V> e = (Map.Entry<K,V>)o;\n            Object k = e.getKey();\n            Entry candidate = getEntry(k);\n            return candidate != null && candidate.equals(e);\n        }\n\n        public boolean remove(\/*@Nullable*\/ Object o) {\n            return removeMapping(o) != null;\n        }\n\n        \/*@Pure*\/\n        public int size() {\n            return WeakIdentityHashMap.this.size();\n        }\n\n        public void clear() {\n            WeakIdentityHashMap.this.clear();\n        }\n\n        public Object[] toArray() {\n            Collection<Map.Entry<K,V>> c = new ArrayList<Map.Entry<K,V>>(size());\n            for (Iterator<Map.Entry<K,V>> i = iterator(); i.hasNext(); )\n                c.add(new OurSimpleEntry<K,V>(i.next()));\n            return c.toArray();\n        }\n\n        public <T> T[] toArray(T[] a) {\n            Collection<Map.Entry<K,V>> c = new ArrayList<Map.Entry<K,V>>(size());\n            for (Iterator<Map.Entry<K,V>> i = iterator(); i.hasNext(); )\n                c.add(new OurSimpleEntry<K,V>(i.next()));\n            return c.toArray(a);\n        }\n    }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 1037,col 5)-(line 1090,col 5)","classOrInterfaceTokenRange":"static class OurSimpleEntry<K,V> implements Map.Entry<K,V> {\n        K key;\n        V value;\n\n        public OurSimpleEntry(K key, V value) {\n            this.key   = key;\n                this.value = value;\n        }\n\n        public OurSimpleEntry(Map.Entry<K,V> e) {\n            this.key   = e.getKey();\n                this.value = e.getValue();\n        }\n\n        \/*@Pure*\/\n        public K getKey() {\n            return key;\n        }\n\n        \/*@Pure*\/\n        public V getValue() {\n            return value;\n        }\n\n        public V setValue(V value) {\n            V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        \/*@Pure*\/\n        public boolean equals(\/*@Nullable*\/ Object o) {\n            if (!(o instanceof Map.Entry))\n            return false;\n            Map.Entry<K,V> e = (Map.Entry<K,V>)o;\n            return WeakIdentityHashMap.eq(key, e.getKey())\n                && eq(value, e.getValue());\n        }\n\n        \/*@Pure*\/\n        public int hashCode() {\n            return ((key   == null)   ? 0 :   key.hashCode()) ^\n               ((value == null)   ? 0 : value.hashCode());\n        }\n\n        \/*@SideEffectFree*\/\n        public String toString() {\n            return key + \"=\" + value;\n        }\n\n        private static boolean eq(\/*@Nullable*\/ Object o1, \/*@Nullable*\/ Object o2) {\n            return (o1 == null ? o2 == null : o1.equals(o2));\n        }\n    }","classOrInterfaceJavadocComment":" Version copied from Abstract Map because it is not public ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Version copied from Abstract Map because it is not public'}]}, blockTags=[]}]"}],"methods":[{"methodDeclaration":"private static Object maskNull(Object key)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (key == null ? NULL_KEY : key);\n}","methodRange":"(line 277,col 5)-(line 279,col 5)","methodTokenRange":"private static \/*@NonNull*\/ Object maskNull(\/*@Nullable*\/ Object key) {\n        return (key == null ? NULL_KEY : key);\n    }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"maskNull","methodQualifiedSignature":"plume.WeakIdentityHashMap.maskNull","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 278,col 24)-(line 278,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.maskNull(java.lang.Object)"},{"methodDeclaration":"private static K unmaskNull(K key)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (key == NULL_KEY ? null : key);\n}","methodRange":"(line 285,col 5)-(line 289,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    \/*@Pure*\/\n    private static <K> \/*@Nullable*\/ K unmaskNull(K key) {\n        return (key == NULL_KEY ? null : key);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(K, bounds=[])}","methodJavadocComment":" Argument is actually either of type K, or is NULL_KEY.","methodParameters":[{"parameterType":"K","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(K, bounds=[])}","parameterTypeResolvedDescribed":"K","parameter":"K key","parameterName":"key"}],"methodName":"unmaskNull","methodQualifiedSignature":"plume.WeakIdentityHashMap.unmaskNull","methodJavadoc":"","methodReturnTypeDescribed":"K","methodType":"K","literalExprs":[{"literalExprRange":"(line 285,col 23)-(line 285,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 288,col 35)-(line 288,col 38)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.unmaskNull(K)"},{"methodDeclaration":" static boolean eq(Object x, Object y)","methodAccessSpecifier":"NONE","methodBody":"{\n    return x == y;\n}","methodRange":"(line 296,col 5)-(line 298,col 5)","methodTokenRange":"static boolean eq(Object x, \/*@Nullable*\/ Object y) {\n        return x == y;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object x","parameterName":"x"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object y","parameterName":"y"}],"methodName":"eq","methodQualifiedSignature":"plume.WeakIdentityHashMap.eq","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityHashMap.eq(java.lang.Object, java.lang.Object)"},{"methodDeclaration":" static int hasher(Object x)","methodAccessSpecifier":"NONE","methodBody":"{\n    return System.identityHashCode(x);\n}","methodRange":"(line 302,col 5)-(line 304,col 5)","methodTokenRange":"static int hasher (Object x) {\n        return System.identityHashCode (x);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object x","parameterName":"x"}],"methodName":"hasher","methodQualifiedSignature":"plume.WeakIdentityHashMap.hasher","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityHashMap.hasher(java.lang.Object)"},{"methodDeclaration":" static int indexFor(int h, int length)","methodAccessSpecifier":"NONE","methodBody":"{\n    return h & (length - 1);\n}","methodRange":"(line 310,col 5)-(line 312,col 5)","methodTokenRange":"static int indexFor(int h, int length) {\n        return h & (length-1);\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int h","parameterName":"h"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"indexFor","methodQualifiedSignature":"plume.WeakIdentityHashMap.indexFor","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 311,col 28)-(line 311,col 28)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.indexFor(int, int)"},{"javadocBlockTags":[],"methodDeclaration":"private void expungeStaleEntries()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Entry<K, V> e;\n    while ((e = (Entry<K, V>) queue.poll()) != null) {\n        int h = e.hash;\n        int i = indexFor(h, table.length);\n        Entry<K, V> prev = table[i];\n        Entry<K, V> p = prev;\n        while (p != null) {\n            Entry<K, V> next = p.next;\n            if (p == e) {\n                if (prev == e)\n                    table[i] = next;\n                else\n                    prev.next = next;\n                e.next = null;\n                e.value = null;\n                size--;\n                break;\n            }\n            prev = p;\n            p = next;\n        }\n    }\n}","methodRange":"(line 317,col 5)-(line 344,col 5)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ actually has side effects due to weak pointers\n    \/*@SideEffectFree*\/\n    private void expungeStaleEntries() {\n\tEntry<K,V> e;\n        \/\/ These types look wrong to me.\n        while ( (e = (Entry<K,V>) queue.poll()) != null) { \/\/ unchecked cast\n            int h = e.hash;\n            int i = indexFor(h, table.length);\n\n            Entry<K,V> prev = table[i];\n            Entry<K,V> p = prev;\n            while (p != null) {\n                Entry<K,V> next = p.next;\n                if (p == e) {\n                    if (prev == e)\n                        table[i] = next;\n                    else\n                        prev.next = next;\n                    e.next = null;  \/\/ Help GC\n                    e.value = null; \/\/  \"   \"\n                    size--;\n                    break;\n                }\n                prev = p;\n                p = next;\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Expunge stale entries from the table.\n     ","methodParameters":[],"methodName":"expungeStaleEntries","methodQualifiedSignature":"plume.WeakIdentityHashMap.expungeStaleEntries","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Expunge stale entries from the table.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 317,col 23)-(line 317,col 30)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 322,col 52)-(line 322,col 55)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 328,col 25)-(line 328,col 28)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 335,col 30)-(line 335,col 33)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 336,col 31)-(line 336,col 34)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.expungeStaleEntries()"},{"methodDeclaration":"private Entry<K, V>[] getTable()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    expungeStaleEntries();\n    return table;\n}","methodRange":"(line 350,col 5)-(line 353,col 5)","methodTokenRange":"private \/*@Nullable*\/ Entry<K,V>[] getTable() {\n        expungeStaleEntries();\n        return table;\n    }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"getTable","methodQualifiedSignature":"plume.WeakIdentityHashMap.getTable","methodJavadoc":"","methodReturnTypeDescribed":"plume.WeakIdentityHashMap.Entry<K, V>[]","methodType":"Entry<K, V>[]","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityHashMap.getTable()"},{"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (size == 0)\n        return 0;\n    expungeStaleEntries();\n    return size;\n}","methodRange":"(line 362,col 5)-(line 367,col 5)","methodTokenRange":"public int size() {\n        if (size == 0)\n            return 0;\n        expungeStaleEntries();\n        return size;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"size","methodQualifiedSignature":"plume.WeakIdentityHashMap.size","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 363,col 21)-(line 363,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 364,col 20)-(line 364,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.size()"},{"methodDeclaration":"public boolean isEmpty()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return size() == 0;\n}","methodRange":"(line 376,col 5)-(line 378,col 5)","methodTokenRange":"public boolean isEmpty() {\n        return size() == 0;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"isEmpty","methodQualifiedSignature":"plume.WeakIdentityHashMap.isEmpty","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 377,col 26)-(line 377,col 26)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.isEmpty()"},{"methodDeclaration":"public V get(Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object k = maskNull(key);\n    int h = hasher(k);\n    Entry<K, V>[] tab = getTable();\n    int index = indexFor(h, tab.length);\n    Entry<K, V> e = tab[index];\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}","methodRange":"(line 395,col 5)-(line 407,col 5)","methodTokenRange":"public \/*@Nullable*\/ V get(\/*@Nullable*\/ Object key) {\n        Object k = maskNull(key);\n        int h = hasher (k);\n        \/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        int index = indexFor(h, tab.length);\n        Entry<K,V> e = tab[index];\n        while (e != null) {\n            if (e.hash == h && eq(k, e.get()))\n                return e.value;\n            e = e.next;\n        }\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"get","methodQualifiedSignature":"plume.WeakIdentityHashMap.get","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 401,col 21)-(line 401,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 406,col 16)-(line 406,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.get(java.lang.Object)"},{"methodDeclaration":"public boolean containsKey(Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return getEntry(key) != null;\n}","methodRange":"(line 418,col 5)-(line 420,col 5)","methodTokenRange":"public boolean containsKey(\/*@Nullable*\/ Object key) {\n        return getEntry(key) != null;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"containsKey","methodQualifiedSignature":"plume.WeakIdentityHashMap.containsKey","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 419,col 33)-(line 419,col 36)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.containsKey(java.lang.Object)"},{"methodDeclaration":" Entry<K, V> getEntry(Object key)","methodAccessSpecifier":"NONE","methodBody":"{\n    Object k = maskNull(key);\n    int h = hasher(k);\n    Entry<K, V>[] tab = getTable();\n    int index = indexFor(h, tab.length);\n    Entry<K, V> e = tab[index];\n    while (e != null && !(e.hash == h && eq(k, e.get()))) e = e.next;\n    return e;\n}","methodRange":"(line 427,col 19)-(line 436,col 5)","methodTokenRange":"Entry<K,V> getEntry(\/*@Nullable*\/ Object key) {\n        Object k = maskNull(key);\n        int h = hasher (k);\n        \/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        int index = indexFor(h, tab.length);\n        Entry<K,V> e = tab[index];\n        while (e != null && !(e.hash == h && eq(k, e.get())))\n            e = e.next;\n        return e;\n    }","methodReturnTypeResolved":"ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","methodJavadocComment":"@Nullable","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"getEntry","methodQualifiedSignature":"plume.WeakIdentityHashMap.getEntry","methodJavadoc":"","methodReturnTypeDescribed":"plume.WeakIdentityHashMap.Entry<K, V>","methodType":"Entry<K, V>","literalExprs":[{"literalExprRange":"(line 433,col 21)-(line 433,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.getEntry(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"key with which the specified value is to be associated.","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='key with which the specified value is to be associated.'}]}', name=Optional[key]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be associated with the specified key.","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be associated with the specified key.'}]}', name=Optional[value]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"previous value associated with specified key, or <code>null<\/code>\n       if there was no mapping for key.  A <code>null<\/code> return can\n       also indicate that the HashMap previously associated\n       <code>null<\/code> with the specified key.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified key, or <code>null<\/code>\n       if there was no mapping for key.  A <code>null<\/code> return can\n       also indicate that the HashMap previously associated\n       <code>null<\/code> with the specified key.'}]}', name=Optional.empty}"}],"methodDeclaration":"public V put(K key, V value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"unchecked\")\n    K k = (K) maskNull(key);\n    int h = System.identityHashCode(k);\n    Entry<K, V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    for (Entry<K, V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n    modCount++;\n    Entry<K, V> e = tab[i];\n    tab[i] = new Entry<K, V>(k, value, queue, h, e);\n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}","methodRange":"(line 450,col 5)-(line 472,col 5)","methodTokenRange":"public \/*@Nullable*\/ V put(K key, V value) {\n        @SuppressWarnings(\"unchecked\")\n        K k = (K) maskNull(key);\n        int h = System.identityHashCode (k);\n        \/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        int i = indexFor(h, tab.length);\n\n        for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n            if (h == e.hash && eq(k, e.get())) {\n                V oldValue = e.value;\n                if (value != oldValue)\n                    e.value = value;\n                return oldValue;\n            }\n        }\n\n        modCount++;\n\tEntry<K,V> e = tab[i];\n        tab[i] = new Entry<K,V>(k, value, queue, h, e);\n        if (++size >= threshold)\n            resize(tab.length * 2);\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Associates the specified value with the specified key in this map.\n     * If the map previously contained a mapping for this key, the old\n     * value is replaced.\n     *\n     * @param key key with which the specified value is to be associated.\n     * @param value value to be associated with the specified key.\n     * @return previous value associated with specified key, or <code>null<\/code>\n     *\t       if there was no mapping for key.  A <code>null<\/code> return can\n     *\t       also indicate that the HashMap previously associated\n     *\t       <code>null<\/code> with the specified key.\n     ","methodParameters":[{"parameterType":"K","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(K, bounds=[])}","parameterTypeResolvedDescribed":"K","parameter":"K key","parameterName":"key"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V value","parameterName":"value"}],"methodName":"put","methodQualifiedSignature":"plume.WeakIdentityHashMap.put","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Associates the specified value with the specified key in this map.\nIf the map previously contained a mapping for this key, the old\nvalue is replaced.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='key with which the specified value is to be associated.'}]}', name=Optional[key]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be associated with the specified key.'}]}', name=Optional[value]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified key, or <code>null<\/code>\n       if there was no mapping for key.  A <code>null<\/code> return can\n       also indicate that the HashMap previously associated\n       <code>null<\/code> with the specified key.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 451,col 27)-(line 451,col 37)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 457,col 42)-(line 457,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 470,col 33)-(line 470,col 33)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 471,col 16)-(line 471,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.put(K, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the new capacity, MUST be a power of two;\n       must be greater than current capacity unless current\n       capacity is MAXIMUM_CAPACITY (in which case value\n       is irrelevant).","javadocBlockTagName":"newCapacity","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new capacity, MUST be a power of two;\n       must be greater than current capacity unless current\n       capacity is MAXIMUM_CAPACITY (in which case value\n       is irrelevant).'}]}', name=Optional[newCapacity]}"}],"methodDeclaration":" void resize(int newCapacity)","methodAccessSpecifier":"NONE","methodBody":"{\n    Entry<K, V>[] oldTable = getTable();\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n    @SuppressWarnings(\"unchecked\")\n    Entry<K, V>[] newTable = (Entry<K, V>[]) new Entry[newCapacity];\n    transfer(oldTable, newTable);\n    table = newTable;\n    if (size >= threshold \/ 2) {\n        threshold = (int) (newCapacity * loadFactor);\n    } else {\n        expungeStaleEntries();\n        transfer(newTable, oldTable);\n        table = oldTable;\n    }\n}","methodRange":"(line 488,col 5)-(line 513,col 5)","methodTokenRange":"void resize(int newCapacity) {\n        \/*@Nullable*\/ Entry<K,V>[] oldTable = getTable();\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Entry<K,V>[] newTable = (Entry<K,V>[]) new Entry[newCapacity];\n        transfer(oldTable, newTable);\n        table = newTable;\n\n        \/*\n         * If ignoring null elements and processing ref queue caused massive\n         * shrinkage, then restore old table.  This should be rare, but avoids\n         * unbounded expansion of garbage-filled tables.\n         *\/\n        if (size >= threshold \/ 2) {\n            threshold = (int)(newCapacity * loadFactor);\n        } else {\n            expungeStaleEntries();\n            transfer(newTable, oldTable);\n            table = oldTable;\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Rehashes the contents of this map into a new array with a\n     * larger capacity.  This method is called automatically when the\n     * number of keys in this map reaches its threshold.\n     *\n     * If current capacity is MAXIMUM_CAPACITY, this method does not\n     * resize the map, but sets threshold to Integer.MAX_VALUE.\n     * This has the effect of preventing future calls.\n     *\n     * @param newCapacity the new capacity, MUST be a power of two;\n     *        must be greater than current capacity unless current\n     *        capacity is MAXIMUM_CAPACITY (in which case value\n     *        is irrelevant).\n     ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int newCapacity","parameterName":"newCapacity"}],"methodName":"resize","methodQualifiedSignature":"plume.WeakIdentityHashMap.resize","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Rehashes the contents of this map into a new array with a\nlarger capacity.  This method is called automatically when the\nnumber of keys in this map reaches its threshold.\n\nIf current capacity is MAXIMUM_CAPACITY, this method does not\nresize the map, but sets threshold to Integer.MAX_VALUE.\nThis has the effect of preventing future calls.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new capacity, MUST be a power of two;\n       must be greater than current capacity unless current\n       capacity is MAXIMUM_CAPACITY (in which case value\n       is irrelevant).'}]}', name=Optional[newCapacity]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 496,col 27)-(line 496,col 37)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 506,col 33)-(line 506,col 33)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.resize(int)"},{"javadocBlockTags":[],"methodDeclaration":"private void transfer(Entry<K, V>[] src, Entry<K, V>[] dest)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (int j = 0; j < src.length; ++j) {\n        Entry<K, V> e = src[j];\n        src[j] = null;\n        while (e != null) {\n            Entry<K, V> next = e.next;\n            Object key = e.get();\n            if (key == null) {\n                e.next = null;\n                e.value = null;\n                size--;\n            } else {\n                int i = indexFor(e.hash, dest.length);\n                e.next = dest[i];\n                dest[i] = e;\n            }\n            e = next;\n        }\n    }\n}","methodRange":"(line 516,col 5)-(line 535,col 5)","methodTokenRange":"private void transfer(\/*@Nullable*\/ Entry<K,V>[] src, \/*@Nullable*\/ Entry<K,V>[] dest) {\n        for (int j = 0; j < src.length; ++j) {\n            Entry<K,V> e = src[j];\n            src[j] = null;          \/\/ Help GC (?)\n            while (e != null) {\n                Entry<K,V> next = e.next;\n                Object key = e.get();\n                if (key == null) {\n                    e.next = null;  \/\/ Help GC\n                    e.value = null; \/\/  \"   \"\n                    size--;\n                } else {\n                    int i = indexFor(e.hash, dest.length);\n                    e.next = dest[i];\n                    dest[i] = e;\n                }\n                e = next;\n            }\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Transfer all entries from src to dest tables ","methodParameters":[{"parameterType":"Entry<K, V>[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","parameterTypeResolvedDescribed":"plume.WeakIdentityHashMap.Entry<K, V>[]","parameter":"Entry<K, V>[] src","parameterName":"src"},{"parameterType":"Entry<K, V>[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","parameterTypeResolvedDescribed":"plume.WeakIdentityHashMap.Entry<K, V>[]","parameter":"Entry<K, V>[] dest","parameterName":"dest"}],"methodName":"transfer","methodQualifiedSignature":"plume.WeakIdentityHashMap.transfer","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Transfer all entries from src to dest tables'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 517,col 22)-(line 517,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 519,col 22)-(line 519,col 25)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 520,col 25)-(line 520,col 28)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 523,col 28)-(line 523,col 31)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 524,col 30)-(line 524,col 33)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 525,col 31)-(line 525,col 34)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.transfer(plume.WeakIdentityHashMap.Entry<K, V>[], plume.WeakIdentityHashMap.Entry<K, V>[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"mappings to be stored in this map.","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='mappings to be stored in this map.'}]}', name=Optional[m]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the specified map is null.","javadocBlockTagName":"NullPointerException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified map is null.'}]}', name=Optional[NullPointerException]}"}],"methodDeclaration":"public void putAll(Map<? extends K, ? extends V> m)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int numKeysToBeAdded = m.size();\n    if (numKeysToBeAdded == 0)\n        return;\n    if (numKeysToBeAdded > threshold) {\n        int targetCapacity = (int) (numKeysToBeAdded \/ loadFactor + 1);\n        if (targetCapacity > MAXIMUM_CAPACITY)\n            targetCapacity = MAXIMUM_CAPACITY;\n        int newCapacity = table.length;\n        while (newCapacity < targetCapacity) newCapacity <<= 1;\n        if (newCapacity > table.length)\n            resize(newCapacity);\n    }\n    for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {\n        Map.Entry<? extends K, ? extends V> e = i.next();\n        put(e.getKey(), e.getValue());\n    }\n}","methodRange":"(line 545,col 5)-(line 574,col 5)","methodTokenRange":"public void putAll(Map<? extends K, ? extends V> m) {\n        int numKeysToBeAdded = m.size();\n        if (numKeysToBeAdded == 0)\n            return;\n\n        \/*\n         * Expand the map if the map if the number of mappings to be added\n         * is greater than or equal to threshold.  This is conservative; the\n         * obvious condition is (m.size() + size) >= threshold, but this\n         * condition could result in a map with twice the appropriate capacity,\n         * if the keys to be added overlap with the keys already in this map.\n         * By using the conservative calculation, we subject ourself\n         * to at most one extra resize.\n         *\/\n        if (numKeysToBeAdded > threshold) {\n            int targetCapacity = (int)(numKeysToBeAdded \/ loadFactor + 1);\n            if (targetCapacity > MAXIMUM_CAPACITY)\n                targetCapacity = MAXIMUM_CAPACITY;\n            int newCapacity = table.length;\n            while (newCapacity < targetCapacity)\n                newCapacity <<= 1;\n            if (newCapacity > table.length)\n                resize(newCapacity);\n        }\n\n        for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i = m.entrySet().iterator(); i.hasNext(); ) {\n            Map.Entry<? extends K, ? extends V> e = i.next();\n            put(e.getKey(), e.getValue());\n        }\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Copies all of the mappings from the specified map to this map These\n     * mappings will replace any mappings that this map had for any of the\n     * keys currently in the specified map.<p>\n     *\n     * @param m mappings to be stored in this map.\n     * @throws  NullPointerException if the specified map is null.\n     ","methodParameters":[{"parameterType":"Map<? extends K, ? extends V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(K, bounds=[])}}, java.util.Map.V=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Map<? extends K, ? extends V>","parameter":"Map<? extends K, ? extends V> m","parameterName":"m"}],"methodName":"putAll","methodQualifiedSignature":"plume.WeakIdentityHashMap.putAll","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Copies all of the mappings from the specified map to this map These\nmappings will replace any mappings that this map had for any of the\nkeys currently in the specified map.<p>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='mappings to be stored in this map.'}]}', name=Optional[m]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the specified map is null.'}]}', name=Optional[NullPointerException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 547,col 33)-(line 547,col 33)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 560,col 72)-(line 560,col 72)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 565,col 33)-(line 565,col 33)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.putAll(java.util.Map<? extends K, ? extends V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"key whose mapping is to be removed from the map.","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='key whose mapping is to be removed from the map.'}]}', name=Optional[key]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"previous value associated with specified key, or <code>null<\/code>\n       if there was no mapping for key.  A <code>null<\/code> return can\n       also indicate that the map previously associated <code>null<\/code>\n       with the specified key.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified key, or <code>null<\/code>\n       if there was no mapping for key.  A <code>null<\/code> return can\n       also indicate that the map previously associated <code>null<\/code>\n       with the specified key.'}]}', name=Optional.empty}"}],"methodDeclaration":"public V remove(Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object k = maskNull(key);\n    int h = hasher(k);\n    Entry<K, V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    Entry<K, V> prev = tab[i];\n    Entry<K, V> e = prev;\n    while (e != null) {\n        Entry<K, V> next = e.next;\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n    return null;\n}","methodRange":"(line 585,col 5)-(line 609,col 5)","methodTokenRange":"public \/*@Nullable*\/ V remove(Object key) {\n        Object k = maskNull(key);\n        int h = hasher (k);\n        \/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        int i = indexFor(h, tab.length);\n        Entry<K,V> prev = tab[i];\n        Entry<K,V> e = prev;\n\n        while (e != null) {\n            Entry<K,V> next = e.next;\n            if (h == e.hash && eq(k, e.get())) {\n                modCount++;\n                size--;\n                if (prev == e)\n                    tab[i] = next;\n                else\n                    prev.next = next;\n                return e.value;\n            }\n            prev = e;\n            e = next;\n        }\n\n        return null;\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Removes the mapping for this key from this map if present.\n     *\n     * @param key key whose mapping is to be removed from the map.\n     * @return previous value associated with specified key, or <code>null<\/code>\n     *\t       if there was no mapping for key.  A <code>null<\/code> return can\n     *\t       also indicate that the map previously associated <code>null<\/code>\n     *\t       with the specified key.\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"remove","methodQualifiedSignature":"plume.WeakIdentityHashMap.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the mapping for this key from this map if present.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='key whose mapping is to be removed from the map.'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='previous value associated with specified key, or <code>null<\/code>\n       if there was no mapping for key.  A <code>null<\/code> return can\n       also indicate that the map previously associated <code>null<\/code>\n       with the specified key.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 593,col 21)-(line 593,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 608,col 16)-(line 608,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.remove(java.lang.Object)"},{"methodDeclaration":" Entry<K, V> removeMapping(Object o)","methodAccessSpecifier":"NONE","methodBody":"{\n    if (!(o instanceof Map.Entry))\n        return null;\n    Entry<K, V>[] tab = getTable();\n    Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n    Object k = maskNull(entry.getKey());\n    int h = hasher(k);\n    int i = indexFor(h, tab.length);\n    Entry<K, V> prev = tab[i];\n    Entry<K, V> e = prev;\n    while (e != null) {\n        Entry<K, V> next = e.next;\n        if (h == e.hash && e.equals(entry)) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            return e;\n        }\n        prev = e;\n        e = next;\n    }\n    return null;\n}","methodRange":"(line 614,col 19)-(line 641,col 5)","methodTokenRange":"Entry<K,V> removeMapping(\/*@Nullable*\/ Object o) {\n        if (!(o instanceof Map.Entry))\n            return null;\n        \/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        Map.Entry<K,V> entry = (Map.Entry<K,V>)o;\n        Object k = maskNull(entry.getKey());\n        int h = hasher (k);\n        int i = indexFor(h, tab.length);\n        Entry<K,V> prev = tab[i];\n        Entry<K,V> e = prev;\n\n        while (e != null) {\n            Entry<K,V> next = e.next;\n            if (h == e.hash && e.equals(entry)) {\n                modCount++;\n                size--;\n                if (prev == e)\n                    tab[i] = next;\n                else\n                    prev.next = next;\n                return e;\n            }\n            prev = e;\n            e = next;\n        }\n\n        return null;\n    }","methodReturnTypeResolved":"ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","methodJavadocComment":"@Nullable","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"removeMapping","methodQualifiedSignature":"plume.WeakIdentityHashMap.removeMapping","methodJavadoc":"","methodReturnTypeDescribed":"plume.WeakIdentityHashMap.Entry<K, V>","methodType":"Entry<K, V>","literalExprs":[{"literalExprRange":"(line 616,col 20)-(line 616,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 625,col 21)-(line 625,col 24)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 640,col 16)-(line 640,col 19)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.removeMapping(java.lang.Object)"},{"javadocBlockTags":[],"methodDeclaration":"public void clear()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    while (queue.poll() != null) ;\n    modCount++;\n    Entry<K, V>[] tab = table;\n    for (int i = 0; i < tab.length; ++i) tab[i] = null;\n    size = 0;\n    while (queue.poll() != null) ;\n}","methodRange":"(line 646,col 5)-(line 663,col 4)","methodTokenRange":"public void clear() {\n        \/\/ clear out ref queue. We don't need to expunge entries\n        \/\/ since table is getting cleared.\n        while (queue.poll() != null)\n            ;\n\n        modCount++;\n        \/*@Nullable*\/ Entry<K,V>[] tab = table;\n        for (int i = 0; i < tab.length; ++i)\n            tab[i] = null;                   \/\/ Help GC (?)\n        size = 0;\n\n        \/\/ Allocation of array may have caused GC, which may have caused\n        \/\/ additional entries to go stale.  Removing these entries from the\n        \/\/ reference queue will make them eligible for reclamation.\n        while (queue.poll() != null)\n            ;\n   }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes all mappings from this map.\n     ","methodParameters":[],"methodName":"clear","methodQualifiedSignature":"plume.WeakIdentityHashMap.clear","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all mappings from this map.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 649,col 32)-(line 649,col 35)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 654,col 22)-(line 654,col 22)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 655,col 22)-(line 655,col 25)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 656,col 16)-(line 656,col 16)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 661,col 32)-(line 661,col 35)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.clear()"},{"methodDeclaration":"public boolean containsValue(Object value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (value == null)\n        return containsNullValue();\n    Entry<K, V>[] tab = getTable();\n    for (int i = tab.length; i-- > 0; ) for (Entry e = tab[i]; e != null; e = e.next) if (value.equals(e.value))\n        return true;\n    return false;\n}","methodRange":"(line 674,col 5)-(line 684,col 5)","methodTokenRange":"public boolean containsValue(\/*@Nullable*\/ Object value) {\n\tif (value==null)\n            return containsNullValue();\n\n\t\/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        for (int i = tab.length ; i-- > 0 ;)\n            for (Entry e = tab[i] ; e != null ; e = e.next)\n                if (value.equals(e.value))\n                    return true;\n\treturn false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object value","parameterName":"value"}],"methodName":"containsValue","methodQualifiedSignature":"plume.WeakIdentityHashMap.containsValue","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 675,col 13)-(line 675,col 16)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 679,col 41)-(line 679,col 41)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 680,col 42)-(line 680,col 45)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 682,col 28)-(line 682,col 31)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 683,col 9)-(line 683,col 13)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.containsValue(java.lang.Object)"},{"javadocBlockTags":[],"methodDeclaration":"private boolean containsNullValue()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Entry<K, V>[] tab = getTable();\n    for (int i = tab.length; i-- > 0; ) for (Entry e = tab[i]; e != null; e = e.next) if (e.value == null)\n        return true;\n    return false;\n}","methodRange":"(line 689,col 5)-(line 696,col 5)","methodTokenRange":"private boolean containsNullValue() {\n\t\/*@Nullable*\/ Entry<K,V>[] tab = getTable();\n        for (int i = tab.length ; i-- > 0 ;)\n            for (Entry e = tab[i] ; e != null ; e = e.next)\n                if (e.value==null)\n                    return true;\n\treturn false;\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n     * Special-case code for containsValue with null argument\n     ","methodParameters":[],"methodName":"containsNullValue","methodQualifiedSignature":"plume.WeakIdentityHashMap.containsNullValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Special-case code for containsValue with null argument'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 691,col 41)-(line 691,col 41)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 692,col 42)-(line 692,col 45)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 693,col 30)-(line 693,col 33)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 694,col 28)-(line 694,col 31)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 695,col 9)-(line 695,col 13)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.containsNullValue()"},{"methodDeclaration":"public Set<K> keySet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<K> ks = our_keySet;\n    return (ks != null ? ks : (our_keySet = new KeySet()));\n}","methodRange":"(line 873,col 5)-(line 876,col 5)","methodTokenRange":"public Set<K> keySet() {\n        Set<K> ks = our_keySet;\n        return (ks != null ? ks : (our_keySet = new KeySet()));\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"keySet","methodQualifiedSignature":"plume.WeakIdentityHashMap.keySet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<K>","methodType":"Set<K>","literalExprs":[{"literalExprRange":"(line 875,col 23)-(line 875,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.keySet()"},{"methodDeclaration":"public Collection<V> values()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Collection<V> vs = our_values;\n    return (vs != null ? vs : (our_values = new Values()));\n}","methodRange":"(line 935,col 5)-(line 938,col 5)","methodTokenRange":"public Collection<V> values() {\n        Collection<V> vs = our_values;\n        return (vs != null ?  vs : (our_values = new Values()));\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"values","methodQualifiedSignature":"plume.WeakIdentityHashMap.values","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Collection<V>","methodType":"Collection<V>","literalExprs":[{"literalExprRange":"(line 937,col 23)-(line 937,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.values()"},{"methodDeclaration":"public Set<Map.Entry<K, V>> entrySet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<Map.Entry<K, V>> es = entrySet;\n    return (es != null ? es : (entrySet = new EntrySet()));\n}","methodRange":"(line 988,col 5)-(line 991,col 5)","methodTokenRange":"public Set<Map.Entry<K,V>> entrySet() {\n        Set<Map.Entry<K,V>> es = entrySet;\n        return (es != null ? es : (entrySet = new EntrySet()));\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"entrySet","methodQualifiedSignature":"plume.WeakIdentityHashMap.entrySet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<java.util.Map.Entry<K, V>>","methodType":"Set<Map.Entry<K, V>>","literalExprs":[{"literalExprRange":"(line 990,col 23)-(line 990,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityHashMap.entrySet()"}],"classJavadoc":"\/**\n * This class combines the features of {@link java.util.WeakHashMap} and\n * {@link java.util.IdentityHashMap}.\n * The implementation is a modified version of {@link java.util.WeakHashMap}\n * from JDK 1.5, which differs from the original in two ways:\n * <ul>\n *  <li> uses of hashCode() are replaced by System.identityHashCode()<\/li>\n *  <li> uses of object equality (.equals) are replaced by identity checks (==)<\/li>\n * <\/ul>\n * See {@link java.util.IdentityHashMap}\n * for more information on the changes made in an identity hash map..\n *\n * <hr>\n *\n * A hashtable-based <code>Map<\/code> implementation with <em>weak\n * keys<\/em>.  An entry in a <code>WeakIdentityHashMap<\/code> will\n * automatically be removed when its key is no longer in ordinary use.\n * More precisely, the presence of a mapping for a given key will not\n * prevent the key from being discarded by the garbage collector, that\n * is, made finalizable, finalized, and then reclaimed.  When a key\n * has been discarded its entry is effectively removed from the map,\n * so this class behaves somewhat differently than other <code>Map<\/code>\n * implementations.\n *\n * <p> Both null values and the null key are supported. This class has\n * performance characteristics similar to those of the <code>HashMap<\/code>\n * class, and has the same efficiency parameters of <em>initial capacity<\/em>\n * and <em>load factor<\/em>.\n *\n * <p> Like most collection classes, this class is not synchronized.  A\n * synchronized <code>WeakIdentityHashMap<\/code> may be constructed using the\n * <code>Collections.synchronizedMap<\/code> method.\n *\n * <p> The behavior of the <code>WeakIdentityHashMap<\/code> class depends\n * in part upon the actions of the garbage collector, so several\n * familiar (though not required) <code>Map<\/code> invariants do not hold\n * for this class.  Because the garbage collector may discard keys at\n * any time, a <code>WeakIdentityHashMap<\/code> may behave as though an\n * unknown thread is silently removing entries.  In particular, even\n * if you synchronize on a <code>WeakIdentityHashMap<\/code> instance and\n * invoke none of its mutator methods, it is possible for the\n * <code>size<\/code> method to return smaller values over time, for the\n * <code>isEmpty<\/code> method to return <code>false<\/code> and then\n * <code>true<\/code>, for the <code>containsKey<\/code> method to return\n * <code>true<\/code> and later <code>false<\/code> for a given key, for the\n * <code>get<\/code> method to return a value for a given key but later\n * return <code>null<\/code>, for the <code>put<\/code> method to return\n * <code>null<\/code> and the <code>remove<\/code> method to return\n * <code>false<\/code> for a key that previously appeared to be in the map,\n * and for successive examinations of the key set, the value set, and\n * the entry set to yield successively smaller numbers of elements.\n *\n * <p> Each key object in a <code>WeakIdentityHashMap<\/code> is stored\n * indirectly as the referent of a weak reference.  Therefore a key\n * will automatically be removed only after the weak references to it,\n * both inside and outside of the map, have been cleared by the\n * garbage collector.\n *\n * <p> <strong>Implementation note:<\/strong> The value objects in a\n * <code>WeakIdentityHashMap<\/code> are held by ordinary strong\n * references.  Thus care should be taken to ensure that value objects\n * do not strongly refer to their own keys, either directly or\n * indirectly, since that will prevent the keys from being discarded.\n * Note that a value object may refer indirectly to its key via the\n * <code>WeakIdentityHashMap<\/code> itself; that is, a value object may\n * strongly refer to some other key object whose associated value\n * object, in turn, strongly refers to the key of the first value\n * object.  One way to deal with this is to wrap values themselves\n * within <code>WeakReferences<\/code> before inserting, as in:\n * <code>m.put(key, new WeakReference(value))<\/code>, and then unwrapping\n * upon each <code>get<\/code>.\n *\n * <p>The iterators returned by all of this class's \"collection view methods\"\n * are <i>fail-fast<\/i>: if the map is structurally modified at any time after\n * the iterator is created, in any way except through the iterator's own\n * <code>remove<\/code> or <code>add<\/code> methods, the iterator will throw a\n * <code>ConcurrentModificationException<\/code>.  Thus, in the face of concurrent\n * modification, the iterator fails quickly and cleanly, rather than risking\n * arbitrary, non-deterministic behavior at an undetermined time in the\n * future.\n *\n * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n * as it is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification.  Fail-fast iterators\n * throw <code>ConcurrentModificationException<\/code> on a best-effort basis.\n * Therefore, it would be wrong to write a program that depended on this\n * exception for its correctness:  <i>the fail-fast behavior of iterators\n * should be used only to detect bugs.<\/i>\n *\n * <p>This class is a member of the\n * <a href=\"{@docRoot}\/..\/guide\/collections\/index.html\">\n * Java Collections Framework<\/a>.\n *\n * @version\t1.30, 02\/19\/04\n * @author      Doug Lea\n * @author      Josh Bloch\n * @author\tMark Reinhold\n * @since\t1.2\n * @see\t\tjava.util.HashMap\n * @see\t\tjava.lang.ref.WeakReference\n *\/\n","className":"WeakIdentityHashMap","fields":[{"fieldRange":"(line 140,col 5)-(line 140,col 59)","fieldName":"DEFAULT_INITIAL_CAPACITY","fieldJavadocComment":"\n     * The default initial capacity -- MUST be a power of two.\n     ","fieldTokenRange":"private static final int DEFAULT_INITIAL_CAPACITY = 16;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 140,col 57)-(line 140,col 58)","literalExprId":1,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[16]","fieldType":"int","fieldJavadoc":"The default initial capacity -- MUST be a power of two.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 147,col 5)-(line 147,col 56)","fieldName":"MAXIMUM_CAPACITY","fieldJavadocComment":"\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     ","fieldTokenRange":"private static final int MAXIMUM_CAPACITY = 1 << 30;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 147,col 49)-(line 147,col 49)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 54)-(line 147,col 55)","literalExprId":2,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[1 << 30]","fieldType":"int","fieldJavadoc":"The maximum capacity, used if a higher value is implicitly specified\nby either of the constructors with arguments.\nMUST be a power of two <= 1<<30.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 152,col 5)-(line 152,col 59)","fieldName":"DEFAULT_LOAD_FACTOR","fieldJavadocComment":"\n     * The load fast used when none specified in constructor.\n     ","fieldTokenRange":"private static final float DEFAULT_LOAD_FACTOR = 0.75f;","fieldTypeResolved":"PrimitiveTypeUsage{name='float'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 152,col 54)-(line 152,col 58)","literalExprId":1,"literalExpr":"0.75f","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[0.75f]","fieldType":"float","fieldJavadoc":"The load fast used when none specified in constructor.\n","fieldTypeResolvedDescribed":"float"},{"fieldRange":"(line 157,col 5)-(line 157,col 45)","fieldName":"table","fieldJavadocComment":"\n     * The table, resized as necessary. Length MUST Always be a power of two.\n     ","fieldTokenRange":"private \/*@Nullable*\/ Entry<K,V>[] table;","fieldTypeResolved":"ResolvedArrayType{ReferenceType{plume.WeakIdentityHashMap.Entry, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityHashMap.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}, plume.WeakIdentityHashMap.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Entry<K, V>[]","fieldJavadoc":"The table, resized as necessary. Length MUST Always be a power of two.\n","fieldTypeResolvedDescribed":"plume.WeakIdentityHashMap.Entry<K, V>[]"},{"fieldRange":"(line 162,col 5)-(line 162,col 21)","fieldName":"size","fieldJavadocComment":"\n     * The number of key-value mappings contained in this weak hash map.\n     ","fieldTokenRange":"private int size;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The number of key-value mappings contained in this weak hash map.\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 167,col 5)-(line 167,col 26)","fieldName":"threshold","fieldJavadocComment":"\n     * The next size value at which to resize (capacity * load factor).\n     ","fieldTokenRange":"private int threshold;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The next size value at which to resize (capacity * load factor).\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 172,col 5)-(line 172,col 35)","fieldName":"loadFactor","fieldJavadocComment":"\n     * The load factor for the hash table.\n     ","fieldTokenRange":"private final float loadFactor;","fieldTypeResolved":"PrimitiveTypeUsage{name='float'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"float","fieldJavadoc":"The load factor for the hash table.\n","fieldTypeResolvedDescribed":"float"},{"fieldRange":"(line 177,col 5)-(line 177,col 68)","fieldName":"queue","fieldJavadocComment":"\n     * Reference queue for cleared WeakEntries\n     ","fieldTokenRange":"private final ReferenceQueue<K> queue = new ReferenceQueue<K>();","fieldTypeResolved":"ReferenceType{java.lang.ref.ReferenceQueue, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.ReferenceQueue.T=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ReferenceQueue<K>()]","fieldType":"ReferenceQueue<K>","fieldJavadoc":"Reference queue for cleared WeakEntries\n","fieldTypeResolvedDescribed":"java.lang.ref.ReferenceQueue<K>"},{"fieldRange":"(line 186,col 5)-(line 186,col 34)","fieldName":"modCount","fieldJavadocComment":"\n     * The number of times this HashMap has been structurally modified\n     * Structural modifications are those that change the number of mappings in\n     * the HashMap or otherwise modify its internal structure (e.g.,\n     * rehash).  This field is used to make iterators on Collection-views of\n     * the HashMap fail-fast.  (See ConcurrentModificationException).\n     ","fieldTokenRange":"private volatile int modCount;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The number of times this HashMap has been structurally modified\nStructural modifications are those that change the number of mappings in\nthe HashMap or otherwise modify its internal structure (e.g.,\nrehash).  This field is used to make iterators on Collection-views of\nthe HashMap fail-fast.  (See ConcurrentModificationException).\n","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 270,col 5)-(line 270,col 56)","fieldName":"NULL_KEY","fieldJavadocComment":" because NULL_KEY is a static field but K is a per-instance type parameter.","fieldTokenRange":"private static final Object NULL_KEY = new Object();","fieldTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new Object()]","fieldType":"Object","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Object"},{"fieldRange":"(line 858,col 5)-(line 858,col 72)","fieldName":"entrySet","fieldJavadocComment":"","fieldTokenRange":"private transient \/*@Nullable*\/ Set<Map.Entry<K,V>> entrySet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 858,col 68)-(line 858,col 71)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<Map.Entry<K, V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<java.util.Map.Entry<K, V>>"},{"fieldRange":"(line 859,col 5)-(line 859,col 72)","fieldName":"our_keySet","fieldJavadocComment":"","fieldTokenRange":"private transient volatile \/*@Nullable*\/ Set<K>   our_keySet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 859,col 68)-(line 859,col 71)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<K>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<K>"},{"fieldRange":"(line 921,col 5)-(line 921,col 69)","fieldName":"our_values","fieldJavadocComment":"","fieldTokenRange":"transient volatile \/*@Nullable*\/ Collection<V> our_values = null;","fieldTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 921,col 65)-(line 921,col 68)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Collection<V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Collection<V>"}]}],"sourceFileId":9,"packageName":"plume"},{"sourceFileName":"plume.IterableIterator","imports":[{"importId":1,"import":"import java.util.Iterator;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the iterator to wrap.","javadocBlockTagName":"iter","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the iterator to wrap.'}]}', name=Optional[iter]}"}],"constructorQualifiedSignature":"plume.IterableIterator.IterableIterator(java.util.Iterator<T>)","variableDeclarationExprs":[],"constructorRange":"(line 61,col 3)-(line 63,col 3)","constructorJavadocComment":"\n   * Create an IterableIterator.\n   * @param iter the iterator to wrap.\n   * ","constructorDeclaration":"public IterableIterator(Iterator<T> iter)","constructorBody":"{\n    this.iter = iter;\n}","constructorName":"IterableIterator","constructorQualifiedName":"plume.IterableIterator.IterableIterator","constructorParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> iter","parameterName":"iter"}],"literalExprs":[],"constructorTokenRange":"public IterableIterator(Iterator<T> iter) {\n    this.iter = iter;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create an IterableIterator.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the iterator to wrap.'}]}', name=Optional[iter]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the iterator","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the iterator'}]}', name=Optional.empty}"}],"methodDeclaration":"public Iterator<T> iterator()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return iter;\n}","methodRange":"(line 68,col 3)-(line 70,col 3)","methodTokenRange":"public Iterator<T> iterator() {\n    return iter;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":" Return the iterator.\n   * @return the iterator\n   ","methodParameters":[],"methodName":"iterator","methodQualifiedSignature":"plume.IterableIterator.iterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the iterator.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the iterator'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<T>","methodType":"Iterator<T>","literalExprs":[],"methodQualifiedName":"plume.IterableIterator.iterator()"}],"classJavadoc":"\/**\n * In Java, Iterators are not Iterable, so they cannot be used in new-style\n * for loops.  This wrapper works around that by making an Iterator that is\n * also Iterable &mdash; that is, it implements the iterator() method.\n * <p>\n *\n * As an example, suppose that you have a class with a method:\n * <pre>  public Iterator&lt;String&gt; backwardIterator() { ... }<\/pre>\n * Because this method is not named {@code iterator()}, which probably\n * has a different meaning than {@code backwardIterator()}, it is not\n * possible to use Java's new-style for loop (also known as the foreach\n * loop).  Instead, a client must do:\n * <pre>\n *  for (Iterator&lt;String&gt; itor = myObject.backwardIterator(); itor.hasNext(); ) {\n *    String element = itor.next();\n *    ...\n *  }\n * <\/pre>\n *\n * The {@code IterableIterator} class lets you write this more compactly:\n * <pre>\n *  for (String element : new IterableIterator(myObject.backwardIterator())) {\n *     ...\n *  }\n * <\/pre>\n * Another advantage of this syntax is that it explicitly indicates that\n * the Iterator is not being modified in the loop body, which is a common\n * reason for not using the new-style for loop.\n * <p>\n *\n * It's often better to use a real Iterable (e.g., a collections class)\n * rather than an Iterator.  But in some cases the overhead is undesirable,\n * or there are multiple ways to iterate so it doesn't make sense to\n * reserve the iterator() method for just one of them, or it is desirable\n * to use an Iterator because it throws a ConcurrentModificationException\n * in case of errors, or for other reasons.  This class can be appropriate\n * in such circumstances.\n * <p>\n *\n * <b>Warning:<\/b> Some clients might expect that calling Iterable.iterator()\n * twice on a given Iterable results in two objects that can both iterate over\n * the whole sequence, and that won't interfere with one another.  That is\n * not the case for this Iterable.\n *\n * @param <T> the element type of the IterableIterator\n *\/\n","className":"IterableIterator","fields":[{"fieldRange":"(line 55,col 3)-(line 55,col 27)","fieldName":"iter","fieldJavadocComment":" The Iterator that this is a wrapper around. ","fieldTokenRange":"private Iterator<T> iter;","fieldTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Iterator<T>","fieldJavadoc":"The Iterator that this is a wrapper around.\n","fieldTypeResolvedDescribed":"java.util.Iterator<T>"}]}],"sourceFileId":10,"packageName":"plume"},{"sourceFileName":"plume.Lookup","imports":[{"importId":1,"import":"import static plume.EntryReader.Entry;\n"},{"importId":2,"import":"import java.io.BufferedReader;\n"},{"importId":3,"import":"import java.io.FileNotFoundException;\n"},{"importId":4,"import":"import java.io.IOException;\n"},{"importId":5,"import":"import java.io.InputStream;\n"},{"importId":6,"import":"import java.io.InputStreamReader;\n"},{"importId":7,"import":"import java.util.ArrayList;\n"},{"importId":8,"import":"import java.util.List;\n"},{"importId":9,"import":"import java.util.regex.Pattern;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.Lookup.Lookup()","variableDeclarationExprs":[],"constructorRange":"(line 128,col 3)-(line 130,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private Lookup()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"Lookup","constructorQualifiedName":"plume.Lookup.Lookup","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 129,col 21)-(line 129,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private Lookup() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"command-line arguments; see documentation","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments; see documentation'}]}', name=Optional[args]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading a file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static void main(String[] args) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Options options = new Options(usage_string, Lookup.class);\n    String[] keywords = options.parse_or_usage(args);\n    if (help) {\n        InputStream is = Lookup.class.getResourceAsStream(\"lookup.txt\");\n        if (is == null) {\n            System.out.println(\"Unable to find resource 'lookup.txt' with help text.\");\n            System.exit(1);\n        }\n        BufferedReader help_stream = new BufferedReader(new InputStreamReader(is));\n        String line = help_stream.readLine();\n        while (line != null) {\n            System.out.println(line);\n            line = help_stream.readLine();\n        }\n        System.exit(0);\n    }\n    if (verbose) {\n        System.out.printf(\"Options settings: %n%s%n\", options.settings());\n    }\n    if (keywords.length == 0) {\n        options.print_usage(\"Error: No keywords specified\");\n        System.exit(254);\n    }\n    assert comment_re != null : \"@AssumeAssertion(nullness): application invariant\";\n    if (comment_re.equals(\"\")) {\n        comment_re = null;\n    }\n    EntryReader reader = null;\n    String[] entry_files = entry_file.split(\":\");\n    List<Exception> file_errors = new ArrayList<Exception>();\n    for (String ef : entry_files) {\n        ef = UtilMDE.expandFilename(ef);\n        try {\n            reader = new EntryReader(ef, comment_re, include_re);\n        } catch (FileNotFoundException e) {\n            file_errors.add(e);\n        }\n        if (reader != null) {\n            break;\n        }\n    }\n    if (reader == null) {\n        System.out.println(\"Error: Can't read any entry files\");\n        for (Exception file_error : file_errors) {\n            System.out.printf(\"  entry file %s%n\", file_error.getMessage());\n        }\n        System.exit(254);\n    }\n    reader.set_entry_start_stop(entry_start_re, entry_stop_re);\n    List<Entry> matching_entries = new ArrayList<Entry>();\n    try {\n        int entry_cnt = 0;\n        Entry entry = reader.get_entry();\n        while (entry != null) {\n            entry_cnt++;\n            if (verbose && ((entry_cnt % 1000) == 0)) {\n                System.out.printf(\"%d matches in %d entries\\r\", matching_entries.size(), entry_cnt);\n            }\n            int matchcount = 0;\n            for (String keyword : keywords) {\n                String search = entry.get_description(description_re);\n                if (search_body || entry.short_entry) {\n                    search = entry.body;\n                }\n                if (!case_sensitive) {\n                    search = search.toLowerCase();\n                }\n                if (regular_expressions) {\n                    int flags = Pattern.CASE_INSENSITIVE;\n                    if (case_sensitive) {\n                        flags = 0;\n                    }\n                    if (!RegexUtil.isRegex(keyword)) {\n                        System.out.println(\"Error: not a regex: \" + keyword);\n                        System.exit(254);\n                    }\n                    if (Pattern.compile(keyword, flags).matcher(search).find()) {\n                        matchcount++;\n                    }\n                } else {\n                    if (!case_sensitive) {\n                        keyword = keyword.toLowerCase();\n                    }\n                    if (word_match) {\n                        String keyword_re = \"\\\\b\" + Pattern.quote(keyword) + \"\\\\b\";\n                        if (Pattern.compile(keyword_re).matcher(search).find()) {\n                            matchcount++;\n                        }\n                    } else if (search.contains(keyword)) {\n                        matchcount++;\n                    }\n                }\n            }\n            if (matchcount == keywords.length) {\n                matching_entries.add(entry);\n            }\n            entry = reader.get_entry();\n        }\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n    }\n    if (matching_entries.size() == 0) {\n        System.out.println(\"Nothing found.\");\n    } else if (matching_entries.size() == 1) {\n        Entry e = matching_entries.get(0);\n        if (show_location) {\n            System.out.printf(\"%s:%d:%n\", e.filename, e.line_number);\n        }\n        System.out.print(e.body);\n    } else {\n        if (item_num != null) {\n            if (item_num < 1) {\n                System.out.printf(\"Illegal --item-num %d, should be positive%n\", item_num);\n                System.exit(1);\n            }\n            if (item_num > matching_entries.size()) {\n                System.out.printf(\"Illegal --item-num %d, should be <= %d%n\", item_num, matching_entries.size());\n                System.exit(1);\n            }\n            Entry e = matching_entries.get(item_num - 1);\n            if (show_location) {\n                System.out.printf(\"%s:%d:%n\", e.filename, e.line_number);\n            }\n            System.out.print(e.body);\n        } else {\n            int i = 0;\n            if (print_all) {\n                System.out.printf(\"%d matches found (separated by dashes below)%n\", matching_entries.size());\n            } else {\n                System.out.printf(\"%d matches found. Use -i to print a specific match or -a to see them all%n\", matching_entries.size());\n            }\n            for (Entry e : matching_entries) {\n                i++;\n                if (print_all) {\n                    if (show_location) {\n                        System.out.printf(\"%n-------------------------%n%s:%d:%n\", e.filename, e.line_number);\n                    } else {\n                        System.out.printf(\"%n-------------------------%n\");\n                    }\n                    System.out.print(e.body);\n                } else {\n                    if (show_location) {\n                        System.out.printf(\"  -i=%d %s:%d: %s%n\", i, e.filename, e.line_number, e.first_line);\n                    } else {\n                        System.out.printf(\"  -i=%d %s%n\", i, e.get_description(description_re));\n                    }\n                }\n            }\n        }\n    }\n}","methodRange":"(line 237,col 3)-(line 422,col 3)","methodTokenRange":"public static void main(String[] args) throws IOException {\n\n    Options options = new Options(usage_string, Lookup.class);\n    String[] keywords = options.parse_or_usage(args);\n\n    \/\/ If help was requested, print it and exit\n    if (help) {\n      InputStream is = Lookup.class.getResourceAsStream(\"lookup.txt\");\n      if (is == null) {\n        \/\/ This should never happen.\n        System.out.println(\"Unable to find resource 'lookup.txt' with help text.\");\n        System.exit(1);\n      }\n      BufferedReader help_stream = new BufferedReader(new InputStreamReader(is));\n      String line = help_stream.readLine();\n      while (line != null) {\n        System.out.println(line);\n        line = help_stream.readLine();\n      }\n      System.exit(0);\n    }\n\n    if (verbose) {\n      System.out.printf(\"Options settings: %n%s%n\", options.settings());\n    }\n\n    \/\/ Make sure at least one keyword was specified\n    if (keywords.length == 0) {\n      options.print_usage(\"Error: No keywords specified\");\n      System.exit(254);\n    }\n\n    \/\/ comment_re starts out non-null and the option processing code can't\n    \/\/ make it null, so no null pointer exception is possible in the\n    \/\/ if statement predicate that immediately follows this assertion.\n    assert comment_re != null : \"@AssumeAssertion(nullness): application invariant\";\n\n    \/\/ If the comment regular expression is empty, turn off comment processing\n    if (comment_re.equals(\"\")) {\n      comment_re = null;\n    }\n\n    \/\/ Open the first readable root file\n    EntryReader reader = null;\n    String[] entry_files = entry_file.split(\":\");\n    List<Exception> file_errors = new ArrayList<Exception>();\n    for (String ef : entry_files) {\n      ef = UtilMDE.expandFilename(ef);\n      try {\n        reader = new EntryReader(ef, comment_re, include_re);\n      } catch (FileNotFoundException e) {\n        file_errors.add(e);\n      }\n      if (reader != null) {\n        break;\n      }\n    }\n    if (reader == null) {\n      System.out.println(\"Error: Can't read any entry files\");\n      for (Exception file_error : file_errors) {\n        System.out.printf(\"  entry file %s%n\", file_error.getMessage());\n      }\n      System.exit(254);\n    }\n\n    \/\/ Setup the regular expressions for long entries\n    reader.set_entry_start_stop(entry_start_re, entry_stop_re);\n\n    List<Entry> matching_entries = new ArrayList<Entry>();\n\n    try {\n      \/\/ Process each entry looking for matches\n      int entry_cnt = 0;\n      Entry entry = reader.get_entry();\n      while (entry != null) {\n        entry_cnt++;\n        if (verbose && ((entry_cnt % 1000) == 0)) {\n          System.out.printf(\"%d matches in %d entries\\r\", matching_entries.size(), entry_cnt);\n        }\n        int matchcount = 0;\n        for (String keyword : keywords) {\n          String search = entry.get_description(description_re);\n          if (search_body || entry.short_entry) {\n            search = entry.body;\n          }\n          if (!case_sensitive) {\n            search = search.toLowerCase();\n          }\n          if (regular_expressions) {\n            int flags = Pattern.CASE_INSENSITIVE;\n            if (case_sensitive) {\n              flags = 0;\n            }\n\n            if (!RegexUtil.isRegex(keyword)) {\n              System.out.println(\"Error: not a regex: \" + keyword);\n              System.exit(254);\n            }\n\n            if (Pattern.compile(keyword, flags).matcher(search).find()) {\n              matchcount++;\n            }\n          } else {\n            if (!case_sensitive) {\n              keyword = keyword.toLowerCase();\n            }\n            if (word_match) {\n              String keyword_re = \"\\\\b\" + Pattern.quote(keyword) + \"\\\\b\";\n              if (Pattern.compile(keyword_re).matcher(search).find()) {\n                matchcount++;\n              }\n            } else if (search.contains(keyword)) {\n              matchcount++;\n            }\n          }\n        }\n        if (matchcount == keywords.length) {\n          matching_entries.add(entry);\n        }\n        entry = reader.get_entry();\n      }\n    } catch (FileNotFoundException e) {\n      System.out.printf(\n          \"Error: Can't read %s at line %d in file %s%n\",\n          e.getMessage(),\n          reader.getLineNumber(),\n          reader.getFileName());\n      System.exit(254);\n    }\n\n    \/\/ Print the results\n    if (matching_entries.size() == 0) {\n      System.out.println(\"Nothing found.\");\n    } else if (matching_entries.size() == 1) {\n      Entry e = matching_entries.get(0);\n      if (show_location) {\n        System.out.printf(\"%s:%d:%n\", e.filename, e.line_number);\n      }\n      System.out.print(e.body);\n    } else { \/\/ there must be multiple matches\n      if (item_num != null) {\n        if (item_num < 1) {\n          System.out.printf(\"Illegal --item-num %d, should be positive%n\", item_num);\n          System.exit(1);\n        }\n        if (item_num > matching_entries.size()) {\n          System.out.printf(\n              \"Illegal --item-num %d, should be <= %d%n\", item_num, matching_entries.size());\n          System.exit(1);\n        }\n        Entry e = matching_entries.get(item_num - 1);\n        if (show_location) {\n          System.out.printf(\"%s:%d:%n\", e.filename, e.line_number);\n        }\n        System.out.print(e.body);\n      } else {\n        int i = 0;\n        if (print_all) {\n          System.out.printf(\n              \"%d matches found (separated by dashes below)%n\", matching_entries.size());\n        } else {\n          System.out.printf(\n              \"%d matches found. Use -i to print a specific match or -a to see them all%n\",\n              matching_entries.size());\n        }\n\n        for (Entry e : matching_entries) {\n          i++;\n          if (print_all) {\n            if (show_location) {\n              System.out.printf(\"%n-------------------------%n%s:%d:%n\", e.filename, e.line_number);\n            } else {\n              System.out.printf(\"%n-------------------------%n\");\n            }\n            System.out.print(e.body);\n          } else {\n            if (show_location) {\n              System.out.printf(\"  -i=%d %s:%d: %s%n\", i, e.filename, e.line_number, e.first_line);\n            } else {\n              System.out.printf(\"  -i=%d %s%n\", i, e.get_description(description_re));\n            }\n          }\n        }\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Look for the specified keywords in the file(s) and print\n   * the corresponding entries.\n   * @param args command-line arguments; see documentation\n   * @throws IOException if there is a problem reading a file\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.Lookup.main","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Look for the specified keywords in the file(s) and print\nthe corresponding entries.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments; see documentation'}]}', name=Optional[args]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 244,col 57)-(line 244,col 68)","literalExprId":1,"literalExpr":"\"lookup.txt\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 245,col 17)-(line 245,col 20)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 247,col 28)-(line 247,col 81)","literalExprId":3,"literalExpr":"\"Unable to find resource 'lookup.txt' with help text.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 248,col 21)-(line 248,col 21)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 252,col 22)-(line 252,col 25)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 256,col 19)-(line 256,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 260,col 25)-(line 260,col 50)","literalExprId":7,"literalExpr":"\"Options settings: %n%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 264,col 28)-(line 264,col 28)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 265,col 27)-(line 265,col 56)","literalExprId":9,"literalExpr":"\"Error: No keywords specified\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 266,col 19)-(line 266,col 21)","literalExprId":10,"literalExpr":"254","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 272,col 26)-(line 272,col 29)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 272,col 33)-(line 272,col 83)","literalExprId":12,"literalExpr":"\"@AssumeAssertion(nullness): application invariant\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 275,col 27)-(line 275,col 28)","literalExprId":13,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 276,col 20)-(line 276,col 23)","literalExprId":14,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 280,col 26)-(line 280,col 29)","literalExprId":15,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 281,col 45)-(line 281,col 47)","literalExprId":16,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 290,col 21)-(line 290,col 24)","literalExprId":17,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 294,col 19)-(line 294,col 22)","literalExprId":18,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 295,col 26)-(line 295,col 60)","literalExprId":19,"literalExpr":"\"Error: Can't read any entry files\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 297,col 27)-(line 297,col 45)","literalExprId":20,"literalExpr":"\"  entry file %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 299,col 19)-(line 299,col 21)","literalExprId":21,"literalExpr":"254","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 309,col 23)-(line 309,col 23)","literalExprId":22,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 311,col 23)-(line 311,col 26)","literalExprId":23,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 313,col 38)-(line 313,col 41)","literalExprId":24,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 313,col 47)-(line 313,col 47)","literalExprId":25,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 314,col 29)-(line 314,col 56)","literalExprId":26,"literalExpr":"\"%d matches in %d entries\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 316,col 26)-(line 316,col 26)","literalExprId":27,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 328,col 23)-(line 328,col 23)","literalExprId":28,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 332,col 34)-(line 332,col 55)","literalExprId":29,"literalExpr":"\"Error: not a regex: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 333,col 27)-(line 333,col 29)","literalExprId":30,"literalExpr":"254","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 344,col 35)-(line 344,col 39)","literalExprId":31,"literalExpr":"\"\\\\b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 344,col 68)-(line 344,col 72)","literalExprId":32,"literalExpr":"\"\\\\b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 360,col 11)-(line 360,col 56)","literalExprId":33,"literalExpr":"\"Error: Can't read %s at line %d in file %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 364,col 19)-(line 364,col 21)","literalExprId":34,"literalExpr":"254","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 368,col 36)-(line 368,col 36)","literalExprId":35,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 369,col 26)-(line 369,col 41)","literalExprId":36,"literalExpr":"\"Nothing found.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 370,col 43)-(line 370,col 43)","literalExprId":37,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 371,col 38)-(line 371,col 38)","literalExprId":38,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 373,col 27)-(line 373,col 36)","literalExprId":39,"literalExpr":"\"%s:%d:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 377,col 23)-(line 377,col 26)","literalExprId":40,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 378,col 24)-(line 378,col 24)","literalExprId":41,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 379,col 29)-(line 379,col 73)","literalExprId":42,"literalExpr":"\"Illegal --item-num %d, should be positive%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 380,col 23)-(line 380,col 23)","literalExprId":43,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 384,col 15)-(line 384,col 56)","literalExprId":44,"literalExpr":"\"Illegal --item-num %d, should be <= %d%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 385,col 23)-(line 385,col 23)","literalExprId":45,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 387,col 51)-(line 387,col 51)","literalExprId":46,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 389,col 29)-(line 389,col 38)","literalExprId":47,"literalExpr":"\"%s:%d:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 393,col 17)-(line 393,col 17)","literalExprId":48,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 396,col 15)-(line 396,col 62)","literalExprId":49,"literalExpr":"\"%d matches found (separated by dashes below)%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 399,col 15)-(line 399,col 90)","literalExprId":50,"literalExpr":"\"%d matches found. Use -i to print a specific match or -a to see them all%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 407,col 33)-(line 407,col 71)","literalExprId":51,"literalExpr":"\"%n-------------------------%n%s:%d:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 409,col 33)-(line 409,col 63)","literalExprId":52,"literalExpr":"\"%n-------------------------%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 414,col 33)-(line 414,col 53)","literalExprId":53,"literalExpr":"\"  -i=%d %s:%d: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 416,col 33)-(line 416,col 46)","literalExprId":54,"literalExpr":"\"  -i=%d %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Lookup.main(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"where to read the entry from","javadocBlockTagName":"reader","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to read the entry from'}]}', name=Optional[reader]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the next entry, or null","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next entry, or null'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading a file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static Entry old_get_entry(EntryReader reader) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        String line = reader.readLine();\n        while ((line != null) && (line.trim().length() == 0)) {\n            line = reader.readLine();\n        }\n        if (line == null) {\n            return (null);\n        }\n        Entry entry = null;\n        String filename = reader.getFileName();\n        long line_number = reader.getLineNumber();\n        if (line.startsWith(\">entry\")) {\n            String current_filename = reader.getFileName();\n            line = line.replaceFirst(\"^>entry *\", \"\");\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            while ((line != null) && !line.startsWith(\">entry\") && !line.equals(\"<entry\") && current_filename.equals(reader.getFileName())) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            if ((line != null) && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n                reader.putback(line);\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, false);\n        } else {\n            String first_line = line;\n            StringBuilder body = new StringBuilder();\n            while ((line != null) && (line.trim().length() != 0)) {\n                body.append(line);\n                body.append(lineSep);\n                line = reader.readLine();\n            }\n            entry = new Entry(first_line, body.toString(), filename, line_number, true);\n        }\n        return (entry);\n    } catch (FileNotFoundException e) {\n        System.out.printf(\"Error: Can't read %s at line %d in file %s%n\", e.getMessage(), reader.getLineNumber(), reader.getFileName());\n        System.exit(254);\n        return (null);\n    }\n}","methodRange":"(line 430,col 3)-(line 503,col 3)","methodTokenRange":"public static \/*@Nullable*\/ Entry old_get_entry(EntryReader reader) throws IOException {\n\n    try {\n\n      \/\/ Skip any preceeding blank lines\n      String line = reader.readLine();\n      while ((line != null) && (line.trim().length() == 0)) {\n        line = reader.readLine();\n      }\n      if (line == null) {\n        return (null);\n      }\n\n      Entry entry = null;\n      String filename = reader.getFileName();\n      long line_number = reader.getLineNumber();\n\n      \/\/ If this is a long entry\n      if (line.startsWith(\">entry\")) {\n\n        \/\/ Get the current filename\n        String current_filename = reader.getFileName();\n\n        \/\/ Remove '>entry' from the line\n        line = line.replaceFirst(\"^>entry *\", \"\");\n        String first_line = line;\n\n        StringBuilder body = new StringBuilder();\n        \/\/ Read until we find the termination of the entry\n        while ((line != null)\n            && !line.startsWith(\">entry\")\n            && !line.equals(\"<entry\")\n            && current_filename.equals(reader.getFileName())) {\n          body.append(line);\n          body.append(lineSep);\n          line = reader.readLine();\n        }\n\n        \/\/ If this entry was terminated by the start of the next one,\n        \/\/ put that line back\n        if ((line != null)\n            && (line.startsWith(\">entry\") || !current_filename.equals(reader.getFileName()))) {\n          reader.putback(line);\n        }\n\n        entry = new Entry(first_line, body.toString(), filename, line_number, false);\n\n      } else { \/\/ blank separated entry\n\n        String first_line = line;\n\n        StringBuilder body = new StringBuilder();\n        \/\/ Read until we find another blank line\n        while ((line != null) && (line.trim().length() != 0)) {\n          body.append(line);\n          body.append(lineSep);\n          line = reader.readLine();\n        }\n\n        entry = new Entry(first_line, body.toString(), filename, line_number, true);\n      }\n\n      return (entry);\n\n    } catch (FileNotFoundException e) {\n      System.out.printf(\n          \"Error: Can't read %s at line %d in file %s%n\",\n          e.getMessage(),\n          reader.getLineNumber(),\n          reader.getFileName());\n      System.exit(254);\n      return (null);\n    }\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * Returns the next entry.  If no more entries are available, returns null.\n   * @param reader where to read the entry from\n   * @return the next entry, or null\n   * @throws IOException if there is a problem reading a file\n   ","methodParameters":[{"parameterType":"EntryReader","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.EntryReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.EntryReader","parameter":"EntryReader reader","parameterName":"reader"}],"methodName":"old_get_entry","methodQualifiedSignature":"plume.Lookup.old_get_entry","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the next entry.  If no more entries are available, returns null.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to read the entry from'}]}', name=Optional[reader]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next entry, or null'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"","methodType":"Entry","literalExprs":[{"literalExprRange":"(line 436,col 23)-(line 436,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 436,col 57)-(line 436,col 57)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 439,col 19)-(line 439,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 440,col 17)-(line 440,col 20)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 443,col 21)-(line 443,col 24)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 448,col 27)-(line 448,col 34)","literalExprId":6,"literalExpr":"\">entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 454,col 34)-(line 454,col 44)","literalExprId":7,"literalExpr":"\"^>entry *\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 454,col 47)-(line 454,col 48)","literalExprId":8,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 459,col 25)-(line 459,col 28)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 460,col 33)-(line 460,col 40)","literalExprId":10,"literalExpr":"\">entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 461,col 29)-(line 461,col 36)","literalExprId":11,"literalExpr":"\"<entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 470,col 22)-(line 470,col 25)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 471,col 33)-(line 471,col 40)","literalExprId":13,"literalExpr":"\">entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 475,col 79)-(line 475,col 83)","literalExprId":14,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 483,col 25)-(line 483,col 28)","literalExprId":15,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 483,col 59)-(line 483,col 59)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 489,col 79)-(line 489,col 82)","literalExprId":17,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 496,col 11)-(line 496,col 56)","literalExprId":18,"literalExpr":"\"Error: Can't read %s at line %d in file %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 500,col 19)-(line 500,col 21)","literalExprId":19,"literalExpr":"254","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 501,col 15)-(line 501,col 18)","literalExprId":20,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Lookup.old_get_entry(plume.EntryReader)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the entry whose first line to return","javadocBlockTagName":"entry","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the entry whose first line to return'}]}', name=Optional[entry]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the first line of entry","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the first line of entry'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String first_line(String entry)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n        return entry;\n    }\n    return entry.substring(0, ii);\n}","methodRange":"(line 509,col 3)-(line 516,col 3)","methodTokenRange":"public static String first_line(String entry) {\n\n    int ii = entry.indexOf(lineSep);\n    if (ii == -1) {\n      return entry;\n    }\n    return entry.substring(0, ii);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns the first line of entry.\n   * @param entry the entry whose first line to return\n   * @return the first line of entry\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String entry","parameterName":"entry"}],"methodName":"first_line","methodQualifiedSignature":"plume.Lookup.first_line","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the first line of entry.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the entry whose first line to return'}]}', name=Optional[entry]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the first line of entry'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 512,col 16)-(line 512,col 16)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 515,col 28)-(line 515,col 28)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Lookup.first_line(java.lang.String)"}],"classJavadoc":"\/**\n * Lookup searches a set of files, much like <code>grep<\/code> does.  However,\n * Lookup searches by entry (by default, paragraphs) rather than by line,\n * respects comments (ignores matches within them), respects\n * <code>\\include<\/code> directives (searches the named file), and has other\n * features. <p>\n *\n * Each search criterion is a keyword or regular expression.  Lookup\n * outputs each <em>entry<\/em> that matches all the search criteria. <p>\n *\n * By default, search criteria are treated as keywords, and each paragraph\n * is treated as an entry &mdash; in other words, Lookup prints each\n * paragraph (in any of the files) that contains all the keywords,\n * essentially performing paragraph-wise grep. <p>\n *\n * A file can contain one or more entries, each of which is a short entry\n * or a long entry.\n * <ul>\n *   <li>A short entry is a single paragraph (delimited from the next entry\n *       by a blank line).  Lookup searches all of a short entry.<\/li>\n *   <li>A long entry is introduced by a line that begins with '&gt;entry'.  The\n *       remainder of that line is a one-line description of the entry.  A\n *       long entry is terminated by '&lt;entry', by the start of a new long\n *       entry, or by the start of a new file.  Lookup searches only the first\n *       line of a long entry.<\/li>\n * <\/ul>\n *\n * If multiple entries match, the first line of each is printed.  If only\n * one entry matches, then that entry is printed in its entirety. <p>\n *\n * By default, Lookup searches the file ~\/lookup\/root.  Files can\n * contain comments and can include other files.  Comments start with\n * a % sign in the first column.  Any comment line is ignored (it is\n * not treated as a blank line for the purpose of separating entries).\n * A file can include another file via a line of the form\n * '\\include{filename}'. <p>\n *\n * The default behavior can be customized by way of command-line options. <p>\n *\n * The <a name=\"command-line-options\">command-line options<\/a> are as follows:\n * <!-- start options doc (DO NOT EDIT BY HAND) -->\n * <ul>\n *   <li id=\"optiongroup:Getting-help\">Getting help\n *     <ul>\n *       <li id=\"option:help\"><b>-h<\/b> <b>--help=<\/b><i>boolean<\/i>.\n *        Show detailed help information and exit. [default false]<\/li>\n *       <li id=\"option:verbose\"><b>-v<\/b> <b>--verbose=<\/b><i>boolean<\/i>.\n *        Print progress information [default false]<\/li>\n *     <\/ul>\n *   <\/li>\n *   <li id=\"optiongroup:Where-to-search\">Where to search\n *     <ul>\n *       <li id=\"option:entry-file\"><b>-f<\/b> <b>--entry-file=<\/b><i>string<\/i>.\n *        Specify the colon-separated search list for the file that contains\n *  information to be searched.  Only the first file found is used, though\n *  it may itself contain include directives. [default ~\/lookup\/root]<\/li>\n *       <li id=\"option:search-body\"><b>-b<\/b> <b>--search-body=<\/b><i>boolean<\/i>.\n *        Search the body of long entries in addition to the entry's\n *  description.  The bodies of short entries are always searched. [default false]<\/li>\n *     <\/ul>\n *   <\/li>\n *   <li id=\"optiongroup:What-to-search-for\">What to search for\n *     <ul>\n *       <li id=\"option:regular-expressions\"><b>-e<\/b> <b>--regular-expressions=<\/b><i>boolean<\/i>.\n *        Specifies that keywords are regular expressions.  If false, keywords\n *  are text matches. [default false]<\/li>\n *       <li id=\"option:case-sensitive\"><b>-c<\/b> <b>--case-sensitive=<\/b><i>boolean<\/i>.\n *        If true, keywords matching is case sensistive.  By default, both\n *  regular expressions and text keywords are case-insensitive. [default false]<\/li>\n *       <li id=\"option:word-match\"><b>-w<\/b> <b>--word-match=<\/b><i>boolean<\/i>.\n *        If true, match a text keyword only as a separate word, not as a\n *  substring of a word.  This option is ignored if\n *  regular_expressions is true. [default false]<\/li>\n *     <\/ul>\n *   <\/li>\n *   <li id=\"optiongroup:How-to-print-matches\">How to print matches\n *     <ul>\n *       <li id=\"option:print-all\"><b>-a<\/b> <b>--print-all=<\/b><i>boolean<\/i>.\n *        By default, if multiple entries are matched, only a synopsis\n *  of each entry is printed.  If 'print_all' is selected then\n *  the body of each matching entry is printed. [default false]<\/li>\n *       <li id=\"option:item-num\"><b>-i<\/b> <b>--item-num=<\/b><i>integer<\/i>.\n *        Specifies which item to print when there are multiple matches.\n *  The index is 1-based; that is, it starts counting at 1.<\/li>\n *       <li id=\"option:show-location\"><b>-l<\/b> <b>--show-location=<\/b><i>boolean<\/i>.\n *        If true, show the filename\/line number of each matching entry\n *  in the output. [default false]<\/li>\n *     <\/ul>\n *   <\/li>\n *   <li id=\"optiongroup:Customizing-format-of-files-to-be-searched\">Customizing format of files to be searched\n *     <ul>\n *       <li id=\"option:entry-start-re\"><b>--entry-start-re=<\/b><i>regex<\/i>.\n *        Regex that denotes the start of a long entry [default ^&gt;entry *()]<\/li>\n *       <li id=\"option:entry-stop-re\"><b>--entry-stop-re=<\/b><i>regex<\/i>.\n *        Regex that denotes the end of a long entry [default ^&lt;entry]<\/li>\n *       <li id=\"option:description-re\"><b>--description-re=<\/b><i>regex<\/i>.\n *        Regex that finds an entry's description (for long entries)<\/li>\n *       <li id=\"option:comment-re\"><b>--comment-re=<\/b><i>string<\/i>.\n *        Regex that matches an entire comment (not just a comment start) [default ^%.*]<\/li>\n *       <li id=\"option:include-re\"><b>--include-re=<\/b><i>string<\/i>.\n *        Regex that matches an include directive; group 1 is the file name [default \\\\include\\{(.*)\\}]<\/li>\n *     <\/ul>\n *   <\/li>\n * <\/ul>\n * <!-- end options doc -->\n *\/\n","className":"Lookup","fields":[{"fieldRange":"(line 133,col 3)-(line 135,col 37)","fieldName":"help","fieldJavadocComment":" Show detailed help information and exit. ","fieldTokenRange":"@OptionGroup(\"Getting help\")\n  @Option(\"-h Show detailed help information\")\n  public static boolean help = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 133,col 16)-(line 133,col 29)","literalExprId":1,"literalExpr":"\"Getting help\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 134,col 11)-(line 134,col 45)","literalExprId":2,"literalExpr":"\"-h Show detailed help information\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 135,col 32)-(line 135,col 36)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"Show detailed help information and exit.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 137,col 3)-(line 138,col 40)","fieldName":"verbose","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-v Print progress information\")\n  public static boolean verbose = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 137,col 11)-(line 137,col 41)","literalExprId":1,"literalExpr":"\"-v Print progress information\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 138,col 35)-(line 138,col 39)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 150,col 3)-(line 153,col 52)","fieldName":"entry_file","fieldJavadocComment":"\n   * Specify the colon-separated search list for the file that contains\n   * information to be searched.  Only the first file found is used, though\n   * it may itself contain include directives.\n   ","fieldTokenRange":"@OptionGroup(\"Where to search\")\n  @Option(\n      \"-f Specify the colon-separated search list of files of information; may only be supplied once\")\n  public static String entry_file = \"~\/lookup\/root\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 150,col 16)-(line 150,col 32)","literalExprId":1,"literalExpr":"\"Where to search\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 152,col 7)-(line 152,col 101)","literalExprId":2,"literalExpr":"\"-f Specify the colon-separated search list of files of information; may only be supplied once\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 153,col 37)-(line 153,col 51)","literalExprId":3,"literalExpr":"\"~\/lookup\/root\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"~\/lookup\/root\"]","fieldType":"String","fieldJavadoc":"Specify the colon-separated search list for the file that contains\ninformation to be searched.  Only the first file found is used, though\nit may itself contain include directives.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 159,col 3)-(line 160,col 44)","fieldName":"search_body","fieldJavadocComment":"\n   * Search the body of long entries in addition to the entry's\n   * description.  The bodies of short entries are always searched.\n   ","fieldTokenRange":"@Option(\"-b Search body of long entries for matches\")\n  public static boolean search_body = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 159,col 11)-(line 159,col 54)","literalExprId":1,"literalExpr":"\"-b Search body of long entries for matches\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 160,col 39)-(line 160,col 43)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"Search the body of long entries in addition to the entry's\ndescription.  The bodies of short entries are always searched.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 166,col 3)-(line 168,col 52)","fieldName":"regular_expressions","fieldJavadocComment":"\n   * Specifies that keywords are regular expressions.  If false, keywords\n   * are text matches.\n   ","fieldTokenRange":"@OptionGroup(\"What to search for\")\n  @Option(\"-e Keywords are regular expressions\")\n  public static boolean regular_expressions = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 166,col 16)-(line 166,col 35)","literalExprId":1,"literalExpr":"\"What to search for\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 167,col 11)-(line 167,col 47)","literalExprId":2,"literalExpr":"\"-e Keywords are regular expressions\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 168,col 47)-(line 168,col 51)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"Specifies that keywords are regular expressions.  If false, keywords\nare text matches.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 174,col 3)-(line 175,col 47)","fieldName":"case_sensitive","fieldJavadocComment":"\n   * If true, keywords matching is case sensistive.  By default, both\n   * regular expressions and text keywords are case-insensitive.\n   ","fieldTokenRange":"@Option(\"-c Keywords are case sensistive\")\n  public static boolean case_sensitive = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 174,col 11)-(line 174,col 43)","literalExprId":1,"literalExpr":"\"-c Keywords are case sensistive\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 175,col 42)-(line 175,col 46)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"If true, keywords matching is case sensistive.  By default, both\nregular expressions and text keywords are case-insensitive.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 182,col 3)-(line 183,col 43)","fieldName":"word_match","fieldJavadocComment":"\n   * If true, match a text keyword only as a separate word, not as a\n   * substring of a word.  This option is ignored if\n   * regular_expressions is true.\n   ","fieldTokenRange":"@Option(\"-w Only match text keywords against complete words\")\n  public static boolean word_match = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 182,col 11)-(line 182,col 62)","literalExprId":1,"literalExpr":"\"-w Only match text keywords against complete words\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 183,col 38)-(line 183,col 42)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"If true, match a text keyword only as a separate word, not as a\nsubstring of a word.  This option is ignored if\nregular_expressions is true.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 190,col 3)-(line 192,col 42)","fieldName":"print_all","fieldJavadocComment":"\n   * By default, if multiple entries are matched, only a synopsis\n   * of each entry is printed.  If 'print_all' is selected then\n   * the body of each matching entry is printed.\n   ","fieldTokenRange":"@OptionGroup(\"How to print matches\")\n  @Option(\"-a Print the entire entry for each match\")\n  public static boolean print_all = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 190,col 16)-(line 190,col 37)","literalExprId":1,"literalExpr":"\"How to print matches\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 191,col 11)-(line 191,col 52)","literalExprId":2,"literalExpr":"\"-a Print the entire entry for each match\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 192,col 37)-(line 192,col 41)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"By default, if multiple entries are matched, only a synopsis\nof each entry is printed.  If 'print_all' is selected then\nthe body of each matching entry is printed.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 198,col 3)-(line 199,col 47)","fieldName":"item_num","fieldJavadocComment":"\n   * Specifies which item to print when there are multiple matches.\n   * The index is 1-based; that is, it starts counting at 1.\n   ","fieldTokenRange":"@Option(\"-i Choose a specific item when there are multiple matches; index is 1-based\")\n  public static \/*@Nullable*\/ Integer item_num;","fieldTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 198,col 11)-(line 198,col 87)","literalExprId":1,"literalExpr":"\"-i Choose a specific item when there are multiple matches; index is 1-based\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"","fieldType":"Integer","fieldJavadoc":"Specifies which item to print when there are multiple matches.\nThe index is 1-based; that is, it starts counting at 1.\n","fieldTypeResolvedDescribed":"java.lang.Integer"},{"fieldRange":"(line 205,col 3)-(line 206,col 46)","fieldName":"show_location","fieldJavadocComment":"\n   * If true, show the filename\/line number of each matching entry\n   * in the output.\n   ","fieldTokenRange":"@Option(\"-l Show the location of each matching entry\")\n  public static boolean show_location = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 205,col 11)-(line 205,col 55)","literalExprId":1,"literalExpr":"\"-l Show the location of each matching entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 206,col 41)-(line 206,col 45)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"If true, show the filename\/line number of each matching entry\nin the output.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 208,col 3)-(line 210,col 86)","fieldName":"entry_start_re","fieldJavadocComment":"","fieldTokenRange":"@OptionGroup(\"Customizing format of files to be searched\")\n  @Option(\"Regex that denotes the start of a long entry\")\n  public static \/*@Regex(1)*\/ Pattern entry_start_re = Pattern.compile(\"^>entry *()\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 208,col 16)-(line 208,col 59)","literalExprId":1,"literalExpr":"\"Customizing format of files to be searched\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 11)-(line 209,col 56)","literalExprId":2,"literalExpr":"\"Regex that denotes the start of a long entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 210,col 72)-(line 210,col 84)","literalExprId":3,"literalExpr":"\"^>entry *()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"^>entry *()\")]","fieldType":"Pattern","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 212,col 3)-(line 213,col 67)","fieldName":"entry_stop_re","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Regex that denotes the end of a long entry\")\n  public static Pattern entry_stop_re = Pattern.compile(\"^<entry\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 212,col 11)-(line 212,col 54)","literalExprId":1,"literalExpr":"\"Regex that denotes the end of a long entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 213,col 57)-(line 213,col 65)","literalExprId":2,"literalExpr":"\"^<entry\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"^<entry\")]","fieldType":"Pattern","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 215,col 3)-(line 216,col 60)","fieldName":"description_re","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Regex that finds an entry's description (for long entries)\")\n  public static \/*@Nullable*\/ Pattern description_re = null;","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 215,col 11)-(line 215,col 70)","literalExprId":1,"literalExpr":"\"Regex that finds an entry's description (for long entries)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 216,col 56)-(line 216,col 59)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Pattern","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 219,col 3)-(line 220,col 68)","fieldName":"comment_re","fieldJavadocComment":" If \"\", gets set to null immediately after option processing.","fieldTokenRange":"@Option(\"Regex that matches an entire comment (not just a comment start)\")\n  public static \/*@Nullable*\/ \/*@Regex*\/ String comment_re = \"^%.*\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 219,col 11)-(line 219,col 75)","literalExprId":1,"literalExpr":"\"Regex that matches an entire comment (not just a comment start)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 220,col 62)-(line 220,col 67)","literalExprId":2,"literalExpr":"\"^%.*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"^%.*\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 222,col 3)-(line 223,col 74)","fieldName":"include_re","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Regex that matches an include directive; group 1 is the file name\")\n  public static \/*@Regex(1)*\/ String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 222,col 11)-(line 222,col 77)","literalExprId":1,"literalExpr":"\"Regex that matches an include directive; group 1 is the file name\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 223,col 51)-(line 223,col 73)","literalExprId":2,"literalExpr":"\"\\\\\\\\include\\\\{(.*)\\\\}\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"\\\\\\\\include\\\\{(.*)\\\\}\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 226,col 3)-(line 226,col 77)","fieldName":"lineSep","fieldJavadocComment":" Platform-specific line separator. ","fieldTokenRange":"private static final String lineSep = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 226,col 60)-(line 226,col 75)","literalExprId":1,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"Platform-specific line separator.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 229,col 3)-(line 229,col 72)","fieldName":"usage_string","fieldJavadocComment":" One line synopsis of usage. ","fieldTokenRange":"private static String usage_string = \"lookup [options] <keyword> ...\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 229,col 40)-(line 229,col 71)","literalExprId":1,"literalExpr":"\"lookup [options] <keyword> ...\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"lookup [options] <keyword> ...\"]","fieldType":"String","fieldJavadoc":"One line synopsis of usage.\n","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":11,"packageName":"plume"},{"sourceFileName":"plume.Pair","imports":[],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first element of the pair","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first element of the pair'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second element of the pair","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second element of the pair'}]}', name=Optional[b]}"}],"constructorQualifiedSignature":"plume.Pair.Pair(T1, T2)","variableDeclarationExprs":[],"constructorRange":"(line 25,col 3)-(line 28,col 3)","constructorJavadocComment":" Make a new pair.\n   * @param a the first element of the pair\n   * @param b the second element of the pair\n   ","constructorDeclaration":"public Pair(T1 a, T2 b)","constructorBody":"{\n    this.a = a;\n    this.b = b;\n}","constructorName":"Pair","constructorQualifiedName":"plume.Pair.Pair","constructorParameters":[{"parameterType":"T1","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T1, bounds=[Object])}","parameterTypeResolvedDescribed":"T1","parameter":"T1 a","parameterName":"a"},{"parameterType":"T2","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T2, bounds=[Object])}","parameterTypeResolvedDescribed":"T2","parameter":"T2 b","parameterName":"b"}],"literalExprs":[],"constructorTokenRange":"public Pair(T1 a, T2 b) {\n    this.a = a;\n    this.b = b;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Make a new pair.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first element of the pair'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second element of the pair'}]}', name=Optional[b]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of first argument","javadocBlockTagName":"<A>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of first argument'}]}', name=Optional[<A>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of second argument","javadocBlockTagName":"<B>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of second argument'}]}', name=Optional[<B>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"first argument","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first argument'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second argument","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second argument'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a pair of the values (a, b)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a pair of the values (a, b)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Pair<A, B> of(A a, B b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new Pair<A, B>(a, b);\n}","methodRange":"(line 37,col 3)-(line 40,col 3)","methodTokenRange":"public static <A extends \/*@Nullable*\/ Object, B extends \/*@Nullable*\/ Object> Pair<A, B> of(\n      A a, B b) {\n    return new Pair<A, B>(a, b);\n  }","methodReturnTypeResolved":"ReferenceType{plume.Pair, typeParametersMap=TypeParametersMap{nameToValue={plume.Pair.T1=TypeVariable {JPTypeParameter(A, bounds=[Object])}, plume.Pair.T2=TypeVariable {JPTypeParameter(B, bounds=[Object])}}}}","methodJavadocComment":" Factory method with short name and no need to name type parameters.\n   * @param <A> type of first argument\n   * @param <B> type of second argument\n   * @param a first argument\n   * @param b second argument\n   * @return a pair of the values (a, b)\n   ","methodParameters":[{"parameterType":"A","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(A, bounds=[Object])}","parameterTypeResolvedDescribed":"A","parameter":"A a","parameterName":"a"},{"parameterType":"B","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[Object])}","parameterTypeResolvedDescribed":"B","parameter":"B b","parameterName":"b"}],"methodName":"of","methodQualifiedSignature":"plume.Pair.of","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Factory method with short name and no need to name type parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of first argument'}]}', name=Optional[<A>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of second argument'}]}', name=Optional[<B>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first argument'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second argument'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a pair of the values (a, b)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.Pair<A, B>","methodType":"Pair<A, B>","literalExprs":[],"methodQualifiedName":"plume.Pair.of(A, B)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return \"<\" + String.valueOf(a) + \",\" + String.valueOf(b) + \">\";\n}","methodRange":"(line 42,col 3)-(line 46,col 3)","methodTokenRange":"@Override\n  \/*@SideEffectFree*\/\n  public String toString(\/*>>>@GuardSatisfied Pair<T1,T2> this*\/) {\n    return \"<\" + String.valueOf(a) + \",\" + String.valueOf(b) + \">\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.Pair.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 45,col 12)-(line 45,col 14)","literalExprId":1,"literalExpr":"\"<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 45,col 38)-(line 45,col 40)","literalExprId":2,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 45,col 64)-(line 45,col 66)","literalExprId":3,"literalExpr":"\">\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Pair.toString()"},{"methodDeclaration":"public boolean equals(Object obj)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!(obj instanceof Pair<?, ?>)) {\n        return false;\n    }\n    @SuppressWarnings(\"unchecked\")\n    Pair<T1, T2> other = (Pair<T1, T2>) obj;\n    return (((this.a == other.a) || (this.a != null && (this.a.equals(other.a)))) && ((this.b == other.b) || (this.b != null && (this.b.equals(other.b)))));\n}","methodRange":"(line 48,col 3)-(line 62,col 3)","methodTokenRange":"@Override\n  @SuppressWarnings(\"interning\") \/\/ equality testing optimization\n  \/*@Pure*\/\n  public boolean equals(\n      \/*>>>@GuardSatisfied Pair<T1,T2> this,*\/\n      \/*@GuardSatisfied*\/ \/*@Nullable*\/ Object obj) {\n    if (!(obj instanceof Pair<?, ?>)) {\n      return false;\n    }\n    \/\/ generics are not checked at run time!\n    @SuppressWarnings(\"unchecked\")\n    Pair<T1, T2> other = (Pair<T1, T2>) obj;\n    return (((this.a == other.a) || (this.a != null && (this.a.equals(other.a))))\n        && ((this.b == other.b) || (this.b != null && (this.b.equals(other.b)))));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"equals","methodQualifiedSignature":"plume.Pair.equals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 49,col 21)-(line 49,col 31)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 55,col 14)-(line 55,col 18)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 58,col 23)-(line 58,col 33)","literalExprId":3,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 60,col 48)-(line 60,col 51)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 61,col 47)-(line 61,col 50)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Pair.equals(java.lang.Object)"},{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (((a == null) ? 0 : a.hashCode()) + ((b == null) ? 0 : b.hashCode()));\n}","methodRange":"(line 67,col 3)-(line 71,col 3)","methodTokenRange":"@Override\n  \/*@Pure*\/\n  public int hashCode(\/*>>>@GuardSatisfied Pair<T1,T2> this*\/) {\n    return (((a == null) ? 0 : a.hashCode()) + ((b == null) ? 0 : b.hashCode()));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" But then the class would not be useful for mutable pairs.","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"plume.Pair.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 70,col 20)-(line 70,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 70,col 28)-(line 70,col 28)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 70,col 55)-(line 70,col 58)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 70,col 63)-(line 70,col 63)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Pair.hashCode()"}],"classJavadoc":"\/**\n * Mutable pair class:\n * type-safely holds two objects of possibly-different types.\n * @param <T1> the type of the first element of the pair\n * @param <T2> the type of the second element of the pair\n *\/\n","className":"Pair","fields":[{"fieldRange":"(line 17,col 3)-(line 17,col 14)","fieldName":"a","fieldJavadocComment":" The first element of the pair. ","fieldTokenRange":"public T1 a;","fieldTypeResolved":"TypeVariable {JPTypeParameter(T1, bounds=[\/*@Nullable*\/\nObject])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"T1","fieldJavadoc":"The first element of the pair.\n","fieldTypeResolvedDescribed":"T1"},{"fieldRange":"(line 19,col 3)-(line 19,col 14)","fieldName":"b","fieldJavadocComment":" The second element of the pair. ","fieldTokenRange":"public T2 b;","fieldTypeResolved":"TypeVariable {JPTypeParameter(T2, bounds=[\/*@Nullable*\/\nObject])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"T2","fieldJavadoc":"The second element of the pair.\n","fieldTypeResolvedDescribed":"T2"}]}],"sourceFileId":12,"packageName":"plume"},{"sourceFileName":"plume.FileCompiler","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.IOException;\n"},{"importId":3,"import":"import java.util.ArrayList;\n"},{"importId":4,"import":"import java.util.HashSet;\n"},{"importId":5,"import":"import java.util.List;\n"},{"importId":6,"import":"import java.util.regex.Matcher;\n"},{"importId":7,"import":"import java.util.regex.Pattern;\n"},{"importId":8,"import":"import java.util.regex.PatternSyntaxException;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"#FileCompiler(String, long)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#FileCompiler(String, long)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.FileCompiler.FileCompiler()","variableDeclarationExprs":[],"constructorRange":"(line 65,col 3)-(line 67,col 3)","constructorJavadocComment":"\n   * Creates a new FileCompiler.  Equivalent to FileCompiler(\"javac\", 6000).\n   * @see #FileCompiler(String, long)\n   ","constructorDeclaration":"public FileCompiler()","constructorBody":"{\n    this(\"javac\", 6000);\n}","constructorName":"FileCompiler","constructorQualifiedName":"plume.FileCompiler.FileCompiler","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 66,col 10)-(line 66,col 16)","literalExprId":1,"literalExpr":"\"javac\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 66,col 19)-(line 66,col 22)","literalExprId":2,"literalExpr":"6000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FileCompiler() {\n    this(\"javac\", 6000);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new FileCompiler.  Equivalent to FileCompiler(\"javac\", 6000).'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#FileCompiler(String, long)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.","javadocBlockTagName":"compiler","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.'}]}', name=Optional[compiler]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum permitted compilation time, in msec","javadocBlockTagName":"timeLimit","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum permitted compilation time, in msec'}]}', name=Optional[timeLimit]}"}],"constructorQualifiedSignature":"plume.FileCompiler.FileCompiler(java.lang.String[], long)","variableDeclarationExprs":[],"constructorRange":"(line 78,col 3)-(line 85,col 3)","constructorJavadocComment":"\n   * Creates a new FileCompiler.\n   * Compared to {@link #FileCompiler(String,long)}, this constructor permits\n   * spaces and other special characters in the command and arguments.\n   * @param compiler an array of Strings representing a command that runs a\n   * Java compiler (it could be the full path name or whatever is used on\n   * the commandline), plus any command-line options.\n   * @param timeLimit the maximum permitted compilation time, in msec\n   ","constructorDeclaration":"public FileCompiler(String[] compiler, long timeLimit)","constructorBody":"{\n    if (compiler.length == 0) {\n        throw new Error(\"no compile command was provided\");\n    }\n    this.compiler = compiler;\n    this.timeLimit = timeLimit;\n}","constructorName":"FileCompiler","constructorQualifiedName":"plume.FileCompiler.FileCompiler","constructorParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] compiler","parameterName":"compiler"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long timeLimit","parameterName":"timeLimit"}],"literalExprs":[{"literalExprRange":"(line 79,col 28)-(line 79,col 28)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 80,col 23)-(line 80,col 55)","literalExprId":2,"literalExpr":"\"no compile command was provided\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public FileCompiler(String[] compiler, long timeLimit) {\n    if (compiler.length == 0) {\n      throw new Error(\"no compile command was provided\");\n    }\n\n    this.compiler = compiler;\n    this.timeLimit = timeLimit;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new FileCompiler.\nCompared to '}, JavadocInlineTag{tagName='link', type=LINK, content=' #FileCompiler(String,long)'}, JavadocSnippet{text=', this constructor permits\nspaces and other special characters in the command and arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.'}]}', name=Optional[compiler]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum permitted compilation time, in msec'}]}', name=Optional[timeLimit]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.","javadocBlockTagName":"compiler","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.'}]}', name=Optional[compiler]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum permitted compilation time, in msec","javadocBlockTagName":"timeLimit","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum permitted compilation time, in msec'}]}', name=Optional[timeLimit]}"}],"constructorQualifiedSignature":"plume.FileCompiler.FileCompiler(java.util.ArrayList<java.lang.String>, long)","variableDeclarationExprs":[],"constructorRange":"(line 96,col 3)-(line 98,col 3)","constructorJavadocComment":"\n   * Creates a new FileCompiler.\n   * Compared to {@link #FileCompiler(String,long)}, this constructor permits\n   * spaces and other special characters in the command and arguments.\n   * @param compiler a list of Strings representing a command that runs a\n   * Java compiler (it could be the full path name or whatever is used on\n   * the commandline), plus any command-line options.\n   * @param timeLimit the maximum permitted compilation time, in msec\n   ","constructorDeclaration":"public FileCompiler(ArrayList<String> compiler, long timeLimit)","constructorBody":"{\n    this(compiler.toArray(new String[0]), timeLimit);\n}","constructorName":"FileCompiler","constructorQualifiedName":"plume.FileCompiler.FileCompiler","constructorParameters":[{"parameterType":"ArrayList<String>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.ArrayList<java.lang.String>","parameter":"ArrayList<String> compiler","parameterName":"compiler"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long timeLimit","parameterName":"timeLimit"}],"literalExprs":[{"literalExprRange":"(line 97,col 38)-(line 97,col 38)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public FileCompiler(ArrayList<String> compiler, long timeLimit) {\n    this(compiler.toArray(new String[0]), timeLimit);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new FileCompiler.\nCompared to '}, JavadocInlineTag{tagName='link', type=LINK, content=' #FileCompiler(String,long)'}, JavadocSnippet{text=', this constructor permits\nspaces and other special characters in the command and arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list of Strings representing a command that runs a\nJava compiler (it could be the full path name or whatever is used on\nthe commandline), plus any command-line options.'}]}', name=Optional[compiler]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum permitted compilation time, in msec'}]}', name=Optional[timeLimit]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a command that runs a Java compiler; for instance, it\ncould be the full path name or whatever is used on the commandline.\nIt may contain command-line arguments, and is split on spaces.","javadocBlockTagName":"compiler","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a command that runs a Java compiler; for instance, it\ncould be the full path name or whatever is used on the commandline.\nIt may contain command-line arguments, and is split on spaces.'}]}', name=Optional[compiler]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum permitted compilation time, in msec","javadocBlockTagName":"timeLimit","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum permitted compilation time, in msec'}]}', name=Optional[timeLimit]}"}],"constructorQualifiedSignature":"plume.FileCompiler.FileCompiler(java.lang.String, long)","variableDeclarationExprs":[],"constructorRange":"(line 107,col 3)-(line 109,col 3)","constructorJavadocComment":"\n   * Creates a new FileCompiler.\n   * @param compiler a command that runs a Java compiler; for instance, it\n   * could be the full path name or whatever is used on the commandline.\n   * It may contain command-line arguments, and is split on spaces.\n   * @param timeLimit the maximum permitted compilation time, in msec\n   ","constructorDeclaration":"public FileCompiler(String compiler, long timeLimit)","constructorBody":"{\n    this(compiler.trim().split(\" +\"), timeLimit);\n}","constructorName":"FileCompiler","constructorQualifiedName":"plume.FileCompiler.FileCompiler","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String compiler","parameterName":"compiler"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long timeLimit","parameterName":"timeLimit"}],"literalExprs":[{"literalExprRange":"(line 108,col 32)-(line 108,col 35)","literalExprId":1,"literalExpr":"\" +\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public FileCompiler(String compiler, long timeLimit) {\n    this(compiler.trim().split(\" +\"), timeLimit);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new FileCompiler.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a command that runs a Java compiler; for instance, it\ncould be the full path name or whatever is used on the commandline.\nIt may contain command-line arguments, and is split on spaces.'}]}', name=Optional[compiler]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum permitted compilation time, in msec'}]}', name=Optional[timeLimit]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the error output from compiling the files","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the error output from compiling the files'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"paths to the files to be compiled as Strings","javadocBlockTagName":"fileNames","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths to the files to be compiled as Strings'}]}', name=Optional[fileNames]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading a file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public String compileFiles(List<String> fileNames) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TimeLimitProcess p = compile_source(fileNames);\n    String compile_errors = \"\";\n    String compile_output = \"\";\n    try {\n        int result = p.waitFor();\n    } catch (Throwable e) {\n        compile_errors = UtilMDE.streamString(p.getErrorStream());\n        compile_output = UtilMDE.streamString(p.getInputStream());\n        System.out.println(\"Unexpected exception while compiling \" + e);\n        if (p.timed_out()) {\n            System.out.println(\"Compile timed out after \" + p.timeout_msecs() + \" msecs\");\n        }\n        e.printStackTrace();\n        runtime.exit(1);\n    }\n    compile_errors = UtilMDE.streamString(p.getErrorStream());\n    compile_output = UtilMDE.streamString(p.getInputStream());\n    if (compiler[0].indexOf(\"javac\") != -1) {\n        recompile_without_errors(fileNames, compile_errors);\n    }\n    return compile_errors;\n}","methodRange":"(line 118,col 3)-(line 157,col 3)","methodTokenRange":"public String compileFiles(List<String> fileNames) throws IOException {\n\n    \/\/ System.out.printf (\"compileFiles: %s%n\", fileNames);\n\n    \/\/ Start a process to compile all of the files (in one command)\n    TimeLimitProcess p = compile_source(fileNames);\n\n    String compile_errors = \"\";\n    String compile_output = \"\";\n\n    try {\n      int result = p.waitFor();\n    } catch (Throwable e) {\n      \/\/ Print stderr and stdout if there is an unexpected exception (timeout).\n      compile_errors = UtilMDE.streamString(p.getErrorStream());\n      compile_output = UtilMDE.streamString(p.getInputStream());\n      System.out.println(\"Unexpected exception while compiling \" + e);\n      if (p.timed_out()) {\n        System.out.println(\"Compile timed out after \" + p.timeout_msecs() + \" msecs\");\n      }\n      \/\/ System.out.println (\"Compile errors: \" + compile_errors);\n      \/\/ System.out.println (\"Compile output: \" + compile_output);\n      e.printStackTrace();\n      runtime.exit(1);\n    }\n\n    compile_errors = UtilMDE.streamString(p.getErrorStream());\n    compile_output = UtilMDE.streamString(p.getInputStream());\n    \/\/ System.out.println (\"Compile errors: \" + compile_errors);\n    \/\/ System.out.println (\"Compile output: \" + compile_output);\n\n    \/\/ javac tends to stop without completing the compilation if there\n    \/\/ is an error in one of the files.  Remove all the erring files\n    \/\/ and recompile only the good ones.\n    if (compiler[0].indexOf(\"javac\") != -1) {\n      recompile_without_errors(fileNames, compile_errors);\n    }\n\n    return compile_errors;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Compiles the files given by fileNames.\n   * Return the error output.\n   * @return the error output from compiling the files\n   * @param fileNames paths to the files to be compiled as Strings\n   * @throws IOException if there is a problem reading a file\n   ","methodParameters":[{"parameterType":"List<String>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.String>","parameter":"List<String> fileNames","parameterName":"fileNames"}],"methodName":"compileFiles","methodQualifiedSignature":"plume.FileCompiler.compileFiles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compiles the files given by fileNames.\nReturn the error output.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the error output from compiling the files'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='paths to the files to be compiled as Strings'}]}', name=Optional[fileNames]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 125,col 29)-(line 125,col 30)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 126,col 29)-(line 126,col 30)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 134,col 26)-(line 134,col 64)","literalExprId":3,"literalExpr":"\"Unexpected exception while compiling \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 136,col 28)-(line 136,col 53)","literalExprId":4,"literalExpr":"\"Compile timed out after \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 136,col 77)-(line 136,col 84)","literalExprId":5,"literalExpr":"\" msecs\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 141,col 20)-(line 141,col 20)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 18)-(line 152,col 18)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 29)-(line 152,col 35)","literalExprId":8,"literalExpr":"\"javac\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 152,col 42)-(line 152,col 42)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.FileCompiler.compileFiles(java.util.List<java.lang.String>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the paths of the Java source to be compiled as Strings","javadocBlockTagName":"filenames","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the paths of the Java source to be compiled as Strings'}]}', name=Optional[filenames]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the process that executed the external compile command","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the process that executed the external compile command'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if an empty list of filenames is provided.","javadocBlockTagName":"Error","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an empty list of filenames is provided.'}]}', name=Optional[Error]}"}],"methodDeclaration":"private TimeLimitProcess compile_source(List<String> filenames) throws IOException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int num_files = filenames.size();\n    if (num_files == 0) {\n        throw new Error(\"no files to compile were provided\");\n    }\n    String[] command = new String[num_files + compiler.length];\n    System.arraycopy(compiler, 0, command, 0, compiler.length);\n    for (int i = 0; i < num_files; i++) {\n        command[i + compiler.length] = filenames.get(i);\n    }\n    return new TimeLimitProcess(runtime.exec(command), timeLimit, true);\n}","methodRange":"(line 173,col 3)-(line 188,col 3)","methodTokenRange":"private TimeLimitProcess compile_source(List<String> filenames) throws IOException {\n    int num_files = filenames.size();\n\n    if (num_files == 0) {\n      throw new Error(\"no files to compile were provided\");\n    }\n\n    String[] command = new String[num_files + compiler.length];\n    System.arraycopy(compiler, 0, command, 0, compiler.length);\n    for (int i = 0; i < num_files; i++) {\n      command[i + compiler.length] = filenames.get(i);\n    }\n\n    \/\/ System.out.println (\"\\nexecuting compile command: \" + command);\n    return new TimeLimitProcess(runtime.exec(command), timeLimit, true);\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * @param filenames the paths of the Java source to be compiled as Strings\n   * @return the process that executed the external compile command\n   * @throws Error if an empty list of filenames is provided.\n   ","methodParameters":[{"parameterType":"List<String>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.String>","parameter":"List<String> filenames","parameterName":"filenames"}],"methodName":"compile_source","methodQualifiedSignature":"plume.FileCompiler.compile_source","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the paths of the Java source to be compiled as Strings'}]}', name=Optional[filenames]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the process that executed the external compile command'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if an empty list of filenames is provided.'}]}', name=Optional[Error]}]}","methodReturnTypeDescribed":"","methodType":"TimeLimitProcess","literalExprs":[{"literalExprRange":"(line 176,col 22)-(line 176,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 177,col 23)-(line 177,col 57)","literalExprId":2,"literalExpr":"\"no files to compile were provided\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 181,col 32)-(line 181,col 32)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 181,col 44)-(line 181,col 44)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 182,col 18)-(line 182,col 18)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 187,col 67)-(line 187,col 70)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.FileCompiler.compile_source(java.util.List<java.lang.String>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"all the files that were attempted to be compiled","javadocBlockTagName":"fileNames","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='all the files that were attempted to be compiled'}]}', name=Optional[fileNames]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the error string that indicates which files\n  could not be compiled","javadocBlockTagName":"errorString","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the error string that indicates which files\n  could not be compiled'}]}', name=Optional[errorString]}"}],"methodDeclaration":"private void recompile_without_errors(List<String> fileNames, String errorString) throws IOException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (errorString != null) {\n        HashSet<String> errorClasses = new HashSet<String>();\n        Matcher m = java_filename_pattern.matcher(errorString);\n        while (m.find()) {\n            @SuppressWarnings(\"nullness\")\n            String sansExtension = m.group(1);\n            errorClasses.add(sansExtension);\n        }\n        List<String> retry = new ArrayList<String>();\n        String filenames = \"\";\n        for (String sourceFileName : fileNames) {\n            sourceFileName = sourceFileName.trim();\n            String classFilePath = getClassFilePath(sourceFileName);\n            if (!fileExists(classFilePath)) {\n                if (!errorClasses.contains(sourceFileName)) {\n                    retry.add(sourceFileName);\n                    filenames += \" \" + sourceFileName;\n                }\n            }\n        }\n        if (retry.size() > 0) {\n            TimeLimitProcess tp = compile_source(retry);\n            try {\n                tp.waitFor();\n            } catch (InterruptedException e) {\n                System.out.println(\"Compile of \" + filenames + \" interrupted: \" + e);\n            }\n        }\n    }\n}","methodRange":"(line 200,col 3)-(line 236,col 3)","methodTokenRange":"private void recompile_without_errors(List<String> fileNames, String errorString)\n      throws IOException {\n    \/\/ search the error string and extract the files with errors.\n    if (errorString != null) {\n      HashSet<String> errorClasses = new HashSet<String>();\n      Matcher m = java_filename_pattern.matcher(errorString);\n      while (m.find()) {\n        @SuppressWarnings(\n            \"nullness\") \/\/ Regex Checker imprecision:  find() guarantees that group 1 exists in regexp\n        \/*@NonNull*\/ String sansExtension = m.group(1);\n        errorClasses.add(sansExtension);\n      }\n      \/\/ Collect all the files that were not compiled into retry\n      List<String> retry = new ArrayList<String>();\n      String filenames = \"\";\n      for (String sourceFileName : fileNames) {\n        sourceFileName = sourceFileName.trim();\n        String classFilePath = getClassFilePath(sourceFileName);\n        if (!fileExists(classFilePath)) {\n          if (!errorClasses.contains(sourceFileName)) {\n            retry.add(sourceFileName);\n            filenames += \" \" + sourceFileName;\n          }\n        }\n      }\n\n      if (retry.size() > 0) {\n        TimeLimitProcess tp = compile_source(retry);\n\n        try {\n          tp.waitFor();\n        } catch (InterruptedException e) {\n          System.out.println(\"Compile of \" + filenames + \" interrupted: \" + e);\n        }\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Examine the errorString to identify the files that cannot\n   * compile, then recompile all the other files. This function is\n   * necessary when compiling with javac because javac does not\n   * compile all the files supplied to it if some of them contain\n   * errors. So some \"good\" files end up not being compiled.\n   * @param fileNames all the files that were attempted to be compiled\n   * @param errorString the error string that indicates which files\n   *   could not be compiled\n   ","methodParameters":[{"parameterType":"List<String>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.String>","parameter":"List<String> fileNames","parameterName":"fileNames"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String errorString","parameterName":"errorString"}],"methodName":"recompile_without_errors","methodQualifiedSignature":"plume.FileCompiler.recompile_without_errors","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Examine the errorString to identify the files that cannot\ncompile, then recompile all the other files. This function is\nnecessary when compiling with javac because javac does not\ncompile all the files supplied to it if some of them contain\nerrors. So some \"good\" files end up not being compiled.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='all the files that were attempted to be compiled'}]}', name=Optional[fileNames]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the error string that indicates which files\n  could not be compiled'}]}', name=Optional[errorString]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 203,col 24)-(line 203,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 208,col 13)-(line 208,col 22)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 209,col 53)-(line 209,col 53)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 214,col 26)-(line 214,col 27)","literalExprId":4,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 221,col 26)-(line 221,col 28)","literalExprId":5,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 226,col 26)-(line 226,col 26)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 232,col 30)-(line 232,col 42)","literalExprId":7,"literalExpr":"\"Compile of \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 232,col 58)-(line 232,col 73)","literalExprId":8,"literalExpr":"\" interrupted: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.FileCompiler.recompile_without_errors(java.util.List<java.lang.String>, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the path to the .java file","javadocBlockTagName":"sourceFilePath","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the path to the .java file'}]}', name=Optional[sourceFilePath]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the path to the corresponding .class file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the path to the corresponding .class file'}]}', name=Optional.empty}"}],"methodDeclaration":"private static String getClassFilePath(String sourceFilePath)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int index = sourceFilePath.lastIndexOf('.');\n    if (index == -1) {\n        throw new IllegalArgumentException(\"sourceFilePath: \" + sourceFilePath + \" must end with an extention.\");\n    }\n    return sourceFilePath.substring(0, index) + \".class\";\n}","methodRange":"(line 244,col 3)-(line 251,col 3)","methodTokenRange":"private static String getClassFilePath(String sourceFilePath) {\n    int index = sourceFilePath.lastIndexOf('.');\n    if (index == -1) {\n      throw new IllegalArgumentException(\n          \"sourceFilePath: \" + sourceFilePath + \" must end with an extention.\");\n    }\n    return sourceFilePath.substring(0, index) + \".class\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the file path to where a class file for a source\n   * file at sourceFilePath would be generated.\n   * @param sourceFilePath the path to the .java file\n   * @return the path to the corresponding .class file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String sourceFilePath","parameterName":"sourceFilePath"}],"methodName":"getClassFilePath","methodQualifiedSignature":"plume.FileCompiler.getClassFilePath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the file path to where a class file for a source\nfile at sourceFilePath would be generated.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the path to the .java file'}]}', name=Optional[sourceFilePath]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the path to the corresponding .class file'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 245,col 44)-(line 245,col 46)","literalExprId":1,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 246,col 19)-(line 246,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 248,col 11)-(line 248,col 28)","literalExprId":3,"literalExpr":"\"sourceFilePath: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 248,col 49)-(line 248,col 78)","literalExprId":4,"literalExpr":"\" must end with an extention.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 250,col 37)-(line 250,col 37)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 250,col 49)-(line 250,col 56)","literalExprId":6,"literalExpr":"\".class\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.FileCompiler.getClassFilePath(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"path to check for existence","javadocBlockTagName":"pathName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='path to check for existence'}]}', name=Optional[pathName]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the file exists","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the file exists'}]}', name=Optional.empty}"}],"methodDeclaration":"private static boolean fileExists(String pathName)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (new File(pathName)).exists();\n}","methodRange":"(line 257,col 3)-(line 259,col 3)","methodTokenRange":"private static boolean fileExists(String pathName) {\n    return (new File(pathName)).exists();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns true if the given file exists.\n   * @param pathName path to check for existence\n   * @return true iff the file exists\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String pathName","parameterName":"pathName"}],"methodName":"fileExists","methodQualifiedSignature":"plume.FileCompiler.fileExists","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the given file exists.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='path to check for existence'}]}', name=Optional[pathName]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the file exists'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.FileCompiler.fileExists(java.lang.String)"}],"classJavadoc":"\/**\n * This class has method {@link #compileFiles(List)}\n * that compiles Java source files.\n * It invokes a user-specified external command, such as <code>javac<\/code> or\n * <code>jikes<\/code>.\n *\/\n","className":"FileCompiler","fields":[{"fieldRange":"(line 26,col 3)-(line 26,col 65)","fieldName":"runtime","fieldJavadocComment":" The Runtime of the JVM. ","fieldTokenRange":"public static Runtime runtime = java.lang.Runtime.getRuntime();","fieldTypeResolved":"ReferenceType{java.lang.Runtime, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[java.lang.Runtime.getRuntime()]","fieldType":"Runtime","fieldJavadoc":"The Runtime of the JVM.\n","fieldTypeResolvedDescribed":"java.lang.Runtime"},{"fieldRange":"(line 31,col 3)-(line 31,col 53)","fieldName":"java_filename_pattern","fieldJavadocComment":"\n   * Matches the names of Java source files.\n   * Match group 1 is the complete filename.\n   ","fieldTokenRange":"static \/*@Regex(1)*\/ Pattern java_filename_pattern;","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Pattern","fieldJavadoc":"Matches the names of Java source files.\nMatch group 1 is the complete filename.\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 36,col 3)-(line 36,col 28)","fieldName":"compiler","fieldJavadocComment":"\n   * External command used to compile Java files, and command-line arguments.\n   * Guaranteed to be non-empty.\n   ","fieldTokenRange":"private String[] compiler;","fieldTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"String[]","fieldJavadoc":"External command used to compile Java files, and command-line arguments.\nGuaranteed to be non-empty.\n","fieldTypeResolvedDescribed":"java.lang.String[]"},{"fieldRange":"(line 38,col 3)-(line 38,col 25)","fieldName":"timeLimit","fieldJavadocComment":" Time limit for compilation jobs. ","fieldTokenRange":"private long timeLimit;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"long","fieldJavadoc":"Time limit for compilation jobs.\n","fieldTypeResolvedDescribed":"long"}]}],"sourceFileId":13,"packageName":"plume"},{"sourceFileName":"plume.MultiRandSelector","imports":[{"importId":1,"import":"import java.util.ArrayList;\n"},{"importId":2,"import":"import java.util.HashMap;\n"},{"importId":3,"import":"import java.util.Iterator;\n"},{"importId":4,"import":"import java.util.Map;\n"},{"importId":5,"import":"import java.util.Random;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of elements to select from each bucket","javadocBlockTagName":"num_elts","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of elements to select from each bucket'}]}', name=Optional[num_elts]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"partioner that determines how to partition the objects from\n the iteration","javadocBlockTagName":"eq","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='partioner that determines how to partition the objects from\n the iteration'}]}', name=Optional[eq]}"}],"constructorQualifiedSignature":"plume.MultiRandSelector.MultiRandSelector(int, plume.Partitioner<T, T>)","variableDeclarationExprs":[],"constructorRange":"(line 47,col 3)-(line 49,col 3)","constructorJavadocComment":" @param num_elts the number of elements to select from each bucket\n   *  @param eq partioner that determines how to partition the objects from\n   *  the iteration\n   ","constructorDeclaration":"public MultiRandSelector(int num_elts, Partitioner<T, T> eq)","constructorBody":"{\n    this(num_elts, new Random(), eq);\n}","constructorName":"MultiRandSelector","constructorQualifiedName":"plume.MultiRandSelector.MultiRandSelector","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num_elts","parameterName":"num_elts"},{"parameterType":"Partitioner<T, T>","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.Partitioner, typeParametersMap=TypeParametersMap{nameToValue={plume.Partitioner.ELEMENT=TypeVariable {JPTypeParameter(T, bounds=[])}, plume.Partitioner.CLASS=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"plume.Partitioner<T, T>","parameter":"Partitioner<T, T> eq","parameterName":"eq"}],"literalExprs":[],"constructorTokenRange":"public MultiRandSelector(int num_elts, Partitioner<T, T> eq) {\n    this(num_elts, new Random(), eq);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of elements to select from each bucket'}]}', name=Optional[num_elts]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='partioner that determines how to partition the objects from\n the iteration'}]}', name=Optional[eq]}]}"},{"constructorName":"MultiRandSelector","constructorQualifiedName":"plume.MultiRandSelector.MultiRandSelector","constructorQualifiedSignature":"plume.MultiRandSelector.MultiRandSelector(double, plume.Partitioner<T, T>)","constructorParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double keep_prob","parameterName":"keep_prob"},{"parameterType":"Partitioner<T, T>","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.Partitioner, typeParametersMap=TypeParametersMap{nameToValue={plume.Partitioner.ELEMENT=TypeVariable {JPTypeParameter(T, bounds=[])}, plume.Partitioner.CLASS=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"plume.Partitioner<T, T>","parameter":"Partitioner<T, T> eq","parameterName":"eq"}],"literalExprs":[],"constructorTokenRange":"public MultiRandSelector(double keep_prob, Partitioner<T, T> eq) {\n    this(keep_prob, new Random(), eq);\n  }","variableDeclarationExprs":[],"constructorRange":"(line 51,col 3)-(line 53,col 3)","constructorJavadocComment":"","constructorDeclaration":"public MultiRandSelector(double keep_prob, Partitioner<T, T> eq)","constructorBody":"{\n    this(keep_prob, new Random(), eq);\n}","constructorJavadoc":""},{"constructorName":"MultiRandSelector","constructorQualifiedName":"plume.MultiRandSelector.MultiRandSelector","constructorQualifiedSignature":"plume.MultiRandSelector.MultiRandSelector(int, java.util.Random, plume.Partitioner<T, T>)","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num_elts","parameterName":"num_elts"},{"parameterType":"Random","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Random","parameter":"Random r","parameterName":"r"},{"parameterType":"Partitioner<T, T>","parameterId":3,"parameterTypeResolved":"ReferenceType{plume.Partitioner, typeParametersMap=TypeParametersMap{nameToValue={plume.Partitioner.ELEMENT=TypeVariable {JPTypeParameter(T, bounds=[])}, plume.Partitioner.CLASS=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"plume.Partitioner<T, T>","parameter":"Partitioner<T, T> eq","parameterName":"eq"}],"literalExprs":[{"literalExprRange":"(line 56,col 22)-(line 56,col 26)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public MultiRandSelector(int num_elts, Random r, Partitioner<T, T> eq) {\n    coin_toss_mode = false;\n    this.num_elts = num_elts;\n    seed = r;\n    this.eq = eq;\n    map = new HashMap<T, RandomSelector<T>>();\n  }","variableDeclarationExprs":[],"constructorRange":"(line 55,col 3)-(line 61,col 3)","constructorJavadocComment":"","constructorDeclaration":"public MultiRandSelector(int num_elts, Random r, Partitioner<T, T> eq)","constructorBody":"{\n    coin_toss_mode = false;\n    this.num_elts = num_elts;\n    seed = r;\n    this.eq = eq;\n    map = new HashMap<T, RandomSelector<T>>();\n}","constructorJavadoc":""},{"constructorName":"MultiRandSelector","constructorQualifiedName":"plume.MultiRandSelector.MultiRandSelector","constructorQualifiedSignature":"plume.MultiRandSelector.MultiRandSelector(double, java.util.Random, plume.Partitioner<T, T>)","constructorParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double keep_prob","parameterName":"keep_prob"},{"parameterType":"Random","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Random","parameter":"Random r","parameterName":"r"},{"parameterType":"Partitioner<T, T>","parameterId":3,"parameterTypeResolved":"ReferenceType{plume.Partitioner, typeParametersMap=TypeParametersMap{nameToValue={plume.Partitioner.ELEMENT=TypeVariable {JPTypeParameter(T, bounds=[])}, plume.Partitioner.CLASS=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"plume.Partitioner<T, T>","parameter":"Partitioner<T, T> eq","parameterName":"eq"}],"literalExprs":[{"literalExprRange":"(line 65,col 22)-(line 65,col 25)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public MultiRandSelector(double keep_prob, Random r, Partitioner<T, T> eq) {\n    this.keep_probability = keep_prob;\n    coin_toss_mode = true;\n    seed = r;\n    this.eq = eq;\n    map = new HashMap<T, RandomSelector<T>>();\n  }","variableDeclarationExprs":[],"constructorRange":"(line 63,col 3)-(line 69,col 3)","constructorJavadocComment":"","constructorDeclaration":"public MultiRandSelector(double keep_prob, Random r, Partitioner<T, T> eq)","constructorBody":"{\n    this.keep_probability = keep_prob;\n    coin_toss_mode = true;\n    seed = r;\n    this.eq = eq;\n    map = new HashMap<T, RandomSelector<T>>();\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public void acceptIter(Iterator<T> iter)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    while (iter.hasNext()) {\n        accept(iter.next());\n    }\n}","methodRange":"(line 71,col 3)-(line 75,col 3)","methodTokenRange":"public void acceptIter(Iterator<T> iter) {\n    while (iter.hasNext()) {\n      accept(iter.next());\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> iter","parameterName":"iter"}],"methodName":"acceptIter","methodQualifiedSignature":"plume.MultiRandSelector.acceptIter","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.MultiRandSelector.acceptIter(java.util.Iterator<T>)"},{"methodDeclaration":"public void accept(T next)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    T equivClass = eq.assignToBucket(next);\n    if (equivClass == null) {\n        return;\n    }\n    RandomSelector<T> delegation = map.get(equivClass);\n    if (delegation == null) {\n        delegation = ((coin_toss_mode) ? new RandomSelector<T>(keep_probability, seed) : new RandomSelector<T>(num_elts, seed));\n        map.put(equivClass, delegation);\n    }\n    delegation.accept(next);\n}","methodRange":"(line 77,col 3)-(line 91,col 3)","methodTokenRange":"public void accept(T next) {\n    T equivClass = eq.assignToBucket(next);\n    if (equivClass == null) {\n      return;\n    }\n    RandomSelector<T> delegation = map.get(equivClass);\n    if (delegation == null) {\n      delegation =\n          ((coin_toss_mode)\n              ? new RandomSelector<T>(keep_probability, seed)\n              : new RandomSelector<T>(num_elts, seed));\n      map.put(equivClass, delegation);\n    }\n    delegation.accept(next);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T next","parameterName":"next"}],"methodName":"accept","methodQualifiedSignature":"plume.MultiRandSelector.accept","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 79,col 23)-(line 79,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 83,col 23)-(line 83,col 26)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.MultiRandSelector.accept(T)"},{"methodDeclaration":"public Map<T, RandomSelector<T>> values()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return map;\n}","methodRange":"(line 95,col 3)-(line 97,col 3)","methodTokenRange":"public Map<T, RandomSelector<T>> values() {\n    return map;\n  }","methodReturnTypeResolved":"","methodJavadocComment":" NOT safe from concurrent modification.","methodParameters":[],"methodName":"values","methodQualifiedSignature":"plume.MultiRandSelector.values","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Map<T, RandomSelector<T>>","literalExprs":[],"methodQualifiedName":"plume.MultiRandSelector.values()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"an iterator of all objects selected.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an iterator of all objects selected.'}]}', name=Optional.empty}"}],"methodDeclaration":"public Iterator<T> valuesIter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ArrayList<T> ret = new ArrayList<T>();\n    for (RandomSelector<T> rs : map.values()) {\n        ret.addAll(rs.getValues());\n    }\n    return ret.iterator();\n}","methodRange":"(line 101,col 3)-(line 107,col 3)","methodTokenRange":"public Iterator<T> valuesIter() {\n    ArrayList<T> ret = new ArrayList<T>();\n    for (RandomSelector<T> rs : map.values()) {\n      ret.addAll(rs.getValues());\n    }\n    return ret.iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":" Returns an iterator of all objects selected.\n   * @return an iterator of all objects selected. ","methodParameters":[],"methodName":"valuesIter","methodQualifiedSignature":"plume.MultiRandSelector.valuesIter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an iterator of all objects selected.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an iterator of all objects selected.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<T>","methodType":"Iterator<T>","literalExprs":[],"methodQualifiedName":"plume.MultiRandSelector.valuesIter()"}],"classJavadoc":"\/**\n * Performs uniform random selection over an iterator, where the objects in\n * the iteration may be partitioned so that the random selection chooses\n * the same number from each group.\n *\n * <p>For example, given data about incomes by state, it may be more\n * useful to select 1000 people from each state rather than 50,000 from the\n * nation. As another example, for selecting invocations in a Daikon trace\n * file, it may be more useful to select an equal number of samples per\n * program point.\n *\n * <p>The performance is the same as running a set of RandomSelector\n * Objects, one for each bucket, plus some overhead for\n * determining which bucket to assign to each Object in the iteration.\n *\n * <p>To use this class, call this.accept() on every Object in the\n * iteration to be sampled. Then, call valuesIter() to receive an\n * iteration of all the values selected by the random selection.\n *\n * @param <T> the type of elements to be selected among\n *\n * @see RandomSelector\n *\/\n","className":"MultiRandSelector","fields":[{"fieldRange":"(line 35,col 3)-(line 35,col 28)","fieldName":"num_elts","fieldJavadocComment":"","fieldTokenRange":"private int num_elts = -1;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 35,col 27)-(line 35,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[-1]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 36,col 3)-(line 36,col 33)","fieldName":"coin_toss_mode","fieldJavadocComment":"","fieldTokenRange":"private boolean coin_toss_mode;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 37,col 3)-(line 37,col 41)","fieldName":"keep_probability","fieldJavadocComment":"","fieldTokenRange":"private double keep_probability = -1.0;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 37,col 38)-(line 37,col 40)","literalExprId":1,"literalExpr":"1.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[-1.0]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 38,col 3)-(line 38,col 22)","fieldName":"seed","fieldJavadocComment":"","fieldTokenRange":"private Random seed;","fieldTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Random","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Random"},{"fieldRange":"(line 39,col 3)-(line 39,col 31)","fieldName":"eq","fieldJavadocComment":"","fieldTokenRange":"private Partitioner<T, T> eq;","fieldTypeResolved":"ReferenceType{plume.Partitioner, typeParametersMap=TypeParametersMap{nameToValue={plume.Partitioner.ELEMENT=TypeVariable {JPTypeParameter(T, bounds=[])}, plume.Partitioner.CLASS=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Partitioner<T, T>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.Partitioner<T, T>"},{"fieldRange":"(line 41,col 3)-(line 41,col 44)","fieldName":"map","fieldJavadocComment":"","fieldTokenRange":"private HashMap<T, RandomSelector<T>> map;","fieldTypeResolved":"ReferenceType{java.util.HashMap, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashMap.V=ReferenceType{plume.RandomSelector, typeParametersMap=TypeParametersMap{nameToValue={plume.RandomSelector.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}, java.util.HashMap.K=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"HashMap<T, RandomSelector<T>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.HashMap<T, plume.RandomSelector<T>>"}]}],"sourceFileId":14,"packageName":"plume"},{"sourceFileName":"plume.RandoopMappedCalls","imports":[{"importId":1,"import":"import java.awt.Component;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.RandoopMappedCalls.RandoopMappedCalls()","variableDeclarationExprs":[],"constructorRange":"(line 9,col 3)-(line 11,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private RandoopMappedCalls()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"RandoopMappedCalls","constructorQualifiedName":"plume.RandoopMappedCalls.RandoopMappedCalls","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 10,col 21)-(line 10,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private RandoopMappedCalls() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static void showMessageDialog(Component parentComponent, Object message, String title, int messageType)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    System.out.printf(\"Dialog box with message: %s%n\", message);\n}","methodRange":"(line 15,col 3)-(line 18,col 3)","methodTokenRange":"public static void showMessageDialog(\n      Component parentComponent, Object message, String title, int messageType) {\n    System.out.printf(\"Dialog box with message: %s%n\", message);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" dialog box would have popped up.","methodParameters":[{"parameterType":"Component","parameterId":1,"parameterTypeResolved":"ReferenceType{java.awt.Component, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.awt.Component","parameter":"Component parentComponent","parameterName":"parentComponent"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object message","parameterName":"message"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String title","parameterName":"title"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int messageType","parameterName":"messageType"}],"methodName":"showMessageDialog","methodQualifiedSignature":"plume.RandoopMappedCalls.showMessageDialog","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 17,col 23)-(line 17,col 53)","literalExprId":1,"literalExpr":"\"Dialog box with message: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RandoopMappedCalls.showMessageDialog(java.awt.Component, java.lang.Object, java.lang.String, int)"},{"methodDeclaration":"public static void showConfirmDialog(Component parentComponent, Object message, String title, int messageType)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    System.out.printf(\"Confirm Dialog box with message: %s%n\", message);\n}","methodRange":"(line 20,col 3)-(line 23,col 3)","methodTokenRange":"public static void showConfirmDialog(\n      Component parentComponent, Object message, String title, int messageType) {\n    System.out.printf(\"Confirm Dialog box with message: %s%n\", message);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Component","parameterId":1,"parameterTypeResolved":"ReferenceType{java.awt.Component, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.awt.Component","parameter":"Component parentComponent","parameterName":"parentComponent"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object message","parameterName":"message"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String title","parameterName":"title"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int messageType","parameterName":"messageType"}],"methodName":"showConfirmDialog","methodQualifiedSignature":"plume.RandoopMappedCalls.showConfirmDialog","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 22,col 23)-(line 22,col 61)","literalExprId":1,"literalExpr":"\"Confirm Dialog box with message: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RandoopMappedCalls.showConfirmDialog(java.awt.Component, java.lang.Object, java.lang.String, int)"},{"methodDeclaration":"public static void showConfirmDialog(Component parentComponent, Object message, String title, int messageType, int ii)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    System.out.printf(\"Confirm Dialog box with message: %s%n\", message);\n}","methodRange":"(line 25,col 3)-(line 28,col 3)","methodTokenRange":"public static void showConfirmDialog(\n      Component parentComponent, Object message, String title, int messageType, int ii) {\n    System.out.printf(\"Confirm Dialog box with message: %s%n\", message);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"Component","parameterId":1,"parameterTypeResolved":"ReferenceType{java.awt.Component, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.awt.Component","parameter":"Component parentComponent","parameterName":"parentComponent"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object message","parameterName":"message"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String title","parameterName":"title"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int messageType","parameterName":"messageType"},{"parameterType":"int","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int ii","parameterName":"ii"}],"methodName":"showConfirmDialog","methodQualifiedSignature":"plume.RandoopMappedCalls.showConfirmDialog","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 27,col 23)-(line 27,col 61)","literalExprId":1,"literalExpr":"\"Confirm Dialog box with message: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RandoopMappedCalls.showConfirmDialog(java.awt.Component, java.lang.Object, java.lang.String, int, int)"},{"methodDeclaration":"public static void exit(int status)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    System.out.printf(\"System exit with status %d ignored%n\", status);\n}","methodRange":"(line 32,col 3)-(line 34,col 3)","methodTokenRange":"public static void exit(int status) {\n    System.out.printf(\"System exit with status %d ignored%n\", status);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" that the call would have been made.","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int status","parameterName":"status"}],"methodName":"exit","methodQualifiedSignature":"plume.RandoopMappedCalls.exit","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 33,col 23)-(line 33,col 60)","literalExprId":1,"literalExpr":"\"System exit with status %d ignored%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RandoopMappedCalls.exit(int)"}],"classJavadoc":"\/**\n * A helper class for running <a href=\"http:\/\/code.google.com\/p\/randoop\/\">Randoop<\/a>.\n *\/\n","className":"RandoopMappedCalls","fields":[]}],"sourceFileId":15,"packageName":"plume"},{"sourceFileName":"plume.Stopwatch","imports":[{"importId":1,"import":"import java.text.DecimalFormat;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.Stopwatch.Stopwatch()","variableDeclarationExprs":[],"constructorRange":"(line 19,col 3)-(line 21,col 3)","constructorJavadocComment":" When created, the stopwatch is running by default. ","constructorDeclaration":"public Stopwatch()","constructorBody":"{\n    this(true);\n}","constructorName":"Stopwatch","constructorQualifiedName":"plume.Stopwatch.Stopwatch","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 20,col 10)-(line 20,col 13)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public Stopwatch() {\n    this(true);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='When created, the stopwatch is running by default.'}]}, blockTags=[]}"},{"constructorName":"Stopwatch","constructorQualifiedName":"plume.Stopwatch.Stopwatch","constructorQualifiedSignature":"plume.Stopwatch.Stopwatch(boolean)","constructorParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean start","parameterName":"start"}],"literalExprs":[],"constructorTokenRange":"public Stopwatch(boolean start) {\n    if (start) {\n      start();\n    }\n  }","variableDeclarationExprs":[],"constructorRange":"(line 23,col 3)-(line 27,col 3)","constructorJavadocComment":"","constructorDeclaration":"public Stopwatch(boolean start)","constructorBody":"{\n    if (start) {\n        start();\n    }\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[],"methodDeclaration":"public void reset()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    startTime = 0;\n    elapsedMillis = 0;\n    start();\n}","methodRange":"(line 30,col 3)-(line 34,col 3)","methodTokenRange":"public void reset() {\n    startTime = 0;\n    elapsedMillis = 0;\n    start();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Also starts the stopwatch. ","methodParameters":[],"methodName":"reset","methodQualifiedSignature":"plume.Stopwatch.reset","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Also starts the stopwatch.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 31,col 17)-(line 31,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 32,col 21)-(line 32,col 21)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.reset()"},{"methodDeclaration":"public void clear()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    startTime = 0;\n    elapsedMillis = 0;\n}","methodRange":"(line 36,col 3)-(line 39,col 3)","methodTokenRange":"public void clear() {\n    startTime = 0;\n    elapsedMillis = 0;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"clear","methodQualifiedSignature":"plume.Stopwatch.clear","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 37,col 17)-(line 37,col 17)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 38,col 21)-(line 38,col 21)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.clear()"},{"methodDeclaration":"public void start()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (startTime != 0) {\n        throw new Error(\"Stopwatch is not stopped\");\n    }\n    startTime = System.currentTimeMillis();\n}","methodRange":"(line 41,col 3)-(line 46,col 3)","methodTokenRange":"public void start(\/*>>> @UnknownInitialization @Raw Stopwatch this*\/) {\n    if (startTime != 0) {\n      throw new Error(\"Stopwatch is not stopped\");\n    }\n    startTime = System.currentTimeMillis();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"start","methodQualifiedSignature":"plume.Stopwatch.start","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 42,col 22)-(line 42,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 43,col 23)-(line 43,col 48)","literalExprId":2,"literalExpr":"\"Stopwatch is not stopped\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.start()"},{"methodDeclaration":"public void stop()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (startTime == 0) {\n        throw new Error(\"Stopwatch is not started\");\n    }\n    elapsedMillis += (System.currentTimeMillis() - startTime);\n    startTime = 0;\n}","methodRange":"(line 48,col 3)-(line 54,col 3)","methodTokenRange":"public void stop() {\n    if (startTime == 0) {\n      throw new Error(\"Stopwatch is not started\");\n    }\n    elapsedMillis += (System.currentTimeMillis() - startTime);\n    startTime = 0;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"stop","methodQualifiedSignature":"plume.Stopwatch.stop","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 49,col 22)-(line 49,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 50,col 23)-(line 50,col 48)","literalExprId":2,"literalExpr":"\"Stopwatch is not started\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 53,col 17)-(line 53,col 17)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.stop()"},{"methodDeclaration":"public long snapshot()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (System.currentTimeMillis() - startTime);\n}","methodRange":"(line 56,col 3)-(line 58,col 3)","methodTokenRange":"public long snapshot() {\n    return (System.currentTimeMillis() - startTime);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[],"methodName":"snapshot","methodQualifiedSignature":"plume.Stopwatch.snapshot","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.Stopwatch.snapshot()"},{"methodDeclaration":"public long elapsedMillis()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return elapsedMillis;\n}","methodRange":"(line 60,col 3)-(line 62,col 3)","methodTokenRange":"public long elapsedMillis() {\n    return elapsedMillis;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"","methodParameters":[],"methodName":"elapsedMillis","methodQualifiedSignature":"plume.Stopwatch.elapsedMillis","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.Stopwatch.elapsedMillis()"},{"methodDeclaration":"public double elapsedSeconds()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return elapsedMillis \/ 1000.0;\n}","methodRange":"(line 64,col 3)-(line 66,col 3)","methodTokenRange":"public double elapsedSeconds() {\n    return elapsedMillis \/ 1000.0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"","methodParameters":[],"methodName":"elapsedSeconds","methodQualifiedSignature":"plume.Stopwatch.elapsedSeconds","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 65,col 28)-(line 65,col 33)","literalExprId":1,"literalExpr":"1000.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.elapsedSeconds()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a String representing the elapsed time","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String representing the elapsed time'}]}', name=Optional.empty}"}],"methodDeclaration":"public String stop_start()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    stop();\n    String result = format();\n    start();\n    return (result);\n}","methodRange":"(line 81,col 3)-(line 86,col 3)","methodTokenRange":"public String stop_start() {\n    stop();\n    String result = format();\n    start();\n    return (result);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Stops the watch, calculates the elapsed time, restarts the watch,\n   * and returns the elapsed time.\n   * @return a String representing the elapsed time\n   ","methodParameters":[],"methodName":"stop_start","methodQualifiedSignature":"plume.Stopwatch.stop_start","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Stops the watch, calculates the elapsed time, restarts the watch,\nand returns the elapsed time.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String representing the elapsed time'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.Stopwatch.stop_start()"},{"methodDeclaration":"public String format()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return format(1);\n}","methodRange":"(line 88,col 3)-(line 90,col 3)","methodTokenRange":"public String format() {\n    return format(1);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"format","methodQualifiedSignature":"plume.Stopwatch.format","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 89,col 19)-(line 89,col 19)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.format()"},{"methodDeclaration":"public String format(int digits)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long runningMillis = elapsedMillis;\n    if (startTime != 0) {\n        runningMillis += (System.currentTimeMillis() - startTime);\n    }\n    return Stopwatch.timeFormat[digits].format(runningMillis \/ 1000.0) + \"s\";\n}","methodRange":"(line 92,col 3)-(line 98,col 3)","methodTokenRange":"public String format(int digits) {\n    long runningMillis = elapsedMillis;\n    if (startTime != 0) {\n      runningMillis += (System.currentTimeMillis() - startTime);\n    }\n    return Stopwatch.timeFormat[digits].format(runningMillis \/ 1000.0) + \"s\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int digits","parameterName":"digits"}],"methodName":"format","methodQualifiedSignature":"plume.Stopwatch.format","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 94,col 22)-(line 94,col 22)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 97,col 64)-(line 97,col 69)","literalExprId":2,"literalExpr":"1000.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 97,col 74)-(line 97,col 76)","literalExprId":3,"literalExpr":"\"s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Stopwatch.format(int)"}],"classJavadoc":"\/**\n * A simple class for recording elapsed time.\n *\/\n","className":"Stopwatch","fields":[{"fieldRange":"(line 15,col 3)-(line 15,col 25)","fieldName":"elapsedMillis","fieldJavadocComment":"","fieldTokenRange":"long elapsedMillis = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 15,col 24)-(line 15,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 16,col 3)-(line 16,col 21)","fieldName":"startTime","fieldJavadocComment":"","fieldTokenRange":"long startTime = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 16,col 20)-(line 16,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 68,col 3)-(line 74,col 4)","fieldName":"timeFormat","fieldJavadocComment":"","fieldTokenRange":"private static final DecimalFormat[] timeFormat = {\n    new DecimalFormat(\"#.#\"),\n    new DecimalFormat(\"#.#\"),\n    new DecimalFormat(\"#.#\"),\n    new DecimalFormat(\"#.#\"),\n    new DecimalFormat(\"#.#\"),\n  };","fieldTypeResolved":"ResolvedArrayType{ReferenceType{java.text.DecimalFormat, typeParametersMap=TypeParametersMap{nameToValue={}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 69,col 23)-(line 69,col 27)","literalExprId":1,"literalExpr":"\"#.#\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 70,col 23)-(line 70,col 27)","literalExprId":2,"literalExpr":"\"#.#\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 71,col 23)-(line 71,col 27)","literalExprId":3,"literalExpr":"\"#.#\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 72,col 23)-(line 72,col 27)","literalExprId":4,"literalExpr":"\"#.#\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 73,col 23)-(line 73,col 27)","literalExprId":5,"literalExpr":"\"#.#\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[{ new DecimalFormat(\"#.#\"), new DecimalFormat(\"#.#\"), new DecimalFormat(\"#.#\"), new DecimalFormat(\"#.#\"), new DecimalFormat(\"#.#\") }]","fieldType":"DecimalFormat[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.text.DecimalFormat[]"}]}],"sourceFileId":16,"packageName":"plume"},{"sourceFileName":"plume.TaskManager","imports":[{"importId":1,"import":"import java.io.IOException;\n"},{"importId":2,"import":"import java.text.DateFormat;\n"},{"importId":3,"import":"import java.text.SimpleDateFormat;\n"},{"importId":4,"import":"import java.util.ArrayList;\n"},{"importId":5,"import":"import java.util.Date;\n"},{"importId":6,"import":"import java.util.List;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.TaskManager.TaskManager()","variableDeclarationExprs":[],"constructorRange":"(line 273,col 3)-(line 273,col 25)","constructorJavadocComment":" empty TaskManger. ","constructorDeclaration":"public TaskManager()","constructorBody":"{\n}","constructorName":"TaskManager","constructorQualifiedName":"plume.TaskManager.TaskManager","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public TaskManager() {}","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='empty TaskManger.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"list of files to read tasks from","javadocBlockTagName":"filenames","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of files to read tasks from'}]}', name=Optional[filenames]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading a file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading a file'}]}', name=Optional[IOException]}"}],"constructorQualifiedSignature":"plume.TaskManager.TaskManager(java.lang.String[])","variableDeclarationExprs":[{"variableType":"String","variableName":"filename","variableDeclarationExprId":1,"variableDeclarationExpr":"String filename","variableDeclarationExprRange":"(line 282,col 10)-(line 282,col 24)","variableTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 282,col 17)-(line 282,col 24)"},{"variableType":"EntryReader","variableName":"reader","variableDeclarationExprId":2,"variableDeclarationExpr":"EntryReader reader = new EntryReader(filename, comment_re, include_re)","variableDeclarationExprRange":"(line 284,col 12)-(line 284,col 81)","variableTypeResolved":"ReferenceType{plume.EntryReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 284,col 24)-(line 284,col 81)"},{"variableType":"EntryReader.Entry","variableName":"entry","variableDeclarationExprId":3,"variableDeclarationExpr":"EntryReader.Entry entry = reader.get_entry()","variableDeclarationExprRange":"(line 286,col 11)-(line 286,col 54)","variableTypeResolved":"ReferenceType{plume.EntryReader.Entry, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 286,col 29)-(line 286,col 54)"}],"constructorRange":"(line 279,col 3)-(line 298,col 3)","constructorJavadocComment":" initializes a task manager with all of the tasks in filenames.\n   * @param filenames list of files to read tasks from\n   * @throws IOException if there is trouble reading a file\n   ","constructorDeclaration":"public TaskManager(String[] filenames) throws IOException","constructorBody":"{\n    for (String filename : filenames) {\n        filename = UtilMDE.expandFilename(filename);\n        try (EntryReader reader = new EntryReader(filename, comment_re, include_re)) {\n            while (true) {\n                EntryReader.Entry entry = reader.get_entry();\n                if (entry == null) {\n                    break;\n                }\n                try {\n                    tasks.add(new Task(entry.body, entry.filename, entry.line_number));\n                } catch (IOException e) {\n                    throw new Error(\"Error parsing \" + entry.filename + \" at line \" + entry.line_number, e);\n                }\n            }\n        }\n    }\n}","constructorName":"TaskManager","constructorQualifiedName":"plume.TaskManager.TaskManager","constructorParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] filenames","parameterName":"filenames"}],"literalExprs":[{"literalExprRange":"(line 285,col 16)-(line 285,col 19)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 287,col 24)-(line 287,col 27)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 293,col 29)-(line 293,col 44)","literalExprId":3,"literalExpr":"\"Error parsing \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 293,col 65)-(line 293,col 75)","literalExprId":4,"literalExpr":"\" at line \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public TaskManager(String[] filenames) throws IOException {\n\n    \/\/ Read in each specified task file\n    for (String filename : filenames) {\n      filename = UtilMDE.expandFilename(filename);\n      try (EntryReader reader = new EntryReader(filename, comment_re, include_re)) {\n        while (true) {\n          EntryReader.Entry entry = reader.get_entry();\n          if (entry == null) {\n            break;\n          }\n          try {\n            tasks.add(new Task(entry.body, entry.filename, entry.line_number));\n          } catch (IOException e) {\n            throw new Error(\"Error parsing \" + entry.filename + \" at line \" + entry.line_number, e);\n          }\n        }\n      }\n    }\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='initializes a task manager with all of the tasks in filenames.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of files to read tasks from'}]}', name=Optional[filenames]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading a file'}]}', name=Optional[IOException]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 85,col 3)-(line 267,col 3)","classOrInterfaceTokenRange":"public static class Task {\n\n    String filename;\n    long line_number;\n\n    String task;\n    String responsible;\n    \/*@Nullable*\/ Date assigned_date;\n    \/*@Nullable*\/ String milestone;\n    Float duration;\n    Float completed;\n    \/*@Nullable*\/ String description;\n    \/*@Nullable*\/ String notes;\n\n    \/*@EnsuresNonNull({\"filename\", \"task\", \"responsible\", \"duration\", \"completed\"})*\/\n    private void checkRep(\n        \/*>>> @UnderInitialization(Object.class) @Raw(Object.class) Task this*\/) {\n      assert filename != null\n          : \"No filename at line \" + line_number + \" @AssumeAssertion(nullness)\";\n      assert task != null : \"No task at line \" + line_number + \" @AssumeAssertion(nullness)\";\n      assert responsible != null\n          : \"No responsible at line \" + line_number + \" @AssumeAssertion(nullness)\";\n      assert duration != null\n          : \"No duration at line \" + line_number + \" @AssumeAssertion(nullness)\";\n      assert completed != null\n          : \"No completed at line \" + line_number + \" @AssumeAssertion(nullness)\";\n    }\n\n    public Task(String body, String filename, long line_number) throws IOException {\n\n      this.filename = filename;\n      this.line_number = line_number;\n\n      String[] lines = body.split(lineSep);\n      for (int ii = 0; ii < lines.length; ii++) {\n        String line = lines[ii];\n\n        \/\/ Get the item\/value out of the record.  One line items\n        \/\/ are specifed as '{item}: {value}'.  Multiple line items\n        \/\/ have a start line of '{item}>' and an end line of '<{item}'\n        \/\/ with any number of value lines between.\n        \/*@NonNull*\/ String item;\n        String value;\n        if (line.matches(\"^[_a-zA-Z]+:.*\")) {\n          String[] sa = line.split(\" *: *\", 2);\n          item = sa[0];\n          value = sa[1];\n          if (value.length() == 0) {\n            value = null;\n          }\n        } else if (line.matches(\"^[-a-zA-Z]+>.*\")) {\n          item = line.replaceFirst(\" *>.*\", \"\");\n          value = \"\";\n          for (ii++; ii < lines.length; ii++) {\n            String nline = lines[ii];\n            if (nline.equals(\"<\" + item)) {\n              break;\n            }\n            value += nline + lineSep;\n          }\n        } else {\n          throw new IOException(\"malformed line: \" + line);\n        }\n\n        \/\/ parse the value based on the item and store it away\n        if (item.equals(\"task\")) {\n          if (value == null) {\n            throw new Error(\"Task with no value at line \" + line_number);\n          }\n          task = value;\n        } else if (item.equals(\"responsible\")) {\n          if (value == null) {\n            responsible = \"none\";\n          } else {\n            responsible = value;\n          }\n        } else if (item.equals(\"assigned_date\")) {\n          if (value == null) {\n            assigned_date = null;\n          } else {\n            DateFormat df = new SimpleDateFormat(\"yy-MM-dd\");\n            try {\n              assigned_date = df.parse(value);\n              assert assigned_date != null : value;\n            } catch (Throwable t) {\n              throw new RuntimeException(t);\n            }\n          }\n        } else if (item.equals(\"milestone\")) {\n          if (value == null) {\n            throw new Error(\"Milestone with no value at line \" + line_number);\n          }\n          milestone = value;\n        } else if (item.equals(\"duration\")) {\n          if (value == null) {\n            \/\/ duration is often used without being checked against null\n            throw new Error(\"Duration with no value at line \" + line_number);\n          }\n          duration = Float.parseFloat(value);\n        } else if (item.equals(\"completed\")) {\n          if (value == null) {\n            throw new Error(\"Completed with no value at line \" + line_number);\n          }\n          completed = Float.parseFloat(value);\n        } else if (item.equals(\"description\")) {\n          if (value == null) {\n            throw new Error(\"Description with no value at line \" + line_number);\n          }\n          description = value;\n        } else if (item.equals(\"notes\")) {\n          if (value == null) {\n            throw new Error(\"Notes with no value at line \" + line_number);\n          }\n          notes = value;\n        } else {\n          throw new IOException(\"unknown field \" + item);\n        }\n      }\n      \/\/ Check that all required fields are set.\n      checkRep();\n    }\n\n    \/*@SideEffectFree*\/\n    public static String short_str(float f) {\n      if (((double) f) - Math.floor((double) (f)) > 0.1) {\n        return String.format(\"%.1f\", f);\n      } else {\n        return String.format(\"%d\", Math.round(f));\n      }\n    }\n\n    \/*@SideEffectFree*\/\n    private String completion_str() {\n      return String.format(\"%s\/%s\", short_str(completed), short_str(duration));\n    }\n\n    \/*@SideEffectFree*\/\n    public String toString_short_ascii() {\n      return String.format(\"%-10s %-10s %-6s %s\", responsible, milestone, completion_str(), task);\n    }\n\n    \/*@SideEffectFree*\/\n    public String toString_short_html(double total) {\n      return String.format(\n          \"<tr> <td> %s <\/td><td> %s <\/td><td> %s <\/td><td> %f <\/td><td> %s <\/td><\/tr>\",\n          responsible,\n          milestone,\n          completion_str(),\n          total,\n          task);\n    }\n\n    \/*@SideEffectFree*\/\n    public String toString_milestone_html(double total) {\n      String resp_str = responsible;\n      if (resp_str.equals(\"none\")) {\n        resp_str = \"<font color=red><b>\" + resp_str + \"<\/b><\/font>\";\n      }\n      return String.format(\n          \"<tr> <td> %s <\/td><td> %s <\/td><td> %.1f <\/td><td>\"\n              + \"<a href=%s?file=%s&line=%d> %s <\/a><\/td><\/tr>\",\n          resp_str,\n          completion_str(),\n          total,\n          \"show_task_details.php\",\n          filename,\n          line_number,\n          task);\n    }\n\n    public String all_vals() {\n      StringBuilder out = new StringBuilder();\n      out.append(\"task:            \" + task + lineSep);\n      out.append(\"responsible:     \" + responsible + lineSep);\n      out.append(\"assigned_date:   \" + assigned_date + lineSep);\n      out.append(\"milestone:       \" + milestone + lineSep);\n      out.append(\"duration:        \" + duration + lineSep);\n      out.append(\"completed:       \" + completed + lineSep);\n      out.append(\"description:     \" + description + lineSep);\n      out.append(\"notes:           \" + notes + lineSep);\n      return out.toString();\n    }\n  }","classOrInterfaceJavadocComment":" Information about a single task. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Information about a single task.'}]}, blockTags=[]}]"}],"methods":[{"methodDeclaration":"public static void main(String[] args) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Options options = new Options(usage_string, TaskManager.class);\n    String[] filenames = options.parse_or_usage(args);\n    if (verbose) {\n        System.out.printf(\"Option settings: %s%n\", options.settings());\n    }\n    if (filenames.length == 0) {\n        options.print_usage(\"Error: No task files specified\");\n        System.exit(254);\n    }\n    TaskManager tm = new TaskManager(filenames);\n    if (verbose) {\n        System.out.printf(\"All tasks:%n\");\n        for (Task task : tm.tasks) {\n            System.out.printf(\"%s%n%n\", task.all_vals());\n        }\n    }\n    TaskManager matches = tm.responsible_match(responsible);\n    matches = matches.milestone_match(milestone);\n    if (open) {\n        matches = matches.open_only();\n    }\n    if (completed) {\n        matches = matches.completed_only();\n    }\n    switch(format) {\n        case short_ascii:\n            System.out.println(matches.toString_short_ascii());\n            break;\n        case short_html:\n            System.out.println(matches.toString_short_html());\n            break;\n        case milestone_html:\n            System.out.println(matches.toString_milestone_html());\n            break;\n    }\n}","methodRange":"(line 300,col 3)-(line 345,col 3)","methodTokenRange":"public static void main(String[] args) throws IOException {\n\n    Options options = new Options(usage_string, TaskManager.class);\n    String[] filenames = options.parse_or_usage(args);\n\n    if (verbose) {\n      System.out.printf(\"Option settings: %s%n\", options.settings());\n    }\n\n    \/\/ Make sure at least one file was specified\n    if (filenames.length == 0) {\n      options.print_usage(\"Error: No task files specified\");\n      System.exit(254);\n    }\n\n    TaskManager tm = new TaskManager(filenames);\n\n    \/\/ Dump out the tasks\n    if (verbose) {\n      System.out.printf(\"All tasks:%n\");\n      for (Task task : tm.tasks) {\n        System.out.printf(\"%s%n%n\", task.all_vals());\n      }\n    }\n\n    \/\/ Print specified tasks\n    TaskManager matches = tm.responsible_match(responsible);\n    matches = matches.milestone_match(milestone);\n    if (open) {\n      matches = matches.open_only();\n    }\n    if (completed) {\n      matches = matches.completed_only();\n    }\n    switch (format) {\n      case short_ascii:\n        System.out.println(matches.toString_short_ascii());\n        break;\n      case short_html:\n        System.out.println(matches.toString_short_html());\n        break;\n      case milestone_html:\n        System.out.println(matches.toString_milestone_html());\n        break;\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.TaskManager.main","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 306,col 25)-(line 306,col 47)","literalExprId":1,"literalExpr":"\"Option settings: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 310,col 29)-(line 310,col 29)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 311,col 27)-(line 311,col 58)","literalExprId":3,"literalExpr":"\"Error: No task files specified\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 312,col 19)-(line 312,col 21)","literalExprId":4,"literalExpr":"254","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 319,col 25)-(line 319,col 38)","literalExprId":5,"literalExpr":"\"All tasks:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 321,col 27)-(line 321,col 34)","literalExprId":6,"literalExpr":"\"%s%n%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TaskManager.main(java.lang.String[])"},{"methodDeclaration":"public String toString_short_ascii()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder out = new StringBuilder();\n    for (Task task : tasks) {\n        out.append(task.toString_short_ascii() + lineSep);\n    }\n    return (out.toString());\n}","methodRange":"(line 347,col 3)-(line 355,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public String toString_short_ascii() {\n    StringBuilder out = new StringBuilder();\n    for (Task task : tasks) {\n      out.append(task.toString_short_ascii() + lineSep);\n    }\n    return (out.toString());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString_short_ascii","methodQualifiedSignature":"plume.TaskManager.toString_short_ascii","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 347,col 21)-(line 347,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TaskManager.toString_short_ascii()"},{"methodDeclaration":"public String toString_short_html()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder out = new StringBuilder();\n    double total = 0.0;\n    String responsible = null;\n    out.append(\"<table>\" + lineSep);\n    for (Task task : tasks) {\n        if (!task.responsible.equals(responsible)) {\n            responsible = task.responsible;\n            total = 0.0;\n        }\n        total += (task.duration.floatValue() - task.completed.floatValue());\n        out.append(task.toString_short_html(total) + lineSep);\n    }\n    out.append(\"<\/table>\" + lineSep);\n    return (out.toString());\n}","methodRange":"(line 357,col 3)-(line 374,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public String toString_short_html() {\n    StringBuilder out = new StringBuilder();\n    double total = 0.0;\n    String responsible = null;\n    out.append(\"<table>\" + lineSep);\n    for (Task task : tasks) {\n      if (!task.responsible.equals(responsible)) {\n        responsible = task.responsible;\n        total = 0.0;\n      }\n      total += (task.duration.floatValue() - task.completed.floatValue());\n      out.append(task.toString_short_html(total) + lineSep);\n    }\n    out.append(\"<\/table>\" + lineSep);\n    return (out.toString());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString_short_html","methodQualifiedSignature":"plume.TaskManager.toString_short_html","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 357,col 21)-(line 357,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 361,col 20)-(line 361,col 22)","literalExprId":2,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 362,col 26)-(line 362,col 29)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 363,col 16)-(line 363,col 24)","literalExprId":4,"literalExpr":"\"<table>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 367,col 17)-(line 367,col 19)","literalExprId":5,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 372,col 16)-(line 372,col 25)","literalExprId":6,"literalExpr":"\"<\/table>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TaskManager.toString_short_html()"},{"methodDeclaration":"public String toString_milestone_html()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder out = new StringBuilder();\n    out.append(\"<table border cellspacing=0 cellpadding=2>\" + lineSep);\n    out.append(\"<tr> <th> Responsible <th> C\/D <th> Total <th> Task <\/tr>\" + lineSep);\n    double total = 0.0;\n    String responsible = null;\n    for (Task task : tasks) {\n        if (!task.responsible.equals(responsible)) {\n            if (responsible != null) {\n                out.append(\"<tr bgcolor=grey><td colspan=4><\/td><\/tr>\" + lineSep);\n            }\n            responsible = task.responsible;\n            total = 0.0;\n        }\n        total += (task.duration.floatValue() - task.completed.floatValue());\n        out.append(task.toString_milestone_html(total) + lineSep);\n    }\n    out.append(\"<\/table>\" + lineSep);\n    return (out.toString());\n}","methodRange":"(line 376,col 3)-(line 397,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public String toString_milestone_html() {\n    StringBuilder out = new StringBuilder();\n    out.append(\"<table border cellspacing=0 cellpadding=2>\" + lineSep);\n    out.append(\"<tr> <th> Responsible <th> C\/D <th> Total <th> Task <\/tr>\" + lineSep);\n    double total = 0.0;\n    String responsible = null;\n    for (Task task : tasks) {\n      if (!task.responsible.equals(responsible)) {\n        if (responsible != null) {\n          out.append(\"<tr bgcolor=grey><td colspan=4><\/td><\/tr>\" + lineSep);\n        }\n        responsible = task.responsible;\n        total = 0.0;\n      }\n      total += (task.duration.floatValue() - task.completed.floatValue());\n      out.append(task.toString_milestone_html(total) + lineSep);\n    }\n    out.append(\"<\/table>\" + lineSep);\n    return (out.toString());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString_milestone_html","methodQualifiedSignature":"plume.TaskManager.toString_milestone_html","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 376,col 21)-(line 376,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 380,col 16)-(line 380,col 59)","literalExprId":2,"literalExpr":"\"<table border cellspacing=0 cellpadding=2>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 381,col 16)-(line 381,col 74)","literalExprId":3,"literalExpr":"\"<tr> <th> Responsible <th> C\/D <th> Total <th> Task <\/tr>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 382,col 20)-(line 382,col 22)","literalExprId":4,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 383,col 26)-(line 383,col 29)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 386,col 28)-(line 386,col 31)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 387,col 22)-(line 387,col 64)","literalExprId":7,"literalExpr":"\"<tr bgcolor=grey><td colspan=4><\/td><\/tr>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 390,col 17)-(line 390,col 19)","literalExprId":8,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 395,col 16)-(line 395,col 25)","literalExprId":9,"literalExpr":"\"<\/table>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TaskManager.toString_milestone_html()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the task to be queued on the task list","javadocBlockTagName":"task","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the task to be queued on the task list'}]}', name=Optional[task]}"}],"methodDeclaration":"public void add(Task task)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    tasks.add(task);\n}","methodRange":"(line 402,col 3)-(line 404,col 3)","methodTokenRange":"public void add(Task task) {\n    tasks.add(task);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Adds the specified task to the end of the task list.\n   * @param task the task to be queued on the task list\n   ","methodParameters":[{"parameterType":"Task","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.TaskManager.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.TaskManager.Task","parameter":"Task task","parameterName":"task"}],"methodName":"add","methodQualifiedSignature":"plume.TaskManager.add","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds the specified task to the end of the task list.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the task to be queued on the task list'}]}', name=Optional[task]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.TaskManager.add(plume.TaskManager.Task)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the responsible party, or null; search for tasks assigned to responsible","javadocBlockTagName":"responsible","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the responsible party, or null; search for tasks assigned to responsible'}]}', name=Optional[responsible]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a TaskManger with only those tasks assigned to responsible","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a TaskManger with only those tasks assigned to responsible'}]}', name=Optional.empty}"}],"methodDeclaration":"public TaskManager responsible_match(String responsible)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TaskManager tm = new TaskManager();\n    for (Task task : tasks) {\n        if ((responsible == null) || responsible.equalsIgnoreCase(task.responsible)) {\n            tm.add(task);\n        }\n    }\n    return tm;\n}","methodRange":"(line 412,col 3)-(line 423,col 3)","methodTokenRange":"public TaskManager responsible_match(\/*@Nullable*\/ String responsible) {\n\n    TaskManager tm = new TaskManager();\n\n    for (Task task : tasks) {\n      if ((responsible == null) || responsible.equalsIgnoreCase(task.responsible)) {\n        tm.add(task);\n      }\n    }\n\n    return tm;\n  }","methodReturnTypeResolved":"ReferenceType{plume.TaskManager, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Create a new TaskManger with only those tasks assigned to responsible.\n   * All tasks match a responsible value of null.\n   * @param responsible name of the responsible party, or null; search for tasks assigned to responsible\n   * @return a TaskManger with only those tasks assigned to responsible\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String responsible","parameterName":"responsible"}],"methodName":"responsible_match","methodQualifiedSignature":"plume.TaskManager.responsible_match","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new TaskManger with only those tasks assigned to responsible.\nAll tasks match a responsible value of null.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the responsible party, or null; search for tasks assigned to responsible'}]}', name=Optional[responsible]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a TaskManger with only those tasks assigned to responsible'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.TaskManager","methodType":"TaskManager","literalExprs":[{"literalExprRange":"(line 417,col 27)-(line 417,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.TaskManager.responsible_match(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"milestone to search for","javadocBlockTagName":"milestone","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='milestone to search for'}]}', name=Optional[milestone]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"TaskManger with only the tasks in the given milestone","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='TaskManger with only the tasks in the given milestone'}]}', name=Optional.empty}"}],"methodDeclaration":"public TaskManager milestone_match(String milestone)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TaskManager tm = new TaskManager();\n    if (milestone == null) {\n        return tm;\n    }\n    for (Task task : tasks) {\n        if (milestone.equalsIgnoreCase(task.milestone)) {\n            tm.add(task);\n        }\n    }\n    return tm;\n}","methodRange":"(line 429,col 3)-(line 443,col 3)","methodTokenRange":"public TaskManager milestone_match(\/*@Nullable*\/ String milestone) {\n\n    TaskManager tm = new TaskManager();\n    if (milestone == null) {\n      return tm;\n    }\n\n    for (Task task : tasks) {\n      if (milestone.equalsIgnoreCase(task.milestone)) {\n        tm.add(task);\n      }\n    }\n\n    return tm;\n  }","methodReturnTypeResolved":"ReferenceType{plume.TaskManager, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Create a new TaskManger with only those tasks in milestone.\n   * @param milestone milestone to search for\n   * @return TaskManger with only the tasks in the given milestone\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String milestone","parameterName":"milestone"}],"methodName":"milestone_match","methodQualifiedSignature":"plume.TaskManager.milestone_match","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new TaskManger with only those tasks in milestone.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='milestone to search for'}]}', name=Optional[milestone]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='TaskManger with only the tasks in the given milestone'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.TaskManager","methodType":"TaskManager","literalExprs":[{"literalExprRange":"(line 432,col 22)-(line 432,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.TaskManager.milestone_match(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a new TaskManger with only completed tasks","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a new TaskManger with only completed tasks'}]}', name=Optional.empty}"}],"methodDeclaration":"public TaskManager completed_only()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TaskManager tm = new TaskManager();\n    for (Task task : tasks) {\n        if (task.duration <= task.completed) {\n            tm.add(task);\n        }\n    }\n    return tm;\n}","methodRange":"(line 449,col 3)-(line 460,col 3)","methodTokenRange":"public TaskManager completed_only() {\n\n    TaskManager tm = new TaskManager();\n\n    for (Task task : tasks) {\n      if (task.duration <= task.completed) {\n        tm.add(task);\n      }\n    }\n\n    return tm;\n  }","methodReturnTypeResolved":"ReferenceType{plume.TaskManager, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Create a new TaskManger with only completed tasks.\n   * @return a new TaskManger with only completed tasks\n   ","methodParameters":[],"methodName":"completed_only","methodQualifiedSignature":"plume.TaskManager.completed_only","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new TaskManger with only completed tasks.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a new TaskManger with only completed tasks'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.TaskManager","methodType":"TaskManager","literalExprs":[],"methodQualifiedName":"plume.TaskManager.completed_only()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a new TaskManger with only completed tasks","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a new TaskManger with only completed tasks'}]}', name=Optional.empty}"}],"methodDeclaration":"public TaskManager open_only()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TaskManager tm = new TaskManager();\n    for (Task task : tasks) {\n        if (task.duration > task.completed) {\n            tm.add(task);\n        }\n    }\n    return tm;\n}","methodRange":"(line 466,col 3)-(line 477,col 3)","methodTokenRange":"public TaskManager open_only() {\n\n    TaskManager tm = new TaskManager();\n\n    for (Task task : tasks) {\n      if (task.duration > task.completed) {\n        tm.add(task);\n      }\n    }\n\n    return tm;\n  }","methodReturnTypeResolved":"ReferenceType{plume.TaskManager, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Create a new TaskManger with only open tasks.\n   * @return a new TaskManger with only completed tasks\n   ","methodParameters":[],"methodName":"open_only","methodQualifiedSignature":"plume.TaskManager.open_only","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new TaskManger with only open tasks.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a new TaskManger with only completed tasks'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.TaskManager","methodType":"TaskManager","literalExprs":[],"methodQualifiedName":"plume.TaskManager.open_only()"}],"classJavadoc":"\/**\n * TaskManager extracts information about tasks from text files and\n * provides structured output.  For example, it can extract all of\n * the tasks associated with a specific milestone or person and total\n * the amount of work required. <p>\n *\n * The command-line arguments are as follows:\n * <!-- start options doc (DO NOT EDIT BY HAND) -->\n * <ul>\n *   <li id=\"option:responsible\"><b>-r<\/b> <b>--responsible=<\/b><i>string<\/i>.\n *    Include only those tasks assigned to the specified person<\/li>\n *   <li id=\"option:milestone\"><b>-m<\/b> <b>--milestone=<\/b><i>string<\/i>.\n *    Include only those tasks required for the specified milestone<\/li>\n *   <li id=\"option:completed\"><b>-c<\/b> <b>--completed=<\/b><i>boolean<\/i>.\n *    Include only completed tasks [default false]<\/li>\n *   <li id=\"option:open\"><b>-o<\/b> <b>--open=<\/b><i>boolean<\/i>.\n *    Include only open tasks [default false]<\/li>\n *   <li id=\"option:verbose\"><b>-v<\/b> <b>--verbose=<\/b><i>boolean<\/i>.\n *    Print progress information [default false]<\/li>\n *   <li id=\"option:format\"><b>-f<\/b> <b>--format=<\/b><i>enum<\/i>.\n *    Specify output format [default short_ascii]<ul><li><b>short_ascii<\/b><\/li><li><b>short_html<\/b><\/li><li><b>milestone_html<\/b><\/li><\/ul><\/li>\n *   <li id=\"option:comment-re\"><b>--comment-re=<\/b><i>string<\/i>.\n *    Regex that matches an entire comment (not just a comment start) [default ^%.*]<\/li>\n *   <li id=\"option:include-re\"><b>--include-re=<\/b><i>string<\/i>.\n *    Regex that matches an include directive; group 1 is the file name [default \\\\include\\{(.*)\\}]<\/li>\n * <\/ul>\n * <!-- end options doc -->\n *\/\n","className":"TaskManager","fields":[{"fieldRange":"(line 55,col 3)-(line 56,col 56)","fieldName":"responsible","fieldJavadocComment":" Command line options","fieldTokenRange":"@Option(\"-r Include only those tasks assigned to the specified person\")\n  public static \/*@Nullable*\/ String responsible = null;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 55,col 11)-(line 55,col 72)","literalExprId":1,"literalExpr":"\"-r Include only those tasks assigned to the specified person\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 56,col 52)-(line 56,col 55)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 58,col 3)-(line 59,col 54)","fieldName":"milestone","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-m Include only those tasks required for the specified milestone\")\n  public static \/*@Nullable*\/ String milestone = null;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 58,col 11)-(line 58,col 76)","literalExprId":1,"literalExpr":"\"-m Include only those tasks required for the specified milestone\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 59,col 50)-(line 59,col 53)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 61,col 3)-(line 62,col 42)","fieldName":"completed","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-c Include only completed tasks\")\n  public static boolean completed = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 61,col 11)-(line 61,col 43)","literalExprId":1,"literalExpr":"\"-c Include only completed tasks\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 62,col 37)-(line 62,col 41)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 64,col 3)-(line 65,col 37)","fieldName":"open","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-o Include only open tasks\")\n  public static boolean open = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 64,col 11)-(line 64,col 38)","literalExprId":1,"literalExpr":"\"-o Include only open tasks\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 65,col 32)-(line 65,col 36)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 67,col 3)-(line 68,col 40)","fieldName":"verbose","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-v Print progress information\")\n  public static boolean verbose = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 67,col 11)-(line 67,col 41)","literalExprId":1,"literalExpr":"\"-v Print progress information\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 35)-(line 68,col 39)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 70,col 3)-(line 71,col 63)","fieldName":"format","fieldJavadocComment":"","fieldTokenRange":"@Option(\"-f Specify output format\")\n  public static OutputFormat format = OutputFormat.short_ascii;","fieldTypeResolved":"ReferenceType{plume.TaskManager.OutputFormat, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 70,col 11)-(line 70,col 36)","literalExprId":1,"literalExpr":"\"-f Specify output format\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[OutputFormat.short_ascii]","fieldType":"OutputFormat","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.TaskManager.OutputFormat"},{"fieldRange":"(line 73,col 3)-(line 74,col 54)","fieldName":"comment_re","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Regex that matches an entire comment (not just a comment start)\")\n  public static \/*@Regex*\/ String comment_re = \"^%.*\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 73,col 11)-(line 73,col 75)","literalExprId":1,"literalExpr":"\"Regex that matches an entire comment (not just a comment start)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 74,col 48)-(line 74,col 53)","literalExprId":2,"literalExpr":"\"^%.*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"^%.*\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 76,col 3)-(line 77,col 74)","fieldName":"include_re","fieldJavadocComment":"","fieldTokenRange":"@Option(\"Regex that matches an include directive; group 1 is the file name\")\n  public static \/*@Regex(1)*\/ String include_re = \"\\\\\\\\include\\\\{(.*)\\\\}\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 76,col 11)-(line 76,col 77)","literalExprId":1,"literalExpr":"\"Regex that matches an include directive; group 1 is the file name\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 77,col 51)-(line 77,col 73)","literalExprId":2,"literalExpr":"\"\\\\\\\\include\\\\{(.*)\\\\}\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"\\\\\\\\include\\\\{(.*)\\\\}\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 79,col 3)-(line 79,col 90)","fieldName":"usage_string","fieldJavadocComment":"","fieldTokenRange":"private static String usage_string = \"TaskManger [options] <task-file> <task_file> ...\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 79,col 40)-(line 79,col 89)","literalExprId":1,"literalExpr":"\"TaskManger [options] <task-file> <task_file> ...\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"TaskManger [options] <task-file> <task_file> ...\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 81,col 3)-(line 82,col 87)","fieldName":"lineSep","fieldJavadocComment":"","fieldTokenRange":"@SuppressWarnings(\"regex\") \/\/ line.separator property is a legal regex\n  public static final \/*@Regex*\/ String lineSep = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 81,col 21)-(line 81,col 27)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 82,col 70)-(line 82,col 85)","literalExprId":2,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 270,col 3)-(line 270,col 50)","fieldName":"tasks","fieldJavadocComment":" List of all of the tasks. ","fieldTokenRange":"public List<Task> tasks = new ArrayList<Task>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.TaskManager.Task, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<Task>()]","fieldType":"List<Task>","fieldJavadoc":"List of all of the tasks.\n","fieldTypeResolvedDescribed":"java.util.List<plume.TaskManager.Task>"}]}],"sourceFileId":17,"packageName":"plume"},{"sourceFileName":"plume.WeakHasherMap","imports":[{"importId":1,"import":"import java.util.Iterator;\n"},{"importId":2,"import":"import java.util.Map;\n"},{"importId":3,"import":"import java.util.AbstractMap;\n"},{"importId":4,"import":"import java.util.HashMap;\n"},{"importId":5,"import":"import java.util.Set;\n"},{"importId":6,"import":"import java.util.AbstractSet;\n"},{"importId":7,"import":"import java.util.NoSuchElementException;\n"},{"importId":8,"import":"import java.lang.ref.WeakReference;\n"},{"importId":9,"import":"import java.lang.ref.ReferenceQueue;\n"},{"importId":10,"import":"import plume.Hasher;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the initial capacity of the\n                         <code>WeakHashMap<\/code>","javadocBlockTagName":"initialCapacity","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n                         <code>WeakHashMap<\/code>'}]}', name=Optional[initialCapacity]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the load factor of the <code>WeakHashMap<\/code>","javadocBlockTagName":"loadFactor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the load factor of the <code>WeakHashMap<\/code>'}]}', name=Optional[loadFactor]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If the initial capacity is less than\n                                  zero, or if the load factor is\n                                  nonpositive","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is less than\n                                  zero, or if the load factor is\n                                  nonpositive'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"plume.WeakHasherMap.WeakHasherMap(int, float)","variableDeclarationExprs":[],"constructorRange":"(line 243,col 5)-(line 245,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakHashMap<\/code> with the given\n     * initial capacity and the given load factor.\n     *\n     * @param  initialCapacity  the initial capacity of the\n     *                          <code>WeakHashMap<\/code>\n     *\n     * @param  loadFactor       the load factor of the <code>WeakHashMap<\/code>\n     *\n     * @throws IllegalArgumentException  If the initial capacity is less than\n     *                                   zero, or if the load factor is\n     *                                   nonpositive\n     ","constructorDeclaration":"public WeakHasherMap(int initialCapacity, float loadFactor)","constructorBody":"{\n    hash = new HashMap<WeakKey, V>(initialCapacity, loadFactor);\n}","constructorName":"WeakHasherMap","constructorQualifiedName":"plume.WeakHasherMap.WeakHasherMap","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int initialCapacity","parameterName":"initialCapacity"},{"parameterType":"float","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='float'}","parameterTypeResolvedDescribed":"float","parameter":"float loadFactor","parameterName":"loadFactor"}],"literalExprs":[],"constructorTokenRange":"public WeakHasherMap(int initialCapacity, float loadFactor) {\n\thash = new HashMap<WeakKey,V>(initialCapacity, loadFactor);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakHashMap<\/code> with the given\ninitial capacity and the given load factor.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n                         <code>WeakHashMap<\/code>'}]}', name=Optional[initialCapacity]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the load factor of the <code>WeakHashMap<\/code>'}]}', name=Optional[loadFactor]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is less than\n                                  zero, or if the load factor is\n                                  nonpositive'}]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the initial capacity of the\n                         <code>WeakHashMap<\/code>","javadocBlockTagName":"initialCapacity","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n                         <code>WeakHashMap<\/code>'}]}', name=Optional[initialCapacity]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If the initial capacity is less than\n                                  zero","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is less than\n                                  zero'}]}', name=Optional[IllegalArgumentException]}"}],"constructorQualifiedSignature":"plume.WeakHasherMap.WeakHasherMap(int)","variableDeclarationExprs":[],"constructorRange":"(line 258,col 5)-(line 260,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakHashMap<\/code> with the given\n     * initial capacity and the default load factor, which is\n     * <code>0.75<\/code>.\n     *\n     * @param  initialCapacity  the initial capacity of the\n     *                          <code>WeakHashMap<\/code>\n     *\n     * @throws IllegalArgumentException  If the initial capacity is less than\n     *                                   zero\n     ","constructorDeclaration":"public WeakHasherMap(int initialCapacity)","constructorBody":"{\n    hash = new HashMap<WeakKey, V>(initialCapacity);\n}","constructorName":"WeakHasherMap","constructorQualifiedName":"plume.WeakHasherMap.WeakHasherMap","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int initialCapacity","parameterName":"initialCapacity"}],"literalExprs":[],"constructorTokenRange":"public WeakHasherMap(int initialCapacity) {\n\thash = new HashMap<WeakKey,V>(initialCapacity);\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakHashMap<\/code> with the given\ninitial capacity and the default load factor, which is\n<code>0.75<\/code>.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the initial capacity of the\n                         <code>WeakHashMap<\/code>'}]}', name=Optional[initialCapacity]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the initial capacity is less than\n                                  zero'}]}', name=Optional[IllegalArgumentException]}]}"},{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.WeakHasherMap.WeakHasherMap()","variableDeclarationExprs":[],"constructorRange":"(line 266,col 5)-(line 268,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakHashMap<\/code> with the default\n     * capacity and the default load factor, which is <code>0.75<\/code>.\n     ","constructorDeclaration":"public WeakHasherMap()","constructorBody":"{\n    hash = new HashMap<WeakKey, V>();\n}","constructorName":"WeakHasherMap","constructorQualifiedName":"plume.WeakHasherMap.WeakHasherMap","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public WeakHasherMap() {\n\thash = new HashMap<WeakKey,V>();\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakHashMap<\/code> with the default\ncapacity and the default load factor, which is <code>0.75<\/code>.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Hasher to use when hashing values for this map","javadocBlockTagName":"h","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Hasher to use when hashing values for this map'}]}', name=Optional[h]}"}],"constructorQualifiedSignature":"plume.WeakHasherMap.WeakHasherMap(plume.Hasher)","variableDeclarationExprs":[],"constructorRange":"(line 277,col 5)-(line 280,col 5)","constructorJavadocComment":"\n     * Constructs a new, empty <code>WeakHashMap<\/code> with the default\n     * capacity and the default load factor, which is <code>0.75<\/code>.\n     * The <code>WeakHashMap<\/code> uses the specified hasher for hashing\n     * keys and comparing them for equality.\n     * @param h the Hasher to use when hashing values for this map\n     ","constructorDeclaration":"public WeakHasherMap(Hasher h)","constructorBody":"{\n    hash = new HashMap<WeakKey, V>();\n    hasher = h;\n}","constructorName":"WeakHasherMap","constructorQualifiedName":"plume.WeakHasherMap.WeakHasherMap","constructorParameters":[{"parameterType":"Hasher","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.Hasher, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.Hasher","parameter":"Hasher h","parameterName":"h"}],"literalExprs":[],"constructorTokenRange":"public WeakHasherMap(Hasher h) {\n\thash = new HashMap<WeakKey,V>();\n\thasher = h;\n    }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Constructs a new, empty <code>WeakHashMap<\/code> with the default\ncapacity and the default load factor, which is <code>0.75<\/code>.\nThe <code>WeakHashMap<\/code> uses the specified hasher for hashing\nkeys and comparing them for equality.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Hasher to use when hashing values for this map'}]}', name=Optional[h]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 157,col 5)-(line 204,col 5)","classOrInterfaceTokenRange":"private final class WeakKey extends WeakReference<K> {\n\tprivate int hash;\t\/* Hashcode of key, stored here since the key\n\t\t\t\t   may be tossed by the GC *\/\n\n\tprivate WeakKey(K k) {\n\t    super(k);\n\t    hash = keyHashCode(k);\n\t}\n\n\tprivate \/*@Nullable*\/ WeakKey create(K k) {\n\t    if (k == null) return null;\n\t    else return new WeakKey(k);\n\t}\n\n\tprivate WeakKey(K k, ReferenceQueue<? super K> q) {\n\t    super(k, q);\n\t    hash = keyHashCode(k);\n\t}\n\n\tprivate \/*@Nullable*\/ WeakKey create(K k, ReferenceQueue<? super K> q) {\n\t    if (k == null) return null;\n\t    else return new WeakKey(k, q);\n\t}\n\n        \/* A WeakKey is equal to another WeakKey iff they both refer to objects\n\t   that are, in turn, equal according to their own equals methods *\/\n\t\/*@Pure*\/\n  public boolean equals(\/*@Nullable*\/ Object o) {\n            if (o == null) return false; \/\/ never happens\n\t    if (this == o) return true;\n            \/\/ This test is illegal because WeakKey is a generic type,\n            \/\/ so use the getClass hack below instead.\n\t    \/\/ if (!(o instanceof WeakKey)) return false;\n            if (!(o.getClass().equals(WeakKey.class))) return false;\n\t    Object t = this.get();\n            @SuppressWarnings(\"unchecked\")\n\t    Object u = ((WeakKey)o).get();\n\t    if ((t == null) || (u == null)) return false;\n\t    if (t == u) return true;\n\t    return keyEquals(t, u);\n\t}\n\n\t\/*@Pure*\/\n  public int hashCode() {\n\t    return hash;\n\t}\n\n    }","classOrInterfaceJavadocComment":" Cannot be a static class: uses keyHashCode() and keyEquals()","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 383,col 5)-(line 433,col 5)","classOrInterfaceTokenRange":"private final class Entry<K,V> implements Map.Entry<K,V> {\n\tprivate Map.Entry<WeakKey,V> ent;\n\tprivate K key;\t\/* Strong reference to key, so that the GC\n\t\t\t\t   will leave it alone as long as this Entry\n\t\t\t\t   exists *\/\n\n\tEntry(Map.Entry<WeakKey,V> ent, K key) {\n\t    this.ent = ent;\n\t    this.key = key;\n\t}\n\n\t\/*@Pure*\/\n  public K getKey() {\n\t    return key;\n\t}\n\n\t\/*@Pure*\/\n  public V getValue() {\n\t    return ent.getValue();\n\t}\n\n\tpublic V setValue(V value) {\n\t    return ent.setValue(value);\n\t}\n\n        \/*@Pure*\/\n        private boolean keyvalEquals(K o1, K o2) {\n\t    return (o1 == null) ? (o2 == null) : keyEquals(o1, o2);\n\t}\n\n        \/*@Pure*\/\n        private boolean valEquals(V o1, V o2) {\n\t    return (o1 == null) ? (o2 == null) : o1.equals(o2);\n\t}\n\n        \/*@Pure*\/\n        public boolean equals(Map.Entry<K,V> e \/* Object o*\/) {\n            \/\/ if (! (o instanceof Map.Entry)) return false;\n            \/\/ Map.Entry<K,V> e = (Map.Entry<K,V>)o;\n\t    return (keyvalEquals(key, e.getKey())\n\t\t    && valEquals(getValue(), e.getValue()));\n\t}\n\n\t\/*@Pure*\/\n  public int hashCode() {\n\t    V v;\n\t    return (((key == null) ? 0 : keyHashCode(key))\n\t\t    ^ (((v = getValue()) == null) ? 0 : v.hashCode()));\n\t}\n\n    }","classOrInterfaceJavadocComment":" This can't be static, again because of dependence on hasher.","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 437,col 5)-(line 518,col 5)","classOrInterfaceTokenRange":"private final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n\tSet<Map.Entry<WeakKey,V>> hashEntrySet = hash.entrySet();\n\n\tpublic Iterator<Map.Entry<K,V>> iterator() {\n\n\t    return new Iterator<Map.Entry<K,V>>() {\n\t\tIterator<Map.Entry<WeakKey,V>> hashIterator = hashEntrySet.iterator();\n\t\tMap.Entry<K,V> next = null;\n\n\t\tpublic boolean hasNext() {\n\t\t    while (hashIterator.hasNext()) {\n\t\t\tMap.Entry<WeakKey,V> ent = hashIterator.next();\n\t\t\tWeakKey wk = ent.getKey();\n\t\t\tK k = null;\n\t\t\tif ((wk != null) && ((k = wk.get()) == null)) {\n\t\t\t    \/* Weak key has been cleared by GC *\/\n\t\t\t    continue;\n\t\t\t}\n\t\t\tnext = new Entry<K,V>(ent, k);\n\t\t\treturn true;\n\t\t    }\n\t\t    return false;\n\t\t}\n\n\t\tpublic Map.Entry<K,V> next() {\n\t\t    if ((next == null) && !hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\t    Map.Entry<K,V> e = next;\n\t\t    next = null;\n\t\t    return e;\n\t\t}\n\n\t\tpublic void remove() {\n\t\t    hashIterator.remove();\n\t\t}\n\n\t    };\n\t}\n\n\t\/*@Pure*\/\n  public boolean isEmpty() {\n\t    return !(iterator().hasNext());\n\t}\n\n\t\/*@Pure*\/\n  public int size() {\n\t    int j = 0;\n\t    for (Iterator<Map.Entry<K,V>> i = iterator(); i.hasNext(); i.next()) j++;\n\t    return j;\n\t}\n\n\tpublic boolean remove(Object o) {\n\t    processQueue();\n\t    if (!(o instanceof Map.Entry<?,?>)) return false;\n            @SuppressWarnings(\"unchecked\")\n\t    Map.Entry<K,V> e = (Map.Entry<K,V>)o; \/\/ unchecked cast\n\t    Object ev = e.getValue();\n\t    WeakKey wk = WeakKeyCreate(e.getKey());\n\t    Object hv = hash.get(wk);\n\t    if ((hv == null)\n\t\t? ((ev == null) && hash.containsKey(wk)) : hv.equals(ev)) {\n\t\thash.remove(wk);\n\t\treturn true;\n\t    }\n\t    return false;\n\t}\n\n\t\/*@Pure*\/\n  public int hashCode() {\n\t    int h = 0;\n\t    for (Iterator<Map.Entry<WeakKey,V>> i = hashEntrySet.iterator(); i.hasNext(); ) {\n\t\tMap.Entry<WeakKey,V> ent = i.next();\n\t\tWeakKey wk = ent.getKey();\n\t\tObject v;\n\t\tif (wk == null) continue;\n\t\th += (wk.hashCode()\n\t\t      ^ (((v = ent.getValue()) == null) ? 0 : v.hashCode()));\n\t    }\n\t    return h;\n\t}\n\n    }","classOrInterfaceJavadocComment":" Internal class for entry sets ","classOrInterfaceJavadoc":""}],"methods":[{"methodDeclaration":"private boolean keyEquals(Object k1, Object k2)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (hasher == null ? k1.equals(k2) : hasher.equals(k1, k2));\n}","methodRange":"(line 131,col 5)-(line 134,col 5)","methodTokenRange":"private boolean keyEquals(Object k1, Object k2) {\n\treturn (hasher==null ? k1.equals(k2)\n\t\t\t     : hasher.equals(k1, k2));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object k1","parameterName":"k1"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object k2","parameterName":"k2"}],"methodName":"keyEquals","methodQualifiedSignature":"plume.WeakHasherMap.keyEquals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 132,col 18)-(line 132,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.keyEquals(java.lang.Object, java.lang.Object)"},{"methodDeclaration":"private int keyHashCode(Object k1)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return (hasher == null ? k1.hashCode() : hasher.hashCode(k1));\n}","methodRange":"(line 136,col 5)-(line 139,col 5)","methodTokenRange":"private int keyHashCode(Object k1) {\n\treturn (hasher==null ? k1.hashCode()\n\t\t\t     : hasher.hashCode(k1));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object k1","parameterName":"k1"}],"methodName":"keyHashCode","methodQualifiedSignature":"plume.WeakHasherMap.keyHashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 137,col 18)-(line 137,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.keyHashCode(java.lang.Object)"},{"methodDeclaration":"private WeakKey WeakKeyCreate(K k)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (k == null)\n        return null;\n    else\n        return new WeakKey(k);\n}","methodRange":"(line 147,col 5)-(line 150,col 5)","methodTokenRange":"private \/*@Nullable*\/ WeakKey WeakKeyCreate(K k) {\n\tif (k == null) return null;\n\telse return new WeakKey(k);\n    }","methodReturnTypeResolved":"ReferenceType{plume.WeakHasherMap.WeakKey, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"K","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(K, bounds=[])}","parameterTypeResolvedDescribed":"K","parameter":"K k","parameterName":"k"}],"methodName":"WeakKeyCreate","methodQualifiedSignature":"plume.WeakHasherMap.WeakKeyCreate","methodJavadoc":"","methodReturnTypeDescribed":"plume.WeakHasherMap.WeakKey","methodType":"WeakKey","literalExprs":[{"literalExprRange":"(line 148,col 11)-(line 148,col 14)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 148,col 24)-(line 148,col 27)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.WeakKeyCreate(K)"},{"methodDeclaration":"private WeakKey WeakKeyCreate(K k, ReferenceQueue<? super K> q)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (k == null)\n        return null;\n    else\n        return new WeakKey(k, q);\n}","methodRange":"(line 151,col 5)-(line 154,col 5)","methodTokenRange":"private \/*@Nullable*\/ WeakKey WeakKeyCreate(K k, ReferenceQueue<? super K> q) {\n\tif (k == null) return null;\n\telse return new WeakKey(k, q);\n    }","methodReturnTypeResolved":"ReferenceType{plume.WeakHasherMap.WeakKey, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"K","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(K, bounds=[])}","parameterTypeResolvedDescribed":"K","parameter":"K k","parameterName":"k"},{"parameterType":"ReferenceQueue<? super K>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.ref.ReferenceQueue, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.ReferenceQueue.T=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.lang.ref.ReferenceQueue<? super K>","parameter":"ReferenceQueue<? super K> q","parameterName":"q"}],"methodName":"WeakKeyCreate","methodQualifiedSignature":"plume.WeakHasherMap.WeakKeyCreate","methodJavadoc":"","methodReturnTypeDescribed":"plume.WeakHasherMap.WeakKey","methodType":"WeakKey","literalExprs":[{"literalExprRange":"(line 152,col 11)-(line 152,col 14)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 152,col 24)-(line 152,col 27)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.WeakKeyCreate(K, java.lang.ref.ReferenceQueue<? super K>)"},{"methodDeclaration":"private void processQueue()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    WeakKey wk;\n    while ((wk = (WeakKey) queue.poll()) != null) {\n        hash.remove(wk);\n    }\n}","methodRange":"(line 219,col 5)-(line 225,col 5)","methodTokenRange":"@SuppressWarnings(\"unchecked\")\n    private void processQueue() {\n\tWeakKey wk;\n\twhile ((wk = (WeakKey)queue.poll()) != null) { \/\/ unchecked cast\n\t    hash.remove(wk);\n\t}\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Remove all invalidated entries from the map, that is, remove all entries\n       whose keys have been discarded.  This method should be invoked once by\n       each public mutator in this class.  We don't invoke this method in\n       public accessors because that can lead to surprising\n       ConcurrentModificationExceptions. ","methodParameters":[],"methodName":"processQueue","methodQualifiedSignature":"plume.WeakHasherMap.processQueue","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 219,col 23)-(line 219,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 222,col 41)-(line 222,col 44)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.processQueue()"},{"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return entrySet().size();\n}","methodRange":"(line 292,col 5)-(line 294,col 5)","methodTokenRange":"public int size() {\n\treturn entrySet().size();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"size","methodQualifiedSignature":"plume.WeakHasherMap.size","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.WeakHasherMap.size()"},{"methodDeclaration":"public boolean isEmpty()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return entrySet().isEmpty();\n}","methodRange":"(line 300,col 5)-(line 302,col 5)","methodTokenRange":"public boolean isEmpty() {\n\treturn entrySet().isEmpty();\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"isEmpty","methodQualifiedSignature":"plume.WeakHasherMap.isEmpty","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.WeakHasherMap.isEmpty()"},{"methodDeclaration":"public boolean containsKey(Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"unchecked\")\n    K kkey = (K) key;\n    return hash.containsKey(WeakKeyCreate(kkey));\n}","methodRange":"(line 311,col 5)-(line 315,col 5)","methodTokenRange":"public boolean containsKey(Object key) {\n        @SuppressWarnings(\"unchecked\")\n        K kkey = (K) key;\n\treturn hash.containsKey(WeakKeyCreate(kkey));\n    }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"containsKey","methodQualifiedSignature":"plume.WeakHasherMap.containsKey","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 312,col 27)-(line 312,col 37)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.containsKey(java.lang.Object)"},{"methodDeclaration":"public V get(Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"unchecked\")\n    K kkey = (K) key;\n    return hash.get(WeakKeyCreate(kkey));\n}","methodRange":"(line 328,col 5)-(line 332,col 5)","methodTokenRange":"public \/*@Nullable*\/ V get(Object key) {  \/\/ type of argument is Object, not K\n        @SuppressWarnings(\"unchecked\")\n        K kkey = (K) key;\n\treturn hash.get(WeakKeyCreate(kkey));\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"get","methodQualifiedSignature":"plume.WeakHasherMap.get","methodJavadoc":"","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 329,col 27)-(line 329,col 37)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.get(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the key that is to be mapped to the given\n               <code>value<\/code>","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the key that is to be mapped to the given\n               <code>value<\/code>'}]}', name=Optional[key]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to which the given <code>key<\/code> is to be\n               mapped","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to which the given <code>key<\/code> is to be\n               mapped'}]}', name=Optional[value]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the previous value to which this key was mapped, or\n         <code>null<\/code> if if there was no mapping for the key","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the previous value to which this key was mapped, or\n         <code>null<\/code> if if there was no mapping for the key'}]}', name=Optional.empty}"}],"methodDeclaration":"public V put(K key, V value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    processQueue();\n    return hash.put(WeakKeyCreate(key, queue), value);\n}","methodRange":"(line 348,col 5)-(line 351,col 5)","methodTokenRange":"public V put(K key, V value) {\n\tprocessQueue();\n\treturn hash.put(WeakKeyCreate(key, queue), value);\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Updates this map so that the given <code>key<\/code> maps to the given\n     * <code>value<\/code>.  If the map previously contained a mapping for\n     * <code>key<\/code> then that mapping is replaced and the previous value is\n     * returned.\n     *\n     * @param  key    the key that is to be mapped to the given\n     *                <code>value<\/code>\n     * @param  value  the value to which the given <code>key<\/code> is to be\n     *                mapped\n     *\n     * @return  the previous value to which this key was mapped, or\n     *          <code>null<\/code> if if there was no mapping for the key\n     ","methodParameters":[{"parameterType":"K","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(K, bounds=[])}","parameterTypeResolvedDescribed":"K","parameter":"K key","parameterName":"key"},{"parameterType":"V","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","parameterTypeResolvedDescribed":"V","parameter":"V value","parameterName":"value"}],"methodName":"put","methodQualifiedSignature":"plume.WeakHasherMap.put","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Updates this map so that the given <code>key<\/code> maps to the given\n<code>value<\/code>.  If the map previously contained a mapping for\n<code>key<\/code> then that mapping is replaced and the previous value is\nreturned.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the key that is to be mapped to the given\n               <code>value<\/code>'}]}', name=Optional[key]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to which the given <code>key<\/code> is to be\n               mapped'}]}', name=Optional[value]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the previous value to which this key was mapped, or\n         <code>null<\/code> if if there was no mapping for the key'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[],"methodQualifiedName":"plume.WeakHasherMap.put(K, V)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the key whose mapping is to be removed","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the key whose mapping is to be removed'}]}', name=Optional[key]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the value to which this key was mapped, or <code>null<\/code> if\n         there was no mapping for the key","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value to which this key was mapped, or <code>null<\/code> if\n         there was no mapping for the key'}]}', name=Optional.empty}"}],"methodDeclaration":"public V remove(Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    processQueue();\n    @SuppressWarnings(\"unchecked\")\n    K kkey = (K) key;\n    return hash.remove(WeakKeyCreate(kkey));\n}","methodRange":"(line 362,col 5)-(line 367,col 5)","methodTokenRange":"public V remove(Object key) { \/\/ type of argument is Object, not K\n\tprocessQueue();\n        @SuppressWarnings(\"unchecked\")\n        K kkey = (K) key;\n\treturn hash.remove(WeakKeyCreate(kkey));\n    }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(V, bounds=[])}","methodJavadocComment":"\n     * Removes the mapping for the given <code>key<\/code> from this map, if\n     * present.\n     *\n     * @param  key  the key whose mapping is to be removed\n     *\n     * @return  the value to which this key was mapped, or <code>null<\/code> if\n     *          there was no mapping for the key\n     ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"remove","methodQualifiedSignature":"plume.WeakHasherMap.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes the mapping for the given <code>key<\/code> from this map, if\npresent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the key whose mapping is to be removed'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the value to which this key was mapped, or <code>null<\/code> if\n         there was no mapping for the key'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"V","methodType":"V","literalExprs":[{"literalExprRange":"(line 364,col 27)-(line 364,col 37)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.remove(java.lang.Object)"},{"javadocBlockTags":[],"methodDeclaration":"public void clear()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    processQueue();\n    hash.clear();\n}","methodRange":"(line 372,col 5)-(line 375,col 5)","methodTokenRange":"public void clear() {\n\tprocessQueue();\n\thash.clear();\n    }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n     * Removes all mappings from this map.\n     ","methodParameters":[],"methodName":"clear","methodQualifiedSignature":"plume.WeakHasherMap.clear","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Removes all mappings from this map.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.WeakHasherMap.clear()"},{"methodDeclaration":"public Set<Map.Entry<K, V>> entrySet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (entrySet == null)\n        entrySet = new EntrySet();\n    return entrySet;\n}","methodRange":"(line 527,col 5)-(line 530,col 5)","methodTokenRange":"public Set<Map.Entry<K,V>> entrySet() {\n\tif (entrySet == null) entrySet = new EntrySet();\n\treturn entrySet;\n    }","methodReturnTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"entrySet","methodQualifiedSignature":"plume.WeakHasherMap.entrySet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Set<java.util.Map.Entry<K, V>>","methodType":"Set<Map.Entry<K, V>>","literalExprs":[{"literalExprRange":"(line 528,col 18)-(line 528,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.WeakHasherMap.entrySet()"}],"classJavadoc":"","className":"WeakHasherMap","fields":[{"fieldRange":"(line 129,col 5)-(line 129,col 33)","fieldName":"hasher","fieldJavadocComment":"","fieldTokenRange":"private Hasher hasher = null;","fieldTypeResolved":"ReferenceType{plume.Hasher, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 129,col 29)-(line 129,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Hasher","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.Hasher"},{"fieldRange":"(line 208,col 5)-(line 208,col 32)","fieldName":"hash","fieldJavadocComment":" Hash table mapping WeakKeys to values ","fieldTokenRange":"private Map<WeakKey,V> hash;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{plume.WeakHasherMap.WeakKey, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<WeakKey, V>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<plume.WeakHasherMap.WeakKey, V>"},{"fieldRange":"(line 211,col 5)-(line 211,col 70)","fieldName":"queue","fieldJavadocComment":" Reference queue for cleared WeakKeys ","fieldTokenRange":"private ReferenceQueue<? super K> queue = new ReferenceQueue<K>();","fieldTypeResolved":"ReferenceType{java.lang.ref.ReferenceQueue, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.ReferenceQueue.T=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(K, bounds=[])}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ReferenceQueue<K>()]","fieldType":"ReferenceQueue<? super K>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.ref.ReferenceQueue<? super K>"},{"fieldRange":"(line 521,col 5)-(line 521,col 62)","fieldName":"entrySet","fieldJavadocComment":"","fieldTokenRange":"private \/*@Nullable*\/ Set<Map.Entry<K,V>> entrySet = null;","fieldTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=ReferenceType{java.util.Map.Entry, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.Entry.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.Entry.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 521,col 58)-(line 521,col 61)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Set<Map.Entry<K, V>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Set<java.util.Map.Entry<K, V>>"}]}],"sourceFileId":18,"packageName":"plume"},{"sourceFileName":"plume.ClassFileVersion","imports":[{"importId":1,"import":"import java.io.DataInputStream;\n"},{"importId":2,"import":"import java.io.File;\n"},{"importId":3,"import":"import java.io.FileInputStream;\n"},{"importId":4,"import":"import java.io.IOException;\n"},{"importId":5,"import":"import java.io.InputStream;\n"},{"importId":6,"import":"import java.util.Enumeration;\n"},{"importId":7,"import":"import java.util.jar.JarEntry;\n"},{"importId":8,"import":"import java.util.jar.JarFile;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.ClassFileVersion.ClassFileVersion()","variableDeclarationExprs":[],"constructorRange":"(line 31,col 3)-(line 33,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private ClassFileVersion()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"ClassFileVersion","constructorQualifiedName":"plume.ClassFileVersion.ClassFileVersion","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 32,col 21)-(line 32,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private ClassFileVersion() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"command-line arguments","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments'}]}', name=Optional[args]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if a file cannot be read","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a file cannot be read'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static void main(String[] args) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (args.length == 0) {\n        System.out.println(\"Supplied no arguments.\");\n        System.out.println(\"Usage: java ClassFileVersion [-min JDKVER] <.class or .jar files>\");\n        System.exit(1);\n    }\n    if ((args.length >= 2) && (args[0].equals(\"-min\"))) {\n        minversion = Double.parseDouble(args[1]);\n        if (minversion == 1.6) {\n            minversion = 6;\n        } else if (minversion == 1.7) {\n            minversion = 7;\n        }\n        args = ArraysMDE.subarray(args, 2, args.length - 2);\n    }\n    for (String filename : args) {\n        if (!new File(filename).exists()) {\n            System.out.println(filename + \" does not exist!\");\n            continue;\n        }\n        if (filename.endsWith(\".class\")) {\n            try (FileInputStream fis = new FileInputStream(filename)) {\n                processClassFile(filename, fis);\n            }\n        } else if (filename.endsWith(\".jar\")) {\n            JarFile jarFile = new JarFile(filename);\n            for (Enumeration<JarEntry> e = jarFile.entries(); e.hasMoreElements(); ) {\n                JarEntry entry = e.nextElement();\n                String entryName = entry.getName();\n                if (entryName.endsWith(\".class\")) {\n                    try (InputStream is = jarFile.getInputStream(entry)) {\n                        processClassFile(filename + \":\" + entryName, is);\n                    }\n                }\n            }\n        } else {\n            System.out.println(filename + \" is neither a .class nor a .jar file\");\n        }\n    }\n}","methodRange":"(line 42,col 3)-(line 88,col 3)","methodTokenRange":"public static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n      System.out.println(\"Supplied no arguments.\");\n      System.out.println(\"Usage: java ClassFileVersion [-min JDKVER] <.class or .jar files>\");\n      System.exit(1);\n    }\n\n    \/\/ Process and remove \"-min JDKVER\" command-line argument, if present.\n    if ((args.length >= 2) && (args[0].equals(\"-min\"))) {\n      minversion = Double.parseDouble(args[1]);\n      if (minversion == 1.6) {\n        minversion = 6;\n      } else if (minversion == 1.7) {\n        minversion = 7;\n      }\n      args = ArraysMDE.subarray(args, 2, args.length - 2);\n    }\n\n    \/\/ System.out.println(\"newargs: \" + java.util.Arrays.toString(args));\n\n    for (String filename : args) {\n      if (!new File(filename).exists()) {\n        System.out.println(filename + \" does not exist!\");\n        continue;\n      }\n\n      if (filename.endsWith(\".class\")) {\n        try (FileInputStream fis = new FileInputStream(filename)) {\n          processClassFile(filename, fis);\n        }\n      } else if (filename.endsWith(\".jar\")) {\n        JarFile jarFile = new JarFile(filename);\n        for (Enumeration<JarEntry> e = jarFile.entries(); e.hasMoreElements(); ) {\n          JarEntry entry = e.nextElement();\n          String entryName = entry.getName();\n          \/\/ Should really process recursively included jar files...\n          if (entryName.endsWith(\".class\")) {\n            try (InputStream is = jarFile.getInputStream(entry)) {\n              processClassFile(filename + \":\" + entryName, is);\n            }\n          }\n        }\n      } else {\n        System.out.println(filename + \" is neither a .class nor a .jar file\");\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Main method for the ClassFileVersion program.\n   * @param args command-line arguments\n   * @throws IOException if a file cannot be read\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.ClassFileVersion.main","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Main method for the ClassFileVersion program.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments'}]}', name=Optional[args]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a file cannot be read'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 43,col 24)-(line 43,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 44,col 26)-(line 44,col 49)","literalExprId":2,"literalExpr":"\"Supplied no arguments.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 45,col 26)-(line 45,col 92)","literalExprId":3,"literalExpr":"\"Usage: java ClassFileVersion [-min JDKVER] <.class or .jar files>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 46,col 19)-(line 46,col 19)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 50,col 25)-(line 50,col 25)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 50,col 37)-(line 50,col 37)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 50,col 47)-(line 50,col 52)","literalExprId":7,"literalExpr":"\"-min\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 51,col 44)-(line 51,col 44)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 52,col 25)-(line 52,col 27)","literalExprId":9,"literalExpr":"1.6","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 53,col 22)-(line 53,col 22)","literalExprId":10,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 54,col 32)-(line 54,col 34)","literalExprId":11,"literalExpr":"1.7","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 55,col 22)-(line 55,col 22)","literalExprId":12,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 57,col 39)-(line 57,col 39)","literalExprId":13,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 57,col 56)-(line 57,col 56)","literalExprId":14,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 64,col 39)-(line 64,col 56)","literalExprId":15,"literalExpr":"\" does not exist!\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 29)-(line 68,col 36)","literalExprId":16,"literalExpr":"\".class\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 72,col 36)-(line 72,col 41)","literalExprId":17,"literalExpr":"\".jar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 34)-(line 78,col 41)","literalExprId":18,"literalExpr":"\".class\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 80,col 43)-(line 80,col 45)","literalExprId":19,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 85,col 39)-(line 85,col 76)","literalExprId":20,"literalExpr":"\" is neither a .class nor a .jar file\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ClassFileVersion.main(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"file name to appear in printed messages","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file name to appear in printed messages'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"input stream from which to read classfile bytes to process","javadocBlockTagName":"is","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream from which to read classfile bytes to process'}]}', name=Optional[is]}"}],"methodDeclaration":"public static void processClassFile(String filename, InputStream is)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double[] versions = versionNumbers(is);\n    if (versions == null) {\n        System.out.println(filename + \" is not a .class file (or IOException)\");\n    } else {\n        double major = versions[0];\n        double minor = versions[1];\n        double jdkVersion = versions[2];\n        if (jdkVersion >= minversion) {\n            System.out.println(filename + \" class file version is \" + (int) major + \".\" + (int) minor + \", requires JDK \" + ((jdkVersion == (int) jdkVersion) ? Integer.toString((int) jdkVersion) : Double.toString(jdkVersion)) + \" or later\");\n        }\n    }\n}","methodRange":"(line 95,col 3)-(line 118,col 3)","methodTokenRange":"public static void processClassFile(String filename, InputStream is) {\n    double[] versions = versionNumbers(is);\n    if (versions == null) {\n      System.out.println(filename + \" is not a .class file (or IOException)\");\n    } else {\n      double major = versions[0];\n      double minor = versions[1];\n      double jdkVersion = versions[2];\n\n      if (jdkVersion >= minversion) {\n        System.out.println(\n            filename\n                + \" class file version is \"\n                + (int) major\n                + \".\"\n                + (int) minor\n                + \", requires JDK \"\n                + ((jdkVersion == (int) jdkVersion)\n                    ? Integer.toString((int) jdkVersion)\n                    : Double.toString(jdkVersion))\n                + \" or later\");\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print, to standard out, the version number for the class file found in is.\n   * @param filename file name to appear in printed messages\n   * @param is input stream from which to read classfile bytes to process\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"InputStream","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream is","parameterName":"is"}],"methodName":"processClassFile","methodQualifiedSignature":"plume.ClassFileVersion.processClassFile","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print, to standard out, the version number for the class file found in is.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file name to appear in printed messages'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream from which to read classfile bytes to process'}]}', name=Optional[is]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 97,col 21)-(line 97,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 98,col 37)-(line 98,col 76)","literalExprId":2,"literalExpr":"\" is not a .class file (or IOException)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 100,col 31)-(line 100,col 31)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 101,col 31)-(line 101,col 31)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 102,col 36)-(line 102,col 36)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 107,col 19)-(line 107,col 43)","literalExprId":6,"literalExpr":"\" class file version is \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 109,col 19)-(line 109,col 21)","literalExprId":7,"literalExpr":"\".\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 111,col 19)-(line 111,col 35)","literalExprId":8,"literalExpr":"\", requires JDK \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 115,col 19)-(line 115,col 29)","literalExprId":9,"literalExpr":"\" or later\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ClassFileVersion.processClassFile(java.lang.String, java.io.InputStream)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"input stream from which to read a class","javadocBlockTagName":"is","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream from which to read a class'}]}', name=Optional[is]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"array of three version numbers","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='array of three version numbers'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double[] versionNumbers(InputStream is)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        DataInputStream dis = new DataInputStream(is);\n        int magic = dis.readInt();\n        if (magic != 0xcafebabe) {\n            return null;\n        }\n        double minor = dis.readShort();\n        double major = dis.readShort();\n        double jdkVersion;\n        if (major < 48) {\n            jdkVersion = 1.3;\n        } else if (major == 48) {\n            jdkVersion = 1.4;\n        } else if (major == 49) {\n            jdkVersion = 1.5;\n        } else if (major == 50) {\n            jdkVersion = 6;\n        } else {\n            jdkVersion = 7;\n        }\n        return new double[] { major, minor, jdkVersion };\n    } catch (IOException e) {\n        return null;\n    }\n}","methodRange":"(line 127,col 3)-(line 155,col 3)","methodTokenRange":"public static double \/*@Nullable*\/ [] versionNumbers(InputStream is) {\n    try {\n      DataInputStream dis = new DataInputStream(is);\n      int magic = dis.readInt();\n      if (magic != 0xcafebabe) {\n        return null;\n      }\n\n      double minor = dis.readShort();\n      double major = dis.readShort();\n      double jdkVersion;\n\n      if (major < 48) {\n        jdkVersion = 1.3; \/\/ really 1.3.1\n      } else if (major == 48) {\n        jdkVersion = 1.4; \/\/ really 1.4.2\n      } else if (major == 49) {\n        jdkVersion = 1.5;\n      } else if (major == 50) {\n        jdkVersion = 6;\n      } else {\n        jdkVersion = 7;\n      }\n\n      return new double[] {major, minor, jdkVersion};\n    } catch (IOException e) {\n      return null;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","methodJavadocComment":"\n   * Return an array of the major vernios, minor version, and JDK version\n   * of the class read from the input stream.\n   * Return null if there is an error or the input isn't a class file.\n   * @param is input stream from which to read a class\n   * @return array of three version numbers\n   ","methodParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream is","parameterName":"is"}],"methodName":"versionNumbers","methodQualifiedSignature":"plume.ClassFileVersion.versionNumbers","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of the major vernios, minor version, and JDK version\nof the class read from the input stream.\nReturn null if there is an error or the input isn't a class file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream from which to read a class'}]}', name=Optional[is]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='array of three version numbers'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double[]","methodType":"double[]","literalExprs":[{"literalExprRange":"(line 131,col 20)-(line 131,col 29)","literalExprId":1,"literalExpr":"0xcafebabe","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 132,col 16)-(line 132,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 139,col 19)-(line 139,col 20)","literalExprId":3,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 140,col 22)-(line 140,col 24)","literalExprId":4,"literalExpr":"1.3","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 141,col 27)-(line 141,col 28)","literalExprId":5,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 142,col 22)-(line 142,col 24)","literalExprId":6,"literalExpr":"1.4","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 143,col 27)-(line 143,col 28)","literalExprId":7,"literalExpr":"49","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 144,col 22)-(line 144,col 24)","literalExprId":8,"literalExpr":"1.5","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 145,col 27)-(line 145,col 28)","literalExprId":9,"literalExpr":"50","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 22)-(line 146,col 22)","literalExprId":10,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 148,col 22)-(line 148,col 22)","literalExprId":11,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 14)-(line 153,col 17)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.ClassFileVersion.versionNumbers(java.io.InputStream)"}],"classJavadoc":"\/**\n * Given a list of .class files, print the class file version and also the\n * JDK\/JRE version required to run it.\n * A .jar file can also be supplied, in which case each .class file within\n * it is processed.\n * Example use:  <pre>  java ClassFileVersion MyClass.class<\/pre>\n * Supplying the \"-min JDKVER\" argument suppresses output except for .class\n * files that require at least that JDK version.  For instance, to list all\n * the .class\/.jar files that require JDK 6 or later, in this or any\n * subdirectory, run\n *   <pre>  find . \\( -name '*.class' -o -name '*.jar' \\) -print | xargs java ClassFileVersion -min 6<\/pre>\n *\/\n","className":"ClassFileVersion","fields":[{"fieldRange":"(line 36,col 3)-(line 36,col 31)","fieldName":"minversion","fieldJavadocComment":" Only report versions that are at least this large. ","fieldTokenRange":"static double minversion = 0;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 36,col 30)-(line 36,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[0]","fieldType":"double","fieldJavadoc":"Only report versions that are at least this large.\n","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":19,"packageName":"plume"},{"sourceFileName":"plume.WeakIdentityPair","imports":[{"importId":1,"import":"import java.lang.ref.WeakReference;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"WeakIdentityPair","constructorQualifiedName":"plume.WeakIdentityPair.WeakIdentityPair","constructorQualifiedSignature":"plume.WeakIdentityPair.WeakIdentityPair(T1, T2)","constructorParameters":[{"parameterType":"T1","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T1, bounds=[Object])}","parameterTypeResolvedDescribed":"T1","parameter":"T1 a","parameterName":"a"},{"parameterType":"T2","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T2, bounds=[Object])}","parameterTypeResolvedDescribed":"T2","parameter":"T2 b","parameterName":"b"}],"literalExprs":[{"literalExprRange":"(line 28,col 14)-(line 28,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 28,col 27)-(line 28,col 30)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 30,col 25)-(line 30,col 66)","literalExprId":3,"literalExpr":"\"WeakIdentityPair cannot hold null: %s %s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 34,col 25)-(line 34,col 25)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public WeakIdentityPair(T1 a, T2 b) {\n    if (a == null || b == null) {\n      throw new IllegalArgumentException(\n          String.format(\"WeakIdentityPair cannot hold null: %s %s\", a, b));\n    }\n    this.a = new WeakReference<T1>(a);\n    this.b = new WeakReference<T2>(b);\n    int localHashCode = 0;\n    try {\n      localHashCode = a.hashCode() + b.hashCode();\n    } catch (StackOverflowError e) {\n    }\n    hashCode = localHashCode;\n  }","variableDeclarationExprs":[{"variableType":"int","variableName":"localHashCode","variableDeclarationExprId":1,"variableDeclarationExpr":"int localHashCode = 0","variableDeclarationExprRange":"(line 34,col 5)-(line 34,col 25)","variableTypeResolved":"PrimitiveTypeUsage{name='int'}","variableRange":"(line 34,col 9)-(line 34,col 25)"}],"constructorRange":"(line 27,col 3)-(line 40,col 3)","constructorJavadocComment":"","constructorDeclaration":"public WeakIdentityPair(T1 a, T2 b)","constructorBody":"{\n    if (a == null || b == null) {\n        throw new IllegalArgumentException(String.format(\"WeakIdentityPair cannot hold null: %s %s\", a, b));\n    }\n    this.a = new WeakReference<T1>(a);\n    this.b = new WeakReference<T2>(b);\n    int localHashCode = 0;\n    try {\n        localHashCode = a.hashCode() + b.hashCode();\n    } catch (StackOverflowError e) {\n    }\n    hashCode = localHashCode;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of first argument","javadocBlockTagName":"<A>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of first argument'}]}', name=Optional[<A>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of second argument","javadocBlockTagName":"<B>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of second argument'}]}', name=Optional[<B>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"first argument","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first argument'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second argument","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second argument'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a WeakIdentityPair of (a, b)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a WeakIdentityPair of (a, b)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static WeakIdentityPair<A, B> of(A a, B b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new WeakIdentityPair<A, B>(a, b);\n}","methodRange":"(line 49,col 3)-(line 51,col 3)","methodTokenRange":"public static <A extends Object, B extends Object> WeakIdentityPair<A, B> of(A a, B b) {\n    return new WeakIdentityPair<A, B>(a, b);\n  }","methodReturnTypeResolved":"ReferenceType{plume.WeakIdentityPair, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityPair.T2=TypeVariable {JPTypeParameter(B, bounds=[Object])}, plume.WeakIdentityPair.T1=TypeVariable {JPTypeParameter(A, bounds=[Object])}}}}","methodJavadocComment":" Factory method with short name and no need to name type parameters.\n   * @param <A> type of first argument\n   * @param <B> type of second argument\n   * @param a first argument\n   * @param b second argument\n   * @return a WeakIdentityPair of (a, b)\n   ","methodParameters":[{"parameterType":"A","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(A, bounds=[Object])}","parameterTypeResolvedDescribed":"A","parameter":"A a","parameterName":"a"},{"parameterType":"B","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[Object])}","parameterTypeResolvedDescribed":"B","parameter":"B b","parameterName":"b"}],"methodName":"of","methodQualifiedSignature":"plume.WeakIdentityPair.of","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Factory method with short name and no need to name type parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of first argument'}]}', name=Optional[<A>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of second argument'}]}', name=Optional[<B>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first argument'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second argument'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a WeakIdentityPair of (a, b)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.WeakIdentityPair<A, B>","methodType":"WeakIdentityPair<A, B>","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityPair.of(A, B)"},{"methodDeclaration":"public T1 getA()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return a.get();\n}","methodRange":"(line 57,col 3)-(line 59,col 3)","methodTokenRange":"public \/*@Nullable*\/ T1 getA(\/*>>>@GuardSatisfied WeakIdentityPair<T1,T2> this*\/) {\n    return a.get();\n  }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T1, bounds=[Object])}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"getA","methodQualifiedSignature":"plume.WeakIdentityPair.getA","methodJavadoc":"","methodReturnTypeDescribed":"T1","methodType":"T1","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityPair.getA()"},{"methodDeclaration":"public T2 getB()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return b.get();\n}","methodRange":"(line 65,col 3)-(line 67,col 3)","methodTokenRange":"public \/*@Nullable*\/ T2 getB(\/*>>>@GuardSatisfied WeakIdentityPair<T1,T2> this*\/) {\n    return b.get();\n  }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T2, bounds=[Object])}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"getB","methodQualifiedSignature":"plume.WeakIdentityPair.getB","methodJavadoc":"","methodReturnTypeDescribed":"T2","methodType":"T2","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityPair.getB()"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return \"<\" + String.valueOf(a) + \",\" + String.valueOf(b) + \">\";\n}","methodRange":"(line 69,col 3)-(line 73,col 3)","methodTokenRange":"@Override\n  \/*@SideEffectFree*\/\n  public String toString(\/*>>>@GuardSatisfied WeakIdentityPair<T1,T2> this*\/) {\n    return \"<\" + String.valueOf(a) + \",\" + String.valueOf(b) + \">\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.WeakIdentityPair.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 72,col 12)-(line 72,col 14)","literalExprId":1,"literalExpr":"\"<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 72,col 38)-(line 72,col 40)","literalExprId":2,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 72,col 64)-(line 72,col 66)","literalExprId":3,"literalExpr":"\">\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityPair.toString()"},{"methodDeclaration":"public boolean equals(Object obj)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!(obj instanceof WeakIdentityPair<?, ?>)) {\n        return false;\n    }\n    @SuppressWarnings(\"unchecked\")\n    WeakIdentityPair<T1, T2> other = (WeakIdentityPair<T1, T2>) obj;\n    if (hashCode != other.hashCode) {\n        return false;\n    }\n    T1 a = getA();\n    T2 b = getB();\n    T1 oa = other.getA();\n    T2 ob = other.getB();\n    if (a == null || b == null || oa == null || ob == null) {\n        return false;\n    }\n    return a == oa && b == ob;\n}","methodRange":"(line 75,col 3)-(line 104,col 3)","methodTokenRange":"@Override\n  @SuppressWarnings({\n    \"interning\",\n    \"not.deterministic.call\"\n  }) \/\/ getA is not @deterministic, but its value is checked, so this method is deterministic\n  \/*@Pure*\/\n  public boolean equals(\n      \/*>>>@GuardSatisfied WeakIdentityPair<T1,T2> this,*\/\n      \/*@GuardSatisfied*\/ \/*@Nullable*\/ Object obj) {\n    if (!(obj instanceof WeakIdentityPair<?, ?>)) {\n      return false;\n    }\n    \/\/ generics are not checked at run time!\n    @SuppressWarnings(\"unchecked\")\n    WeakIdentityPair<T1, T2> other = (WeakIdentityPair<T1, T2>) obj;\n\n    if (hashCode != other.hashCode) {\n      return false;\n    }\n\n    \/*@Nullable*\/ T1 a = getA();\n    \/*@Nullable*\/ T2 b = getB();\n    \/*@Nullable*\/ T1 oa = other.getA();\n    \/*@Nullable*\/ T2 ob = other.getB();\n    if (a == null || b == null || oa == null || ob == null) {\n      \/\/ false if any of the components has been garbage-collected\n      return false;\n    }\n    return a == oa && b == ob;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"equals","methodQualifiedSignature":"plume.WeakIdentityPair.equals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 77,col 5)-(line 77,col 15)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 5)-(line 78,col 28)","literalExprId":2,"literalExpr":"\"not.deterministic.call\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 85,col 14)-(line 85,col 18)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 88,col 23)-(line 88,col 33)","literalExprId":4,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 92,col 14)-(line 92,col 18)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 99,col 14)-(line 99,col 17)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 99,col 27)-(line 99,col 30)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 99,col 41)-(line 99,col 44)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 99,col 55)-(line 99,col 58)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 101,col 14)-(line 101,col 18)","literalExprId":10,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.WeakIdentityPair.equals(java.lang.Object)"},{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return hashCode;\n}","methodRange":"(line 106,col 3)-(line 110,col 3)","methodTokenRange":"@Override\n  \/*@Pure*\/\n  public int hashCode(\/*>>>@GuardSatisfied WeakIdentityPair<T1,T2> this*\/) {\n    return hashCode;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"plume.WeakIdentityPair.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.WeakIdentityPair.hashCode()"}],"classJavadoc":"\/**\n * Immutable pair class:\n * type-safely holds two objects of possibly-different types.\n * <p>\n * Differs from Pair in the following ways:  is immutable, cannot hold\n * null, holds its elements with weak pointers, and its equals() method\n * uses object equality to compare its elements.\n *\/\n","className":"WeakIdentityPair","fields":[{"fieldRange":"(line 21,col 3)-(line 21,col 36)","fieldName":"a","fieldJavadocComment":"","fieldTokenRange":"final private WeakReference<T1> a;","fieldTypeResolved":"ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=TypeVariable {JPTypeParameter(T1, bounds=[Object])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakReference<T1>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.ref.WeakReference<T1>"},{"fieldRange":"(line 22,col 3)-(line 22,col 36)","fieldName":"b","fieldJavadocComment":"","fieldTokenRange":"final private WeakReference<T2> b;","fieldTypeResolved":"ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=TypeVariable {JPTypeParameter(T2, bounds=[Object])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakReference<T2>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.ref.WeakReference<T2>"},{"fieldRange":"(line 25,col 3)-(line 25,col 29)","fieldName":"hashCode","fieldJavadocComment":" Must cache the hashCode to prevent it from changing.","fieldTokenRange":"final private int hashCode;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":20,"packageName":"plume"},{"sourceFileName":"plume.OptionsDoclet","imports":[{"importId":1,"import":"import com.sun.javadoc.ClassDoc;\n"},{"importId":2,"import":"import com.sun.javadoc.Doc;\n"},{"importId":3,"import":"import com.sun.javadoc.DocErrorReporter;\n"},{"importId":4,"import":"import com.sun.javadoc.FieldDoc;\n"},{"importId":5,"import":"import com.sun.javadoc.RootDoc;\n"},{"importId":6,"import":"import com.sun.javadoc.SeeTag;\n"},{"importId":7,"import":"import com.sun.javadoc.Tag;\n"},{"importId":8,"import":"import java.io.BufferedReader;\n"},{"importId":9,"import":"import java.io.BufferedWriter;\n"},{"importId":10,"import":"import java.io.File;\n"},{"importId":11,"import":"import java.io.FileReader;\n"},{"importId":12,"import":"import java.io.FileWriter;\n"},{"importId":13,"import":"import java.io.OutputStreamWriter;\n"},{"importId":14,"import":"import java.io.PrintWriter;\n"},{"importId":15,"import":"import java.lang.reflect.Constructor;\n"},{"importId":16,"import":"import java.lang.reflect.Field;\n"},{"importId":17,"import":"import java.lang.reflect.Modifier;\n"},{"importId":18,"import":"import java.util.ArrayList;\n"},{"importId":19,"import":"import java.util.Formatter;\n"},{"importId":20,"import":"import java.util.LinkedHashMap;\n"},{"importId":21,"import":"import java.util.List;\n"},{"importId":22,"import":"import java.util.Map;\n"},{"importId":23,"import":"import java.util.Scanner;\n"},{"importId":24,"import":"import org.apache.commons.lang3.StringEscapeUtils;\n"},{"importId":25,"import":"import org.apache.commons.lang3.StringUtils;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"OptionsDoclet","constructorQualifiedName":"plume.OptionsDoclet.OptionsDoclet","constructorQualifiedSignature":"","constructorParameters":[{"parameterType":"RootDoc","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"RootDoc root","parameterName":"root"},{"parameterType":"Options","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.Options, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.Options","parameter":"Options options","parameterName":"options"}],"literalExprs":[],"constructorTokenRange":"public OptionsDoclet(RootDoc root, Options options) {\n    this.root = root;\n    this.options = options;\n  }","variableDeclarationExprs":[],"constructorRange":"(line 213,col 3)-(line 216,col 3)","constructorJavadocComment":"","constructorDeclaration":"public OptionsDoclet(RootDoc root, Options options)","constructorBody":"{\n    this.root = root;\n    this.options = options;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the root document","javadocBlockTagName":"root","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the root document'}]}', name=Optional[root]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if processing completed without an error","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if processing completed without an error'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean start(RootDoc root)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n        if (doc.containingClass() != null) {\n            continue;\n        }\n        Class<?> clazz;\n        try {\n            @SuppressWarnings(\"signature\")\n            String className = doc.qualifiedName();\n            clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        }\n        if (needsInstantiation(clazz)) {\n            try {\n                Constructor<?> c = clazz.getDeclaredConstructor();\n                c.setAccessible(true);\n                objs.add(c.newInstance(new Object[0]));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        } else {\n            objs.add(clazz);\n        }\n    }\n    if (objs.isEmpty()) {\n        System.out.println(\"Error: no classes found\");\n        return false;\n    }\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n        System.out.println(\"Error: no @Option-annotated fields found\");\n        return false;\n    }\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n        o.write();\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}","methodRange":"(line 225,col 3)-(line 284,col 3)","methodTokenRange":"public static boolean start(RootDoc root) {\n    List<Object> objs = new ArrayList<Object>();\n    for (ClassDoc doc : root.specifiedClasses()) {\n      \/\/ TODO: Class.forName() expects a binary name but doc.qualifiedName()\n      \/\/ returns a fully qualified name.  I do not know a good way to convert\n      \/\/ between these two name formats.  For now, we simply ignore inner\n      \/\/ classes.  This limitation can be removed when we figure out a better\n      \/\/ way to go from ClassDoc to Class<?>.\n      if (doc.containingClass() != null) {\n        continue;\n      }\n\n      Class<?> clazz;\n      try {\n        @SuppressWarnings(\"signature\") \/\/ Javadoc source code is not yet annotated\n        \/*@BinaryNameForNonArray*\/ String className = doc.qualifiedName();\n        clazz = Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return false;\n      }\n\n      if (needsInstantiation(clazz)) {\n        try {\n          Constructor<?> c = clazz.getDeclaredConstructor();\n          c.setAccessible(true);\n          objs.add(c.newInstance(new Object[0]));\n        } catch (Exception e) {\n          e.printStackTrace();\n          return false;\n        }\n      } else {\n        objs.add(clazz);\n      }\n    }\n\n    if (objs.isEmpty()) {\n      System.out.println(\"Error: no classes found\");\n      return false;\n    }\n\n    Object[] objarray = objs.toArray();\n    Options options = new Options(objarray);\n    if (options.getOptions().size() < 1) {\n      System.out.println(\"Error: no @Option-annotated fields found\");\n      return false;\n    }\n\n    OptionsDoclet o = new OptionsDoclet(root, options);\n    o.setOptions(root.options());\n    o.processJavadoc();\n    try {\n      o.write();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return false;\n    }\n\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Entry point for the doclet.\n   * @param root the root document\n   * @return true if processing completed without an error\n   ","methodParameters":[{"parameterType":"RootDoc","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"RootDoc root","parameterName":"root"}],"methodName":"start","methodQualifiedSignature":"plume.OptionsDoclet.start","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Entry point for the doclet.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the root document'}]}', name=Optional[root]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if processing completed without an error'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 233,col 36)-(line 233,col 39)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 239,col 27)-(line 239,col 37)","literalExprId":2,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 241,col 42)-(line 241,col 45)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 244,col 16)-(line 244,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 250,col 27)-(line 250,col 30)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 251,col 45)-(line 251,col 45)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 254,col 18)-(line 254,col 22)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 262,col 26)-(line 262,col 50)","literalExprId":8,"literalExpr":"\"Error: no classes found\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 263,col 14)-(line 263,col 18)","literalExprId":9,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 268,col 39)-(line 268,col 39)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 269,col 26)-(line 269,col 67)","literalExprId":11,"literalExpr":"\"Error: no @Option-annotated fields found\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 270,col 14)-(line 270,col 18)","literalExprId":12,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 280,col 14)-(line 280,col 18)","literalExprId":13,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 283,col 12)-(line 283,col 15)","literalExprId":14,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the command-line option","javadocBlockTagName":"option","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line option'}]}', name=Optional[option]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the number of command-line arguments needed when using the option","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the number of command-line arguments needed when using the option'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"<a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='<a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int optionLength(String option)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (option.equals(\"-help\")) {\n        System.out.printf(USAGE);\n        return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n        return 1;\n    }\n    if (option.equals(\"-docfile\") || option.equals(\"-outfile\") || option.equals(\"-format\") || option.equals(\"-d\")) {\n        return 2;\n    }\n    return 0;\n}","methodRange":"(line 296,col 3)-(line 311,col 3)","methodTokenRange":"public static int optionLength(String option) {\n    if (option.equals(\"-help\")) {\n      System.out.printf(USAGE);\n      return 1;\n    }\n    if (option.equals(\"-i\") || option.equals(\"-classdoc\") || option.equals(\"-singledash\")) {\n      return 1;\n    }\n    if (option.equals(\"-docfile\")\n        || option.equals(\"-outfile\")\n        || option.equals(\"-format\")\n        || option.equals(\"-d\")) {\n      return 2;\n    }\n    return 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Given a command-line option of this doclet, returns the number of\n   * arguments you must specify on the command line for the given option.\n   * Returns 0 if the argument is not recognized.  This method is\n   * automatically invoked.\n   *\n   * @param option the command-line option\n   * @return the number of command-line arguments needed when using the option\n   * @see <a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String option","parameterName":"option"}],"methodName":"optionLength","methodQualifiedSignature":"plume.OptionsDoclet.optionLength","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a command-line option of this doclet, returns the number of\narguments you must specify on the command line for the given option.\nReturns 0 if the argument is not recognized.  This method is\nautomatically invoked.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line option'}]}', name=Optional[option]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the number of command-line arguments needed when using the option'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='<a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 297,col 23)-(line 297,col 29)","literalExprId":1,"literalExpr":"\"-help\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 299,col 14)-(line 299,col 14)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 301,col 23)-(line 301,col 26)","literalExprId":3,"literalExpr":"\"-i\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 301,col 46)-(line 301,col 56)","literalExprId":4,"literalExpr":"\"-classdoc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 301,col 76)-(line 301,col 88)","literalExprId":5,"literalExpr":"\"-singledash\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 302,col 14)-(line 302,col 14)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 304,col 23)-(line 304,col 32)","literalExprId":7,"literalExpr":"\"-docfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 305,col 26)-(line 305,col 35)","literalExprId":8,"literalExpr":"\"-outfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 306,col 26)-(line 306,col 34)","literalExprId":9,"literalExpr":"\"-format\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 307,col 26)-(line 307,col 29)","literalExprId":10,"literalExpr":"\"-d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 308,col 14)-(line 308,col 14)","literalExprId":11,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 310,col 12)-(line 310,col 12)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.optionLength(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the command-line options to be checked: an array of 1- or 2-element arrays","javadocBlockTagName":"options","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line options to be checked: an array of 1- or 2-element arrays'}]}', name=Optional[options]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"where to report errors","javadocBlockTagName":"reporter","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to report errors'}]}', name=Optional[reporter]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the command-line options are valid","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the command-line options are valid'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"<a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='<a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean validOptions(String[][] options, DocErrorReporter reporter)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            if (hasDocFile) {\n                reporter.printError(\"-docfile option specified twice\");\n                return false;\n            }\n            File f = new File(os[1]);\n            if (!f.exists()) {\n                reporter.printError(\"-docfile file not found: \" + os[1]);\n                return false;\n            }\n            docFile = os[1];\n            hasDocFile = true;\n        }\n        if (opt.equals(\"-outfile\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-outfile option specified twice\");\n                return false;\n            }\n            if (inPlace) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            outFile = os[1];\n            hasOutFile = true;\n        }\n        if (opt.equals(\"-i\")) {\n            if (hasOutFile) {\n                reporter.printError(\"-i and -outfile can not be used at the same time\");\n                return false;\n            }\n            inPlace = true;\n        }\n        if (opt.equals(\"-format\")) {\n            if (hasFormat) {\n                reporter.printError(\"-format option specified twice\");\n                return false;\n            }\n            if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n                reporter.printError(\"unrecognized output format: \" + os[1]);\n                return false;\n            }\n            hasFormat = true;\n        }\n        if (opt.equals(\"-d\")) {\n            if (hasDestDir) {\n                reporter.printError(\"-d specified twice\");\n                return false;\n            }\n            hasDestDir = true;\n        }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n        reporter.printError(\"docfile must be different from outfile\");\n        return false;\n    }\n    if (inPlace && docFile == null) {\n        reporter.printError(\"-i supplied but -docfile was not\");\n        return false;\n    }\n    return true;\n}","methodRange":"(line 323,col 3)-(line 394,col 3)","methodTokenRange":"public static boolean validOptions(String[][] options, DocErrorReporter reporter) {\n    boolean hasDocFile = false;\n    boolean hasOutFile = false;\n    boolean hasDestDir = false;\n    boolean hasFormat = false;\n    boolean inPlace = false;\n    String docFile = null;\n    String outFile = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        if (hasDocFile) {\n          reporter.printError(\"-docfile option specified twice\");\n          return false;\n        }\n        File f = new File(os[1]);\n        if (!f.exists()) {\n          reporter.printError(\"-docfile file not found: \" + os[1]);\n          return false;\n        }\n        docFile = os[1];\n        hasDocFile = true;\n      }\n      if (opt.equals(\"-outfile\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-outfile option specified twice\");\n          return false;\n        }\n        if (inPlace) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        outFile = os[1];\n        hasOutFile = true;\n      }\n      if (opt.equals(\"-i\")) {\n        if (hasOutFile) {\n          reporter.printError(\"-i and -outfile can not be used at the same time\");\n          return false;\n        }\n        inPlace = true;\n      }\n      if (opt.equals(\"-format\")) {\n        if (hasFormat) {\n          reporter.printError(\"-format option specified twice\");\n          return false;\n        }\n        if (!os[1].equals(\"javadoc\") && !os[1].equals(\"html\")) {\n          reporter.printError(\"unrecognized output format: \" + os[1]);\n          return false;\n        }\n        hasFormat = true;\n      }\n      if (opt.equals(\"-d\")) {\n        if (hasDestDir) {\n          reporter.printError(\"-d specified twice\");\n          return false;\n        }\n        hasDestDir = true;\n      }\n    }\n    if (docFile != null && outFile != null && outFile.equals(docFile)) {\n      reporter.printError(\"docfile must be different from outfile\");\n      return false;\n    }\n    if (inPlace && docFile == null) {\n      reporter.printError(\"-i supplied but -docfile was not\");\n      return false;\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Tests the validity of command-line arguments passed to this doclet.\n   * Returns true if the option usage is valid, and false otherwise.  This\n   * method is automatically invoked.\n   *\n   * @param options the command-line options to be checked: an array of 1- or 2-element arrays\n   * @param reporter where to report errors\n   * @return true iff the command-line options are valid\n   * @see <a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>\n   ","methodParameters":[{"parameterType":"String[][]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}","parameterTypeResolvedDescribed":"java.lang.String[][]","parameter":"String[][] options","parameterName":"options"},{"parameterType":"DocErrorReporter","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"DocErrorReporter reporter","parameterName":"reporter"}],"methodName":"validOptions","methodQualifiedSignature":"plume.OptionsDoclet.validOptions","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests the validity of command-line arguments passed to this doclet.\nReturns true if the option usage is valid, and false otherwise.  This\nmethod is automatically invoked.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line options to be checked: an array of 1- or 2-element arrays'}]}', name=Optional[options]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to report errors'}]}', name=Optional[reporter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the command-line options are valid'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='<a href=\"http:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/javadoc\/doclet\/overview.html\">Doclet overview<\/a>'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 324,col 26)-(line 324,col 30)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 325,col 26)-(line 325,col 30)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 326,col 26)-(line 326,col 30)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 327,col 25)-(line 327,col 29)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 328,col 23)-(line 328,col 27)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 329,col 22)-(line 329,col 25)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 330,col 22)-(line 330,col 25)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 331,col 19)-(line 331,col 19)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 333,col 23)-(line 333,col 23)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 334,col 22)-(line 334,col 31)","literalExprId":10,"literalExpr":"\"-docfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 336,col 31)-(line 336,col 63)","literalExprId":11,"literalExpr":"\"-docfile option specified twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 337,col 18)-(line 337,col 22)","literalExprId":12,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 339,col 30)-(line 339,col 30)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 341,col 31)-(line 341,col 57)","literalExprId":14,"literalExpr":"\"-docfile file not found: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 341,col 64)-(line 341,col 64)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 342,col 18)-(line 342,col 22)","literalExprId":16,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 344,col 22)-(line 344,col 22)","literalExprId":17,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 345,col 22)-(line 345,col 25)","literalExprId":18,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 347,col 22)-(line 347,col 31)","literalExprId":19,"literalExpr":"\"-outfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 349,col 31)-(line 349,col 63)","literalExprId":20,"literalExpr":"\"-outfile option specified twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 350,col 18)-(line 350,col 22)","literalExprId":21,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 353,col 31)-(line 353,col 80)","literalExprId":22,"literalExpr":"\"-i and -outfile can not be used at the same time\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 354,col 18)-(line 354,col 22)","literalExprId":23,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 356,col 22)-(line 356,col 22)","literalExprId":24,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 357,col 22)-(line 357,col 25)","literalExprId":25,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 359,col 22)-(line 359,col 25)","literalExprId":26,"literalExpr":"\"-i\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 361,col 31)-(line 361,col 80)","literalExprId":27,"literalExpr":"\"-i and -outfile can not be used at the same time\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 362,col 18)-(line 362,col 22)","literalExprId":28,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 364,col 19)-(line 364,col 22)","literalExprId":29,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 366,col 22)-(line 366,col 30)","literalExprId":30,"literalExpr":"\"-format\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 368,col 31)-(line 368,col 62)","literalExprId":31,"literalExpr":"\"-format option specified twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 369,col 18)-(line 369,col 22)","literalExprId":32,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 371,col 17)-(line 371,col 17)","literalExprId":33,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 371,col 27)-(line 371,col 35)","literalExprId":34,"literalExpr":"\"javadoc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 371,col 45)-(line 371,col 45)","literalExprId":35,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 371,col 55)-(line 371,col 60)","literalExprId":36,"literalExpr":"\"html\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 372,col 31)-(line 372,col 60)","literalExprId":37,"literalExpr":"\"unrecognized output format: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 372,col 67)-(line 372,col 67)","literalExprId":38,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 373,col 18)-(line 373,col 22)","literalExprId":39,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 375,col 21)-(line 375,col 24)","literalExprId":40,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 377,col 22)-(line 377,col 25)","literalExprId":41,"literalExpr":"\"-d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 379,col 31)-(line 379,col 50)","literalExprId":42,"literalExpr":"\"-d specified twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 380,col 18)-(line 380,col 22)","literalExprId":43,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 382,col 22)-(line 382,col 25)","literalExprId":44,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 385,col 20)-(line 385,col 23)","literalExprId":45,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 385,col 39)-(line 385,col 42)","literalExprId":46,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 386,col 27)-(line 386,col 66)","literalExprId":47,"literalExpr":"\"docfile must be different from outfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 387,col 14)-(line 387,col 18)","literalExprId":48,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 389,col 31)-(line 389,col 34)","literalExprId":49,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 390,col 27)-(line 390,col 60)","literalExprId":50,"literalExpr":"\"-i supplied but -docfile was not\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 391,col 14)-(line 391,col 18)","literalExprId":51,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 393,col 12)-(line 393,col 15)","literalExprId":52,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the command-line options to parse: a list of 1- or 2-element arrays","javadocBlockTagName":"options","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line options to parse: a list of 1- or 2-element arrays'}]}', name=Optional[options]}"}],"methodDeclaration":"public void setOptions(String[][] options)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String outFilename = null;\n    File destDir = null;\n    for (int oi = 0; oi < options.length; oi++) {\n        String[] os = options[oi];\n        String opt = os[0].toLowerCase();\n        if (opt.equals(\"-docfile\")) {\n            this.docFile = new File(os[1]);\n        } else if (opt.equals(\"-d\")) {\n            destDir = new File(os[1]);\n        } else if (opt.equals(\"-outfile\")) {\n            outFilename = os[1];\n        } else if (opt.equals(\"-i\")) {\n            this.inPlace = true;\n        } else if (opt.equals(\"-format\")) {\n            if (os[1].equals(\"javadoc\")) {\n                setFormatJavadoc(true);\n            }\n        } else if (opt.equals(\"-classdoc\")) {\n            this.includeClassDoc = true;\n        } else if (opt.equals(\"-singledash\")) {\n            setUseSingleDash(true);\n        }\n    }\n    if (outFilename != null) {\n        if (destDir != null) {\n            this.outFile = new File(destDir, outFilename);\n        } else {\n            this.outFile = new File(outFilename);\n        }\n    }\n}","methodRange":"(line 401,col 3)-(line 432,col 3)","methodTokenRange":"public void setOptions(String[][] options) {\n    String outFilename = null;\n    File destDir = null;\n    for (int oi = 0; oi < options.length; oi++) {\n      String[] os = options[oi];\n      String opt = os[0].toLowerCase();\n      if (opt.equals(\"-docfile\")) {\n        this.docFile = new File(os[1]);\n      } else if (opt.equals(\"-d\")) {\n        destDir = new File(os[1]);\n      } else if (opt.equals(\"-outfile\")) {\n        outFilename = os[1];\n      } else if (opt.equals(\"-i\")) {\n        this.inPlace = true;\n      } else if (opt.equals(\"-format\")) {\n        if (os[1].equals(\"javadoc\")) {\n          setFormatJavadoc(true);\n        }\n      } else if (opt.equals(\"-classdoc\")) {\n        this.includeClassDoc = true;\n      } else if (opt.equals(\"-singledash\")) {\n        setUseSingleDash(true);\n      }\n    }\n    if (outFilename != null) {\n      if (destDir != null) {\n        this.outFile = new File(destDir, outFilename);\n      } else {\n        this.outFile = new File(outFilename);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Set the options for this class based on command-line arguments given by\n   * RootDoc.options().\n   * @param options the command-line options to parse: a list of 1- or 2-element arrays\n   ","methodParameters":[{"parameterType":"String[][]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}","parameterTypeResolvedDescribed":"java.lang.String[][]","parameter":"String[][] options","parameterName":"options"}],"methodName":"setOptions","methodQualifiedSignature":"plume.OptionsDoclet.setOptions","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the options for this class based on command-line arguments given by\nRootDoc.options().'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line options to parse: a list of 1- or 2-element arrays'}]}', name=Optional[options]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 402,col 26)-(line 402,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 403,col 20)-(line 403,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 404,col 19)-(line 404,col 19)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 406,col 23)-(line 406,col 23)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 407,col 22)-(line 407,col 31)","literalExprId":5,"literalExpr":"\"-docfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 408,col 36)-(line 408,col 36)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 409,col 29)-(line 409,col 32)","literalExprId":7,"literalExpr":"\"-d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 410,col 31)-(line 410,col 31)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 29)-(line 411,col 38)","literalExprId":9,"literalExpr":"\"-outfile\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 412,col 26)-(line 412,col 26)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 29)-(line 413,col 32)","literalExprId":11,"literalExpr":"\"-i\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 414,col 24)-(line 414,col 27)","literalExprId":12,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 415,col 29)-(line 415,col 37)","literalExprId":13,"literalExpr":"\"-format\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 416,col 16)-(line 416,col 16)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 26)-(line 416,col 34)","literalExprId":15,"literalExpr":"\"javadoc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 417,col 28)-(line 417,col 31)","literalExprId":16,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 419,col 29)-(line 419,col 39)","literalExprId":17,"literalExpr":"\"-classdoc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 420,col 32)-(line 420,col 35)","literalExprId":18,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 421,col 29)-(line 421,col 41)","literalExprId":19,"literalExpr":"\"-singledash\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 422,col 26)-(line 422,col 29)","literalExprId":20,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 425,col 24)-(line 425,col 27)","literalExprId":21,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 426,col 22)-(line 426,col 25)","literalExprId":22,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.setOptions(java.lang.String[][])"},{"javadocBlockTags":[],"methodDeclaration":"private static boolean needsInstantiation(Class<?> clazz)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    for (Field f : clazz.getDeclaredFields()) {\n        if (f.isAnnotationPresent(Option.class) && !Modifier.isStatic(f.getModifiers())) {\n            return true;\n        }\n    }\n    return false;\n}","methodRange":"(line 438,col 3)-(line 445,col 3)","methodTokenRange":"private static boolean needsInstantiation(Class<?> clazz) {\n    for (Field f : clazz.getDeclaredFields()) {\n      if (f.isAnnotationPresent(Option.class) && !Modifier.isStatic(f.getModifiers())) {\n        return true;\n      }\n    }\n    return false;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Determine if a class needs to be instantiated in order to work properly\n   * with {@link Options}.\n   ","methodParameters":[{"parameterType":"Class<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.lang.Class<?>","parameter":"Class<?> clazz","parameterName":"clazz"}],"methodName":"needsInstantiation","methodQualifiedSignature":"plume.OptionsDoclet.needsInstantiation","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determine if a class needs to be instantiated in order to work properly\nwith '}, JavadocInlineTag{tagName='link', type=LINK, content=' Options'}, JavadocSnippet{text='.'}]}, blockTags=[]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 441,col 16)-(line 441,col 19)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 444,col 12)-(line 444,col 16)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.needsInstantiation(java.lang.Class<?>)"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble","javadocBlockTagName":"Exception","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble'}]}', name=Optional[Exception]}"}],"methodDeclaration":"public void write() throws Exception","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    PrintWriter out;\n    String output = output();\n    if (outFile != null) {\n        out = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));\n    } else if (inPlace) {\n        assert docFile != null : \"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\";\n        out = new PrintWriter(new BufferedWriter(new FileWriter(docFile)));\n    } else {\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n    out.println(output);\n    out.flush();\n    out.close();\n}","methodRange":"(line 453,col 3)-(line 470,col 3)","methodTokenRange":"public void write() throws Exception {\n    PrintWriter out;\n    String output = output();\n\n    if (outFile != null) {\n      out = new PrintWriter(new BufferedWriter(new FileWriter(outFile)));\n    } else if (inPlace) {\n      assert docFile != null\n          : \"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\";\n      out = new PrintWriter(new BufferedWriter(new FileWriter(docFile)));\n    } else {\n      out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    }\n\n    out.println(output);\n    out.flush();\n    out.close();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Write the output of this doclet to the correct file.\n   * @throws Exception if there is trouble\n   ","methodParameters":[],"methodName":"write","methodQualifiedSignature":"plume.OptionsDoclet.write","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Write the output of this doclet to the correct file.'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble'}]}', name=Optional[Exception]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 457,col 20)-(line 457,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 460,col 25)-(line 460,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 461,col 13)-(line 461,col 91)","literalExprId":3,"literalExpr":"\"@AssumeAssertion(nullness): dependent: docFile is non-null if inPlace is true\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.write()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the user-visible doclet output","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the user-visible doclet output'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble","javadocBlockTagName":"Exception","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble'}]}', name=Optional[Exception]}"}],"methodDeclaration":"public String output() throws Exception","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (docFile == null) {\n        if (formatJavadoc) {\n            return optionsToJavadoc(0);\n        } else {\n            return optionsToHtml();\n        }\n    }\n    return newDocFileText();\n}","methodRange":"(line 478,col 3)-(line 488,col 3)","methodTokenRange":"public String output() throws Exception {\n    if (docFile == null) {\n      if (formatJavadoc) {\n        return optionsToJavadoc(0);\n      } else {\n        return optionsToHtml();\n      }\n    }\n\n    return newDocFileText();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Get the final output of this doclet.  The string returned by this method\n   * is the output seen by the user.\n   * @return the user-visible doclet output\n   * @throws Exception if there is trouble\n   ","methodParameters":[],"methodName":"output","methodQualifiedSignature":"plume.OptionsDoclet.output","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the final output of this doclet.  The string returned by this method\nis the output seen by the user.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the user-visible doclet output'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble'}]}', name=Optional[Exception]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 479,col 20)-(line 479,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 481,col 33)-(line 481,col 33)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.output()"},{"methodDeclaration":"private String newDocFileText() throws Exception","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    BufferedReader doc = new BufferedReader(new FileReader(docFile));\n    String docline;\n    boolean replacing = false;\n    boolean replaced_once = false;\n    while ((docline = doc.readLine()) != null) {\n        if (replacing) {\n            if (docline.trim().equals(endDelim)) {\n                replacing = false;\n            } else {\n                continue;\n            }\n        }\n        b.append(docline);\n        if (!replaced_once && docline.trim().equals(startDelim)) {\n            if (formatJavadoc) {\n                b.append(optionsToJavadoc(docline.indexOf('*')));\n            } else {\n                b.append(optionsToHtml());\n            }\n            replaced_once = true;\n            replacing = true;\n        }\n    }\n    doc.close();\n    return b.toString();\n}","methodRange":"(line 494,col 3)-(line 525,col 3)","methodTokenRange":"private String newDocFileText() throws Exception {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    BufferedReader doc = new BufferedReader(new FileReader(docFile));\n    String docline;\n    boolean replacing = false;\n    boolean replaced_once = false;\n\n    while ((docline = doc.readLine()) != null) {\n      if (replacing) {\n        if (docline.trim().equals(endDelim)) {\n          replacing = false;\n        } else {\n          continue;\n        }\n      }\n\n      b.append(docline);\n\n      if (!replaced_once && docline.trim().equals(startDelim)) {\n        if (formatJavadoc) {\n          b.append(optionsToJavadoc(docline.indexOf('*')));\n        } else {\n          b.append(optionsToHtml());\n        }\n        replaced_once = true;\n        replacing = true;\n      }\n    }\n\n    doc.close();\n    return b.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@RequiresNonNull(\"docFile\")","methodParameters":[],"methodName":"newDocFileText","methodQualifiedSignature":"plume.OptionsDoclet.newDocFileText","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 498,col 25)-(line 498,col 29)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 499,col 29)-(line 499,col 33)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 501,col 42)-(line 501,col 45)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 504,col 23)-(line 504,col 27)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 514,col 53)-(line 514,col 55)","literalExprId":5,"literalExpr":"'*'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 518,col 25)-(line 518,col 28)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 519,col 21)-(line 519,col 24)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.newDocFileText()"},{"javadocBlockTags":[],"methodDeclaration":"public void processJavadoc()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (Options.OptionInfo oi : options.getOptions()) {\n        ClassDoc opt_doc = root.classNamed(oi.get_declaring_class().getName());\n        if (opt_doc != null) {\n            String nameWithUnderscores = oi.long_name.replace('-', '_');\n            for (FieldDoc fd : opt_doc.fields()) {\n                if (fd.name().equals(nameWithUnderscores)) {\n                    if (fd.getRawCommentText().length() == 0) {\n                        oi.jdoc = StringEscapeUtils.escapeHtml4(oi.description);\n                    } else if (formatJavadoc) {\n                        oi.jdoc = fd.commentText();\n                    } else {\n                        oi.jdoc = javadocToHtml(fd);\n                    }\n                    break;\n                }\n            }\n        }\n        if (oi.base_type.isEnum()) {\n            processEnumJavadoc(oi);\n        }\n    }\n}","methodRange":"(line 532,col 3)-(line 558,col 3)","methodTokenRange":"public void processJavadoc() {\n    for (Options.OptionInfo oi : options.getOptions()) {\n      ClassDoc opt_doc = root.classNamed(oi.get_declaring_class().getName());\n      if (opt_doc != null) {\n        String nameWithUnderscores = oi.long_name.replace('-', '_');\n        for (FieldDoc fd : opt_doc.fields()) {\n          if (fd.name().equals(nameWithUnderscores)) {\n            \/\/ If Javadoc for field is unavailable, then use the @Option\n            \/\/ description in the documentation.\n            if (fd.getRawCommentText().length() == 0) {\n              \/\/ Input is a string rather than a Javadoc (HTML) comment so we\n              \/\/ must escape it.\n              oi.jdoc = StringEscapeUtils.escapeHtml4(oi.description);\n            } else if (formatJavadoc) {\n              oi.jdoc = fd.commentText();\n            } else {\n              oi.jdoc = javadocToHtml(fd);\n            }\n            break;\n          }\n        }\n      }\n      if (oi.base_type.isEnum()) {\n        processEnumJavadoc(oi);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Process each option and add in the Javadoc info.\n   ","methodParameters":[],"methodName":"processJavadoc","methodQualifiedSignature":"plume.OptionsDoclet.processJavadoc","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Process each option and add in the Javadoc info.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 535,col 22)-(line 535,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 536,col 59)-(line 536,col 61)","literalExprId":2,"literalExpr":"'-'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 536,col 64)-(line 536,col 66)","literalExprId":3,"literalExpr":"'_'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 541,col 52)-(line 541,col 52)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.processJavadoc()"},{"javadocBlockTags":[],"methodDeclaration":"private void processEnumJavadoc(Options.OptionInfo oi)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Enum<?>[] constants = (Enum<?>[]) oi.base_type.getEnumConstants();\n    if (constants == null) {\n        return;\n    }\n    oi.enum_jdoc = new LinkedHashMap<String, String>();\n    for (Enum<?> constant : constants) {\n        assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n        oi.enum_jdoc.put(constant.name(), \"\");\n    }\n    ClassDoc enum_doc = root.classNamed(oi.base_type.getName());\n    if (enum_doc == null) {\n        return;\n    }\n    assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n    for (String name : oi.enum_jdoc.keySet()) {\n        for (FieldDoc fd : enum_doc.fields()) {\n            if (fd.name().equals(name)) {\n                if (formatJavadoc) {\n                    oi.enum_jdoc.put(name, fd.commentText());\n                } else {\n                    oi.enum_jdoc.put(name, javadocToHtml(fd));\n                }\n                break;\n            }\n        }\n    }\n}","methodRange":"(line 564,col 3)-(line 595,col 3)","methodTokenRange":"private void processEnumJavadoc(Options.OptionInfo oi) {\n    Enum<?>[] constants = (Enum<?>[]) oi.base_type.getEnumConstants();\n    if (constants == null) {\n      return;\n    }\n\n    oi.enum_jdoc = new LinkedHashMap<String, String>();\n\n    for (Enum<?> constant : constants) {\n      assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n      oi.enum_jdoc.put(constant.name(), \"\");\n    }\n\n    ClassDoc enum_doc = root.classNamed(oi.base_type.getName());\n    if (enum_doc == null) {\n      return;\n    }\n\n    assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): bug in flow?\";\n    for (String name : oi.enum_jdoc.keySet()) {\n      for (FieldDoc fd : enum_doc.fields()) {\n        if (fd.name().equals(name)) {\n          if (formatJavadoc) {\n            oi.enum_jdoc.put(name, fd.commentText());\n          } else {\n            oi.enum_jdoc.put(name, javadocToHtml(fd));\n          }\n          break;\n        }\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Initializes {@link Options.OptionInfo.enum_jdoc} for the given\n   * <code>OptionInfo<\/code>.\n   ","methodParameters":[{"parameterType":"Options.OptionInfo","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.Options.OptionInfo","parameter":"Options.OptionInfo oi","parameterName":"oi"}],"methodName":"processEnumJavadoc","methodQualifiedSignature":"plume.OptionsDoclet.processEnumJavadoc","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initializes '}, JavadocInlineTag{tagName='link', type=LINK, content=' Options.OptionInfo.enum_jdoc'}, JavadocSnippet{text=' for the given\n<code>OptionInfo<\/code>.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 566,col 22)-(line 566,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 573,col 30)-(line 573,col 33)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 573,col 37)-(line 573,col 78)","literalExprId":3,"literalExpr":"\"@AssumeAssertion(nullness): bug in flow?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 574,col 41)-(line 574,col 42)","literalExprId":4,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 578,col 21)-(line 578,col 24)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 582,col 28)-(line 582,col 31)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 582,col 35)-(line 582,col 76)","literalExprId":7,"literalExpr":"\"@AssumeAssertion(nullness): bug in flow?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.processEnumJavadoc(plume.Options.OptionInfo)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the HTML documentation for the underlying options instance","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML documentation for the underlying options instance'}]}', name=Optional.empty}"}],"methodDeclaration":"public String optionsToHtml()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    if (includeClassDoc && root.classes().length > 0) {\n        b.append(OptionsDoclet.javadocToHtml(root.classes()[0]));\n        b.append(\"<p>Command line options:<\/p>\");\n    }\n    b.append(\"<ul>\");\n    if (!options.isUsingGroups()) {\n        b.append(optionListToHtml(options.getOptions(), 2));\n    } else {\n        for (Options.OptionGroupInfo gi : options.getOptionGroups()) {\n            if (!gi.any_publicized()) {\n                continue;\n            }\n            b.append(\"  <li id=\\\"optiongroup:\" + gi.name.replace(\" \", \"-\").replace(\"\/\", \"-\") + \"\\\">\" + gi.name);\n            b.append(\"    <ul>\");\n            b.append(optionListToHtml(gi.optionList, 6));\n            b.append(\"    <\/ul>\");\n            b.append(\"  <\/li>\");\n        }\n    }\n    b.append(\"<\/ul>\");\n    for (Options.OptionInfo oi : options.getOptions()) {\n        if (oi.list != null && !oi.unpublicized) {\n            b.append(LIST_HELP);\n            break;\n        }\n    }\n    return b.toString();\n}","methodRange":"(line 601,col 3)-(line 640,col 3)","methodTokenRange":"public String optionsToHtml() {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n\n    if (includeClassDoc && root.classes().length > 0) {\n      b.append(OptionsDoclet.javadocToHtml(root.classes()[0]));\n      b.append(\"<p>Command line options:<\/p>\");\n    }\n\n    b.append(\"<ul>\");\n    if (!options.isUsingGroups()) {\n      b.append(optionListToHtml(options.getOptions(), 2));\n    } else {\n      for (Options.OptionGroupInfo gi : options.getOptionGroups()) {\n        \/\/ Do not include groups without publicized options in output\n        if (!gi.any_publicized()) {\n          continue;\n        }\n\n        b.append(\n            \"  <li id=\\\"optiongroup:\"\n                + gi.name.replace(\" \", \"-\").replace(\"\/\", \"-\")\n                + \"\\\">\"\n                + gi.name);\n        b.append(\"    <ul>\");\n        b.append(optionListToHtml(gi.optionList, 6));\n        b.append(\"    <\/ul>\");\n        b.append(\"  <\/li>\");\n      }\n    }\n    b.append(\"<\/ul>\");\n\n    for (Options.OptionInfo oi : options.getOptions()) {\n      if (oi.list != null && !oi.unpublicized) {\n        b.append(LIST_HELP);\n        break;\n      }\n    }\n\n    return b.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Get the HTML documentation for the underlying options instance.\n   * @return the HTML documentation for the underlying options instance\n   ","methodParameters":[],"methodName":"optionsToHtml","methodQualifiedSignature":"plume.OptionsDoclet.optionsToHtml","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the HTML documentation for the underlying options instance.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML documentation for the underlying options instance'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 604,col 52)-(line 604,col 52)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 605,col 59)-(line 605,col 59)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 606,col 16)-(line 606,col 45)","literalExprId":3,"literalExpr":"\"<p>Command line options:<\/p>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 609,col 14)-(line 609,col 19)","literalExprId":4,"literalExpr":"\"<ul>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 611,col 55)-(line 611,col 55)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 620,col 13)-(line 620,col 37)","literalExprId":6,"literalExpr":"\"  <li id=\\\"optiongroup:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 621,col 35)-(line 621,col 37)","literalExprId":7,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 621,col 40)-(line 621,col 42)","literalExprId":8,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 621,col 53)-(line 621,col 55)","literalExprId":9,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 621,col 58)-(line 621,col 60)","literalExprId":10,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 622,col 19)-(line 622,col 23)","literalExprId":11,"literalExpr":"\"\\\">\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 624,col 18)-(line 624,col 27)","literalExprId":12,"literalExpr":"\"    <ul>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 625,col 50)-(line 625,col 50)","literalExprId":13,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 626,col 18)-(line 626,col 28)","literalExprId":14,"literalExpr":"\"    <\/ul>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 627,col 18)-(line 627,col 26)","literalExprId":15,"literalExpr":"\"  <\/li>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 630,col 14)-(line 630,col 20)","literalExprId":16,"literalExpr":"\"<\/ul>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 633,col 22)-(line 633,col 25)","literalExprId":17,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.optionsToHtml()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the padding to add in the Javadoc output","javadocBlockTagName":"padding","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the padding to add in the Javadoc output'}]}', name=Optional[padding]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the HTML documentation for the underlying options instance","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML documentation for the underlying options instance'}]}', name=Optional.empty}"}],"methodDeclaration":"public String optionsToJavadoc(int padding)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    Scanner s = new Scanner(optionsToHtml());\n    while (s.hasNextLine()) {\n        StringBuilder bb = new StringBuilder();\n        bb.append(StringUtils.repeat(\" \", padding)).append(\"* \").append(s.nextLine());\n        b.append(bb);\n    }\n    return b.toString();\n}","methodRange":"(line 648,col 3)-(line 659,col 3)","methodTokenRange":"public String optionsToJavadoc(int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    Scanner s = new Scanner(optionsToHtml());\n\n    while (s.hasNextLine()) {\n      StringBuilder bb = new StringBuilder();\n      bb.append(StringUtils.repeat(\" \", padding)).append(\"* \").append(s.nextLine());\n      b.append(bb);\n    }\n\n    return b.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Get the HTML documentation for the underlying options instance, formatted\n   * as a Javadoc comment.\n   * @param padding the padding to add in the Javadoc output\n   * @return the HTML documentation for the underlying options instance\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int padding","parameterName":"padding"}],"methodName":"optionsToJavadoc","methodQualifiedSignature":"plume.OptionsDoclet.optionsToJavadoc","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the HTML documentation for the underlying options instance, formatted\nas a Javadoc comment.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the padding to add in the Javadoc output'}]}', name=Optional[padding]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the HTML documentation for the underlying options instance'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 654,col 36)-(line 654,col 38)","literalExprId":1,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 654,col 58)-(line 654,col 61)","literalExprId":2,"literalExpr":"\"* \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.optionsToJavadoc(int)"},{"javadocBlockTags":[],"methodDeclaration":"private String optionListToHtml(List<Options.OptionInfo> opt_list, int padding)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    for (Options.OptionInfo oi : opt_list) {\n        if (oi.unpublicized) {\n            continue;\n        }\n        StringBuilder bb = new StringBuilder();\n        String optHtml = optionToHtml(oi, padding);\n        bb.append(StringUtils.repeat(\" \", padding));\n        bb.append(\"<li id=\\\"option:\" + oi.long_name + \"\\\">\").append(optHtml).append(\"<\/li>\");\n        b.append(bb);\n    }\n    return b.toString();\n}","methodRange":"(line 664,col 3)-(line 677,col 3)","methodTokenRange":"private String optionListToHtml(List<Options.OptionInfo> opt_list, int padding) {\n    StringBuilderDelimited b = new StringBuilderDelimited(eol);\n    for (Options.OptionInfo oi : opt_list) {\n      if (oi.unpublicized) {\n        continue;\n      }\n      StringBuilder bb = new StringBuilder();\n      String optHtml = optionToHtml(oi, padding);\n      bb.append(StringUtils.repeat(\" \", padding));\n      bb.append(\"<li id=\\\"option:\" + oi.long_name + \"\\\">\").append(optHtml).append(\"<\/li>\");\n      b.append(bb);\n    }\n    return b.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Get the HTML describing many options, formatted as an HTML list.\n   ","methodParameters":[{"parameterType":"List<Options.OptionInfo>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<plume.Options.OptionInfo>","parameter":"List<Options.OptionInfo> opt_list","parameterName":"opt_list"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int padding","parameterName":"padding"}],"methodName":"optionListToHtml","methodQualifiedSignature":"plume.OptionsDoclet.optionListToHtml","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the HTML describing many options, formatted as an HTML list.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 672,col 36)-(line 672,col 38)","literalExprId":1,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 673,col 17)-(line 673,col 34)","literalExprId":2,"literalExpr":"\"<li id=\\\"option:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 673,col 53)-(line 673,col 57)","literalExprId":3,"literalExpr":"\"\\\">\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 673,col 83)-(line 673,col 89)","literalExprId":4,"literalExpr":"\"<\/li>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.optionListToHtml(java.util.List<plume.Options.OptionInfo>, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the option to describe","javadocBlockTagName":"oi","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the option to describe'}]}', name=Optional[oi]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"HTML describing oi","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='HTML describing oi'}]}', name=Optional.empty}"}],"methodDeclaration":"public String optionToHtml(Options.OptionInfo oi, int padding)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder b = new StringBuilder();\n    Formatter f = new Formatter(b);\n    if (oi.short_name != null) {\n        f.format(\"<b>-%s<\/b> \", oi.short_name);\n    }\n    for (String a : oi.aliases) {\n        f.format(\"<b>%s<\/b> \", a);\n    }\n    String prefix = getUseSingleDash() ? \"-\" : \"--\";\n    f.format(\"<b>%s%s=<\/b><i>%s<\/i>\", prefix, oi.long_name, oi.type_name);\n    if (oi.list != null) {\n        b.append(\" <code>[+]<\/code>\");\n    }\n    f.format(\".%n \");\n    f.format(\"%s\", StringUtils.repeat(\" \", padding));\n    String jdoc = ((oi.jdoc == null) ? \"\" : oi.jdoc);\n    if (oi.no_doc_default || oi.default_str == null) {\n        f.format(\"%s\", jdoc);\n    } else {\n        String default_str = \"default \" + oi.default_str;\n        String suffix = \"\";\n        if (jdoc.endsWith(\"<\/p>\")) {\n            suffix = \"<\/p>\";\n            jdoc = jdoc.substring(0, jdoc.length() - suffix.length());\n        }\n        f.format(\"%s [%s]%s\", jdoc, StringEscapeUtils.escapeHtml4(default_str), suffix);\n    }\n    if (oi.base_type.isEnum()) {\n        b.append(\"<ul>\");\n        assert oi.enum_jdoc != null : \"@AssumeAssertion(nullness): dependent: non-null if oi.base_type is an enum\";\n        for (Map.Entry<String, String> entry : oi.enum_jdoc.entrySet()) {\n            b.append(\"<li><b>\").append(entry.getKey()).append(\"<\/b>\");\n            if (entry.getValue().length() != 0) {\n                b.append(\" \").append(entry.getValue());\n            }\n            b.append(\"<\/li>\");\n        }\n        b.append(\"<\/ul>\");\n    }\n    return b.toString();\n}","methodRange":"(line 684,col 3)-(line 729,col 3)","methodTokenRange":"public String optionToHtml(Options.OptionInfo oi, int padding) {\n    StringBuilder b = new StringBuilder();\n    Formatter f = new Formatter(b);\n    if (oi.short_name != null) {\n      f.format(\"<b>-%s<\/b> \", oi.short_name);\n    }\n    for (String a : oi.aliases) {\n      f.format(\"<b>%s<\/b> \", a);\n    }\n    String prefix = getUseSingleDash() ? \"-\" : \"--\";\n    f.format(\"<b>%s%s=<\/b><i>%s<\/i>\", prefix, oi.long_name, oi.type_name);\n    if (oi.list != null) {\n      b.append(\" <code>[+]<\/code>\");\n    }\n    f.format(\".%n \");\n    f.format(\"%s\", StringUtils.repeat(\" \", padding));\n\n    String jdoc = ((oi.jdoc == null) ? \"\" : oi.jdoc);\n    if (oi.no_doc_default || oi.default_str == null) {\n      f.format(\"%s\", jdoc);\n    } else {\n      String default_str = \"default \" + oi.default_str;\n      \/\/ The default string must be HTML-escaped since it comes from a string\n      \/\/ rather than a Javadoc comment.\n      String suffix = \"\";\n      if (jdoc.endsWith(\"<\/p>\")) {\n        suffix = \"<\/p>\";\n        jdoc = jdoc.substring(0, jdoc.length() - suffix.length());\n      }\n      f.format(\"%s [%s]%s\", jdoc, StringEscapeUtils.escapeHtml4(default_str), suffix);\n    }\n    if (oi.base_type.isEnum()) {\n      b.append(\"<ul>\");\n      assert oi.enum_jdoc != null\n          : \"@AssumeAssertion(nullness): dependent: non-null if oi.base_type is an enum\";\n      for (Map.Entry<String, String> entry : oi.enum_jdoc.entrySet()) {\n        b.append(\"<li><b>\").append(entry.getKey()).append(\"<\/b>\");\n        if (entry.getValue().length() != 0) {\n          b.append(\" \").append(entry.getValue());\n        }\n        b.append(\"<\/li>\");\n      }\n      b.append(\"<\/ul>\");\n    }\n    return b.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Get the line of HTML describing an Option.\n   * @param oi the option to describe\n   * @return HTML describing oi\n   ","methodParameters":[{"parameterType":"Options.OptionInfo","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.Options.OptionInfo","parameter":"Options.OptionInfo oi","parameterName":"oi"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int padding","parameterName":"padding"}],"methodName":"optionToHtml","methodQualifiedSignature":"plume.OptionsDoclet.optionToHtml","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Get the line of HTML describing an Option.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the option to describe'}]}', name=Optional[oi]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='HTML describing oi'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 687,col 26)-(line 687,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 688,col 16)-(line 688,col 28)","literalExprId":2,"literalExpr":"\"<b>-%s<\/b> \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 691,col 16)-(line 691,col 27)","literalExprId":3,"literalExpr":"\"<b>%s<\/b> \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 693,col 42)-(line 693,col 44)","literalExprId":4,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 693,col 48)-(line 693,col 51)","literalExprId":5,"literalExpr":"\"--\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 694,col 14)-(line 694,col 36)","literalExprId":6,"literalExpr":"\"<b>%s%s=<\/b><i>%s<\/i>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 695,col 20)-(line 695,col 23)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 696,col 16)-(line 696,col 34)","literalExprId":8,"literalExpr":"\" <code>[+]<\/code>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 698,col 14)-(line 698,col 19)","literalExprId":9,"literalExpr":"\".%n \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 699,col 14)-(line 699,col 17)","literalExprId":10,"literalExpr":"\"%s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 699,col 39)-(line 699,col 41)","literalExprId":11,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 701,col 32)-(line 701,col 35)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 701,col 40)-(line 701,col 41)","literalExprId":13,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 702,col 48)-(line 702,col 51)","literalExprId":14,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 703,col 16)-(line 703,col 19)","literalExprId":15,"literalExpr":"\"%s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 705,col 28)-(line 705,col 37)","literalExprId":16,"literalExpr":"\"default \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 708,col 23)-(line 708,col 24)","literalExprId":17,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 709,col 25)-(line 709,col 30)","literalExprId":18,"literalExpr":"\"<\/p>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 710,col 18)-(line 710,col 23)","literalExprId":19,"literalExpr":"\"<\/p>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 711,col 31)-(line 711,col 31)","literalExprId":20,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 713,col 16)-(line 713,col 26)","literalExprId":21,"literalExpr":"\"%s [%s]%s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 716,col 16)-(line 716,col 21)","literalExprId":22,"literalExpr":"\"<ul>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 717,col 30)-(line 717,col 33)","literalExprId":23,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 718,col 13)-(line 718,col 88)","literalExprId":24,"literalExpr":"\"@AssumeAssertion(nullness): dependent: non-null if oi.base_type is an enum\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 720,col 18)-(line 720,col 26)","literalExprId":25,"literalExpr":"\"<li><b>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 720,col 59)-(line 720,col 64)","literalExprId":26,"literalExpr":"\"<\/b>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 721,col 42)-(line 721,col 42)","literalExprId":27,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 722,col 20)-(line 722,col 22)","literalExprId":28,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 724,col 18)-(line 724,col 24)","literalExprId":29,"literalExpr":"\"<\/li>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 726,col 16)-(line 726,col 22)","literalExprId":30,"literalExpr":"\"<\/ul>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.optionToHtml(plume.Options.OptionInfo, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a Javadoc comment to convert to HTML","javadocBlockTagName":"doc","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Javadoc comment to convert to HTML'}]}', name=Optional[doc]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"HTML version of doc","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='HTML version of doc'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String javadocToHtml(Doc doc)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n        if (tag instanceof SeeTag) {\n            b.append(\"<code>\" + tag.text() + \"<\/code>\");\n        } else {\n            b.append(tag.text());\n        }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n        b.append(\" See: \");\n        {\n            StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n            for (SeeTag tag : seetags) {\n                bb.append(\"<code>\" + tag.text() + \"<\/code>\");\n            }\n            b.append(bb);\n        }\n        b.append(\".\");\n    }\n    return b.toString();\n}","methodRange":"(line 742,col 3)-(line 765,col 3)","methodTokenRange":"public static String javadocToHtml(Doc doc) {\n    StringBuilder b = new StringBuilder();\n    Tag[] tags = doc.inlineTags();\n    for (Tag tag : tags) {\n      if (tag instanceof SeeTag) {\n        b.append(\"<code>\" + tag.text() + \"<\/code>\");\n      } else {\n        b.append(tag.text());\n      }\n    }\n    SeeTag[] seetags = doc.seeTags();\n    if (seetags.length > 0) {\n      b.append(\" See: \");\n      {\n        StringBuilderDelimited bb = new StringBuilderDelimited(\", \");\n        for (SeeTag tag : seetags) {\n          bb.append(\"<code>\" + tag.text() + \"<\/code>\");\n        }\n        b.append(bb);\n      }\n      b.append(\".\");\n    }\n    return b.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Replace the @link tags and block @see tags in a Javadoc comment with\n   * sensible, non-hyperlinked HTML.  This keeps most of the information in the\n   * comment while still being presentable. <p>\n   *\n   * This is only a temporary solution.  Ideally, @link\/@see tags would be\n   * converted to HTML links that point to actual documentation.\n   *\n   * @param doc a Javadoc comment to convert to HTML\n   * @return HTML version of doc\n   ","methodParameters":[{"parameterType":"Doc","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Doc doc","parameterName":"doc"}],"methodName":"javadocToHtml","methodQualifiedSignature":"plume.OptionsDoclet.javadocToHtml","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Replace the @link tags and block @see tags in a Javadoc comment with\nsensible, non-hyperlinked HTML.  This keeps most of the information in the\ncomment while still being presentable. <p>\n\nThis is only a temporary solution.  Ideally, @link\/@see tags would be\nconverted to HTML links that point to actual documentation.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Javadoc comment to convert to HTML'}]}', name=Optional[doc]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='HTML version of doc'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 747,col 18)-(line 747,col 25)","literalExprId":1,"literalExpr":"\"<code>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 747,col 42)-(line 747,col 50)","literalExprId":2,"literalExpr":"\"<\/code>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 753,col 26)-(line 753,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 754,col 16)-(line 754,col 23)","literalExprId":4,"literalExpr":"\" See: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 756,col 64)-(line 756,col 67)","literalExprId":5,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 21)-(line 758,col 28)","literalExprId":6,"literalExpr":"\"<code>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 45)-(line 758,col 53)","literalExprId":7,"literalExpr":"\"<\/code>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 762,col 16)-(line 762,col 18)","literalExprId":8,"literalExpr":"\".\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"methodDeclaration":"public boolean getFormatJavadoc()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return formatJavadoc;\n}","methodRange":"(line 769,col 3)-(line 771,col 3)","methodTokenRange":"public boolean getFormatJavadoc() {\n    return formatJavadoc;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"getFormatJavadoc","methodQualifiedSignature":"plume.OptionsDoclet.getFormatJavadoc","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.OptionsDoclet.getFormatJavadoc()"},{"methodDeclaration":"public void setFormatJavadoc(boolean val)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (val && !formatJavadoc) {\n        startDelim = \"* \" + startDelim;\n        endDelim = \"* \" + endDelim;\n    } else if (!val && formatJavadoc) {\n        startDelim = StringUtils.removeStart(\"* \", startDelim);\n        endDelim = StringUtils.removeStart(\"* \", endDelim);\n    }\n    this.formatJavadoc = val;\n}","methodRange":"(line 773,col 3)-(line 782,col 3)","methodTokenRange":"public void setFormatJavadoc(boolean val) {\n    if (val && !formatJavadoc) {\n      startDelim = \"* \" + startDelim;\n      endDelim = \"* \" + endDelim;\n    } else if (!val && formatJavadoc) {\n      startDelim = StringUtils.removeStart(\"* \", startDelim);\n      endDelim = StringUtils.removeStart(\"* \", endDelim);\n    }\n    this.formatJavadoc = val;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean val","parameterName":"val"}],"methodName":"setFormatJavadoc","methodQualifiedSignature":"plume.OptionsDoclet.setFormatJavadoc","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 775,col 20)-(line 775,col 23)","literalExprId":1,"literalExpr":"\"* \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 776,col 18)-(line 776,col 21)","literalExprId":2,"literalExpr":"\"* \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 778,col 44)-(line 778,col 47)","literalExprId":3,"literalExpr":"\"* \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 779,col 42)-(line 779,col 45)","literalExprId":4,"literalExpr":"\"* \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.setFormatJavadoc(boolean)"},{"methodDeclaration":"public boolean getUseSingleDash()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return options.isUsingSingleDash();\n}","methodRange":"(line 784,col 3)-(line 786,col 3)","methodTokenRange":"public boolean getUseSingleDash() {\n    return options.isUsingSingleDash();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"getUseSingleDash","methodQualifiedSignature":"plume.OptionsDoclet.getUseSingleDash","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.OptionsDoclet.getUseSingleDash()"},{"methodDeclaration":"public void setUseSingleDash(boolean val)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    options.use_single_dash(true);\n}","methodRange":"(line 788,col 3)-(line 790,col 3)","methodTokenRange":"public void setUseSingleDash(boolean val) {\n    options.use_single_dash(true);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean val","parameterName":"val"}],"methodName":"setUseSingleDash","methodQualifiedSignature":"plume.OptionsDoclet.setUseSingleDash","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 789,col 29)-(line 789,col 32)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.OptionsDoclet.setUseSingleDash(boolean)"}],"classJavadoc":"","className":"OptionsDoclet","fields":[{"fieldRange":"(line 182,col 3)-(line 182,col 67)","fieldName":"eol","fieldJavadocComment":"","fieldTokenRange":"private static String eol = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 182,col 50)-(line 182,col 65)","literalExprId":1,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 184,col 3)-(line 193,col 70)","fieldName":"USAGE","fieldJavadocComment":"","fieldTokenRange":"private final static \/*@Format({})*\/ String USAGE =\n      \"Provided by Options doclet:%n\"\n          + \"-docfile <file>        Specify file into which options documentation is inserted%n\"\n          + \"-outfile <file>        Specify destination for resulting output%n\"\n          + \"-d <directory>         Destination directory for -outfile%n\"\n          + \"-i                     Edit the docfile in-place%n\"\n          + \"-format javadoc        Format output as a Javadoc comment%n\"\n          + \"-classdoc              Include 'main' class documentation in output%n\"\n          + \"-singledash            Use single dashes for long options (see plume.Options)%n\"\n          + \"See the OptionsDoclet documentation for more details.%n\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 185,col 7)-(line 185,col 37)","literalExprId":1,"literalExpr":"\"Provided by Options doclet:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 186,col 13)-(line 186,col 96)","literalExprId":2,"literalExpr":"\"-docfile <file>        Specify file into which options documentation is inserted%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 187,col 13)-(line 187,col 79)","literalExprId":3,"literalExpr":"\"-outfile <file>        Specify destination for resulting output%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 188,col 13)-(line 188,col 73)","literalExprId":4,"literalExpr":"\"-d <directory>         Destination directory for -outfile%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 189,col 13)-(line 189,col 64)","literalExprId":5,"literalExpr":"\"-i                     Edit the docfile in-place%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 190,col 13)-(line 190,col 73)","literalExprId":6,"literalExpr":"\"-format javadoc        Format output as a Javadoc comment%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 191,col 13)-(line 191,col 83)","literalExprId":7,"literalExpr":"\"-classdoc              Include 'main' class documentation in output%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 192,col 13)-(line 192,col 93)","literalExprId":8,"literalExpr":"\"-singledash            Use single dashes for long options (see plume.Options)%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 193,col 13)-(line 193,col 69)","literalExprId":9,"literalExpr":"\"See the OptionsDoclet documentation for more details.%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"Provided by Options doclet:%n\" + \"-docfile <file>        Specify file into which options documentation is inserted%n\" + \"-outfile <file>        Specify destination for resulting output%n\" + \"-d <directory>         Destination directory for -outfile%n\" + \"-i                     Edit the docfile in-place%n\" + \"-format javadoc        Format output as a Javadoc comment%n\" + \"-classdoc              Include 'main' class documentation in output%n\" + \"-singledash            Use single dashes for long options (see plume.Options)%n\" + \"See the OptionsDoclet documentation for more details.%n\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 195,col 3)-(line 196,col 71)","fieldName":"LIST_HELP","fieldJavadocComment":"","fieldTokenRange":"private static final String LIST_HELP =\n      \"<code>[+]<\/code> marked option can be specified multiple times\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 196,col 7)-(line 196,col 70)","literalExprId":1,"literalExpr":"\"<code>[+]<\/code> marked option can be specified multiple times\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"<code>[+]<\/code> marked option can be specified multiple times\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 198,col 3)-(line 198,col 81)","fieldName":"startDelim","fieldJavadocComment":"","fieldTokenRange":"private String startDelim = \"<!-- start options doc (DO NOT EDIT BY HAND) -->\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 198,col 31)-(line 198,col 80)","literalExprId":1,"literalExpr":"\"<!-- start options doc (DO NOT EDIT BY HAND) -->\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"<!-- start options doc (DO NOT EDIT BY HAND) -->\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 199,col 3)-(line 199,col 55)","fieldName":"endDelim","fieldJavadocComment":"","fieldTokenRange":"private String endDelim = \"<!-- end options doc -->\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 199,col 29)-(line 199,col 54)","literalExprId":1,"literalExpr":"\"<!-- end options doc -->\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"<!-- end options doc -->\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 201,col 3)-(line 201,col 44)","fieldName":"docFile","fieldJavadocComment":"","fieldTokenRange":"private \/*@Nullable*\/ File docFile = null;","fieldTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 201,col 40)-(line 201,col 43)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"File","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.io.File"},{"fieldRange":"(line 202,col 3)-(line 202,col 44)","fieldName":"outFile","fieldJavadocComment":"","fieldTokenRange":"private \/*@Nullable*\/ File outFile = null;","fieldTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 202,col 40)-(line 202,col 43)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"File","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.io.File"},{"fieldRange":"(line 205,col 3)-(line 205,col 34)","fieldName":"inPlace","fieldJavadocComment":" If true, then edit docFile in place (and docFile is non-null). ","fieldTokenRange":"private boolean inPlace = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 205,col 29)-(line 205,col 33)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"If true, then edit docFile in place (and docFile is non-null).\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 207,col 3)-(line 207,col 40)","fieldName":"formatJavadoc","fieldJavadocComment":" If true, then output format is Javadoc. ","fieldTokenRange":"private boolean formatJavadoc = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 207,col 35)-(line 207,col 39)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"If true, then output format is Javadoc.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 208,col 3)-(line 208,col 42)","fieldName":"includeClassDoc","fieldJavadocComment":"","fieldTokenRange":"private boolean includeClassDoc = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 208,col 37)-(line 208,col 41)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 210,col 3)-(line 210,col 23)","fieldName":"root","fieldJavadocComment":"","fieldTokenRange":"private RootDoc root;","fieldTypeResolved":"","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"RootDoc","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 211,col 3)-(line 211,col 26)","fieldName":"options","fieldJavadocComment":"","fieldTokenRange":"private Options options;","fieldTypeResolved":"ReferenceType{plume.Options, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Options","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.Options"}]}],"sourceFileId":21,"packageName":"plume"},{"sourceFileName":"plume.DeclarationAnnotations","imports":[{"importId":1,"import":"import com.google.common.reflect.ClassPath;\n"},{"importId":2,"import":"import com.google.common.reflect.ClassPath.ClassInfo;\n"},{"importId":3,"import":"import java.io.IOException;\n"},{"importId":4,"import":"import java.lang.annotation.Annotation;\n"},{"importId":5,"import":"import java.lang.annotation.ElementType;\n"},{"importId":6,"import":"import java.lang.annotation.Target;\n"},{"importId":7,"import":"import java.util.Set;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"methodDeclaration":"public static void main(String[] args) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    System.out.println(\"declarationAnnotationsBuiltin = set([\");\n    ClassLoader cl = DeclarationAnnotations.class.getClassLoader();\n    @SuppressWarnings(\"nullness\")\n    Set<ClassPath.ClassInfo> classes = ClassPath.from(cl).getAllClasses();\n    for (ClassPath.ClassInfo ci : classes) {\n        if (debug) {\n            System.out.println(\"Trying: \" + ci);\n        }\n        Class<?> c;\n        try {\n            c = ci.load();\n        } catch (Throwable e) {\n            if (debug) {\n                System.out.printf(\"Trouble in load(): %s: %s \\\"%s\\\"%n\", ci, e.getClass(), e.getMessage());\n            }\n            continue;\n        }\n        if (!c.isAnnotation())\n            continue;\n        Annotation anno = null;\n        try {\n            anno = c.getAnnotation(Target.class);\n        } catch (Throwable e) {\n            if (debug) {\n                System.out.printf(\"Trouble in getAnnotation(Target.class): %s: %s: %s \\\"%s\\\"%n\", ci, c, e.getClass(), e.getMessage());\n            }\n        }\n        if (anno != null) {\n            Target t = (Target) anno;\n            boolean isTypeAnnotation = false;\n            for (ElementType et : t.value()) {\n                if (et.name().equals(\"TYPE_USE\")) {\n                    isTypeAnnotation = true;\n                    break;\n                }\n            }\n            if (!isTypeAnnotation) {\n                System.out.println(\"  \\\"\" + ci.getSimpleName() + \"\\\", # \" + ci.getName());\n            }\n        }\n    }\n    System.out.println(\"])\");\n}","methodRange":"(line 29,col 3)-(line 82,col 3)","methodTokenRange":"public static void main(String[] args) throws IOException {\n\n    System.out.println(\"declarationAnnotationsBuiltin = set([\");\n\n    ClassLoader cl = DeclarationAnnotations.class.getClassLoader();\n    @SuppressWarnings(\"nullness\") \/\/ unannotated Guava library\n    Set<ClassPath.ClassInfo> classes = ClassPath.from(cl).getAllClasses();\n    for (ClassPath.ClassInfo ci : classes) {\n      if (debug) {\n        System.out.println(\"Trying: \" + ci);\n      }\n      Class<?> c;\n      try {\n        c = ci.load();\n      } catch (Throwable e) {\n        if (debug) {\n          System.out.printf(\"Trouble in load(): %s: %s \\\"%s\\\"%n\", ci, e.getClass(), e.getMessage());\n        }\n        continue;\n      }\n      if (!c.isAnnotation()) continue;\n      Annotation anno = null;\n      try {\n        anno = c.getAnnotation(Target.class);\n      } catch (Throwable e) {\n        if (debug) {\n          System.out.printf(\n              \"Trouble in getAnnotation(Target.class): %s: %s: %s \\\"%s\\\"%n\",\n              ci,\n              c,\n              e.getClass(),\n              e.getMessage());\n        }\n      }\n      if (anno != null) {\n        Target t = (Target) anno;\n        boolean isTypeAnnotation = false;\n        for (ElementType et : t.value()) {\n          \/\/ In Java 8, this can be \"if (et == ElementType.TYPE_USE)\".\n          if (et.name().equals(\"TYPE_USE\")) {\n            isTypeAnnotation = true;\n            break;\n          }\n        }\n        \/\/ Debugging output\n        \/\/ System.out.println((isTypeAnnotation ? \"type        \" : \"declaration \") + ci.getName());\n        if (!isTypeAnnotation) {\n          System.out.println(\"  \\\"\" + ci.getSimpleName() + \"\\\", # \" + ci.getName());\n        }\n      }\n    }\n\n    System.out.println(\"])\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.DeclarationAnnotations.main","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 31,col 24)-(line 31,col 62)","literalExprId":1,"literalExpr":"\"declarationAnnotationsBuiltin = set([\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 34,col 23)-(line 34,col 32)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 38,col 28)-(line 38,col 37)","literalExprId":3,"literalExpr":"\"Trying: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 45,col 29)-(line 45,col 64)","literalExprId":4,"literalExpr":"\"Trouble in load(): %s: %s \\\"%s\\\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 50,col 25)-(line 50,col 28)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 56,col 15)-(line 56,col 75)","literalExprId":6,"literalExpr":"\"Trouble in getAnnotation(Target.class): %s: %s: %s \\\"%s\\\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 63,col 19)-(line 63,col 22)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 65,col 36)-(line 65,col 40)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 68,col 32)-(line 68,col 41)","literalExprId":9,"literalExpr":"\"TYPE_USE\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 69,col 32)-(line 69,col 35)","literalExprId":10,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 76,col 30)-(line 76,col 35)","literalExprId":11,"literalExpr":"\"  \\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 76,col 60)-(line 76,col 67)","literalExprId":12,"literalExpr":"\"\\\", # \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 81,col 24)-(line 81,col 27)","literalExprId":13,"literalExpr":"\"])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.DeclarationAnnotations.main(java.lang.String[])"}],"classJavadoc":"","className":"DeclarationAnnotations","fields":[{"fieldRange":"(line 27,col 3)-(line 27,col 31)","fieldName":"debug","fieldJavadocComment":"","fieldTokenRange":"static boolean debug = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 27,col 26)-(line 27,col 30)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":22,"packageName":"plume"},{"sourceFileName":"plume.Option","imports":[{"importId":1,"import":"import java.lang.annotation.ElementType;\n"},{"importId":2,"import":"import java.lang.annotation.Retention;\n"},{"importId":3,"import":"import java.lang.annotation.RetentionPolicy;\n"},{"importId":4,"import":"import java.lang.annotation.Target;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[],"classJavadoc":"","className":"Option","fields":[]}],"sourceFileId":23,"packageName":"plume"},{"sourceFileName":"plume.RegexUtil","imports":[{"importId":1,"import":"import java.util.regex.Pattern;\n"},{"importId":2,"import":"import java.util.regex.PatternSyntaxException;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.RegexUtil.RegexUtil()","variableDeclarationExprs":[],"constructorRange":"(line 32,col 3)-(line 34,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private RegexUtil()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"RegexUtil","constructorQualifiedName":"plume.RegexUtil.RegexUtil","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 33,col 21)-(line 33,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private RegexUtil() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 67,col 3)-(line 138,col 3)","classOrInterfaceTokenRange":"public static class CheckedPatternSyntaxException extends Exception {\n\n    private static final long serialVersionUID = 6266881831979001480L;\n\n    \/** The PatternSyntaxException that this is a wrapper around. *\/\n    private final PatternSyntaxException pse;\n\n    \/**\n     * Constructs a new CheckedPatternSyntaxException equivalent to the\n     * given {@link PatternSyntaxException}.\n     * <p>\n     * Consider calling this constructor with the result of\n     * {@link RegexUtil#regexError}.\n     * @param pse the PatternSyntaxException to be wrapped\n     *\/\n    public CheckedPatternSyntaxException(PatternSyntaxException pse) {\n      this.pse = pse;\n    }\n\n    \/**\n     * Constructs a new CheckedPatternSyntaxException.\n     *\n     * @param desc a description of the error\n     * @param regex the erroneous pattern\n     * @param index the approximate index in the pattern of the error,\n     *              or {@code -1} if the index is not known\n     *\/\n    public CheckedPatternSyntaxException(String desc, String regex, int index) {\n      this(new PatternSyntaxException(desc, regex, index));\n    }\n\n    \/**\n     * Retrieves the description of the error.\n     *\n     * @return the description of the error\n     *\/\n    public String getDescription() {\n      return pse.getDescription();\n    }\n\n    \/**\n     * Retrieves the error index.\n     *\n     * @return the approximate index in the pattern of the error, or {@code -1}\n     *         if the index is not known\n     *\/\n    public int getIndex() {\n      return pse.getIndex();\n    }\n\n    \/**\n     * Returns a multi-line string containing the description of the syntax\n     * error and its index, the erroneous regular-expression pattern, and a\n     * visual indication of the error index within the pattern.\n     *\n     * @return the full detail message\n     *\/\n    @Override\n    \/*@Pure*\/\n    public String getMessage(\/*>>>@GuardSatisfied CheckedPatternSyntaxException this*\/) {\n      return pse.getMessage();\n    }\n\n    \/**\n     * Retrieves the erroneous regular-expression pattern.\n     *\n     * @return the erroneous pattern\n     *\/\n    public String getPattern() {\n      return pse.getPattern();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * A checked version of {@link PatternSyntaxException}.\n   * <p>\n   * This exception is useful when an illegal regex is detected but the\n   * contextual information to report a helpful error message is not available\n   * at the current depth in the call stack. By using a checked\n   * PatternSyntaxException the error must be handled up the call stack where\n   * a better error message can be reported.\n   * <p>\n   *\n   * Typical usage is:\n   * <pre>\n   * void myMethod(...) throws CheckedPatternSyntaxException {\n   *   ...\n   *   if (! isRegex(myString)) {\n   *     throw new CheckedPatternSyntaxException(...);\n   *   }\n   *   ... Pattern.compile(myString) ...\n   * <\/pre>\n   *\n   * Simply calling <code>Pattern.compile<\/code> would have a similar effect,\n   * in that <code>PatternSyntaxException<\/code> would be thrown at run time if\n   * <code>myString<\/code> is not a regular expression.  There are two problems\n   * with such an approach.  First, a client of <code>myMethod<\/code> might\n   * forget to handle the exception, since <code>PatternSyntaxException<\/code>\n   * is not checked.  Also, the Regex Checker would issue a warning about\n   * the call to <code>Pattern.compile<\/code> that might throw an exception.\n   * The above usage pattern avoids both problems.\n   *\n   * @see PatternSyntaxException\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A checked version of '}, JavadocInlineTag{tagName='link', type=LINK, content=' PatternSyntaxException'}, JavadocSnippet{text='.\n<p>\nThis exception is useful when an illegal regex is detected but the\ncontextual information to report a helpful error message is not available\nat the current depth in the call stack. By using a checked\nPatternSyntaxException the error must be handled up the call stack where\na better error message can be reported.\n<p>\n\nTypical usage is:\n<pre>\nvoid myMethod(...) throws CheckedPatternSyntaxException {\n  ...\n  if (! isRegex(myString)) {\n    throw new CheckedPatternSyntaxException(...);\n  }\n  ... Pattern.compile(myString) ...\n<\/pre>\n\nSimply calling <code>Pattern.compile<\/code> would have a similar effect,\nin that <code>PatternSyntaxException<\/code> would be thrown at run time if\n<code>myString<\/code> is not a regular expression.  There are two problems\nwith such an approach.  First, a client of <code>myMethod<\/code> might\nforget to handle the exception, since <code>PatternSyntaxException<\/code>\nis not checked.  Also, the Regex Checker would issue a warning about\nthe call to <code>Pattern.compile<\/code> that might throw an exception.\nThe above usage pattern avoids both problems.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='PatternSyntaxException'}]}', name=Optional.empty}]}]"}],"methods":[{"methodDeclaration":"public static boolean isRegex(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return isRegex(s, 0);\n}","methodRange":"(line 148,col 3)-(line 150,col 3)","methodTokenRange":"public static boolean isRegex(String s) {\n    return isRegex(s, 0);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"isRegex","methodQualifiedSignature":"plume.RegexUtil.isRegex","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 149,col 23)-(line 149,col 23)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.isRegex(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check for being a regular expression","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of groups expected","javadocBlockTagName":"groups","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff s is a regular expression with groups groups","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff s is a regular expression with groups groups'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isRegex(String s, int groups)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Pattern p;\n    try {\n        p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n        return false;\n    }\n    return getGroupCount(p) >= groups;\n}","methodRange":"(line 159,col 3)-(line 172,col 3)","methodTokenRange":"@SuppressWarnings({\"regex\", \"deterministic\"}) \/\/ RegexUtil; for purity, catches an exception\n  \/*@Pure*\/\n  \/\/ @EnsuresQualifierIf annotation is extraneous because this method is special-cased\n  \/\/ in RegexTransfer.\n  \/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*\/\n  public static boolean isRegex(String s, int groups) {\n    Pattern p;\n    try {\n      p = Pattern.compile(s);\n    } catch (PatternSyntaxException e) {\n      return false;\n    }\n    return getGroupCount(p) >= groups;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true if the argument is a syntactically valid regular\n   * expression with at least the given number of groups.\n   * @param s string to check for being a regular expression\n   * @param groups number of groups expected\n   * @return true iff s is a regular expression with groups groups\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int groups","parameterName":"groups"}],"methodName":"isRegex","methodQualifiedSignature":"plume.RegexUtil.isRegex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the argument is a syntactically valid regular\nexpression with at least the given number of groups.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff s is a regular expression with groups groups'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 159,col 22)-(line 159,col 28)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 159,col 31)-(line 159,col 45)","literalExprId":2,"literalExpr":"\"deterministic\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 169,col 14)-(line 169,col 18)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.isRegex(java.lang.String, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"char to check for being a regular expression","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='char to check for being a regular expression'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff c is a regular expression","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff c is a regular expression'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isRegex(char c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return isRegex(Character.toString(c));\n}","methodRange":"(line 180,col 3)-(line 188,col 3)","methodTokenRange":"@SuppressWarnings({\n    \"regex\",\n    \"purity.not.deterministic.call\"\n  }) \/\/ RegexUtil; temp value used in pure method is equal up to equals but not up to ==\n  \/*@Pure*\/\n  \/*@EnsuresQualifierIf(result=true, expression=\"#1\", qualifier=Regex.class)*\/\n  public static boolean isRegex(char c) {\n    return isRegex(Character.toString(c));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true if the argument is a syntactically valid regular\n   * expression.\n   * @param c char to check for being a regular expression\n   * @return true iff c is a regular expression\n   ","methodParameters":[{"parameterType":"char","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='char'}","parameterTypeResolvedDescribed":"char","parameter":"char c","parameterName":"c"}],"methodName":"isRegex","methodQualifiedSignature":"plume.RegexUtil.isRegex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the argument is a syntactically valid regular\nexpression.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='char to check for being a regular expression'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff c is a regular expression'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 181,col 5)-(line 181,col 11)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 182,col 5)-(line 182,col 35)","literalExprId":2,"literalExpr":"\"purity.not.deterministic.call\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.isRegex(char)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check for being a regular expression","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"null, or a string describing why the argument is not a regex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a string describing why the argument is not a regex'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String regexError(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return regexError(s, 0);\n}","methodRange":"(line 197,col 3)-(line 201,col 3)","methodTokenRange":"@SuppressWarnings(\"regex\") \/\/ RegexUtil\n  \/*@SideEffectFree*\/\n  public static \/*@Nullable*\/ String regexError(String s) {\n    return regexError(s, 0);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns null if the argument is a syntactically valid regular\n   * expression. Otherwise returns a string describing why the argument is\n   * not a regex.\n   * @param s string to check for being a regular expression\n   * @return null, or a string describing why the argument is not a regex\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"regexError","methodQualifiedSignature":"plume.RegexUtil.regexError","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns null if the argument is a syntactically valid regular\nexpression. Otherwise returns a string describing why the argument is\nnot a regex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a string describing why the argument is not a regex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 197,col 21)-(line 197,col 27)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 200,col 26)-(line 200,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.regexError(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check for being a regular expression","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of groups expected","javadocBlockTagName":"groups","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"null, or a string describing why the argument is not a regex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a string describing why the argument is not a regex'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String regexError(String s, int groups)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return regexErrorMessage(s, groups, actualGroups);\n        }\n    } catch (PatternSyntaxException e) {\n        return e.getMessage();\n    }\n    return null;\n}","methodRange":"(line 211,col 3)-(line 224,col 3)","methodTokenRange":"@SuppressWarnings({\"regex\", \"not.sef\"}) \/\/ RegexUtil;\n  \/*@SideEffectFree*\/\n  public static \/*@Nullable*\/ String regexError(String s, int groups) {\n    try {\n      Pattern p = Pattern.compile(s);\n      int actualGroups = getGroupCount(p);\n      if (actualGroups < groups) {\n        return regexErrorMessage(s, groups, actualGroups);\n      }\n    } catch (PatternSyntaxException e) {\n      return e.getMessage();\n    }\n    return null;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns null if the argument is a syntactically valid regular\n   * expression with at least the given number of groups. Otherwise returns\n   * a string describing why the argument is not a regex.\n   * @param s string to check for being a regular expression\n   * @param groups number of groups expected\n   * @return null, or a string describing why the argument is not a regex\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int groups","parameterName":"groups"}],"methodName":"regexError","methodQualifiedSignature":"plume.RegexUtil.regexError","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns null if the argument is a syntactically valid regular\nexpression with at least the given number of groups. Otherwise returns\na string describing why the argument is not a regex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a string describing why the argument is not a regex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 211,col 22)-(line 211,col 28)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 211,col 31)-(line 211,col 39)","literalExprId":2,"literalExpr":"\"not.sef\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 223,col 12)-(line 223,col 15)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.regexError(java.lang.String, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check for being a regular expression","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"null, or a PatternSyntaxException describing why the argument is not a regex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a PatternSyntaxException describing why the argument is not a regex'}]}', name=Optional.empty}"}],"methodDeclaration":"public static PatternSyntaxException regexException(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return regexException(s, 0);\n}","methodRange":"(line 233,col 3)-(line 237,col 3)","methodTokenRange":"@SuppressWarnings(\"regex\") \/\/ RegexUtil\n  \/*@SideEffectFree*\/\n  public static \/*@Nullable*\/ PatternSyntaxException regexException(String s) {\n    return regexException(s, 0);\n  }","methodReturnTypeResolved":"ReferenceType{java.util.regex.PatternSyntaxException, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns null if the argument is a syntactically valid regular\n   * expression. Otherwise returns a PatternSyntaxException describing\n   * why the argument is not a regex.\n   * @param s string to check for being a regular expression\n   * @return null, or a PatternSyntaxException describing why the argument is not a regex\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"regexException","methodQualifiedSignature":"plume.RegexUtil.regexException","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns null if the argument is a syntactically valid regular\nexpression. Otherwise returns a PatternSyntaxException describing\nwhy the argument is not a regex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a PatternSyntaxException describing why the argument is not a regex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.regex.PatternSyntaxException","methodType":"PatternSyntaxException","literalExprs":[{"literalExprRange":"(line 233,col 21)-(line 233,col 27)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 236,col 30)-(line 236,col 30)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.regexException(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check for being a regular expression","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of groups expected","javadocBlockTagName":"groups","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"null, or a PatternSyntaxException describing why the argument is not a regex","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a PatternSyntaxException describing why the argument is not a regex'}]}', name=Optional.empty}"}],"methodDeclaration":"public static PatternSyntaxException regexException(String s, int groups)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n        }\n    } catch (PatternSyntaxException pse) {\n        return pse;\n    }\n    return null;\n}","methodRange":"(line 247,col 3)-(line 260,col 3)","methodTokenRange":"@SuppressWarnings(\"regex\") \/\/ RegexUtil\n  \/*@SideEffectFree*\/\n  public static \/*@Nullable*\/ PatternSyntaxException regexException(String s, int groups) {\n    try {\n      Pattern p = Pattern.compile(s);\n      int actualGroups = getGroupCount(p);\n      if (actualGroups < groups) {\n        return new PatternSyntaxException(regexErrorMessage(s, groups, actualGroups), s, -1);\n      }\n    } catch (PatternSyntaxException pse) {\n      return pse;\n    }\n    return null;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.regex.PatternSyntaxException, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns null if the argument is a syntactically valid regular\n   * expression with at least the given number of groups. Otherwise returns a\n   * PatternSyntaxException describing why the argument is not a regex.\n   * @param s string to check for being a regular expression\n   * @param groups number of groups expected\n   * @return null, or a PatternSyntaxException describing why the argument is not a regex\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int groups","parameterName":"groups"}],"methodName":"regexException","methodQualifiedSignature":"plume.RegexUtil.regexException","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns null if the argument is a syntactically valid regular\nexpression with at least the given number of groups. Otherwise returns a\nPatternSyntaxException describing why the argument is not a regex.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='null, or a PatternSyntaxException describing why the argument is not a regex'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.regex.PatternSyntaxException","methodType":"PatternSyntaxException","literalExprs":[{"literalExprRange":"(line 247,col 21)-(line 247,col 27)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 254,col 91)-(line 254,col 91)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 259,col 12)-(line 259,col 15)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.regexException(java.lang.String, int)"},{"methodDeclaration":"public static String asRegex(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return asRegex(s, 0);\n}","methodRange":"(line 272,col 3)-(line 274,col 3)","methodTokenRange":"public static \/*@Regex*\/ String asRegex(String s) {\n    return asRegex(s, 0);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" The return type annotation is a conservative bound.","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"asRegex","methodQualifiedSignature":"plume.RegexUtil.asRegex","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 273,col 23)-(line 273,col 23)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.asRegex(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check for being a regular expression","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of groups expected","javadocBlockTagName":"groups","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"its argument","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='its argument'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if argument is not a regex","javadocBlockTagName":"Error","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if argument is not a regex'}]}', name=Optional[Error]}"}],"methodDeclaration":"public static String asRegex(String s, int groups)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        Pattern p = Pattern.compile(s);\n        int actualGroups = getGroupCount(p);\n        if (actualGroups < groups) {\n            throw new Error(regexErrorMessage(s, groups, actualGroups));\n        }\n        return s;\n    } catch (PatternSyntaxException e) {\n        throw new Error(e);\n    }\n}","methodRange":"(line 286,col 3)-(line 301,col 3)","methodTokenRange":"@SuppressWarnings(\"regex\") \/\/ RegexUtil\n  \/*@SideEffectFree*\/\n  \/\/ The return type annotation is irrelevant; it is special-cased by\n  \/\/ RegexAnnotatedTypeFactory.\n  public static \/*@Regex*\/ String asRegex(String s, int groups) {\n    try {\n      Pattern p = Pattern.compile(s);\n      int actualGroups = getGroupCount(p);\n      if (actualGroups < groups) {\n        throw new Error(regexErrorMessage(s, groups, actualGroups));\n      }\n      return s;\n    } catch (PatternSyntaxException e) {\n      throw new Error(e);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the argument as a {@code @Regex(groups) String} if it is a regex\n   * with at least the given number of groups, otherwise throws an error. The\n   * purpose of this method is to suppress Regex Checker warnings. It should\n   * be very rarely needed.\n   * @param s string to check for being a regular expression\n   * @param groups number of groups expected\n   * @return its argument\n   * @throws Error if argument is not a regex\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int groups","parameterName":"groups"}],"methodName":"asRegex","methodQualifiedSignature":"plume.RegexUtil.asRegex","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the argument as a '}, JavadocInlineTag{tagName='code', type=CODE, content=' @Regex(groups) String'}, JavadocSnippet{text=' if it is a regex\nwith at least the given number of groups, otherwise throws an error. The\npurpose of this method is to suppress Regex Checker warnings. It should\nbe very rarely needed.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check for being a regular expression'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of groups expected'}]}', name=Optional[groups]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='its argument'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if argument is not a regex'}]}', name=Optional[Error]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 286,col 21)-(line 286,col 27)","literalExprId":1,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.asRegex(java.lang.String, int)"},{"methodDeclaration":"private static String regexErrorMessage(String s, int expectedGroups, int actualGroups)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return \"regex \\\"\" + s + \"\\\" has \" + actualGroups + \" groups, but \" + expectedGroups + \" groups are needed.\";\n}","methodRange":"(line 311,col 3)-(line 319,col 3)","methodTokenRange":"private static String regexErrorMessage(String s, int expectedGroups, int actualGroups) {\n    return \"regex \\\"\"\n        + s\n        + \"\\\" has \"\n        + actualGroups\n        + \" groups, but \"\n        + expectedGroups\n        + \" groups are needed.\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int expectedGroups","parameterName":"expectedGroups"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int actualGroups","parameterName":"actualGroups"}],"methodName":"regexErrorMessage","methodQualifiedSignature":"plume.RegexUtil.regexErrorMessage","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 312,col 12)-(line 312,col 21)","literalExprId":1,"literalExpr":"\"regex \\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 314,col 11)-(line 314,col 19)","literalExprId":2,"literalExpr":"\"\\\" has \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 316,col 11)-(line 316,col 25)","literalExprId":3,"literalExpr":"\" groups, but \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 318,col 11)-(line 318,col 31)","literalExprId":4,"literalExpr":"\" groups are needed.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.regexErrorMessage(java.lang.String, int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"pattern whose groups to count","javadocBlockTagName":"p","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='pattern whose groups to count'}]}', name=Optional[p]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the count of groups in the argument","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the count of groups in the argument'}]}', name=Optional.empty}"}],"methodDeclaration":"private static int getGroupCount(Pattern p)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    return p.matcher(\"\").groupCount();\n}","methodRange":"(line 326,col 3)-(line 330,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ does not depend on object identity\n  \/*@Pure*\/\n  private static int getGroupCount(Pattern p) {\n    return p.matcher(\"\").groupCount();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the count of groups in the argument.\n   * @param p pattern whose groups to count\n   * @return the count of groups in the argument\n   ","methodParameters":[{"parameterType":"Pattern","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.regex.Pattern","parameter":"Pattern p","parameterName":"p"}],"methodName":"getGroupCount","methodQualifiedSignature":"plume.RegexUtil.getGroupCount","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the count of groups in the argument.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='pattern whose groups to count'}]}', name=Optional[p]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the count of groups in the argument'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 326,col 21)-(line 326,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 329,col 22)-(line 329,col 23)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.RegexUtil.getGroupCount(java.util.regex.Pattern)"}],"classJavadoc":"","className":"RegexUtil","fields":[]}],"sourceFileId":24,"packageName":"plume"},{"sourceFileName":"plume.JWhich","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.net.URL;\n"},{"importId":3,"import":"import java.util.StringTokenizer;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"JWhich","constructorQualifiedName":"plume.JWhich.JWhich","constructorQualifiedSignature":"plume.JWhich.JWhich()","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"private JWhich() {\n    getClasspath();\n  }","variableDeclarationExprs":[],"constructorRange":"(line 78,col 3)-(line 80,col 3)","constructorJavadocComment":" representing an object.","constructorDeclaration":"private JWhich()","constructorBody":"{\n    getClasspath();\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public static void which(String className)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    URL classUrl = findClass(className);\n    if (classUrl == null) {\n        System.out.println(\"\\nClass '\" + className + \"' not found.\");\n    } else {\n        System.out.println(\"\\nClass '\" + className + \"' found in \\n'\" + classUrl.getFile() + \"'\");\n    }\n    validate();\n    printClasspath();\n}","methodRange":"(line 90,col 3)-(line 103,col 3)","methodTokenRange":"public static void which(String className) {\n\n    URL classUrl = findClass(className);\n\n    if (classUrl == null) {\n      System.out.println(\"\\nClass '\" + className + \"' not found.\");\n    } else {\n      System.out.println(\"\\nClass '\" + className + \"' found in \\n'\" + classUrl.getFile() + \"'\");\n    }\n\n    validate();\n\n    printClasspath();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@EnsuresNonNull(\"CLASSPATH\")","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String className","parameterName":"className"}],"methodName":"which","methodQualifiedSignature":"plume.JWhich.which","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 94,col 21)-(line 94,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 95,col 26)-(line 95,col 36)","literalExprId":2,"literalExpr":"\"\\nClass '\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 95,col 52)-(line 95,col 65)","literalExprId":3,"literalExpr":"\"' not found.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 97,col 26)-(line 97,col 36)","literalExprId":4,"literalExpr":"\"\\nClass '\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 97,col 52)-(line 97,col 67)","literalExprId":5,"literalExpr":"\"' found in \\n'\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 97,col 92)-(line 97,col 94)","literalExprId":6,"literalExpr":"\"'\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.JWhich.which(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the class","javadocBlockTagName":"className","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the class'}]}', name=Optional[className]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"class URL, or null of the class was not found","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='class URL, or null of the class was not found'}]}', name=Optional.empty}"}],"methodDeclaration":"public static URL findClass(final String className)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return JWhich.class.getResource(asResourceName(className));\n}","methodRange":"(line 112,col 3)-(line 114,col 3)","methodTokenRange":"public static \/*@Nullable*\/ URL findClass(final String className) {\n    return JWhich.class.getResource(asResourceName(className));\n  }","methodReturnTypeResolved":"ReferenceType{java.net.URL, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the URL of the resource denoted by the specified\n   * class name, as prescribed by the class path.\n   *\n   * @param className name of the class\n   * @return class URL, or null of the class was not found\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"final String className","parameterName":"className"}],"methodName":"findClass","methodQualifiedSignature":"plume.JWhich.findClass","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the URL of the resource denoted by the specified\nclass name, as prescribed by the class path.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the class'}]}', name=Optional[className]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='class URL, or null of the class was not found'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.net.URL","methodType":"URL","literalExprs":[],"methodQualifiedName":"plume.JWhich.findClass(java.lang.String)"},{"methodDeclaration":"protected static String asResourceName(String resource)","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (!resource.startsWith(\"\/\")) {\n        resource = \"\/\" + resource;\n    }\n    resource = resource.replace('.', '\/');\n    resource = resource + \".class\";\n    return resource;\n}","methodRange":"(line 116,col 3)-(line 123,col 3)","methodTokenRange":"protected static String asResourceName(String resource) {\n    if (!resource.startsWith(\"\/\")) {\n      resource = \"\/\" + resource;\n    }\n    resource = resource.replace('.', '\/');\n    resource = resource + \".class\";\n    return resource;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String resource","parameterName":"resource"}],"methodName":"asResourceName","methodQualifiedSignature":"plume.JWhich.asResourceName","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 117,col 30)-(line 117,col 32)","literalExprId":1,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 118,col 18)-(line 118,col 20)","literalExprId":2,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 120,col 33)-(line 120,col 35)","literalExprId":3,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 120,col 38)-(line 120,col 40)","literalExprId":4,"literalExpr":"'\/'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 121,col 27)-(line 121,col 34)","literalExprId":5,"literalExpr":"\".class\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.JWhich.asResourceName(java.lang.String)"},{"methodDeclaration":"public static void validate()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringTokenizer tokenizer = new StringTokenizer(getClasspath(), File.pathSeparator);\n    while (tokenizer.hasMoreTokens()) {\n        String element = tokenizer.nextToken();\n        File f = new File(element);\n        if (!f.exists()) {\n            System.out.println(\"\\nClasspath element '\" + element + \"' does not exist.\");\n        } else if ((!f.isDirectory()) && (!element.toLowerCase().endsWith(\".jar\")) && (!element.toLowerCase().endsWith(\".zip\"))) {\n            System.out.println(\"\\nClasspath element '\" + element + \"' \" + \"is not a directory, .jar file, or .zip file.\");\n        }\n    }\n}","methodRange":"(line 133,col 3)-(line 154,col 3)","methodTokenRange":"public static void validate() {\n\n    StringTokenizer tokenizer = new StringTokenizer(getClasspath(), File.pathSeparator);\n\n    while (tokenizer.hasMoreTokens()) {\n      String element = tokenizer.nextToken();\n      File f = new File(element);\n\n      if (!f.exists()) {\n        System.out.println(\"\\nClasspath element '\" + element + \"' does not exist.\");\n      } else if ((!f.isDirectory())\n          && (!element.toLowerCase().endsWith(\".jar\"))\n          && (!element.toLowerCase().endsWith(\".zip\"))) {\n\n        System.out.println(\n            \"\\nClasspath element '\"\n                + element\n                + \"' \"\n                + \"is not a directory, .jar file, or .zip file.\");\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@EnsuresNonNull(\"CLASSPATH\")","methodParameters":[],"methodName":"validate","methodQualifiedSignature":"plume.JWhich.validate","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 142,col 28)-(line 142,col 50)","literalExprId":1,"literalExpr":"\"\\nClasspath element '\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 142,col 64)-(line 142,col 82)","literalExprId":2,"literalExpr":"\"' does not exist.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 144,col 47)-(line 144,col 52)","literalExprId":3,"literalExpr":"\".jar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 145,col 47)-(line 145,col 52)","literalExprId":4,"literalExpr":"\".zip\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 148,col 13)-(line 148,col 35)","literalExprId":5,"literalExpr":"\"\\nClasspath element '\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 150,col 19)-(line 150,col 22)","literalExprId":6,"literalExpr":"\"' \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 151,col 19)-(line 151,col 64)","literalExprId":7,"literalExpr":"\"is not a directory, .jar file, or .zip file.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.JWhich.validate()"},{"methodDeclaration":"public static void printClasspath()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    System.out.println(\"\\nClasspath:\");\n    StringTokenizer tokenizer = new StringTokenizer(getClasspath(), File.pathSeparator);\n    while (tokenizer.hasMoreTokens()) {\n        System.out.println(tokenizer.nextToken());\n    }\n}","methodRange":"(line 158,col 3)-(line 165,col 3)","methodTokenRange":"public static void printClasspath() {\n\n    System.out.println(\"\\nClasspath:\");\n    StringTokenizer tokenizer = new StringTokenizer(getClasspath(), File.pathSeparator);\n    while (tokenizer.hasMoreTokens()) {\n      System.out.println(tokenizer.nextToken());\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@EnsuresNonNull(\"CLASSPATH\")","methodParameters":[],"methodName":"printClasspath","methodQualifiedSignature":"plume.JWhich.printClasspath","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 160,col 24)-(line 160,col 37)","literalExprId":1,"literalExpr":"\"\\nClasspath:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.JWhich.printClasspath()"},{"methodDeclaration":"public static void setClasspath(String classpath)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    CLASSPATH = classpath;\n}","methodRange":"(line 171,col 3)-(line 173,col 3)","methodTokenRange":"public static void setClasspath(String classpath) {\n    CLASSPATH = classpath;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@EnsuresNonNull(\"CLASSPATH\")","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classpath","parameterName":"classpath"}],"methodName":"setClasspath","methodQualifiedSignature":"plume.JWhich.setClasspath","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.JWhich.setClasspath(java.lang.String)"},{"methodDeclaration":"protected static String getClasspath()","methodAccessSpecifier":"PROTECTED","methodBody":"{\n    if (CLASSPATH == null) {\n        String classpath = System.getProperty(\"java.class.path\");\n        setClasspath(classpath);\n    }\n    return CLASSPATH;\n}","methodRange":"(line 179,col 3)-(line 186,col 3)","methodTokenRange":"protected static String getClasspath() {\n    if (CLASSPATH == null) {\n      String classpath = System.getProperty(\"java.class.path\");\n      setClasspath(classpath);\n    }\n\n    return CLASSPATH;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@EnsuresNonNull(\"CLASSPATH\")","methodParameters":[],"methodName":"getClasspath","methodQualifiedSignature":"plume.JWhich.getClasspath","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 180,col 22)-(line 180,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 181,col 45)-(line 181,col 61)","literalExprId":2,"literalExpr":"\"java.class.path\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.JWhich.getClasspath()"},{"methodDeclaration":"private static void instanceMain(String[] args)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (args.length == 0) {\n        printUsage();\n    }\n    for (int cmdIndex = 0; cmdIndex < args.length; cmdIndex++) {\n        String cmd = args[cmdIndex];\n        if (\"-help\".equals(cmd)) {\n            printUsage();\n        } else {\n            which(cmd);\n        }\n    }\n}","methodRange":"(line 188,col 3)-(line 204,col 3)","methodTokenRange":"private static void instanceMain(String[] args) {\n\n    if (args.length == 0) {\n      printUsage();\n    }\n\n    for (int cmdIndex = 0; cmdIndex < args.length; cmdIndex++) {\n\n      String cmd = args[cmdIndex];\n\n      if (\"-help\".equals(cmd)) {\n        printUsage();\n      } else {\n        which(cmd);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"instanceMain","methodQualifiedSignature":"plume.JWhich.instanceMain","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 190,col 24)-(line 190,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 25)-(line 194,col 25)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 198,col 11)-(line 198,col 17)","literalExprId":3,"literalExpr":"\"-help\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.JWhich.instanceMain(java.lang.String[])"},{"javadocBlockTags":[],"methodDeclaration":"private static void printUsage()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    System.out.println(\"\\nSyntax: java JWhich [options] className\");\n    System.out.println(\"\");\n    System.out.println(\"where options include:\");\n    System.out.println(\"\");\n    System.out.println(\"\\t-help     Prints usage information.\");\n    System.out.println(\"\");\n    System.out.println(\"Examples:\");\n    System.out.println(\"\\tjava JWhich MyClass\");\n    System.out.println(\"\\tjava JWhich my.package.MyClass\");\n    System.exit(0);\n}","methodRange":"(line 207,col 3)-(line 219,col 3)","methodTokenRange":"private static void printUsage() {\n\n    System.out.println(\"\\nSyntax: java JWhich [options] className\");\n    System.out.println(\"\");\n    System.out.println(\"where options include:\");\n    System.out.println(\"\");\n    System.out.println(\"\\t-help     Prints usage information.\");\n    System.out.println(\"\");\n    System.out.println(\"Examples:\");\n    System.out.println(\"\\tjava JWhich MyClass\");\n    System.out.println(\"\\tjava JWhich my.package.MyClass\");\n    System.exit(0);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Print how to call the JWhich program. ","methodParameters":[],"methodName":"printUsage","methodQualifiedSignature":"plume.JWhich.printUsage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print how to call the JWhich program.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 209,col 24)-(line 209,col 66)","literalExprId":1,"literalExpr":"\"\\nSyntax: java JWhich [options] className\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 210,col 24)-(line 210,col 25)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 211,col 24)-(line 211,col 47)","literalExprId":3,"literalExpr":"\"where options include:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 212,col 24)-(line 212,col 25)","literalExprId":4,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 213,col 24)-(line 213,col 62)","literalExprId":5,"literalExpr":"\"\\t-help     Prints usage information.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 214,col 24)-(line 214,col 25)","literalExprId":6,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 215,col 24)-(line 215,col 34)","literalExprId":7,"literalExpr":"\"Examples:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 216,col 24)-(line 216,col 46)","literalExprId":8,"literalExpr":"\"\\tjava JWhich MyClass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 217,col 24)-(line 217,col 57)","literalExprId":9,"literalExpr":"\"\\tjava JWhich my.package.MyClass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 218,col 17)-(line 218,col 17)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.JWhich.printUsage()"},{"methodDeclaration":"public static void main(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    instanceMain(args);\n}","methodRange":"(line 221,col 3)-(line 223,col 3)","methodTokenRange":"public static void main(String[] args) {\n    instanceMain(args);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.JWhich.main","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.JWhich.main(java.lang.String[])"}],"classJavadoc":"\/**\n * <code>JWhich<\/code> is a utility that takes a Java class name\n * and displays the absolute pathname of the class file that would\n * be loaded first by the class loader, as prescribed by the\n * class path.\n * <p>\n * <code>JWhich<\/code> also validates the class path and reports\n * any non-existent or invalid class path entries.\n * <p>\n * Usage is similar to the UNIX <code>which<\/code> command.\n * <p>\n * Example uses:\n * <blockquote>\n *    To find the absolute pathname of <code>MyClass.class<\/code>\n *    not in a package:\n *    <pre>java JWhich MyClass<\/pre>\n *\n *    To find the absolute pathname of <code>MyClass.class<\/code>\n *    in the <code>my.package<\/code> package:\n *    <pre>java JWhich my.package.MyClass<\/pre>\n * <\/blockquote>\n *\n * @author <a href=\"mailto:mike@clarkware.com\">Mike Clark<\/a>\n * @author <a href=\"http:\/\/www.clarkware.com\">Clarkware Consulting, Inc.<\/a>\n *\/\n","className":"JWhich","fields":[{"fieldRange":"(line 74,col 3)-(line 74,col 56)","fieldName":"CLASSPATH","fieldJavadocComment":"","fieldTokenRange":"private static \/*@MonotonicNonNull*\/ String CLASSPATH;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":25,"packageName":"plume"},{"sourceFileName":"plume.TimeLimitProcess","imports":[{"importId":1,"import":"import java.io.ByteArrayInputStream;\n"},{"importId":2,"import":"import java.io.IOException;\n"},{"importId":3,"import":"import java.io.InputStream;\n"},{"importId":4,"import":"import java.io.OutputStream;\n"},{"importId":5,"import":"import java.io.StringWriter;\n"},{"importId":6,"import":"import java.io.UnsupportedEncodingException;\n"},{"importId":7,"import":"import java.nio.charset.Charset;\n"},{"importId":8,"import":"import java.util.Timer;\n"},{"importId":9,"import":"import java.util.TimerTask;\n"},{"importId":10,"import":"import org.apache.commons.io.IOUtils;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"non-null Process to limit the execution of","javadocBlockTagName":"p","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null Process to limit the execution of'}]}', name=Optional[p]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"in milliseconds","javadocBlockTagName":"timeLimit","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='in milliseconds'}]}', name=Optional[timeLimit]}"}],"constructorQualifiedSignature":"plume.TimeLimitProcess.TimeLimitProcess(java.lang.Process, long)","variableDeclarationExprs":[],"constructorRange":"(line 67,col 3)-(line 69,col 3)","constructorJavadocComment":"\n   * Creates a TimeLimitProcess with the given time limit, in wall clock\n   * milliseconds.\n   * @param p non-null Process to limit the execution of\n   * @param timeLimit in milliseconds\n   ","constructorDeclaration":"public TimeLimitProcess(Process p, long timeLimit)","constructorBody":"{\n    this(p, timeLimit, false);\n}","constructorName":"TimeLimitProcess","constructorQualifiedName":"plume.TimeLimitProcess.TimeLimitProcess","constructorParameters":[{"parameterType":"Process","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Process, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Process","parameter":"Process p","parameterName":"p"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long timeLimit","parameterName":"timeLimit"}],"literalExprs":[{"literalExprRange":"(line 68,col 24)-(line 68,col 28)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public TimeLimitProcess(Process p, long timeLimit) {\n    this(p, timeLimit, false);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a TimeLimitProcess with the given time limit, in wall clock\nmilliseconds.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null Process to limit the execution of'}]}', name=Optional[p]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='in milliseconds'}]}', name=Optional[timeLimit]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"non-null Process to limit the execution of","javadocBlockTagName":"p","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null Process to limit the execution of'}]}', name=Optional[p]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"in milliseconds","javadocBlockTagName":"timeLimit","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='in milliseconds'}]}', name=Optional[timeLimit]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"If true, causes the TimeLimitProcess to consume the standard output of the\nunderlying process, and to cache it.  After the process terminates (on\nits own or by being timed out), the output is available via the\ncached_stdout method.  This is necessary because when a Java process\nis terminated, its standard output is no longer available.","javadocBlockTagName":"cacheStdout","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='If true, causes the TimeLimitProcess to consume the standard output of the\nunderlying process, and to cache it.  After the process terminates (on\nits own or by being timed out), the output is available via the\ncached_stdout method.  This is necessary because when a Java process\nis terminated, its standard output is no longer available.'}]}', name=Optional[cacheStdout]}"}],"constructorQualifiedSignature":"plume.TimeLimitProcess.TimeLimitProcess(java.lang.Process, long, boolean)","variableDeclarationExprs":[{"variableType":"TPTimerTask","variableName":"tptt","variableDeclarationExprId":1,"variableDeclarationExpr":"@SuppressWarnings({ \"rawness\", \"initialization\" })\nTPTimerTask tptt = new TPTimerTask(this, timeLimit)","variableDeclarationExprRange":"(line 91,col 5)-(line 95,col 72)","variableTypeResolved":"ReferenceType{plume.TimeLimitProcess.TPTimerTask, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 95,col 34)-(line 95,col 72)"}],"constructorRange":"(line 83,col 3)-(line 103,col 3)","constructorJavadocComment":"\n   * Creates a TimeLimitProcess with the given time limit, in wall clock\n   * milliseconds.\n   * @param p non-null Process to limit the execution of\n   * @param timeLimit in milliseconds\n   * @param cacheStdout\n   * If true, causes the TimeLimitProcess to consume the standard output of the\n   * underlying process, and to cache it.  After the process terminates (on\n   * its own or by being timed out), the output is available via the\n   * cached_stdout method.  This is necessary because when a Java process\n   * is terminated, its standard output is no longer available.\n   ","constructorDeclaration":"public TimeLimitProcess(Process p, long timeLimit, boolean cacheStdout)","constructorBody":"{\n    this.p = p;\n    timer = new Timer(true);\n    this.timeLimit = timeLimit;\n    if (debug) {\n        System.out.printf(\"new timelimit process, timeLimit=%s, cacheStdout=%s%n\", timeLimit, cacheStdout);\n    }\n    @SuppressWarnings({ \"rawness\", \"initialization\" })\n    TPTimerTask tptt = new TPTimerTask(this, timeLimit);\n    timer.schedule(tptt, timeLimit);\n    if (cacheStdout) {\n        cached_stdout = new StringWriter();\n        cached_stderr = new StringWriter();\n        new StdoutStreamReaderThread().start();\n        new StderrStreamReaderThread().start();\n    }\n}","constructorName":"TimeLimitProcess","constructorQualifiedName":"plume.TimeLimitProcess.TimeLimitProcess","constructorParameters":[{"parameterType":"Process","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Process, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Process","parameter":"Process p","parameterName":"p"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long timeLimit","parameterName":"timeLimit"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cacheStdout","parameterName":"cacheStdout"}],"literalExprs":[{"literalExprRange":"(line 85,col 23)-(line 85,col 26)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 89,col 11)-(line 89,col 65)","literalExprId":2,"literalExpr":"\"new timelimit process, timeLimit=%s, cacheStdout=%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 92,col 7)-(line 92,col 15)","literalExprId":3,"literalExpr":"\"rawness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 93,col 7)-(line 93,col 22)","literalExprId":4,"literalExpr":"\"initialization\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public TimeLimitProcess(Process p, long timeLimit, boolean cacheStdout) {\n    this.p = p;\n    timer = new Timer(true);\n    this.timeLimit = timeLimit;\n    if (debug) {\n      System.out.printf(\n          \"new timelimit process, timeLimit=%s, cacheStdout=%s%n\", timeLimit, cacheStdout);\n    }\n    @SuppressWarnings({\n      \"rawness\",\n      \"initialization\"\n    }) \/\/ tptt won't do anything with this until this is fully initialized; can FBC avoid the @SuppressWarnings?\n    \/*@Initialized*\/ TPTimerTask tptt = new TPTimerTask(this, timeLimit);\n    timer.schedule(tptt, timeLimit);\n    if (cacheStdout) {\n      cached_stdout = new StringWriter();\n      cached_stderr = new StringWriter();\n      new StdoutStreamReaderThread().start();\n      new StderrStreamReaderThread().start();\n    }\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a TimeLimitProcess with the given time limit, in wall clock\nmilliseconds.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null Process to limit the execution of'}]}', name=Optional[p]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='in milliseconds'}]}', name=Optional[timeLimit]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='If true, causes the TimeLimitProcess to consume the standard output of the\nunderlying process, and to cache it.  After the process terminates (on\nits own or by being timed out), the output is available via the\ncached_stdout method.  This is necessary because when a Java process\nis terminated, its standard output is no longer available.'}]}', name=Optional[cacheStdout]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 240,col 3)-(line 272,col 3)","classOrInterfaceTokenRange":"private static class TPTimerTask extends TimerTask {\n    TimeLimitProcess tp;\n    long timeLimit;\n\n    public TPTimerTask(TimeLimitProcess tp, long timeLimit) {\n      this.tp = tp;\n      this.timeLimit = timeLimit;\n    }\n\n    public void run() {\n      \/\/ If exitValue is queried while the process is still running,\n      \/\/ the IllegalThreadStateException will be thrown.  If that\n      \/\/ happens, we kill the process and note that so callers can\n      \/\/ tell that a timeout occurred.\n      try {\n        int exit = tp.p.exitValue();\n        if (debug) {\n          System.out.println();\n          System.out.println(\"Process exited with status \" + exit);\n          System.out.println();\n        }\n      } catch (IllegalThreadStateException ie) {\n        tp.p.destroy();\n        tp.timed_out = true;\n        if (debug) {\n          System.out.println(\n              \"Terminated process after timelimit of \" + timeLimit + \" msecs expired\");\n          System.out.println();\n        }\n      }\n      this.cancel();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * This TimerTask destroys the process that is passed to it.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This TimerTask destroys the process that is passed to it.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 277,col 3)-(line 290,col 3)","classOrInterfaceTokenRange":"private class StdoutStreamReaderThread extends Thread {\n    @SuppressWarnings(\n        \"nullness\") \/\/ checker bug: NonNullOnEntry cannot access a variable in an enclosing class\n    \/*@RequiresNonNull(\"cached_stdout\")*\/\n    public void run() {\n      \/\/ This thread will block as the process produces output.  That's OK,\n      \/\/ because the blocking is happening in a separate thread.\n      try {\n        IOUtils.copy(p.getInputStream(), cached_stdout, Charset.defaultCharset());\n      } catch (IOException e) {\n        \/\/ assume the best\n      }\n    }\n  }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""},{"classOrInterfaceRange":"(line 292,col 3)-(line 305,col 3)","classOrInterfaceTokenRange":"private class StderrStreamReaderThread extends Thread {\n    @SuppressWarnings(\n        \"nullness\") \/\/ checker bug: NonNullOnEntry cannot access a variable in an enclosing class\n    \/*@RequiresNonNull(\"cached_stderr\")*\/\n    public void run() {\n      \/\/ This thread will block as the process produces output.  That's OK,\n      \/\/ because the blocking is happening in a separate thread.\n      try {\n        IOUtils.copy(p.getErrorStream(), cached_stderr, Charset.defaultCharset());\n      } catch (IOException e) {\n        \/\/ assume the best\n      }\n    }\n  }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the process has timed out","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the process has timed out'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean timed_out()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (timed_out);\n}","methodRange":"(line 110,col 3)-(line 112,col 3)","methodTokenRange":"public boolean timed_out() {\n    return (timed_out);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true if the process has timed out (has run for more than the\n   * timeLimit msecs specified in the constructor).\n   * @return true iff the process has timed out\n   ","methodParameters":[],"methodName":"timed_out","methodQualifiedSignature":"plume.TimeLimitProcess.timed_out","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the process has timed out (has run for more than the\ntimeLimit msecs specified in the constructor).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the process has timed out'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.TimeLimitProcess.timed_out()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the timeout time in msecs","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the timeout time in msecs'}]}', name=Optional.empty}"}],"methodDeclaration":"public long timeout_msecs()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (timeLimit);\n}","methodRange":"(line 118,col 3)-(line 120,col 3)","methodTokenRange":"public long timeout_msecs() {\n    return (timeLimit);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n   * Return the timeout time in msecs.\n   * @return the timeout time in msecs\n   ","methodParameters":[],"methodName":"timeout_msecs","methodQualifiedSignature":"plume.TimeLimitProcess.timeout_msecs","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the timeout time in msecs.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the timeout time in msecs'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.TimeLimitProcess.timeout_msecs()"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Process#destroy()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#destroy()'}]}', name=Optional.empty}"}],"methodDeclaration":"public void destroy()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    p.destroy();\n}","methodRange":"(line 138,col 3)-(line 140,col 3)","methodTokenRange":"public void destroy() {\n    p.destroy();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Kills the subprocess.\n   * @see Process#destroy()\n   ","methodParameters":[],"methodName":"destroy","methodQualifiedSignature":"plume.TimeLimitProcess.destroy","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Kills the subprocess.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#destroy()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.TimeLimitProcess.destroy()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the exit value for the subprocess","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the exit value for the subprocess'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Process#getErrorStream()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getErrorStream()'}]}', name=Optional.empty}"}],"methodDeclaration":"public int exitValue()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if ((p.exitValue() == 0) && timed_out) {\n        return 255;\n    } else {\n        return p.exitValue();\n    }\n}","methodRange":"(line 147,col 3)-(line 155,col 3)","methodTokenRange":"public int exitValue() {\n    \/\/ I'm not sure whether this is necessary; the Process.destroy()\n    \/\/ documentation doesn't specify the effect on the exit value.\n    if ((p.exitValue() == 0) && timed_out) {\n      return 255;\n    } else {\n      return p.exitValue();\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the exit value for the subprocess.\n   * @return the exit value for the subprocess\n   * @see Process#getErrorStream()\n   ","methodParameters":[],"methodName":"exitValue","methodQualifiedSignature":"plume.TimeLimitProcess.exitValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the exit value for the subprocess.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the exit value for the subprocess'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getErrorStream()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 150,col 27)-(line 150,col 27)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 14)-(line 151,col 16)","literalExprId":2,"literalExpr":"255","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TimeLimitProcess.exitValue()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the error stream","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the error stream'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Process#getErrorStream()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getErrorStream()'}]}', name=Optional.empty}"}],"methodDeclaration":"public InputStream getErrorStream()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (cached_stderr == null) {\n        @SuppressWarnings(\"nullness\")\n        InputStream errorStream = p.getErrorStream();\n        return errorStream;\n    } else {\n        String text = cached_stderr.toString();\n        try {\n            InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n            return is;\n        } catch (UnsupportedEncodingException e) {\n            throw new Error(e);\n        }\n    }\n}","methodRange":"(line 162,col 3)-(line 177,col 3)","methodTokenRange":"public InputStream getErrorStream() {\n    if (cached_stderr == null) {\n      @SuppressWarnings(\"nullness\") \/\/ non-null because we didn't redirect the error stream\n      \/*@NonNull*\/ InputStream errorStream = p.getErrorStream();\n      return errorStream;\n    } else {\n      \/\/ Convert a String to an InputStream\n      String text = cached_stderr.toString();\n      try {\n        InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n        return is;\n      } catch (UnsupportedEncodingException e) {\n        throw new Error(e);\n      }\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Gets the error stream connected to the error output of the subprocess.\n   * @return the error stream\n   * @see Process#getErrorStream()\n   ","methodParameters":[],"methodName":"getErrorStream","methodQualifiedSignature":"plume.TimeLimitProcess.getErrorStream","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the error stream connected to the error output of the subprocess.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the error stream'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getErrorStream()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.io.InputStream","methodType":"InputStream","literalExprs":[{"literalExprRange":"(line 163,col 26)-(line 163,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 164,col 25)-(line 164,col 34)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 171,col 65)-(line 171,col 71)","literalExprId":3,"literalExpr":"\"UTF-8\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TimeLimitProcess.getErrorStream()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the input stream","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the input stream'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Process#getInputStream()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getInputStream()'}]}', name=Optional.empty}"}],"methodDeclaration":"public InputStream getInputStream()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (cached_stdout == null) {\n        @SuppressWarnings(\"nullness\")\n        InputStream inputStream = p.getInputStream();\n        return inputStream;\n    } else {\n        return stringToInputStream(cached_stdout.toString());\n    }\n}","methodRange":"(line 184,col 3)-(line 192,col 3)","methodTokenRange":"public InputStream getInputStream() {\n    if (cached_stdout == null) {\n      @SuppressWarnings(\"nullness\") \/\/ non-null because we didn't redirect the input stream\n      \/*@NonNull*\/ InputStream inputStream = p.getInputStream();\n      return inputStream;\n    } else {\n      return stringToInputStream(cached_stdout.toString());\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Gets an input stream connected to the output of the subprocess.\n   * @return the input stream\n   * @see Process#getInputStream()\n   ","methodParameters":[],"methodName":"getInputStream","methodQualifiedSignature":"plume.TimeLimitProcess.getInputStream","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets an input stream connected to the output of the subprocess.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the input stream'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getInputStream()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.io.InputStream","methodType":"InputStream","literalExprs":[{"literalExprRange":"(line 185,col 26)-(line 185,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 186,col 25)-(line 186,col 34)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TimeLimitProcess.getInputStream()"},{"methodDeclaration":"private InputStream stringToInputStream(String text)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    try {\n        InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n        return is;\n    } catch (UnsupportedEncodingException e) {\n        throw new Error(e);\n    }\n}","methodRange":"(line 195,col 3)-(line 202,col 3)","methodTokenRange":"private InputStream stringToInputStream(String text) {\n    try {\n      InputStream is = new ByteArrayInputStream(text.getBytes(\"UTF-8\"));\n      return is;\n    } catch (UnsupportedEncodingException e) {\n      throw new Error(e);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Convert a String to an InputStream","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String text","parameterName":"text"}],"methodName":"stringToInputStream","methodQualifiedSignature":"plume.TimeLimitProcess.stringToInputStream","methodJavadoc":"","methodReturnTypeDescribed":"java.io.InputStream","methodType":"InputStream","literalExprs":[{"literalExprRange":"(line 197,col 63)-(line 197,col 69)","literalExprId":1,"literalExpr":"\"UTF-8\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TimeLimitProcess.stringToInputStream(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the output stream","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the output stream'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Process#getOutputStream()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getOutputStream()'}]}', name=Optional.empty}"}],"methodDeclaration":"public OutputStream getOutputStream()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return p.getOutputStream();\n}","methodRange":"(line 209,col 3)-(line 212,col 3)","methodTokenRange":"@SuppressWarnings(\"nullness\") \/\/ non-null because we didn't redirect the output stream\n  public OutputStream getOutputStream() {\n    return p.getOutputStream();\n  }","methodReturnTypeResolved":"ReferenceType{java.io.OutputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Gets the output stream connected to the input of the subprocess.\n   * @return the output stream\n   * @see Process#getOutputStream()\n   ","methodParameters":[],"methodName":"getOutputStream","methodQualifiedSignature":"plume.TimeLimitProcess.getOutputStream","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Gets the output stream connected to the input of the subprocess.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the output stream'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#getOutputStream()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.io.OutputStream","methodType":"OutputStream","literalExprs":[{"literalExprRange":"(line 209,col 21)-(line 209,col 30)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TimeLimitProcess.getOutputStream()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the exit value of the subprocess","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the exit value of the subprocess'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Process#waitFor()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#waitFor()'}]}', name=Optional.empty}"}],"methodDeclaration":"public int waitFor() throws InterruptedException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return p.waitFor();\n}","methodRange":"(line 219,col 3)-(line 221,col 3)","methodTokenRange":"public int waitFor() throws InterruptedException {\n    return p.waitFor();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Causes the current thread to wait, if necessary, until the process represented by this Process object has terminated.\n   * @return the exit value of the subprocess\n   * @see Process#waitFor()\n   ","methodParameters":[],"methodName":"waitFor","methodQualifiedSignature":"plume.TimeLimitProcess.waitFor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Causes the current thread to wait, if necessary, until the process represented by this Process object has terminated.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the exit value of the subprocess'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Process#waitFor()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.TimeLimitProcess.waitFor()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if the process if finished, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the process if finished, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean finished()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        p.exitValue();\n        return true;\n    } catch (IllegalThreadStateException ie) {\n        return false;\n    }\n}","methodRange":"(line 226,col 3)-(line 235,col 3)","methodTokenRange":"public boolean finished() {\n    try {\n      \/\/ Process.exitValue() throws an exception if the process is not\n      \/\/ finished.\n      p.exitValue();\n      return true;\n    } catch (IllegalThreadStateException ie) {\n      return false;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * @return true if the process if finished, false otherwise\n   ","methodParameters":[],"methodName":"finished","methodQualifiedSignature":"plume.TimeLimitProcess.finished","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if the process if finished, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 231,col 14)-(line 231,col 17)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 233,col 14)-(line 233,col 18)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.TimeLimitProcess.finished()"}],"classJavadoc":"\/**\n * TimeLimitProcess is a subclass of Process such that the process is\n * killed if it runs for more than the specified number of milliseconds.\n * Wall clock seconds, not CPU seconds, are measured.\n * The process should already be started when TimeLimitProcess is invoked.\n * Typical use:\n * <pre>\n *   ProcessBuilder pb = ...;\n *   TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);<\/pre>\n *\n * <b>Note<\/b>: If a Java process is destroyed (e.g., because it times\n * out), then its output is unreadable:  Java code trying to read its\n * output stream fails.  Here are two ways to get around this problem:\n *\n * <ul>\n * <li>\n * The client of TimeLimitProcess can send the process output to a file (or\n * ByteArrayOutputStream, etc.), which can be read after the process\n * terminates.  This is easy to do in Java 7, for example via\n * ProcessBuilder.redirectOutput(tempFile).  There does not appear to be an\n * easy way to do it in Java 6.\n * <\/li>\n * <li>\n * This class provides a workaround, in which it busy-waits reading the\n * standard and error outputs and stores them away.  Use\n * ...\n * <\/li>\n * <\/ul>\n *\/\n","className":"TimeLimitProcess","fields":[{"fieldRange":"(line 50,col 3)-(line 50,col 20)","fieldName":"p","fieldJavadocComment":"","fieldTokenRange":"private Process p;","fieldTypeResolved":"ReferenceType{java.lang.Process, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Process","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Process"},{"fieldRange":"(line 51,col 3)-(line 51,col 25)","fieldName":"timeLimit","fieldJavadocComment":"","fieldTokenRange":"private long timeLimit;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 52,col 3)-(line 52,col 36)","fieldName":"timed_out","fieldJavadocComment":"","fieldTokenRange":"private boolean timed_out = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 52,col 31)-(line 52,col 35)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 54,col 3)-(line 54,col 59)","fieldName":"cached_stdout","fieldJavadocComment":" can make public for testing","fieldTokenRange":"private \/*@MonotonicNonNull*\/ StringWriter cached_stdout;","fieldTypeResolved":"ReferenceType{java.io.StringWriter, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"StringWriter","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.io.StringWriter"},{"fieldRange":"(line 55,col 3)-(line 55,col 59)","fieldName":"cached_stderr","fieldJavadocComment":"","fieldTokenRange":"private \/*@MonotonicNonNull*\/ StringWriter cached_stderr;","fieldTypeResolved":"ReferenceType{java.io.StringWriter, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"StringWriter","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.io.StringWriter"},{"fieldRange":"(line 57,col 3)-(line 57,col 22)","fieldName":"timer","fieldJavadocComment":"","fieldTokenRange":"private Timer timer;","fieldTypeResolved":"ReferenceType{java.util.Timer, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Timer","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Timer"},{"fieldRange":"(line 59,col 3)-(line 59,col 39)","fieldName":"debug","fieldJavadocComment":"","fieldTokenRange":"private static boolean debug = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 59,col 34)-(line 59,col 38)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":26,"packageName":"plume"},{"sourceFileName":"plume.Intern","imports":[{"importId":1,"import":"import java.lang.ref.WeakReference;\n"},{"importId":2,"import":"import java.util.Arrays;\n"},{"importId":3,"import":"import java.util.Iterator;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.Intern.Intern()","variableDeclarationExprs":[],"constructorRange":"(line 30,col 3)-(line 32,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private Intern()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"Intern","constructorQualifiedName":"plume.Intern.Intern","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 31,col 21)-(line 31,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private Intern() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 105,col 3)-(line 116,col 3)","classOrInterfaceTokenRange":"private static final class IntegerHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Integer i = (Integer) o;\n      return i.intValue();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares Integers.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares Integers.\nThis is the obvious implementation that uses intValue() for the hashCode.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 123,col 3)-(line 134,col 3)","classOrInterfaceTokenRange":"private static final class LongHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Long i = (Long) o;\n      return i.intValue();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares Longs.\n   * This is the obvious implementation that uses intValue() for the hashCode.\n   * @see Hasher\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares Longs.\nThis is the obvious implementation that uses intValue() for the hashCode.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 142,col 3)-(line 152,col 3)","classOrInterfaceTokenRange":"private static final class IntArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((int[]) a1, (int[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((int[]) o);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares int[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(int[], int[])\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares int[] objects according\nto their contents.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Arrays#equals(int[], int[])'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 160,col 3)-(line 170,col 3)","classOrInterfaceTokenRange":"private static final class LongArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((long[]) a1, (long[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((long[]) o);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares long[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals (long[], long[])\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares long[] objects according\nto their contents.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Arrays#equals (long[], long[])'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 180,col 3)-(line 191,col 3)","classOrInterfaceTokenRange":"private static final class DoubleHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return a1.equals(a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      Double d = (Double) o;\n      return d.hashCode();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares Doubles.\n   * @see Hasher\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares Doubles.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 199,col 3)-(line 232,col 3)","classOrInterfaceTokenRange":"private static final class DoubleArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      \/\/ \"Arrays.equals\" considers +0.0 != -0.0.\n      \/\/ Also, it gives inconsistent results (on different JVMs\/classpaths?).\n      \/\/ return Arrays.equals((double[])a1, (double[])a2);\n      double[] da1 = (double[]) a1;\n      double[] da2 = (double[]) a2;\n      if (da1.length != da2.length) {\n        return false;\n      }\n      for (int i = 0; i < da1.length; i++) {\n        if (!((da1[i] == da2[i]) || (Double.isNaN(da1[i]) && Double.isNaN(da2[i])))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      double[] a = (double[]) o;\n      \/\/ Not Arrays.hashCode(a), for consistency with equals method\n      \/\/ immediately above.\n      double running = 0;\n      for (int i = 0; i < a.length; i++) {\n        double elt = (Double.isNaN(a[i]) ? 0.0 : a[i]);\n        running = running * FACTOR + elt * DOUBLE_FACTOR;\n      }\n      \/\/ Could add \"... % Integer.MAX_VALUE\" here; is that good to do?\n      long result = Math.round(running);\n      return (int) (result % Integer.MAX_VALUE);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares double[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[],Object[])\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares double[] objects according\nto their contents.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Arrays#equals(Object[],Object[])'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 240,col 3)-(line 250,col 3)","classOrInterfaceTokenRange":"private static final class StringArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((String[]) a1, (String[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((String[]) o);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   * Arrays.equals\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares String[] objects according\nto their contents.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher\nArrays.equals'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 258,col 3)-(line 268,col 3)","classOrInterfaceTokenRange":"private static final class ObjectArrayHasher implements Hasher {\n    @Override\n    public boolean equals(Object a1, Object a2) {\n      return Arrays.equals((\/*@Nullable*\/ Object[]) a1, (\/*@Nullable*\/ Object[]) a2);\n    }\n\n    @Override\n    public int hashCode(Object o) {\n      return Arrays.hashCode((Object[]) o);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares Object[] objects according\n   * to their contents.\n   * @see Hasher\n   * @see Arrays#equals(Object[], Object[])\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares Object[] objects according\nto their contents.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Arrays#equals(Object[], Object[])'}]}', name=Optional.empty}]}]"},{"classOrInterfaceRange":"(line 942,col 3)-(line 988,col 3)","classOrInterfaceTokenRange":"private static final class SequenceAndIndices<T extends \/*@Interned*\/ Object> {\n    public T seq;\n    public int start;\n    public int end;\n\n    \/**\n     * @param seq an interned array\n     *\/\n    public SequenceAndIndices(T seq, int start, int end) {\n      this.seq = seq;\n      this.start = start;\n      this.end = end;\n      assert isInterned(seq);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    \/*@Pure*\/\n    public boolean equals(\n        \/*>>>@GuardSatisfied SequenceAndIndices<T> this,*\/\n        \/*@GuardSatisfied*\/ \/*@Nullable*\/ Object other) {\n      if (other instanceof SequenceAndIndices<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SequenceAndIndices<T> other_sai = (SequenceAndIndices<T>) other;\n        return equals(other_sai);\n      } else {\n        return false;\n      }\n    }\n\n    \/*@Pure*\/\n    public boolean equals(\n        \/*>>>@GuardSatisfied SequenceAndIndices<T> this,*\/\n        \/*@GuardSatisfied*\/ SequenceAndIndices<T> other) {\n      return ((this.seq == other.seq) && this.start == other.start && this.end == other.end);\n    }\n\n    \/*@Pure*\/\n    public int hashCode(\/*>>>@GuardSatisfied SequenceAndIndices<T> this*\/) {\n      return seq.hashCode() + start * 30 - end * 2;\n    }\n\n    \/\/ For debugging\n    \/*@SideEffectFree*\/\n    public String toString(\/*>>>@GuardSatisfied SequenceAndIndices<T> this*\/) {\n      return \"SAI(\" + start + \",\" + end + \") from: \" + ArraysMDE.toString(seq);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Data structure for storing triples of a sequence and start and\n   * end indices, to represent a subsequence.  Requires that the\n   * sequence be interned.  Used for interning the repeated finding\n   * of subsequences on the same sequence.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Data structure for storing triples of a sequence and start and\nend indices, to represent a subsequence.  Requires that the\nsequence be interned.  Used for interning the repeated finding\nof subsequences on the same sequence.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 995,col 3)-(line 1009,col 3)","classOrInterfaceTokenRange":"private static final class SequenceAndIndicesHasher<T extends \/*@Interned*\/ Object>\n      implements Hasher {\n    public boolean equals(Object a1, Object a2) {\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai1 = (SequenceAndIndices<T>) a1;\n      @SuppressWarnings(\"unchecked\")\n      SequenceAndIndices<T> sai2 = (SequenceAndIndices<T>) a2;\n      \/\/ The SAI objects are *not* interned, but the arrays inside them are.\n      return sai1.equals(sai2);\n    }\n\n    public int hashCode(Object o) {\n      return o.hashCode();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Hasher object which hashes and compares String[] objects according\n   * to their contents.\n   * @see Hasher\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Hasher object which hashes and compares String[] objects according\nto their contents.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Hasher'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array whose elements to intern in place","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array whose elements to intern in place'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned version of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned version of a'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"String#intern","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='String#intern'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] internStrings(String[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (a[i] != null) {\n            a[i] = a[i].intern();\n        }\n    }\n    return a;\n}","methodRange":"(line 45,col 3)-(line 53,col 3)","methodTokenRange":"@SuppressWarnings(\"interning\") \/\/ side-effects the array in place (dangerous, but convenient)\n  public static \/*@Interned*\/ String[] internStrings(String[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (a[i] != null) {\n        a[i] = a[i].intern();\n      }\n    }\n    return a;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Replace each element of the array by its interned version.\n   * Side-effects the array, but also returns it.\n   * @param a the array whose elements to intern in place\n   * @return an interned version of a\n   * @see String#intern\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] a","parameterName":"a"}],"methodName":"internStrings","methodQualifiedSignature":"plume.Intern.internStrings","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Replace each element of the array by its interned version.\nSide-effects the array, but also returns it.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array whose elements to intern in place'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned version of a'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='String#intern'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 45,col 21)-(line 45,col 31)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 47,col 18)-(line 47,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 48,col 19)-(line 48,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Intern.internStrings(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to test for interning","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to test for interning'}]}', name=Optional[value]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff value is interned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff value is interned'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isInterned(Object value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (value == null) {\n        return true;\n    } else if (value instanceof String) {\n        return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n        return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n        return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n        return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n        return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n        return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n        return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n        return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n        return (value == intern((Object[]) value));\n    } else {\n        return true;\n    }\n}","methodRange":"(line 65,col 3)-(line 94,col 3)","methodTokenRange":"@SuppressWarnings(\"interning\") \/\/ interning implementation\n  \/*@Pure*\/\n  public static boolean isInterned(\/*@Nullable*\/ Object value) {\n    if (value == null) {\n      \/\/ nothing to do\n      return true;\n    } else if (value instanceof String) {\n      return (value == ((String) value).intern());\n    } else if (value instanceof String[]) {\n      return (value == intern((String[]) value));\n    } else if (value instanceof Integer) {\n      return (value == intern((Integer) value));\n    } else if (value instanceof Long) {\n      return (value == intern((Long) value));\n    } else if (value instanceof int[]) {\n      return (value == intern((int[]) value));\n    } else if (value instanceof long[]) {\n      return (value == intern((long[]) value));\n    } else if (value instanceof Double) {\n      return (value == intern((Double) value));\n    } else if (value instanceof double[]) {\n      return (value == intern((double[]) value));\n    } else if (value instanceof Object[]) {\n      return (value == intern((Object[]) value));\n    } else {\n      \/\/ Nothing to do, because we don't intern other types.\n      \/\/ System.out.println(\"What type? \" + value.getClass().getName());\n      return true;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true if the argument is interned (is canonical among all\n   * objects equal to itself).\n   * @param value the value to test for interning\n   * @return true iff value is interned\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object value","parameterName":"value"}],"methodName":"isInterned","methodQualifiedSignature":"plume.Intern.isInterned","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true if the argument is interned (is canonical among all\nobjects equal to itself).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to test for interning'}]}', name=Optional[value]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff value is interned'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 65,col 21)-(line 65,col 31)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 68,col 18)-(line 68,col 21)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 70,col 14)-(line 70,col 17)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 92,col 14)-(line 92,col 17)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.Intern.isInterned(java.lang.Object)"},{"methodDeclaration":"public static int numIntegers()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedIntegers.size();\n}","methodRange":"(line 370,col 3)-(line 372,col 3)","methodTokenRange":"public static int numIntegers() {\n    return internedIntegers.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" For testing only","methodParameters":[],"methodName":"numIntegers","methodQualifiedSignature":"plume.Intern.numIntegers","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numIntegers()"},{"methodDeclaration":"public static int numLongs()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedLongs.size();\n}","methodRange":"(line 374,col 3)-(line 376,col 3)","methodTokenRange":"public static int numLongs() {\n    return internedLongs.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numLongs","methodQualifiedSignature":"plume.Intern.numLongs","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numLongs()"},{"methodDeclaration":"public static int numIntArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedIntArrays.size();\n}","methodRange":"(line 378,col 3)-(line 380,col 3)","methodTokenRange":"public static int numIntArrays() {\n    return internedIntArrays.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numIntArrays","methodQualifiedSignature":"plume.Intern.numIntArrays","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numIntArrays()"},{"methodDeclaration":"public static int numLongArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedLongArrays.size();\n}","methodRange":"(line 382,col 3)-(line 384,col 3)","methodTokenRange":"public static int numLongArrays() {\n    return internedLongArrays.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numLongArrays","methodQualifiedSignature":"plume.Intern.numLongArrays","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numLongArrays()"},{"methodDeclaration":"public static int numDoubles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedDoubles.size();\n}","methodRange":"(line 386,col 3)-(line 388,col 3)","methodTokenRange":"public static int numDoubles() {\n    return internedDoubles.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numDoubles","methodQualifiedSignature":"plume.Intern.numDoubles","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numDoubles()"},{"methodDeclaration":"public static int numDoubleArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedDoubleArrays.size();\n}","methodRange":"(line 390,col 3)-(line 392,col 3)","methodTokenRange":"public static int numDoubleArrays() {\n    return internedDoubleArrays.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numDoubleArrays","methodQualifiedSignature":"plume.Intern.numDoubleArrays","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numDoubleArrays()"},{"methodDeclaration":"public static int numStringArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedStringArrays.size();\n}","methodRange":"(line 394,col 3)-(line 396,col 3)","methodTokenRange":"public static int numStringArrays() {\n    return internedStringArrays.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numStringArrays","methodQualifiedSignature":"plume.Intern.numStringArrays","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numStringArrays()"},{"methodDeclaration":"public static int numObjectArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedObjectArrays.size();\n}","methodRange":"(line 398,col 3)-(line 400,col 3)","methodTokenRange":"public static int numObjectArrays() {\n    return internedObjectArrays.size();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"","methodParameters":[],"methodName":"numObjectArrays","methodQualifiedSignature":"plume.Intern.numObjectArrays","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Intern.numObjectArrays()"},{"methodDeclaration":"public static Iterator<Integer> integers()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedIntegers.keySet().iterator();\n}","methodRange":"(line 402,col 3)-(line 404,col 3)","methodTokenRange":"public static Iterator<\/*@Interned*\/ Integer> integers() {\n    return internedIntegers.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"integers","methodQualifiedSignature":"plume.Intern.integers","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<java.lang.Integer>","methodType":"Iterator<Integer>","literalExprs":[],"methodQualifiedName":"plume.Intern.integers()"},{"methodDeclaration":"public static Iterator<Long> longs()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedLongs.keySet().iterator();\n}","methodRange":"(line 406,col 3)-(line 408,col 3)","methodTokenRange":"public static Iterator<\/*@Interned*\/ Long> longs() {\n    return internedLongs.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"longs","methodQualifiedSignature":"plume.Intern.longs","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<java.lang.Long>","methodType":"Iterator<Long>","literalExprs":[],"methodQualifiedName":"plume.Intern.longs()"},{"methodDeclaration":"public static Iterator<int[]> intArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedIntArrays.keySet().iterator();\n}","methodRange":"(line 410,col 3)-(line 412,col 3)","methodTokenRange":"public static Iterator<int \/*@Interned*\/ []> intArrays() {\n    return internedIntArrays.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"intArrays","methodQualifiedSignature":"plume.Intern.intArrays","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<int[]>","methodType":"Iterator<int[]>","literalExprs":[],"methodQualifiedName":"plume.Intern.intArrays()"},{"methodDeclaration":"public static Iterator<long[]> longArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedLongArrays.keySet().iterator();\n}","methodRange":"(line 414,col 3)-(line 416,col 3)","methodTokenRange":"public static Iterator<long \/*@Interned*\/ []> longArrays() {\n    return internedLongArrays.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ResolvedArrayType{PrimitiveTypeUsage{name='long'}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"longArrays","methodQualifiedSignature":"plume.Intern.longArrays","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<long[]>","methodType":"Iterator<long[]>","literalExprs":[],"methodQualifiedName":"plume.Intern.longArrays()"},{"methodDeclaration":"public static Iterator<Double> doubles()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedDoubles.keySet().iterator();\n}","methodRange":"(line 418,col 3)-(line 420,col 3)","methodTokenRange":"public static Iterator<\/*@Interned*\/ Double> doubles() {\n    return internedDoubles.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"doubles","methodQualifiedSignature":"plume.Intern.doubles","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<java.lang.Double>","methodType":"Iterator<Double>","literalExprs":[],"methodQualifiedName":"plume.Intern.doubles()"},{"methodDeclaration":"public static Iterator<double[]> doubleArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedDoubleArrays.keySet().iterator();\n}","methodRange":"(line 422,col 3)-(line 424,col 3)","methodTokenRange":"public static Iterator<double \/*@Interned*\/ []> doubleArrays() {\n    return internedDoubleArrays.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"doubleArrays","methodQualifiedSignature":"plume.Intern.doubleArrays","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<double[]>","methodType":"Iterator<double[]>","literalExprs":[],"methodQualifiedName":"plume.Intern.doubleArrays()"},{"methodDeclaration":"public static Iterator<String[]> stringArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedStringArrays.keySet().iterator();\n}","methodRange":"(line 426,col 3)-(line 428,col 3)","methodTokenRange":"public static Iterator<\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []> stringArrays() {\n    return internedStringArrays.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"stringArrays","methodQualifiedSignature":"plume.Intern.stringArrays","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<java.lang.String[]>","methodType":"Iterator<String[]>","literalExprs":[],"methodQualifiedName":"plume.Intern.stringArrays()"},{"methodDeclaration":"public static Iterator<Object[]> objectArrays()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedObjectArrays.keySet().iterator();\n}","methodRange":"(line 430,col 3)-(line 432,col 3)","methodTokenRange":"public static Iterator<\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []> objectArrays() {\n    return internedObjectArrays.keySet().iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"objectArrays","methodQualifiedSignature":"plume.Intern.objectArrays","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<java.lang.Object[]>","methodType":"Iterator<Object[]>","literalExprs":[],"methodQualifiedName":"plume.Intern.objectArrays()"},{"methodDeclaration":"public static String intern(String a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return null;\n    }\n    return a.intern();\n}","methodRange":"(line 442,col 3)-(line 448,col 3)","methodTokenRange":"public static \/*@Interned*\/ \/*@PolyNull*\/ String intern(\/*@PolyNull*\/ String a) {\n    \/\/ Checker Framework cannot typecheck:  return (a == null) ? null : a.intern();\n    if (a == null) {\n      return null;\n    }\n    return a.intern();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 444,col 14)-(line 444,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 445,col 14)-(line 445,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.String)"},{"methodDeclaration":"public static long intern(long l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return l;\n}","methodRange":"(line 457,col 3)-(line 459,col 3)","methodTokenRange":"public static long intern(long l) {\n    return l;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long l","parameterName":"l"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[],"methodQualifiedName":"plume.Intern.intern(long)"},{"methodDeclaration":"public static double intern(double d)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return d;\n}","methodRange":"(line 468,col 3)-(line 470,col 3)","methodTokenRange":"public static double intern(double d) {\n    return d;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d","parameterName":"d"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[],"methodQualifiedName":"plume.Intern.intern(double)"},{"methodDeclaration":"public static Integer intern(Integer a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    WeakReference<Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        @SuppressWarnings(\"cast\")\n        Integer result = (Integer) a;\n        internedIntegers.put(result, new WeakReference<Integer>(result));\n        return result;\n    }\n}","methodRange":"(line 481,col 3)-(line 493,col 3)","methodTokenRange":"@SuppressWarnings({\"interning\", \"purity\"}) \/\/ interning implementation\n  \/*@Pure*\/\n  public static \/*@Interned*\/ Integer intern(Integer a) {\n    WeakReference<\/*@Interned*\/ Integer> lookup = internedIntegers.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except in JSR 308)\n      \/*@Interned*\/ Integer result = (\/*@Interned*\/ Integer) a;\n      internedIntegers.put(result, new WeakReference<\/*@Interned*\/ Integer>(result));\n      return result;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" the same).  This does not currently take advantage of that.","methodParameters":[{"parameterType":"Integer","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Integer","parameter":"Integer a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 481,col 22)-(line 481,col 32)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 481,col 35)-(line 481,col 42)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 485,col 19)-(line 485,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 488,col 25)-(line 488,col 30)","literalExprId":4,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.Integer)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to intern","javadocBlockTagName":"i","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to intern'}]}', name=Optional[i]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned Integer with value i","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Integer with value i'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Integer internedInteger(int i)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return intern(Integer.valueOf(i));\n}","methodRange":"(line 500,col 3)-(line 502,col 3)","methodTokenRange":"public static \/*@Interned*\/ Integer internedInteger(int i) {\n    return intern(Integer.valueOf(i));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns an interned Integer with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int i","parameterName":"i"}],"methodName":"internedInteger","methodQualifiedSignature":"plume.Intern.internedInteger","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an interned Integer with value i.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to intern'}]}', name=Optional[i]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Integer with value i'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[],"methodQualifiedName":"plume.Intern.internedInteger(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to parse","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to parse'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned Integer parsed from s","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Integer parsed from s'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Integer internedInteger(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return intern(Integer.decode(s));\n}","methodRange":"(line 509,col 3)-(line 511,col 3)","methodTokenRange":"public static \/*@Interned*\/ Integer internedInteger(String s) {\n    return intern(Integer.decode(s));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns an interned Integer with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Integer parsed from s\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"internedInteger","methodQualifiedSignature":"plume.Intern.internedInteger","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an interned Integer with value parsed from the string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to parse'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Integer parsed from s'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[],"methodQualifiedName":"plume.Intern.internedInteger(java.lang.String)"},{"methodDeclaration":"public static Long intern(Long a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    WeakReference<Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        @SuppressWarnings(\"cast\")\n        Long result = (Long) a;\n        internedLongs.put(result, new WeakReference<Long>(result));\n        return result;\n    }\n}","methodRange":"(line 522,col 3)-(line 534,col 3)","methodTokenRange":"@SuppressWarnings({\"interning\", \"purity\"})\n  \/*@Pure*\/\n  public static \/*@Interned*\/ Long intern(Long a) {\n    WeakReference<\/*@Interned*\/ Long> lookup = internedLongs.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except in JSR 308)\n      \/*@Interned*\/ Long result = (\/*@Interned*\/ Long) a;\n      internedLongs.put(result, new WeakReference<\/*@Interned*\/ Long>(result));\n      return result;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" the same).  This could take advantage of that.","methodParameters":[{"parameterType":"Long","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Long","parameter":"Long a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Long","methodType":"Long","literalExprs":[{"literalExprRange":"(line 522,col 22)-(line 522,col 32)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 522,col 35)-(line 522,col 42)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 526,col 19)-(line 526,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 529,col 25)-(line 529,col 30)","literalExprId":4,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.Long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to intern","javadocBlockTagName":"i","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to intern'}]}', name=Optional[i]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned Integer with value i","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Integer with value i'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Long internedLong(long i)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return intern(Long.valueOf(i));\n}","methodRange":"(line 541,col 3)-(line 543,col 3)","methodTokenRange":"public static \/*@Interned*\/ Long internedLong(long i) {\n    return intern(Long.valueOf(i));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns an interned Long with value i.\n   * @param i the value to intern\n   * @return an interned Integer with value i\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long i","parameterName":"i"}],"methodName":"internedLong","methodQualifiedSignature":"plume.Intern.internedLong","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an interned Long with value i.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to intern'}]}', name=Optional[i]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Integer with value i'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Long","methodType":"Long","literalExprs":[],"methodQualifiedName":"plume.Intern.internedLong(long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to parse","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to parse'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned Long parsed from s","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Long parsed from s'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Long internedLong(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return intern(Long.decode(s));\n}","methodRange":"(line 550,col 3)-(line 552,col 3)","methodTokenRange":"public static \/*@Interned*\/ Long internedLong(String s) {\n    return intern(Long.decode(s));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns an interned Long with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Long parsed from s\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"internedLong","methodQualifiedSignature":"plume.Intern.internedLong","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an interned Long with value parsed from the string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to parse'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Long parsed from s'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Long","methodType":"Long","literalExprs":[],"methodQualifiedName":"plume.Intern.internedLong(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to canonicalize","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a canonical representation for the int[] array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the int[] array'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] intern(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    WeakReference<int[]> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        @SuppressWarnings(\"cast\")\n        int[] result = (int[]) a;\n        internedIntArrays.put(result, new WeakReference<int[]>(result));\n        return result;\n    }\n}","methodRange":"(line 566,col 3)-(line 582,col 3)","methodTokenRange":"@SuppressWarnings({\"interning\", \"purity\"})\n  \/*@Pure*\/\n  public static int \/*@Interned*\/ [] intern(int[] a) {\n    \/\/ Throwable stack = new Throwable(\"debug traceback\");\n    \/\/ stack.fillInStackTrace();\n    \/\/ stack.printStackTrace();\n\n    WeakReference<int \/*@Interned*\/ []> lookup = internedIntArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except in JSR 308)\n      \/*@Interned*\/ int[] result = (int \/*@Interned*\/ []) a;\n      internedIntArrays.put(result, new WeakReference<int \/*@Interned*\/ []>(result));\n      return result;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Intern (canonicalize) an int[].\n   * Return a canonical representation for the int[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the int[] array\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Intern (canonicalize) an int[].\nReturn a canonical representation for the int[] array.\nArrays are compared according to their elements.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the int[] array'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 566,col 22)-(line 566,col 32)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 566,col 35)-(line 566,col 42)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 574,col 19)-(line 574,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 577,col 25)-(line 577,col 30)","literalExprId":4,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to canonicalize","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a canonical representation for the long[] array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the long[] array'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] intern(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    WeakReference<long[]> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        @SuppressWarnings(\"cast\")\n        long[] result = (long[]) a;\n        internedLongArrays.put(result, new WeakReference<long[]>(result));\n        return result;\n    }\n}","methodRange":"(line 591,col 3)-(line 605,col 3)","methodTokenRange":"@SuppressWarnings({\"interning\", \"purity\"})\n  \/*@Pure*\/\n  public static long \/*@Interned*\/ [] intern(long[] a) {\n    \/\/System.out.printf (\"intern %s %s long[] %s%n\", a.getClass(),\n    \/\/                   a, Arrays.toString (a));\n    WeakReference<long \/*@Interned*\/ []> lookup = internedLongArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except in JSR 308)\n      \/*@Interned*\/ long[] result = (long \/*@Interned*\/ []) a;\n      internedLongArrays.put(result, new WeakReference<long \/*@Interned*\/ []>(result));\n      return result;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Intern (canonicalize) a long[].\n   * Return a canonical representation for the long[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the long[] array\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Intern (canonicalize) a long[].\nReturn a canonical representation for the long[] array.\nArrays are compared according to their elements.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the long[] array'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 591,col 22)-(line 591,col 32)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 591,col 35)-(line 591,col 42)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 597,col 19)-(line 597,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 600,col 25)-(line 600,col 30)","literalExprId":4,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(long[])"},{"methodDeclaration":"public static Double intern(Double a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.isNaN()) {\n        return internedDoubleNaN;\n    }\n    if (a.doubleValue() == 0) {\n        return internedDoubleZero;\n    }\n    WeakReference<Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        @SuppressWarnings(\"cast\")\n        Double result = (Double) a;\n        internedDoubles.put(result, new WeakReference<Double>(result));\n        return result;\n    }\n}","methodRange":"(line 616,col 3)-(line 636,col 3)","methodTokenRange":"@SuppressWarnings({\"interning\", \"purity\"})\n  \/*@Pure*\/\n  public static \/*@Interned*\/ Double intern(Double a) {\n    \/\/ Double.NaN == Double.Nan  always evaluates to false.\n    if (a.isNaN()) {\n      return internedDoubleNaN;\n    }\n    \/\/ Double.+0 == Double.-0,  but they compare true via equals()\n    if (a.doubleValue() == 0) { \/\/ catches both positive and negative zero\n      return internedDoubleZero;\n    }\n    WeakReference<\/*@Interned*\/ Double> lookup = internedDoubles.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except in JSR 308)\n      \/*@Interned*\/ Double result = (\/*@Interned*\/ Double) a;\n      internedDoubles.put(result, new WeakReference<\/*@Interned*\/ Double>(result));\n      return result;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" the same).  This could take advantage of that.","methodParameters":[{"parameterType":"Double","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Double","parameter":"Double a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Double","methodType":"Double","literalExprs":[{"literalExprRange":"(line 616,col 22)-(line 616,col 32)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 616,col 35)-(line 616,col 42)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 624,col 28)-(line 624,col 28)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 628,col 19)-(line 628,col 22)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 631,col 25)-(line 631,col 30)","literalExprId":5,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.Double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to intern","javadocBlockTagName":"d","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to intern'}]}', name=Optional[d]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned Double with value d","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Double with value d'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Double internedDouble(double d)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return intern(Double.valueOf(d));\n}","methodRange":"(line 643,col 3)-(line 645,col 3)","methodTokenRange":"public static \/*@Interned*\/ Double internedDouble(double d) {\n    return intern(Double.valueOf(d));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns an interned Double with value i.\n   * @param d the value to intern\n   * @return an interned Double with value d\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d","parameterName":"d"}],"methodName":"internedDouble","methodQualifiedSignature":"plume.Intern.internedDouble","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an interned Double with value i.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to intern'}]}', name=Optional[d]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Double with value d'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Double","methodType":"Double","literalExprs":[],"methodQualifiedName":"plume.Intern.internedDouble(double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to parse","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to parse'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an interned Double parsed from s","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Double parsed from s'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Double internedDouble(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return internedDouble(Double.parseDouble(s));\n}","methodRange":"(line 652,col 3)-(line 654,col 3)","methodTokenRange":"public static \/*@Interned*\/ Double internedDouble(String s) {\n    return internedDouble(Double.parseDouble(s));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns an interned Double with value parsed from the string.\n   * @param s the string to parse\n   * @return an interned Double parsed from s\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"internedDouble","methodQualifiedSignature":"plume.Intern.internedDouble","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an interned Double with value parsed from the string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to parse'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an interned Double parsed from s'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Double","methodType":"Double","literalExprs":[],"methodQualifiedName":"plume.Intern.internedDouble(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to canonicalize","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a canonical representation for the double[] array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the double[] array'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double[] intern(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    WeakReference<double[]> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        @SuppressWarnings(\"cast\")\n        double[] result = (double[]) a;\n        internedDoubleArrays.put(result, new WeakReference<double[]>(result));\n        return result;\n    }\n}","methodRange":"(line 668,col 3)-(line 680,col 3)","methodTokenRange":"@SuppressWarnings({\"interning\", \"purity\"})\n  \/*@Pure*\/\n  public static double \/*@Interned*\/ [] intern(double[] a) {\n    WeakReference<double \/*@Interned*\/ []> lookup = internedDoubleArrays.get(a);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except in JSR 308)\n      \/*@Interned*\/ double[] result = (double \/*@Interned*\/ []) a;\n      internedDoubleArrays.put(result, new WeakReference<double \/*@Interned*\/ []>(result));\n      return result;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","methodJavadocComment":"\n   * Intern (canonicalize) a double[].\n   * Return a canonical representation for the double[] array.\n   * Arrays are compared according to their elements.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the double[] array\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Intern (canonicalize) a double[].\nReturn a canonical representation for the double[] array.\nArrays are compared according to their elements.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the double[] array'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double[]","methodType":"double[]","literalExprs":[{"literalExprRange":"(line 668,col 22)-(line 668,col 32)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 668,col 35)-(line 668,col 42)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 672,col 19)-(line 672,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 675,col 25)-(line 675,col 30)","literalExprId":4,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to canonicalize","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a canonical representation for the String[] array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the String[] array'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] intern(String[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int k = 0; k < a.length; k++) {\n        assert a[k] == Intern.intern(a[k]);\n    }\n    WeakReference<String[]> lookup = internedStringArrays.get(a);\n    String[] result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (String[]) a;\n        internedStringArrays.put(result, new WeakReference<String[]>(result));\n    }\n    @SuppressWarnings(\"nullness\")\n    String[] polyresult = result;\n    return polyresult;\n}","methodRange":"(line 691,col 3)-(line 719,col 3)","methodTokenRange":"@SuppressWarnings({\n    \"interning\", \/\/ interns its argument\n    \"purity\",\n    \"cast\"\n  }) \/\/ cast is redundant (except in JSR 308)\n  \/*@Pure*\/\n  public static \/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ [] intern(\n      \/*@PolyNull*\/ \/*@Interned*\/ String[] a) {\n\n    \/\/ Make sure each element is already interned\n    for (int k = 0; k < a.length; k++) {\n      assert a[k] == Intern.intern(a[k]);\n    }\n\n    WeakReference<\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []> lookup =\n        internedStringArrays.get(a);\n    \/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []) a;\n      internedStringArrays.put(\n          result, new WeakReference<\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") \/\/ Polynull because value = parameter a, so same type & nullness as for parameter a\n    \/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ [] polyresult = result;\n    return polyresult;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Intern (canonicalize) an String[].\n   * Return a canonical representation for the String[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the String[] array\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Intern (canonicalize) an String[].\nReturn a canonical representation for the String[] array.\nArrays are compared according to their elements.\nThe elements should themselves already be interned;\nthey are compared using their equals() methods.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the String[] array'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 692,col 5)-(line 692,col 15)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 693,col 5)-(line 693,col 12)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 694,col 5)-(line 694,col 10)","literalExprId":3,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 701,col 18)-(line 701,col 18)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 708,col 19)-(line 708,col 22)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 716,col 9)-(line 716,col 18)","literalExprId":6,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to canonicalize","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a canonical representation for the Object[] array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the Object[] array'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Object[] intern(Object[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> lookup = internedObjectArrays.get(a);\n    Object[] result;\n    if (lookup != null) {\n        result = lookup.get();\n    } else {\n        result = (Object[]) a;\n        internedObjectArrays.put(result, new WeakReference<Object[]>(result));\n    }\n    @SuppressWarnings(\"nullness\")\n    Object[] polyresult = result;\n    return polyresult;\n}","methodRange":"(line 730,col 3)-(line 754,col 3)","methodTokenRange":"@SuppressWarnings({\n    \"interning\", \/\/ interns its argument\n    \"purity\",\n    \"cast\"\n  }) \/\/ cast is redundant (except in JSR 308)\n  \/*@Pure*\/\n  public static \/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ [] intern(\n      \/*@PolyNull*\/ \/*@Interned*\/ Object[] a) {\n    @SuppressWarnings(\n        \"nullness\") \/\/ Polynull because value = parameter a, so same type & nullness as for parameter a\n    WeakReference<\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []> lookup =\n        internedObjectArrays.get(a);\n    \/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ [] result;\n    if (lookup != null) {\n      result = lookup.get();\n    } else {\n      result = (\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []) a;\n      internedObjectArrays.put(\n          result, new WeakReference<\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []>(result));\n    }\n    @SuppressWarnings(\n        \"nullness\") \/\/ Polynull because value = parameter a, so same type & nullness as for parameter a\n    \/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ [] polyresult = result;\n    return polyresult;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Intern (canonicalize) an Object[].\n   * Return a canonical representation for the Object[] array.\n   * Arrays are compared according to their elements.\n   * The elements should themselves already be interned;\n   * they are compared using their equals() methods.\n   * @param a the array to canonicalize\n   * @return a canonical representation for the Object[] array\n   ","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Intern (canonicalize) an Object[].\nReturn a canonical representation for the Object[] array.\nArrays are compared according to their elements.\nThe elements should themselves already be interned;\nthey are compared using their equals() methods.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to canonicalize'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical representation for the Object[] array'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object[]","methodType":"Object[]","literalExprs":[{"literalExprRange":"(line 731,col 5)-(line 731,col 15)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 732,col 5)-(line 732,col 12)","literalExprId":2,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 733,col 5)-(line 733,col 10)","literalExprId":3,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 739,col 9)-(line 739,col 18)","literalExprId":4,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 743,col 19)-(line 743,col 22)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 751,col 9)-(line 751,col 18)","literalExprId":6,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.Object[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an Object to canonicalize","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an Object to canonicalize'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a canonical version of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical version of a'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Object intern(Object a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return null;\n    } else if (a instanceof String) {\n        return intern((String) a);\n    } else if (a instanceof String[]) {\n        @SuppressWarnings(\"interning\")\n        String[] asArray = (String[]) a;\n        return intern(asArray);\n    } else if (a instanceof Integer) {\n        return intern((Integer) a);\n    } else if (a instanceof Long) {\n        return intern((Long) a);\n    } else if (a instanceof int[]) {\n        return intern((int[]) a);\n    } else if (a instanceof long[]) {\n        return intern((long[]) a);\n    } else if (a instanceof Double) {\n        return intern((Double) a);\n    } else if (a instanceof double[]) {\n        return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n        @SuppressWarnings(\"interning\")\n        Object[] asArray = (Object[]) a;\n        return intern(asArray);\n    } else {\n        throw new IllegalArgumentException(\"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n}","methodRange":"(line 765,col 3)-(line 796,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ defensive coding: throw exception when argument is invalid\n  \/*@Pure*\/\n  public static \/*@Interned*\/ \/*@PolyNull*\/ Object intern(\/*@PolyNull*\/ Object a) {\n    if (a == null) {\n      return null;\n    } else if (a instanceof String) {\n      return intern((String) a);\n    } else if (a instanceof String[]) {\n      @SuppressWarnings(\"interning\")\n      \/*@Interned*\/ String[] asArray = (\/*@Interned*\/ String[]) a;\n      return intern(asArray);\n    } else if (a instanceof Integer) {\n      return intern((Integer) a);\n    } else if (a instanceof Long) {\n      return intern((Long) a);\n    } else if (a instanceof int[]) {\n      return intern((int[]) a);\n    } else if (a instanceof long[]) {\n      return intern((long[]) a);\n    } else if (a instanceof Double) {\n      return intern((Double) a);\n    } else if (a instanceof double[]) {\n      return intern((double[]) a);\n    } else if (a instanceof Object[]) {\n      @SuppressWarnings(\"interning\")\n      \/*@Interned*\/ Object[] asArray = (\/*@Interned*\/ Object[]) a;\n      return intern(asArray);\n    } else {\n      throw new IllegalArgumentException(\n          \"Arguments of type \" + a.getClass() + \" cannot be interned\");\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convenince method to intern an Object when we don't know its\n   * runtime type.  Its runtime type must be one of the types for\n   * which we have an intern() method, else an exception is thrown.\n   * If the argument is an array, its elements should themselves be\n   * interned.\n   * @param a an Object to canonicalize\n   * @return a canonical version of a\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object a","parameterName":"a"}],"methodName":"intern","methodQualifiedSignature":"plume.Intern.intern","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convenince method to intern an Object when we don't know its\nruntime type.  Its runtime type must be one of the types for\nwhich we have an intern() method, else an exception is thrown.\nIf the argument is an array, its elements should themselves be\ninterned.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an Object to canonicalize'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a canonical version of a'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 765,col 21)-(line 765,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 768,col 14)-(line 768,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 769,col 14)-(line 769,col 17)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 773,col 25)-(line 773,col 35)","literalExprId":4,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 789,col 25)-(line 789,col 35)","literalExprId":5,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 794,col 11)-(line 794,col 30)","literalExprId":6,"literalExpr":"\"Arguments of type \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 794,col 49)-(line 794,col 69)","literalExprId":7,"literalExpr":"\" cannot be interned\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.intern(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the sequence whose subsequence should be interned","javadocBlockTagName":"seq","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the start of the subsequence to be interned","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the end of the subsequence to be interned","javadocBlockTagName":"end","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a subsequence of seq from start to end that is interned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] internSubsequence(int[] seq, int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int[]> sai = new SequenceAndIndices<int[]>(seq, start, end);\n    WeakReference<int[]> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n        int[] subseq = Intern.intern(subseqUninterned);\n        internedIntSequenceAndIndices.put(sai, new WeakReference<int[]>(subseq));\n        return subseq;\n    }\n}","methodRange":"(line 815,col 3)-(line 828,col 3)","methodTokenRange":"public static int \/*@Interned*\/ [] internSubsequence(int \/*@Interned*\/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<int \/*@Interned*\/ []> sai =\n        new SequenceAndIndices<int \/*@Interned*\/ []>(seq, start, end);\n    WeakReference<int \/*@Interned*\/ []> lookup = internedIntSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      int[] subseqUninterned = ArraysMDE.subarray(seq, start, end - start);\n      int \/*@Interned*\/ [] subseq = Intern.intern(subseqUninterned);\n      internedIntSequenceAndIndices.put(sai, new WeakReference<int \/*@Interned*\/ []>(subseq));\n      return subseq;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return the subsequence of seq from start (inclusive) to end\n   * (exclusive) that is interned.  What's different about this method\n   * from manually finding the subsequence and interning the\n   * subsequence is that if the subsequence is already interned, we\n   * can avoid having to compute the sequence.  Since derived\n   * variables in Daikon compute the subsequence many times, this\n   * shortcut saves quite a bit of computation.  It saves even more\n   * when there may be many derived variables that are non-canonical,\n   * since they are guaranteed to be ==.\n   * <p>\n   * Requires that seq is already interned.\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] seq","parameterName":"seq"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"internSubsequence","methodQualifiedSignature":"plume.Intern.internSubsequence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the subsequence of seq from start (inclusive) to end\n(exclusive) that is interned.  What's different about this method\nfrom manually finding the subsequence and interning the\nsubsequence is that if the subsequence is already interned, we\ncan avoid having to compute the sequence.  Since derived\nvariables in Daikon compute the subsequence many times, this\nshortcut saves quite a bit of computation.  It saves even more\nwhen there may be many derived variables that are non-canonical,\nsince they are guaranteed to be ==.\n<p>\nRequires that seq is already interned.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 820,col 19)-(line 820,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Intern.internSubsequence(int[], int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the sequence whose subsequence should be interned","javadocBlockTagName":"seq","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the start of the subsequence to be interned","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the end of the subsequence to be interned","javadocBlockTagName":"end","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a subsequence of seq from start to end that is interned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#internSubsequence(int[], int, int)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] internSubsequence(long[] seq, int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long[]> sai = new SequenceAndIndices<long[]>(seq, start, end);\n    WeakReference<long[]> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        long[] subseq = Intern.intern(subseq_uninterned);\n        internedLongSequenceAndIndices.put(sai, new WeakReference<long[]>(subseq));\n        return subseq;\n    }\n}","methodRange":"(line 837,col 3)-(line 851,col 3)","methodTokenRange":"public static long \/*@Interned*\/ [] internSubsequence(\n      long \/*@Interned*\/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<long \/*@Interned*\/ []> sai =\n        new SequenceAndIndices<long \/*@Interned*\/ []>(seq, start, end);\n    WeakReference<long \/*@Interned*\/ []> lookup = internedLongSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      long[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      long \/*@Interned*\/ [] subseq = Intern.intern(subseq_uninterned);\n      internedLongSequenceAndIndices.put(sai, new WeakReference<long \/*@Interned*\/ []>(subseq));\n      return subseq;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] seq","parameterName":"seq"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"internSubsequence","methodQualifiedSignature":"plume.Intern.internSubsequence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 843,col 19)-(line 843,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Intern.internSubsequence(long[], int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the sequence whose subsequence should be interned","javadocBlockTagName":"seq","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the start of the subsequence to be interned","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the end of the subsequence to be interned","javadocBlockTagName":"end","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a subsequence of seq from start to end that is interned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#internSubsequence(int[], int, int)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double[] internSubsequence(double[] seq, int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double[]> sai = new SequenceAndIndices<double[]>(seq, start, end);\n    WeakReference<double[]> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        double[] subseq = Intern.intern(subseq_uninterned);\n        internedDoubleSequenceAndIndices.put(sai, new WeakReference<double[]>(subseq));\n        return subseq;\n    }\n}","methodRange":"(line 860,col 3)-(line 874,col 3)","methodTokenRange":"public static double \/*@Interned*\/ [] internSubsequence(\n      double \/*@Interned*\/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<double \/*@Interned*\/ []> sai =\n        new SequenceAndIndices<double \/*@Interned*\/ []>(seq, start, end);\n    WeakReference<double \/*@Interned*\/ []> lookup = internedDoubleSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      double[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      double \/*@Interned*\/ [] subseq = Intern.intern(subseq_uninterned);\n      internedDoubleSequenceAndIndices.put(sai, new WeakReference<double \/*@Interned*\/ []>(subseq));\n      return subseq;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","methodJavadocComment":"\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] seq","parameterName":"seq"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"internSubsequence","methodQualifiedSignature":"plume.Intern.internSubsequence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double[]","methodType":"double[]","literalExprs":[{"literalExprRange":"(line 866,col 19)-(line 866,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Intern.internSubsequence(double[], int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the sequence whose subsequence should be interned","javadocBlockTagName":"seq","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the start of the subsequence to be interned","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the end of the subsequence to be interned","javadocBlockTagName":"end","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a subsequence of seq from start to end that is interned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#internSubsequence(int[], int, int)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Object[] internSubsequence(Object[] seq, int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<Object[]> sai = new SequenceAndIndices<Object[]>(seq, start, end);\n    @SuppressWarnings(\"nullness\")\n    WeakReference<Object[]> lookup = internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        Object[] subseq = Intern.intern(subseq_uninterned);\n        @SuppressWarnings(\"nullness\")\n        Object ignore = internedObjectSequenceAndIndices.put(sai, new WeakReference<Object[]>(subseq));\n        return subseq;\n    }\n}","methodRange":"(line 883,col 3)-(line 904,col 3)","methodTokenRange":"public static \/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ [] internSubsequence(\n      \/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<\/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ []> sai =\n        new SequenceAndIndices<\/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") \/\/ same nullness as key\n    WeakReference<\/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ []> lookup =\n        internedObjectSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      \/*@PolyNull*\/ \/*@Interned*\/ Object[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      \/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") \/\/ safe because map does no side effects\n      Object\n          ignore = \/\/ assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedObjectSequenceAndIndices.put(\n                  sai,\n                  new WeakReference<\/*@PolyNull*\/ \/*@Interned*\/ Object \/*@Interned*\/ []>(subseq));\n      return subseq;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   ","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] seq","parameterName":"seq"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"internSubsequence","methodQualifiedSignature":"plume.Intern.internSubsequence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object[]","methodType":"Object[]","literalExprs":[{"literalExprRange":"(line 888,col 23)-(line 888,col 32)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 891,col 19)-(line 891,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 896,col 25)-(line 896,col 34)","literalExprId":3,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.internSubsequence(java.lang.Object[], int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the sequence whose subsequence should be interned","javadocBlockTagName":"seq","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the start of the subsequence to be interned","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index of the end of the subsequence to be interned","javadocBlockTagName":"end","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a subsequence of seq from start to end that is interned","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#internSubsequence(int[], int, int)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] internSubsequence(String[] seq, int start, int end)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<String[]> sai = new SequenceAndIndices<String[]>(seq, start, end);\n    @SuppressWarnings(\"nullness\")\n    WeakReference<String[]> lookup = internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n        return lookup.get();\n    } else {\n        String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n        String[] subseq = Intern.intern(subseq_uninterned);\n        @SuppressWarnings(\"nullness\")\n        Object ignore = internedStringSequenceAndIndices.put(sai, new WeakReference<String[]>(subseq));\n        return subseq;\n    }\n}","methodRange":"(line 913,col 3)-(line 934,col 3)","methodTokenRange":"public static \/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ [] internSubsequence(\n      \/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ [] seq, int start, int end) {\n    assert Intern.isInterned(seq);\n    SequenceAndIndices<\/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ []> sai =\n        new SequenceAndIndices<\/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ []>(seq, start, end);\n    @SuppressWarnings(\"nullness\") \/\/ same nullness as key\n    WeakReference<\/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ []> lookup =\n        internedStringSequenceAndIndices.get(sai);\n    if (lookup != null) {\n      return lookup.get();\n    } else {\n      \/*@PolyNull*\/ \/*@Interned*\/ String[] subseq_uninterned = ArraysMDE.subarray(seq, start, end - start);\n      \/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ [] subseq = Intern.intern(subseq_uninterned);\n      @SuppressWarnings(\"nullness\") \/\/ safe because map does no side effects\n      Object\n          ignore = \/\/ assignment just so there is a place to hang the @SuppressWarnings annotation\n          internedStringSequenceAndIndices.put(\n                  sai,\n                  new WeakReference<\/*@PolyNull*\/ \/*@Interned*\/ String \/*@Interned*\/ []>(subseq));\n      return subseq;\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * @param seq the sequence whose subsequence should be interned\n   * @param start the index of the start of the subsequence to be interned\n   * @param end the index of the end of the subsequence to be interned\n   * @return a subsequence of seq from start to end that is interned\n   * @see #internSubsequence(int[], int, int)\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] seq","parameterName":"seq"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int end","parameterName":"end"}],"methodName":"internSubsequence","methodQualifiedSignature":"plume.Intern.internSubsequence","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the sequence whose subsequence should be interned'}]}', name=Optional[seq]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the start of the subsequence to be interned'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index of the end of the subsequence to be interned'}]}', name=Optional[end]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a subsequence of seq from start to end that is interned'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#internSubsequence(int[], int, int)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 918,col 23)-(line 918,col 32)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 921,col 19)-(line 921,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 926,col 25)-(line 926,col 34)","literalExprId":3,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Intern.internSubsequence(java.lang.String[], int, int)"}],"classJavadoc":"\/**\n * Utilities for interning objects.  Interning is also known as\n * canonicalization or hash-consing:  it returns a single representative\n * object that <code>.equals()<\/code> the object, and the client discards the\n * argument and uses the result instead.  Since only one object exists for\n * every set of equal objects, space usage is reduced.  Time may also be\n * reduced, since it is possible to use <code>==<\/code> instead of\n * <code>.equals()<\/code> for comparisons.\n * <p>\n *\n * Java builds in interning for Strings, but not for other objects.  The\n * methods in this class extend interning to all Java objects.\n *\/\n","className":"Intern","fields":[{"fieldRange":"(line 172,col 3)-(line 172,col 39)","fieldName":"FACTOR","fieldJavadocComment":"","fieldTokenRange":"private static final int FACTOR = 23;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 172,col 37)-(line 172,col 38)","literalExprId":1,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[23]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 174,col 3)-(line 174,col 50)","fieldName":"DOUBLE_FACTOR","fieldJavadocComment":" private static final double DOUBLE_FACTOR = 65537;","fieldTokenRange":"private static final double DOUBLE_FACTOR = 263;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 174,col 47)-(line 174,col 49)","literalExprId":1,"literalExpr":"263","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[263]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 276,col 3)-(line 277,col 23)","fieldName":"internedIntegers","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\/*@Interned*\/ Integer, WeakReference<\/*@Interned*\/ Integer>>\n      internedIntegers;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, plume.WeakHasherMap.K=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<Integer, WeakReference<Integer>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<java.lang.Integer, java.lang.ref.WeakReference<java.lang.Integer>>"},{"fieldRange":"(line 278,col 3)-(line 278,col 100)","fieldName":"internedLongs","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\/*@Interned*\/ Long, WeakReference<\/*@Interned*\/ Long>> internedLongs;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, plume.WeakHasherMap.K=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<Long, WeakReference<Long>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<java.lang.Long, java.lang.ref.WeakReference<java.lang.Long>>"},{"fieldRange":"(line 279,col 3)-(line 280,col 24)","fieldName":"internedIntArrays","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<int \/*@Interned*\/ [], WeakReference<int \/*@Interned*\/ []>>\n      internedIntArrays;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}}}, plume.WeakHasherMap.K=ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<int[], WeakReference<int[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<int[], java.lang.ref.WeakReference<int[]>>"},{"fieldRange":"(line 281,col 3)-(line 282,col 25)","fieldName":"internedLongArrays","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<long \/*@Interned*\/ [], WeakReference<long \/*@Interned*\/ []>>\n      internedLongArrays;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{PrimitiveTypeUsage{name='long'}}}}}, plume.WeakHasherMap.K=ResolvedArrayType{PrimitiveTypeUsage{name='long'}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<long[], WeakReference<long[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<long[], java.lang.ref.WeakReference<long[]>>"},{"fieldRange":"(line 283,col 3)-(line 284,col 22)","fieldName":"internedDoubles","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\/*@Interned*\/ Double, WeakReference<\/*@Interned*\/ Double>>\n      internedDoubles;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}, plume.WeakHasherMap.K=ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<Double, WeakReference<Double>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<java.lang.Double, java.lang.ref.WeakReference<java.lang.Double>>"},{"fieldRange":"(line 285,col 3)-(line 285,col 56)","fieldName":"internedDoubleNaN","fieldJavadocComment":"","fieldTokenRange":"private static \/*@Interned*\/ Double internedDoubleNaN;","fieldTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Double","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Double"},{"fieldRange":"(line 286,col 3)-(line 286,col 57)","fieldName":"internedDoubleZero","fieldJavadocComment":"","fieldTokenRange":"private static \/*@Interned*\/ Double internedDoubleZero;","fieldTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Double","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Double"},{"fieldRange":"(line 287,col 3)-(line 288,col 27)","fieldName":"internedDoubleArrays","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<double \/*@Interned*\/ [], WeakReference<double \/*@Interned*\/ []>>\n      internedDoubleArrays;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}}}, plume.WeakHasherMap.K=ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<double[], WeakReference<double[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<double[], java.lang.ref.WeakReference<double[]>>"},{"fieldRange":"(line 289,col 3)-(line 292,col 27)","fieldName":"internedStringArrays","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          \/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ [],\n          WeakReference<\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []>>\n      internedStringArrays;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, plume.WeakHasherMap.K=ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<String[], WeakReference<String[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<java.lang.String[], java.lang.ref.WeakReference<java.lang.String[]>>"},{"fieldRange":"(line 293,col 3)-(line 296,col 27)","fieldName":"internedObjectArrays","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          \/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ [],\n          WeakReference<\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []>>\n      internedObjectArrays;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, plume.WeakHasherMap.K=ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<Object[], WeakReference<Object[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<java.lang.Object[], java.lang.ref.WeakReference<java.lang.Object[]>>"},{"fieldRange":"(line 297,col 3)-(line 299,col 36)","fieldName":"internedIntSequenceAndIndices","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          SequenceAndIndices<int \/*@Interned*\/ []>, WeakReference<int \/*@Interned*\/ []>>\n      internedIntSequenceAndIndices;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}}}, plume.WeakHasherMap.K=ReferenceType{plume.Intern.SequenceAndIndices, typeParametersMap=TypeParametersMap{nameToValue={plume.Intern.SequenceAndIndices.T=ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<SequenceAndIndices<int[]>, WeakReference<int[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<plume.Intern.SequenceAndIndices<int[]>, java.lang.ref.WeakReference<int[]>>"},{"fieldRange":"(line 300,col 3)-(line 302,col 37)","fieldName":"internedLongSequenceAndIndices","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          SequenceAndIndices<long \/*@Interned*\/ []>, WeakReference<long \/*@Interned*\/ []>>\n      internedLongSequenceAndIndices;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{PrimitiveTypeUsage{name='long'}}}}}, plume.WeakHasherMap.K=ReferenceType{plume.Intern.SequenceAndIndices, typeParametersMap=TypeParametersMap{nameToValue={plume.Intern.SequenceAndIndices.T=ResolvedArrayType{PrimitiveTypeUsage{name='long'}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<SequenceAndIndices<long[]>, WeakReference<long[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<plume.Intern.SequenceAndIndices<long[]>, java.lang.ref.WeakReference<long[]>>"},{"fieldRange":"(line 303,col 3)-(line 305,col 39)","fieldName":"internedDoubleSequenceAndIndices","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          SequenceAndIndices<double \/*@Interned*\/ []>, WeakReference<double \/*@Interned*\/ []>>\n      internedDoubleSequenceAndIndices;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}}}, plume.WeakHasherMap.K=ReferenceType{plume.Intern.SequenceAndIndices, typeParametersMap=TypeParametersMap{nameToValue={plume.Intern.SequenceAndIndices.T=ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<SequenceAndIndices<double[]>, WeakReference<double[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<plume.Intern.SequenceAndIndices<double[]>, java.lang.ref.WeakReference<double[]>>"},{"fieldRange":"(line 306,col 3)-(line 309,col 39)","fieldName":"internedObjectSequenceAndIndices","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          SequenceAndIndices<\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []>,\n          WeakReference<\/*@Nullable*\/ \/*@Interned*\/ Object \/*@Interned*\/ []>>\n      internedObjectSequenceAndIndices;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, plume.WeakHasherMap.K=ReferenceType{plume.Intern.SequenceAndIndices, typeParametersMap=TypeParametersMap{nameToValue={plume.Intern.SequenceAndIndices.T=ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<SequenceAndIndices<Object[]>, WeakReference<Object[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<plume.Intern.SequenceAndIndices<java.lang.Object[]>, java.lang.ref.WeakReference<java.lang.Object[]>>"},{"fieldRange":"(line 310,col 3)-(line 313,col 39)","fieldName":"internedStringSequenceAndIndices","fieldJavadocComment":"","fieldTokenRange":"private static WeakHasherMap<\n          SequenceAndIndices<\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []>,\n          WeakReference<\/*@Nullable*\/ \/*@Interned*\/ String \/*@Interned*\/ []>>\n      internedStringSequenceAndIndices;","fieldTypeResolved":"ReferenceType{plume.WeakHasherMap, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakHasherMap.V=ReferenceType{java.lang.ref.WeakReference, typeParametersMap=TypeParametersMap{nameToValue={java.lang.ref.WeakReference.T=ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}, plume.WeakHasherMap.K=ReferenceType{plume.Intern.SequenceAndIndices, typeParametersMap=TypeParametersMap{nameToValue={plume.Intern.SequenceAndIndices.T=ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"WeakHasherMap<SequenceAndIndices<String[]>, WeakReference<String[]>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.WeakHasherMap<plume.Intern.SequenceAndIndices<java.lang.String[]>, java.lang.ref.WeakReference<java.lang.String[]>>"}]}],"sourceFileId":27,"packageName":"plume"},{"sourceFileName":"plume.GraphMDE","imports":[{"importId":1,"import":"import java.io.PrintStream;\n"},{"importId":2,"import":"import java.util.ArrayList;\n"},{"importId":3,"import":"import java.util.Collections;\n"},{"importId":4,"import":"import java.util.HashMap;\n"},{"importId":5,"import":"import java.util.List;\n"},{"importId":6,"import":"import java.util.Map;\n"},{"importId":7,"import":"import java.util.Set;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.GraphMDE.GraphMDE()","variableDeclarationExprs":[],"constructorRange":"(line 22,col 3)-(line 24,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private GraphMDE()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"GraphMDE","constructorQualifiedName":"plume.GraphMDE.GraphMDE","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 23,col 21)-(line 23,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private GraphMDE() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the graph nodes","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the graph nodes'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a graph, represented as a predecessor map","javadocBlockTagName":"predecessors","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a graph, represented as a predecessor map'}]}', name=Optional[predecessors]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a map from each node to a list of its pre-dominators","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a map from each node to a list of its pre-dominators'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Map<T, List<T>> dominators(Map<T, List<T>> predecessors)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n    @SuppressWarnings(\"keyfor\")\n    Map<T, List<T>> preds = predecessors;\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n    List<T> roots = new ArrayList<T>();\n    List<T> non_roots = new ArrayList<T>();\n    for (T node : preds.keySet()) {\n        if (preds.get(node).isEmpty()) {\n            Set<T> set = Collections.singleton(node);\n            dom.put(node, new ArrayList<T>(set));\n            roots.add(node);\n        } else {\n            dom.put(node, new ArrayList<T>(nodes));\n            non_roots.add(node);\n        }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n    boolean changed = true;\n    while (changed) {\n        changed = false;\n        for (T node : non_roots) {\n            List<T> new_doms = null;\n            assert preds.containsKey(node);\n            for (T pred : preds.get(node)) {\n                assert dom.containsKey(pred);\n                List<T> dom_of_pred = dom.get(pred);\n                if (new_doms == null) {\n                    new_doms = new ArrayList<T>(dom_of_pred);\n                } else {\n                    new_doms.retainAll(dom_of_pred);\n                }\n            }\n            assert new_doms != null : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n            new_doms.add(node);\n            assert dom.containsKey(node);\n            if (!dom.get(node).equals(new_doms)) {\n                dom.put(node, new_doms);\n                changed = true;\n            }\n        }\n    }\n    for (T node : preds.keySet()) {\n        assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n    return dom;\n}","methodRange":"(line 61,col 3)-(line 140,col 3)","methodTokenRange":"public static <T> Map<T, List<T>> dominators(Map<T, List<\/*@KeyFor(\"#1\")*\/ T>> predecessors) {\n\n    \/\/ Map<\/*@KeyFor({\"preds\",\"dom\"})*\/ T,List<\/*@KeyFor({\"preds\",\"dom\"})*\/ T>> dom = new HashMap<\/*@KeyFor({\"preds\",\"dom\"})*\/ T,List<\/*@KeyFor({\"preds\",\"dom\"})*\/ T>>();\n    Map<T, List<T>> dom = new HashMap<T, List<T>>();\n\n    @SuppressWarnings(\"keyfor\") \/\/ every element of pred's value will be a key for dom\n    Map<T, List<\/*@KeyFor({\"dom\"})*\/ T>> preds = predecessors;\n\n    List<T> nodes = new ArrayList<T>(preds.keySet());\n\n    \/\/ Compute roots & non-roots, for convenience\n    List<\/*@KeyFor({\"preds\",\"dom\"})*\/ T> roots = new ArrayList<T>();\n    List<\/*@KeyFor({\"preds\",\"dom\"})*\/ T> non_roots = new ArrayList<T>();\n\n    \/\/ Initialize result:  for roots just the root, otherwise everything\n    for (T node : preds.keySet()) {\n      if (preds.get(node).isEmpty()) {\n        \/\/ This is a root.  Its only dominator is itself.\n        Set<T> set = Collections.singleton(node);\n        dom.put(node, new ArrayList<T>(set));\n        roots.add(node);\n      } else {\n        \/\/ Initially, set all nodes as dominators;\n        \/\/ will later remove nodes that aren't dominators.\n        dom.put(node, new ArrayList<T>(nodes));\n        non_roots.add(node);\n      }\n    }\n    assert roots.size() + non_roots.size() == nodes.size();\n\n    \/\/ Invariants:\n    \/\/ preds and dom have the same keyset.\n    \/\/ All of the following are keys for both preds and dom:\n    \/\/  * every key in pred\n    \/\/  * elery element of every pred value\n    \/\/  * every key in dom\n    \/\/  * elery element of every dom value\n    \/\/ So, the type of pred is now\n    \/\/\n    \/\/ rather than its original type\n    \/\/   Map<T,List<\/*@KeyFor(\"preds\")*\/ T>> preds\n\n    boolean changed = true;\n    while (changed) {\n      changed = false;\n      for (T node : non_roots) {\n        List<T> new_doms = null;\n        assert preds.containsKey(node);\n        for (T pred : preds.get(node)) {\n          assert dom.containsKey(pred);\n          \/*@NonNull*\/ List<T> dom_of_pred = dom.get(pred);\n          if (new_doms == null) {\n            \/\/ make copy because we may side-effect new_doms\n            new_doms = new ArrayList<T>(dom_of_pred);\n          } else {\n            new_doms.retainAll(dom_of_pred);\n          }\n        }\n        assert new_doms != null\n            : \"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\";\n        new_doms.add(node);\n        assert dom.containsKey(node);\n        if (!dom.get(node).equals(new_doms)) {\n          dom.put(node, new_doms);\n          changed = true;\n        }\n      }\n    }\n\n    for (T node : preds.keySet()) {\n      \/\/ TODO: The following two assert statements would be easier to read\n      \/\/ than the one combined one, but a bug (TODO:  Jonathan will add a\n      \/\/ bug number) prevents it from type-checking.\n      \/\/ assert dom.containsKey(node);\n      \/\/ assert dom.get(node).contains(node);\n      assert dom.containsKey(node) && dom.get(node).contains(node);\n    }\n\n    return dom;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}}}","methodJavadocComment":"\n   * Computes, for each node in the graph, its set of (pre-)dominators.\n   * Supply a successor graph if you want post-dominators.\n   * @param <T> type of the graph nodes\n   * @param predecessors a graph, represented as a predecessor map\n   * @return a map from each node to a list of its pre-dominators\n   ","methodParameters":[{"parameterType":"Map<T, List<T>>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<T, java.util.List<T>>","parameter":"Map<T, List<T>> predecessors","parameterName":"predecessors"}],"methodName":"dominators","methodQualifiedSignature":"plume.GraphMDE.dominators","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Computes, for each node in the graph, its set of (pre-)dominators.\nSupply a successor graph if you want post-dominators.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the graph nodes'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a graph, represented as a predecessor map'}]}', name=Optional[predecessors]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a map from each node to a list of its pre-dominators'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Map<T, java.util.List<T>>","methodType":"Map<T, List<T>>","literalExprs":[{"literalExprRange":"(line 66,col 23)-(line 66,col 30)","literalExprId":1,"literalExpr":"\"keyfor\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 103,col 23)-(line 103,col 26)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 105,col 17)-(line 105,col 21)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 107,col 28)-(line 107,col 31)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 112,col 27)-(line 112,col 30)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 119,col 28)-(line 119,col 31)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 120,col 15)-(line 120,col 141)","literalExprId":7,"literalExpr":"\"@AssumeAssertion(nullness): the loop was entered at least once because this is a non-root, which has at least one predecessor\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 125,col 21)-(line 125,col 24)","literalExprId":8,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.GraphMDE.dominators(java.util.Map<T, java.util.List<T>>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of nodes of the graph","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of nodes of the graph'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the graph to print","javadocBlockTagName":"graph","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to print'}]}', name=Optional[graph]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the PrintStream to which to print the graph","javadocBlockTagName":"ps","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the PrintStream to which to print the graph'}]}', name=Optional[ps]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of spaces by which to indent the printed representation","javadocBlockTagName":"indent","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of spaces by which to indent the printed representation'}]}', name=Optional[indent]}"}],"methodDeclaration":"public static void print(Map<T, List<T>> graph, PrintStream ps, int indent)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String indentString = \"\";\n    for (int i = 0; i < indent; i++) {\n        indentString += \" \";\n    }\n    for (T node : graph.keySet()) {\n        ps.printf(\"%s%s%n\", indentString, node);\n        for (T child : graph.get(node)) {\n            ps.printf(\"  %s%s%n\", indentString, child);\n        }\n    }\n}","methodRange":"(line 149,col 3)-(line 160,col 3)","methodTokenRange":"public static <T> void print(Map<T, List<T>> graph, PrintStream ps, int indent) {\n    String indentString = \"\";\n    for (int i = 0; i < indent; i++) {\n      indentString += \" \";\n    }\n    for (T node : graph.keySet()) {\n      ps.printf(\"%s%s%n\", indentString, node);\n      for (T child : graph.get(node)) {\n        ps.printf(\"  %s%s%n\", indentString, child);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print a representation of the graph to ps, indented by intent spaces.\n   * @param <T> the type of nodes of the graph\n   * @param graph the graph to print\n   * @param ps the PrintStream to which to print the graph\n   * @param indent the number of spaces by which to indent the printed representation\n   ","methodParameters":[{"parameterType":"Map<T, List<T>>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<T, java.util.List<T>>","parameter":"Map<T, List<T>> graph","parameterName":"graph"},{"parameterType":"PrintStream","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.PrintStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.PrintStream","parameter":"PrintStream ps","parameterName":"ps"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indent","parameterName":"indent"}],"methodName":"print","methodQualifiedSignature":"plume.GraphMDE.print","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a representation of the graph to ps, indented by intent spaces.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of nodes of the graph'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the graph to print'}]}', name=Optional[graph]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the PrintStream to which to print the graph'}]}', name=Optional[ps]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of spaces by which to indent the printed representation'}]}', name=Optional[indent]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 150,col 27)-(line 150,col 28)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 151,col 18)-(line 151,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 23)-(line 152,col 25)","literalExprId":3,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 155,col 17)-(line 155,col 24)","literalExprId":4,"literalExpr":"\"%s%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 157,col 19)-(line 157,col 28)","literalExprId":5,"literalExpr":"\"  %s%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.GraphMDE.print(java.util.Map<T, java.util.List<T>>, java.io.PrintStream, int)"}],"classJavadoc":"\/**\n * Graph utility methods.  This class does not model a graph:  all methods\n * are static.\n *\/\n","className":"GraphMDE","fields":[]}],"sourceFileId":28,"packageName":"plume"},{"sourceFileName":"plume.HtmlPrettyPrint","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.IOException;\n"},{"importId":3,"import":"import nu.xom.Builder;\n"},{"importId":4,"import":"import nu.xom.Document;\n"},{"importId":5,"import":"import nu.xom.ParsingException;\n"},{"importId":6,"import":"import nu.xom.Serializer;\n"},{"importId":7,"import":"import org.xml.sax.SAXException;\n"},{"importId":8,"import":"import org.xml.sax.XMLReader;\n"},{"importId":9,"import":"import org.xml.sax.helpers.XMLReaderFactory;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.HtmlPrettyPrint.HtmlPrettyPrint()","variableDeclarationExprs":[],"constructorRange":"(line 20,col 3)-(line 22,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private HtmlPrettyPrint()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"HtmlPrettyPrint","constructorQualifiedName":"plume.HtmlPrettyPrint.HtmlPrettyPrint","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 21,col 21)-(line 21,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private HtmlPrettyPrint() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"command-line arguments","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments'}]}', name=Optional[args]}"}],"methodDeclaration":"public static void main(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (String arg : args) {\n        File f = new File(arg);\n        String url = \"file:\/\/\" + f.getAbsolutePath();\n        try {\n            XMLReader tagsoup = XMLReaderFactory.createXMLReader(\"org.ccil.cowan.tagsoup.Parser\");\n            Builder parser = new Builder(tagsoup);\n            Document document = parser.build(url);\n            Serializer serializer = new Serializer(System.out);\n            serializer.setIndent(2);\n            serializer.setMaxLength(80);\n            try {\n                serializer.write(document);\n            } catch (IOException ex) {\n                System.err.println(ex);\n            }\n        } catch (ParsingException ex) {\n            System.out.println(url + \" is not well-formed.\");\n            throw new Error(ex);\n        } catch (SAXException ex) {\n            System.out.println(\"Could not load Xerces.\");\n            System.out.println(ex.getMessage());\n        } catch (IOException ex) {\n            System.out.println(\"IOException:  parser could not read \" + url);\n        }\n    }\n}","methodRange":"(line 27,col 3)-(line 58,col 3)","methodTokenRange":"public static void main(String[] args) {\n\n    for (String arg : args) {\n      File f = new File(arg);\n      String url = \"file:\/\/\" + f.getAbsolutePath();\n\n      try {\n        XMLReader tagsoup = XMLReaderFactory.createXMLReader(\"org.ccil.cowan.tagsoup.Parser\");\n        Builder parser = new Builder(tagsoup);\n\n        \/\/ Parse the document\n        Document document = parser.build(url);\n\n        Serializer serializer = new Serializer(System.out);\n        serializer.setIndent(2);\n        serializer.setMaxLength(80);\n        try {\n          serializer.write(document);\n        } catch (IOException ex) {\n          System.err.println(ex);\n        }\n      } catch (ParsingException ex) {\n        System.out.println(url + \" is not well-formed.\");\n        throw new Error(ex);\n      } catch (SAXException ex) {\n        System.out.println(\"Could not load Xerces.\");\n        System.out.println(ex.getMessage());\n      } catch (IOException ex) {\n        System.out.println(\"IOException:  parser could not read \" + url);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Entry point for the HtmlPrettyPrint program.\n   * @param args command-line arguments\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.HtmlPrettyPrint.main","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Entry point for the HtmlPrettyPrint program.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments'}]}', name=Optional[args]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 31,col 20)-(line 31,col 28)","literalExprId":1,"literalExpr":"\"file:\/\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 34,col 62)-(line 34,col 92)","literalExprId":2,"literalExpr":"\"org.ccil.cowan.tagsoup.Parser\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 41,col 30)-(line 41,col 30)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 42,col 33)-(line 42,col 34)","literalExprId":4,"literalExpr":"80","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 49,col 34)-(line 49,col 55)","literalExprId":5,"literalExpr":"\" is not well-formed.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 52,col 28)-(line 52,col 51)","literalExprId":6,"literalExpr":"\"Could not load Xerces.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 55,col 28)-(line 55,col 65)","literalExprId":7,"literalExpr":"\"IOException:  parser could not read \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.HtmlPrettyPrint.main(java.lang.String[])"}],"classJavadoc":"\/**\n * Pretty-prints an HTML file, after converting it to valid XML.\n * To use:  <pre>java plume.HtmlPrettyPrint file.html &gt; filepp.html<\/pre>\n *\/\n","className":"HtmlPrettyPrint","fields":[]}],"sourceFileId":29,"packageName":"plume"},{"sourceFileName":"plume.SimpleLog","imports":[{"importId":1,"import":"import java.io.PrintStream;\n"},{"importId":2,"import":"import java.util.Stack;\n"}],"typeDeclarations":[{"constructors":[{"constructorName":"SimpleLog","constructorQualifiedName":"plume.SimpleLog.SimpleLog","constructorQualifiedSignature":"plume.SimpleLog.SimpleLog(boolean, boolean)","constructorParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean enabled","parameterName":"enabled"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean always_traceback","parameterName":"always_traceback"}],"literalExprs":[],"constructorTokenRange":"public SimpleLog(boolean enabled, boolean always_traceback) {\n    this.enabled = enabled;\n    this.always_traceback = always_traceback;\n    push_start_time();\n  }","variableDeclarationExprs":[],"constructorRange":"(line 49,col 3)-(line 53,col 3)","constructorJavadocComment":"","constructorDeclaration":"public SimpleLog(boolean enabled, boolean always_traceback)","constructorBody":"{\n    this.enabled = enabled;\n    this.always_traceback = always_traceback;\n    push_start_time();\n}","constructorJavadoc":""},{"constructorName":"SimpleLog","constructorQualifiedName":"plume.SimpleLog.SimpleLog","constructorQualifiedSignature":"plume.SimpleLog.SimpleLog(boolean)","constructorParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean enabled","parameterName":"enabled"}],"literalExprs":[{"literalExprRange":"(line 56,col 19)-(line 56,col 23)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public SimpleLog(boolean enabled) {\n    this(enabled, false);\n  }","variableDeclarationExprs":[],"constructorRange":"(line 55,col 3)-(line 57,col 3)","constructorJavadocComment":"","constructorDeclaration":"public SimpleLog(boolean enabled)","constructorBody":"{\n    this(enabled, false);\n}","constructorJavadoc":""},{"constructorName":"SimpleLog","constructorQualifiedName":"plume.SimpleLog.SimpleLog","constructorQualifiedSignature":"plume.SimpleLog.SimpleLog()","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 60,col 10)-(line 60,col 13)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"constructorTokenRange":"public SimpleLog() {\n    this(true);\n  }","variableDeclarationExprs":[],"constructorRange":"(line 59,col 3)-(line 61,col 3)","constructorJavadocComment":"","constructorDeclaration":"public SimpleLog()","constructorBody":"{\n    this(true);\n}","constructorJavadoc":""},{"constructorName":"SimpleLog","constructorQualifiedName":"plume.SimpleLog.SimpleLog","constructorQualifiedSignature":"plume.SimpleLog.SimpleLog(java.lang.String, boolean)","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean enabled","parameterName":"enabled"}],"literalExprs":[{"literalExprRange":"(line 68,col 34)-(line 68,col 46)","literalExprId":1,"literalExpr":"\"Can't open \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public SimpleLog(String filename, boolean enabled) {\n    this(enabled);\n    try {\n      logfile = new PrintStream(filename);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Can't open \" + filename, e);\n    }\n  }","variableDeclarationExprs":[],"constructorRange":"(line 63,col 3)-(line 70,col 3)","constructorJavadocComment":"","constructorDeclaration":"public SimpleLog(String filename, boolean enabled)","constructorBody":"{\n    this(enabled);\n    try {\n        logfile = new PrintStream(filename);\n    } catch (Exception e) {\n        throw new RuntimeException(\"Can't open \" + filename, e);\n    }\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"methodDeclaration":"public boolean enabled()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return enabled;\n}","methodRange":"(line 72,col 3)-(line 74,col 3)","methodTokenRange":"public boolean enabled() {\n    return enabled;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[],"methodName":"enabled","methodQualifiedSignature":"plume.SimpleLog.enabled","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.SimpleLog.enabled()"},{"methodDeclaration":"public void log(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        format = add_newline(format);\n        logfile.print(indent_str);\n        logfile.printf(format, args);\n        if (always_traceback) {\n            tb();\n        }\n    }\n}","methodRange":"(line 83,col 3)-(line 95,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"formatter\") \/\/ call to format method is correct because of @FormatMethod annotation\n  public void log(String format, \/*@Nullable*\/ Object... args) {\n\n    if (enabled) {\n      format = add_newline(format);\n      logfile.print(indent_str);\n      logfile.printf(format, args);\n      if (always_traceback) {\n        tb();\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"log","methodQualifiedSignature":"plume.SimpleLog.log","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 84,col 7)-(line 84,col 17)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.log(java.lang.String, java.lang.Object...)"},{"methodDeclaration":"public void log_tb(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        log(format, args);\n        tb();\n    }\n}","methodRange":"(line 102,col 3)-(line 109,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"formatter\") \/\/ call to format method is correct because of @FormatMethod annotation\n  public void log_tb(String format, \/*@Nullable*\/ Object... args) {\n    if (enabled) {\n      log(format, args);\n      tb();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"log_tb","methodQualifiedSignature":"plume.SimpleLog.log_tb","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 103,col 7)-(line 103,col 17)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.log_tb(java.lang.String, java.lang.Object...)"},{"javadocBlockTags":[],"methodDeclaration":"public void tb()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Throwable t = new Throwable();\n    t.fillInStackTrace();\n    StackTraceElement[] ste_arr = t.getStackTrace();\n    for (int ii = 2; ii < ste_arr.length; ii++) {\n        StackTraceElement ste = ste_arr[ii];\n        logfile.printf(\"%s  %s%n\", indent_str, ste);\n    }\n}","methodRange":"(line 112,col 3)-(line 120,col 3)","methodTokenRange":"public void tb() {\n    Throwable t = new Throwable();\n    t.fillInStackTrace();\n    StackTraceElement[] ste_arr = t.getStackTrace();\n    for (int ii = 2; ii < ste_arr.length; ii++) {\n      StackTraceElement ste = ste_arr[ii];\n      logfile.printf(\"%s  %s%n\", indent_str, ste);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Print a backtrace (traceback, or tb) to the log. ","methodParameters":[],"methodName":"tb","methodQualifiedSignature":"plume.SimpleLog.tb","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print a backtrace (traceback, or tb) to the log.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 116,col 19)-(line 116,col 19)","literalExprId":1,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 118,col 22)-(line 118,col 31)","literalExprId":2,"literalExpr":"\"%s  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.tb()"},{"javadocBlockTags":[],"methodDeclaration":"private String add_newline(String format)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!line_oriented) {\n        return format;\n    }\n    if (format.endsWith(\"%n\")) {\n        return format;\n    }\n    return format + \"%n\";\n}","methodRange":"(line 126,col 3)-(line 137,col 3)","methodTokenRange":"private String add_newline(String format) {\n\n    if (!line_oriented) {\n      return format;\n    }\n\n    if (format.endsWith(\"%n\")) {\n      return format;\n    }\n\n    return format + \"%n\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Helper method:  add a newline if one isn't already there, and if\n   * variable line_oriented is set.\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"}],"methodName":"add_newline","methodQualifiedSignature":"plume.SimpleLog.add_newline","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Helper method:  add a newline if one isn't already there, and if\nvariable line_oriented is set.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 132,col 25)-(line 132,col 28)","literalExprId":1,"literalExpr":"\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 136,col 21)-(line 136,col 24)","literalExprId":2,"literalExpr":"\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.add_newline(java.lang.String)"},{"methodDeclaration":"public void indent()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        indent_str += INDENT_STR_ONE_LEVEL;\n        push_start_time();\n    }\n}","methodRange":"(line 143,col 3)-(line 148,col 3)","methodTokenRange":"public void indent() {\n    if (enabled) {\n      indent_str += INDENT_STR_ONE_LEVEL;\n      push_start_time();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"indent","methodQualifiedSignature":"plume.SimpleLog.indent","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.SimpleLog.indent()"},{"methodDeclaration":"public void indent(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        log(format, args);\n        indent();\n    }\n}","methodRange":"(line 151,col 3)-(line 158,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"formatter\") \/\/ call to format method is correct because of @FormatMethod annotation\n  public void indent(String format, \/*@Nullable*\/ Object... args) {\n    if (enabled) {\n      log(format, args);\n      indent();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"indent","methodQualifiedSignature":"plume.SimpleLog.indent","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 152,col 7)-(line 152,col 17)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.indent(java.lang.String, java.lang.Object...)"},{"javadocBlockTags":[],"methodDeclaration":"public void clear()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        indent_str = \"\";\n        start_times.clear();\n        push_start_time();\n    }\n}","methodRange":"(line 163,col 3)-(line 169,col 3)","methodTokenRange":"public void clear() {\n    if (enabled) {\n      indent_str = \"\";\n      start_times.clear();\n      push_start_time();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Clears indent and start times and then pushes one start time.\n   ","methodParameters":[],"methodName":"clear","methodQualifiedSignature":"plume.SimpleLog.clear","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Clears indent and start times and then pushes one start time.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 165,col 20)-(line 165,col 21)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.clear()"},{"methodDeclaration":"public void clear(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        clear();\n        log(format, args);\n    }\n}","methodRange":"(line 177,col 3)-(line 184,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"formatter\") \/\/ call to format method is correct because of @FormatMethod annotation\n  public void clear(String format, \/*@Nullable*\/ Object... args) {\n    if (enabled) {\n      clear();\n      log(format, args);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"clear","methodQualifiedSignature":"plume.SimpleLog.clear","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 178,col 7)-(line 178,col 17)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.clear(java.lang.String, java.lang.Object...)"},{"methodDeclaration":"public void exdent()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        indent_str = indent_str.substring(0, indent_str.length() - INDENT_STR_ONE_LEVEL.length());\n        pop_start_time();\n    }\n}","methodRange":"(line 186,col 3)-(line 191,col 3)","methodTokenRange":"public void exdent() {\n    if (enabled) {\n      indent_str = indent_str.substring(0, indent_str.length() - INDENT_STR_ONE_LEVEL.length());\n      pop_start_time();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"exdent","methodQualifiedSignature":"plume.SimpleLog.exdent","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 188,col 41)-(line 188,col 41)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.exdent()"},{"methodDeclaration":"public void exdent_time(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        log_time(format, args);\n        exdent();\n    }\n}","methodRange":"(line 198,col 3)-(line 206,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"formatter\") \/\/ call to format method is correct because of @FormatMethod annotation\n  public void exdent_time(String format, \/*@Nullable*\/ Object... args) {\n    if (enabled) {\n      \/\/ This puts the time inside, not outside, the indentation.\n      log_time(format, args);\n      exdent();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"exdent_time","methodQualifiedSignature":"plume.SimpleLog.exdent_time","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 199,col 7)-(line 199,col 17)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.exdent_time(java.lang.String, java.lang.Object...)"},{"javadocBlockTags":[],"methodDeclaration":"public void reset_start_time()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        pop_start_time();\n        push_start_time();\n    }\n}","methodRange":"(line 213,col 3)-(line 218,col 3)","methodTokenRange":"public void reset_start_time() {\n    if (enabled) {\n      pop_start_time();\n      push_start_time();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" This overwrites the current start time; it does not push a new one!! ","methodParameters":[],"methodName":"reset_start_time","methodQualifiedSignature":"plume.SimpleLog.reset_start_time","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This overwrites the current start time; it does not push a new one!!'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.SimpleLog.reset_start_time()"},{"methodDeclaration":"public void push_start_time()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        start_times.push(System.currentTimeMillis());\n    }\n}","methodRange":"(line 222,col 3)-(line 227,col 3)","methodTokenRange":"public void push_start_time(\n      \/*>>> @UnknownInitialization(SimpleLog.class) @Raw(SimpleLog.class) SimpleLog this*\/) {\n    if (enabled) {\n      start_times.push(System.currentTimeMillis());\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@RequiresNonNull(\"start_times\")","methodParameters":[],"methodName":"push_start_time","methodQualifiedSignature":"plume.SimpleLog.push_start_time","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.SimpleLog.push_start_time()"},{"methodDeclaration":"public void pop_start_time()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    start_times.pop();\n}","methodRange":"(line 229,col 3)-(line 231,col 3)","methodTokenRange":"public void pop_start_time() {\n    start_times.pop();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"pop_start_time","methodQualifiedSignature":"plume.SimpleLog.pop_start_time","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.SimpleLog.pop_start_time()"},{"methodDeclaration":"public void log_time(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (enabled) {\n        Long start_time = start_times.peek();\n        if (start_time == null) {\n            throw new Error(\"Too many pops before calling log_time\");\n        }\n        long elapsed = System.currentTimeMillis() - start_time.longValue();\n        logfile.print(indent_str);\n        if (elapsed > 1000) {\n            logfile.printf(\"[%,f secs] \", elapsed \/ 1000.0);\n        } else {\n            logfile.print(\"[\" + elapsed + \" ms] \");\n        }\n        format = add_newline(format);\n        logfile.printf(format, args);\n    }\n}","methodRange":"(line 241,col 3)-(line 260,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"formatter\") \/\/ call to format method is correct because of @FormatMethod annotation\n  public void log_time(String format, \/*@Nullable*\/ Object... args) {\n\n    if (enabled) {\n      Long start_time = start_times.peek();\n      if (start_time == null) {\n        throw new Error(\"Too many pops before calling log_time\");\n      }\n      long elapsed = System.currentTimeMillis() - start_time.longValue();\n      logfile.print(indent_str);\n      if (elapsed > 1000) {\n        logfile.printf(\"[%,f secs] \", elapsed \/ 1000.0);\n      } else {\n        logfile.print(\"[\" + elapsed + \" ms] \");\n      }\n      format = add_newline(format);\n      logfile.printf(format, args);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"log_time","methodQualifiedSignature":"plume.SimpleLog.log_time","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 242,col 7)-(line 242,col 17)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 247,col 25)-(line 247,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 248,col 25)-(line 248,col 63)","literalExprId":3,"literalExpr":"\"Too many pops before calling log_time\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 252,col 21)-(line 252,col 24)","literalExprId":4,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 253,col 24)-(line 253,col 36)","literalExprId":5,"literalExpr":"\"[%,f secs] \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 253,col 49)-(line 253,col 54)","literalExprId":6,"literalExpr":"1000.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 255,col 23)-(line 255,col 25)","literalExprId":7,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 255,col 39)-(line 255,col 45)","literalExprId":8,"literalExpr":"\" ms] \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.SimpleLog.log_time(java.lang.String, java.lang.Object...)"}],"classJavadoc":"\/**\n * A logging class with the following features:\n * <ul>\n *   <li>Can be enabled and disabled (when disabled, all operations are no-ops),\n *   <li>Write to a file or to standard output,\n *   <li>Can start and stop a timer, and nest timers,\n *   <li>Can enter and exit subtasks (their output is indented, and they are timed),\n *   <li>Can provide a backtrace (optionally provide a backtrace at every output), and\n *   <li>Can add newlines where appropriate, if variable line_oriented is set.\n * <\/ul>\n *\/\n","className":"SimpleLog","fields":[{"fieldRange":"(line 26,col 3)-(line 26,col 25)","fieldName":"enabled","fieldJavadocComment":" If false, do no output. ","fieldTokenRange":"public boolean enabled;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"If false, do no output.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 29,col 3)-(line 29,col 42)","fieldName":"logfile","fieldJavadocComment":" Where to write logging output. ","fieldTokenRange":"public PrintStream logfile = System.out;","fieldTypeResolved":"ReferenceType{java.io.PrintStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[System.out]","fieldType":"PrintStream","fieldJavadoc":"Where to write logging output.\n","fieldTypeResolvedDescribed":"java.io.PrintStream"},{"fieldRange":"(line 32,col 3)-(line 32,col 32)","fieldName":"indent_str","fieldJavadocComment":" The current indentation string. ","fieldTokenRange":"public String indent_str = \"\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 32,col 30)-(line 32,col 31)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"\"]","fieldType":"String","fieldJavadoc":"The current indentation string.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 34,col 3)-(line 34,col 50)","fieldName":"INDENT_STR_ONE_LEVEL","fieldJavadocComment":" Indentation string for one level of indentation. ","fieldTokenRange":"public final String INDENT_STR_ONE_LEVEL = \"  \";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 34,col 46)-(line 34,col 49)","literalExprId":1,"literalExpr":"\"  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"  \"]","fieldType":"String","fieldJavadoc":"Indentation string for one level of indentation.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 37,col 3)-(line 37,col 42)","fieldName":"always_traceback","fieldJavadocComment":" Always provide a backtrace (traceback) when calling log. ","fieldTokenRange":"public boolean always_traceback = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 37,col 37)-(line 37,col 41)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"Always provide a backtrace (traceback) when calling log.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 45,col 3)-(line 45,col 38)","fieldName":"line_oriented","fieldJavadocComment":"\n   * True if every log call is made with a complete line of text.\n   * False if a log call may contain multiple lines, or if multiple log\n   * calls may be made, each with parts of a line; in this case, you must\n   * manage line delimiters yourself.\n   ","fieldTokenRange":"public boolean line_oriented = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 45,col 34)-(line 45,col 37)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"True if every log call is made with a complete line of text.\nFalse if a log call may contain multiple lines, or if multiple log\ncalls may be made, each with parts of a line; in this case, you must\nmanage line delimiters yourself.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 47,col 3)-(line 47,col 53)","fieldName":"start_times","fieldJavadocComment":"","fieldTokenRange":"public Stack<Long> start_times = new Stack<Long>();","fieldTypeResolved":"ReferenceType{java.util.Stack, typeParametersMap=TypeParametersMap{nameToValue={java.util.Stack.E=ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new Stack<Long>()]","fieldType":"Stack<Long>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Stack<java.lang.Long>"}]}],"sourceFileId":30,"packageName":"plume"},{"sourceFileName":"plume.OptionGroup","imports":[{"importId":1,"import":"import java.lang.annotation.ElementType;\n"},{"importId":2,"import":"import java.lang.annotation.Retention;\n"},{"importId":3,"import":"import java.lang.annotation.RetentionPolicy;\n"},{"importId":4,"import":"import java.lang.annotation.Target;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * Used in conjunction with the <code>@Option<\/code> annotation to indicate that\n * the following <code>@Option<\/code>-annotated fields (including the one the\n * <code>@OptionGroup<\/code> annotation is applied to) belong to the same\n * option group.  Option groups are documented in {@link Options}.\n * <p>\n *\n * Note that <code>@OptionGroup<\/code> must be applied to a field and must\n * appear after that field's Javadoc comment, if any.  A Javadoc comment\n * between {@code @OptionGroup} and the field is ignored.\n *\n * For example, you must write\n * <pre>\n *  \/** comment for first option{@literal *}\/\n * {@literal @}OptionGroup(\"the group\")\n * {@literal @}Option(\"the first option\")\n *  public static int first_option = blah;<\/pre>\n * instead of\n * <pre>\n * {@literal @}OptionGroup(\"the group\")\n *\n *  \/** comment for first option{@literal *}\/\n * {@literal @}Option(\"the first option\")\n *  public static int first_option = blah;<\/pre>\n *\n * @see plume.Options\n * @see plume.Option\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n *\/\n","className":"OptionGroup","fields":[]}],"sourceFileId":31,"packageName":"plume"},{"sourceFileName":"plume.ICalAvailable","imports":[{"importId":1,"import":"import java.io.InputStream;\n"},{"importId":2,"import":"import java.net.URL;\n"},{"importId":3,"import":"import java.text.DateFormat;\n"},{"importId":4,"import":"import java.text.ParseException;\n"},{"importId":5,"import":"import java.text.SimpleDateFormat;\n"},{"importId":6,"import":"import java.util.ArrayList;\n"},{"importId":7,"import":"import java.util.Arrays;\n"},{"importId":8,"import":"import java.util.HashMap;\n"},{"importId":9,"import":"import java.util.List;\n"},{"importId":10,"import":"import java.util.Locale;\n"},{"importId":11,"import":"import java.util.Map;\n"},{"importId":12,"import":"import java.util.regex.Matcher;\n"},{"importId":13,"import":"import java.util.regex.Pattern;\n"},{"importId":14,"import":"import net.fortuna.ical4j.data.CalendarBuilder;\n"},{"importId":15,"import":"import net.fortuna.ical4j.data.ParserException;\n"},{"importId":16,"import":"import net.fortuna.ical4j.model.Calendar;\n"},{"importId":17,"import":"import net.fortuna.ical4j.model.Component;\n"},{"importId":18,"import":"import net.fortuna.ical4j.model.ComponentList;\n"},{"importId":19,"import":"import net.fortuna.ical4j.model.Date;\n"},{"importId":20,"import":"import net.fortuna.ical4j.model.DateTime;\n"},{"importId":21,"import":"import net.fortuna.ical4j.model.Dur;\n"},{"importId":22,"import":"import net.fortuna.ical4j.model.Parameter;\n"},{"importId":23,"import":"import net.fortuna.ical4j.model.Period;\n"},{"importId":24,"import":"import net.fortuna.ical4j.model.PeriodList;\n"},{"importId":25,"import":"import net.fortuna.ical4j.model.TimeZone;\n"},{"importId":26,"import":"import net.fortuna.ical4j.model.TimeZoneRegistry;\n"},{"importId":27,"import":"import net.fortuna.ical4j.model.TimeZoneRegistryFactory;\n"},{"importId":28,"import":"import net.fortuna.ical4j.model.component.VEvent;\n"},{"importId":29,"import":"import net.fortuna.ical4j.model.component.VFreeBusy;\n"},{"importId":30,"import":"import net.fortuna.ical4j.model.parameter.FbType;\n"},{"importId":31,"import":"import net.fortuna.ical4j.model.property.DtStart;\n"},{"importId":32,"import":"import net.fortuna.ical4j.model.property.FreeBusy;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.ICalAvailable.ICalAvailable()","variableDeclarationExprs":[],"constructorRange":"(line 84,col 3)-(line 86,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private ICalAvailable()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"ICalAvailable","constructorQualifiedName":"plume.ICalAvailable.ICalAvailable","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 85,col 21)-(line 85,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private ICalAvailable() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":" static void processOptions(String[] args)","methodAccessSpecifier":"NONE","methodBody":"{\n    Options options = new Options(\"ICalAvailable [options]\", ICalAvailable.class);\n    String[] remaining_args = options.parse_or_usage(args);\n    if (remaining_args.length != 0) {\n        System.err.println(\"Unrecognized arguments: \" + Arrays.toString(remaining_args));\n        System.exit(1);\n    }\n    if (iCal_URL.isEmpty()) {\n        System.err.println(\"Option iCal_URL must be specified.\");\n        System.exit(1);\n    }\n    tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\n    assert tz1 != null;\n    if (tz1 == null) {\n        throw new Error(\"didn't find timezone \" + timezone1);\n    }\n    if (timezone2 != null) {\n        tz2 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone2));\n        if (tz2 == null) {\n            System.err.println(\"Unrecognized time zone (see http:\/\/php.net\/manual\/en\/timezones.php ): \" + timezone2);\n            System.exit(1);\n        }\n    }\n    try {\n        if (!date.equals(\"today\")) {\n            start_date = new DateTime(parseDate(date));\n        }\n    } catch (Exception e) {\n        if (Pattern.matches(\".*\/.*\", date) && !Pattern.matches(\".*\/.*\/\", date)) {\n            System.err.println(\"Could not parse date (missing year?): \" + date);\n            System.exit(1);\n        } else {\n            System.err.println(\"Could not parse date: \" + date);\n            System.exit(1);\n        }\n    }\n    if (start_date == null) {\n        System.err.println(\"Could not parse date: \" + date);\n        System.exit(1);\n    }\n    start_date.setTimeZone(tz1);\n    start_date.setMinutes((start_date.getMinutes() \/ 15) * 15);\n    for (String URL : iCal_URL) {\n        try {\n            URL url = new URL(URL);\n            CalendarBuilder builder = new CalendarBuilder();\n            Calendar c;\n            try {\n                c = builder.build(url.openStream());\n            } catch (ParserException pe) {\n                if (\"Error at line 1: Expected [BEGIN], read [<HTML>]\".equals(pe.getMessage())) {\n                    System.out.println();\n                    System.out.println(\"It is possible that the calendar has moved.\");\n                    URL url2 = new URL(URL);\n                    InputStream url_is = url2.openStream();\n                    System.out.printf(\"URL: %s%n\", url2);\n                    System.out.println(\"Contents:\");\n                    byte[] buffer = new byte[1024];\n                    int len = url_is.read(buffer);\n                    while (len != -1) {\n                        System.out.write(buffer, 0, len);\n                        len = url_is.read(buffer);\n                    }\n                    System.out.println();\n                }\n                throw pe;\n            }\n            calendars.add(c);\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.err.println(\"Could not read calendar from \" + URL);\n            System.exit(1);\n        }\n    }\n    for (String range : business_hours.split(\",\")) {\n        String[] startEnd = range.split(\"-\");\n        if (startEnd.length != 2) {\n            System.err.println(\"Bad time range: \" + range);\n            System.exit(1);\n        }\n        DateTime busStart = parseTime(startEnd[0]);\n        DateTime busEnd = parseTime(startEnd[1]);\n        businessHours.add(new Period(busStart, busEnd));\n    }\n}","methodRange":"(line 161,col 3)-(line 256,col 3)","methodTokenRange":"@SuppressWarnings(\"deprecation\") \/\/ for iCal4j's use of Date.{get,set}Minutes\n  \/*@EnsuresNonNull(\"tz1\")*\/\n  static void processOptions(String[] args) {\n    Options options = new Options(\"ICalAvailable [options]\", ICalAvailable.class);\n    String[] remaining_args = options.parse_or_usage(args);\n    if (remaining_args.length != 0) {\n      System.err.println(\"Unrecognized arguments: \" + Arrays.toString(remaining_args));\n      System.exit(1);\n    }\n    if (iCal_URL.isEmpty()) {\n      System.err.println(\"Option iCal_URL must be specified.\");\n      System.exit(1);\n    }\n\n    \/\/ Convert Strings to TimeZones\n    tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));\n    assert tz1 != null;\n    if (tz1 == null) {\n      throw new Error(\"didn't find timezone \" + timezone1);\n    }\n    if (timezone2 != null) {\n      tz2 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone2));\n      if (tz2 == null) {\n        System.err.println(\n            \"Unrecognized time zone (see http:\/\/php.net\/manual\/en\/timezones.php ): \" + timezone2);\n        System.exit(1);\n      }\n    }\n\n    try {\n      if (!date.equals(\"today\")) {\n        start_date = new DateTime(parseDate(date));\n      }\n    } catch (Exception e) {\n      if (Pattern.matches(\".*\/.*\", date) && !Pattern.matches(\".*\/.*\/\", date)) {\n        System.err.println(\"Could not parse date (missing year?): \" + date);\n        System.exit(1);\n      } else {\n        System.err.println(\"Could not parse date: \" + date);\n        System.exit(1);\n      }\n    }\n    if (start_date == null) {\n      System.err.println(\"Could not parse date: \" + date);\n      System.exit(1);\n    }\n\n    \/\/ Problem:  this may change the actual time?\n    start_date.setTimeZone(tz1);\n    start_date.setMinutes((start_date.getMinutes() \/ 15) * 15);\n\n    for (String URL : iCal_URL) {\n      try {\n        URL url = new URL(URL);\n        CalendarBuilder builder = new CalendarBuilder();\n        Calendar c;\n        try {\n          c = builder.build(url.openStream());\n        } catch (ParserException pe) {\n          if (\"Error at line 1: Expected [BEGIN], read [<HTML>]\".equals(pe.getMessage())) {\n            System.out.println();\n            System.out.println(\"It is possible that the calendar has moved.\");\n            \/\/ Debugging: write the URL contents to standard output\n            URL url2 = new URL(URL);\n            InputStream url_is = url2.openStream();\n            System.out.printf(\"URL: %s%n\", url2);\n            System.out.println(\"Contents:\");\n            byte[] buffer = new byte[1024];\n            int len = url_is.read(buffer);\n            while (len != -1) {\n              System.out.write(buffer, 0, len);\n              len = url_is.read(buffer);\n            }\n            System.out.println();\n          }\n          throw pe;\n        }\n        calendars.add(c);\n      } catch (Exception e) {\n        e.printStackTrace(System.err);\n        System.err.println(\"Could not read calendar from \" + URL);\n        System.exit(1);\n      }\n    }\n\n    for (String range : business_hours.split(\",\")) {\n      String[] startEnd = range.split(\"-\");\n      if (startEnd.length != 2) {\n        System.err.println(\"Bad time range: \" + range);\n        System.exit(1);\n      }\n      DateTime busStart = parseTime(startEnd[0]);\n      DateTime busEnd = parseTime(startEnd[1]);\n      businessHours.add(new Period(busStart, busEnd));\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"processOptions","methodQualifiedSignature":"plume.ICalAvailable.processOptions","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 161,col 21)-(line 161,col 33)","literalExprId":1,"literalExpr":"\"deprecation\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 164,col 35)-(line 164,col 59)","literalExprId":2,"literalExpr":"\"ICalAvailable [options]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 166,col 34)-(line 166,col 34)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 167,col 26)-(line 167,col 51)","literalExprId":4,"literalExpr":"\"Unrecognized arguments: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 168,col 19)-(line 168,col 19)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 171,col 26)-(line 171,col 61)","literalExprId":6,"literalExpr":"\"Option iCal_URL must be specified.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 172,col 19)-(line 172,col 19)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 177,col 19)-(line 177,col 22)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 178,col 16)-(line 178,col 19)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 179,col 23)-(line 179,col 45)","literalExprId":10,"literalExpr":"\"didn't find timezone \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 181,col 22)-(line 181,col 25)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 183,col 18)-(line 183,col 21)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 185,col 13)-(line 185,col 84)","literalExprId":13,"literalExpr":"\"Unrecognized time zone (see http:\/\/php.net\/manual\/en\/timezones.php ): \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 186,col 21)-(line 186,col 21)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 191,col 24)-(line 191,col 30)","literalExprId":15,"literalExpr":"\"today\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 195,col 27)-(line 195,col 33)","literalExprId":16,"literalExpr":"\".*\/.*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 195,col 62)-(line 195,col 69)","literalExprId":17,"literalExpr":"\".*\/.*\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 196,col 28)-(line 196,col 67)","literalExprId":18,"literalExpr":"\"Could not parse date (missing year?): \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 197,col 21)-(line 197,col 21)","literalExprId":19,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 199,col 28)-(line 199,col 51)","literalExprId":20,"literalExpr":"\"Could not parse date: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 200,col 21)-(line 200,col 21)","literalExprId":21,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 203,col 23)-(line 203,col 26)","literalExprId":22,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 204,col 26)-(line 204,col 49)","literalExprId":23,"literalExpr":"\"Could not parse date: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 205,col 19)-(line 205,col 19)","literalExprId":24,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 210,col 54)-(line 210,col 55)","literalExprId":25,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 210,col 60)-(line 210,col 61)","literalExprId":26,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 220,col 15)-(line 220,col 64)","literalExprId":27,"literalExpr":"\"Error at line 1: Expected [BEGIN], read [<HTML>]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 222,col 32)-(line 222,col 76)","literalExprId":28,"literalExpr":"\"It is possible that the calendar has moved.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 226,col 31)-(line 226,col 41)","literalExprId":29,"literalExpr":"\"URL: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 227,col 32)-(line 227,col 42)","literalExprId":30,"literalExpr":"\"Contents:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 228,col 38)-(line 228,col 41)","literalExprId":31,"literalExpr":"1024","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 230,col 28)-(line 230,col 28)","literalExprId":32,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 231,col 40)-(line 231,col 40)","literalExprId":33,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 241,col 28)-(line 241,col 58)","literalExprId":34,"literalExpr":"\"Could not read calendar from \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 242,col 21)-(line 242,col 21)","literalExprId":35,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 246,col 46)-(line 246,col 48)","literalExprId":36,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 247,col 39)-(line 247,col 41)","literalExprId":37,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 248,col 30)-(line 248,col 30)","literalExprId":38,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 249,col 28)-(line 249,col 45)","literalExprId":39,"literalExpr":"\"Bad time range: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 250,col 21)-(line 250,col 21)","literalExprId":40,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 252,col 46)-(line 252,col 46)","literalExprId":41,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 253,col 44)-(line 253,col 44)","literalExprId":42,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ICalAvailable.processOptions(java.lang.String[])"},{"methodDeclaration":" static String canonicalizeTimezone(String timezone)","methodAccessSpecifier":"NONE","methodBody":"{\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n}","methodRange":"(line 287,col 3)-(line 290,col 3)","methodTokenRange":"static String canonicalizeTimezone(String timezone) {\n    String result = canonicalTimezones.get(timezone.toLowerCase());\n    return (result == null) ? timezone : result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String timezone","parameterName":"timezone"}],"methodName":"canonicalizeTimezone","methodQualifiedSignature":"plume.ICalAvailable.canonicalizeTimezone","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 289,col 23)-(line 289,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.ICalAvailable.canonicalizeTimezone(java.lang.String)"},{"methodDeclaration":" static String printedTimezone(TimeZone tz)","methodAccessSpecifier":"NONE","methodBody":"{\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n}","methodRange":"(line 293,col 3)-(line 297,col 3)","methodTokenRange":"static String printedTimezone(TimeZone tz) {\n    String tzString = tz.getDisplayName();\n    String result = printedTimezones.get(tzString);\n    return (result == null) ? tzString : result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"TimeZone","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"TimeZone tz","parameterName":"tz"}],"methodName":"printedTimezone","methodQualifiedSignature":"plume.ICalAvailable.printedTimezone","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 296,col 23)-(line 296,col 26)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":""},{"methodDeclaration":" static DateTime parseTime(String time)","methodAccessSpecifier":"NONE","methodBody":"{\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n        System.err.println(\"Bad time: \" + time);\n        System.exit(1);\n    }\n    @SuppressWarnings(\"nullness\")\n    String hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n        hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n        minute = Integer.parseInt(minuteString);\n    }\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n    return result;\n}","methodRange":"(line 303,col 3)-(line 334,col 3)","methodTokenRange":"@SuppressWarnings(\"deprecation\") \/\/ for iCal4j\n  \/*@RequiresNonNull(\"tz1\")*\/\n  static DateTime parseTime(String time) {\n\n    Matcher m = timeRegexp.matcher(time);\n    if (!m.matches()) {\n      System.err.println(\"Bad time: \" + time);\n      System.exit(1);\n    }\n    @SuppressWarnings(\n        \"nullness\") \/\/ Regex Checker imprecision:  matches() guarantees that group 1 exists in regexp\n    \/*@NonNull*\/ String hourString = m.group(1);\n    String minuteString = m.group(3);\n    String ampmString = m.group(4);\n\n    int hour = Integer.parseInt(hourString);\n    if ((ampmString != null) && ampmString.toLowerCase().equals(\"pm\")) {\n      hour += 12;\n    }\n    int minute = 0;\n    if (minuteString != null) {\n      minute = Integer.parseInt(minuteString);\n    }\n\n    DateTime result = new DateTime();\n    result.setTimeZone(tz1);\n    result.setHours(hour);\n    result.setMinutes(minute);\n    result.setSeconds(0);\n\n    return result;\n  }","methodReturnTypeResolved":"","methodJavadocComment":" Parse a time like \"9:30pm\"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String time","parameterName":"time"}],"methodName":"parseTime","methodQualifiedSignature":"plume.ICalAvailable.parseTime","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"DateTime","literalExprs":[{"literalExprRange":"(line 303,col 21)-(line 303,col 33)","literalExprId":1,"literalExpr":"\"deprecation\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 309,col 26)-(line 309,col 37)","literalExprId":2,"literalExpr":"\"Bad time: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 310,col 19)-(line 310,col 19)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 313,col 9)-(line 313,col 18)","literalExprId":4,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 314,col 46)-(line 314,col 46)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 315,col 35)-(line 315,col 35)","literalExprId":6,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 316,col 33)-(line 316,col 33)","literalExprId":7,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 319,col 24)-(line 319,col 27)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 319,col 65)-(line 319,col 68)","literalExprId":9,"literalExpr":"\"pm\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 320,col 15)-(line 320,col 16)","literalExprId":10,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 322,col 18)-(line 322,col 18)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 323,col 25)-(line 323,col 28)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 331,col 23)-(line 331,col 23)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ICalAvailable.parseTime(java.lang.String)"},{"methodDeclaration":" static void printOptions()","methodAccessSpecifier":"NONE","methodBody":"{\n    System.out.println(\"business_hours: \" + business_hours);\n    System.out.println(\"businessHours: \" + businessHours);\n    System.out.println(\"businessDays: \" + businessDays);\n    System.out.println(\"timezone1: \" + timezone1);\n    System.out.println(\"timezone2: \" + timezone2);\n    System.out.println(\"start_date: \" + start_date);\n    System.out.println(\"days: \" + days);\n    System.out.println(\"iCal_URL: \" + iCal_URL);\n}","methodRange":"(line 337,col 3)-(line 346,col 3)","methodTokenRange":"static void printOptions() {\n    System.out.println(\"business_hours: \" + business_hours);\n    System.out.println(\"businessHours: \" + businessHours);\n    System.out.println(\"businessDays: \" + businessDays);\n    System.out.println(\"timezone1: \" + timezone1);\n    System.out.println(\"timezone2: \" + timezone2);\n    System.out.println(\"start_date: \" + start_date);\n    System.out.println(\"days: \" + days);\n    System.out.println(\"iCal_URL: \" + iCal_URL);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" For debugging","methodParameters":[],"methodName":"printOptions","methodQualifiedSignature":"plume.ICalAvailable.printOptions","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 338,col 24)-(line 338,col 41)","literalExprId":1,"literalExpr":"\"business_hours: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 339,col 24)-(line 339,col 40)","literalExprId":2,"literalExpr":"\"businessHours: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 340,col 24)-(line 340,col 39)","literalExprId":3,"literalExpr":"\"businessDays: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 341,col 24)-(line 341,col 36)","literalExprId":4,"literalExpr":"\"timezone1: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 342,col 24)-(line 342,col 36)","literalExprId":5,"literalExpr":"\"timezone2: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 343,col 24)-(line 343,col 37)","literalExprId":6,"literalExpr":"\"start_date: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 344,col 24)-(line 344,col 31)","literalExprId":7,"literalExpr":"\"days: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 345,col 24)-(line 345,col 35)","literalExprId":8,"literalExpr":"\"iCal_URL: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ICalAvailable.printOptions()"},{"methodDeclaration":"public static void main(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    processOptions(args);\n    List<Period> available = new ArrayList<Period>();\n    if (debug) {\n        System.err.printf(\"Testing %d days%n\", days);\n    }\n    for (int i = 0; i < days; i++) {\n        available.addAll(oneDayAvailable(start_date, calendars));\n        start_date = new DateTime(start_date.getTime() + 1000 * 60 * 60 * 24);\n        start_date.setTimeZone(tz1);\n    }\n    if (tz2 != null) {\n        System.out.printf(\"Timezone: %s  [Timezone: %s]%n\", printedTimezone(tz1), printedTimezone(tz2));\n    }\n    String lastDateString = null;\n    for (Period p : available) {\n        String dateString = formatDate(p.getStart(), tz1);\n        if (!dateString.equals(lastDateString)) {\n            lastDateString = dateString;\n            System.out.println();\n            System.out.println(dateString + \":\");\n        }\n        String rangeString = rangeString(p, tz1);\n        if (tz2 == null) {\n            System.out.println(rangeString);\n        } else {\n            String rangeString2 = rangeString(p, tz2);\n            System.out.printf(\"%-20s[%s]%n\", rangeString, rangeString2);\n        }\n    }\n}","methodRange":"(line 348,col 3)-(line 384,col 3)","methodTokenRange":"public static void main(String[] args) {\n\n    processOptions(args);\n\n    List<Period> available = new ArrayList<Period>();\n    if (debug) {\n      System.err.printf(\"Testing %d days%n\", days);\n    }\n    for (int i = 0; i < days; i++) {\n      available.addAll(oneDayAvailable(start_date, calendars));\n      start_date = new DateTime(start_date.getTime() + 1000 * 60 * 60 * 24);\n      start_date.setTimeZone(tz1);\n    }\n\n    if (tz2 != null) {\n      System.out.printf(\n          \"Timezone: %s  [Timezone: %s]%n\", printedTimezone(tz1), printedTimezone(tz2));\n    }\n    String lastDateString = null;\n    for (Period p : available) {\n      String dateString = formatDate(p.getStart(), tz1);\n      if (!dateString.equals(lastDateString)) {\n        lastDateString = dateString;\n        System.out.println();\n        System.out.println(dateString + \":\");\n      }\n\n      String rangeString = rangeString(p, tz1);\n\n      if (tz2 == null) {\n        System.out.println(rangeString);\n      } else {\n        String rangeString2 = rangeString(p, tz2);\n        System.out.printf(\"%-20s[%s]%n\", rangeString, rangeString2);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.ICalAvailable.main","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 354,col 25)-(line 354,col 43)","literalExprId":1,"literalExpr":"\"Testing %d days%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 356,col 18)-(line 356,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 358,col 56)-(line 358,col 59)","literalExprId":3,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 358,col 63)-(line 358,col 64)","literalExprId":4,"literalExpr":"60","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 358,col 68)-(line 358,col 69)","literalExprId":5,"literalExpr":"60","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 358,col 73)-(line 358,col 74)","literalExprId":6,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 362,col 16)-(line 362,col 19)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 364,col 11)-(line 364,col 42)","literalExprId":8,"literalExpr":"\"Timezone: %s  [Timezone: %s]%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 366,col 29)-(line 366,col 32)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 372,col 41)-(line 372,col 43)","literalExprId":10,"literalExpr":"\":\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 377,col 18)-(line 377,col 21)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 381,col 27)-(line 381,col 39)","literalExprId":12,"literalExpr":"\"%-20s[%s]%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ICalAvailable.main(java.lang.String[])"},{"methodDeclaration":" static String rangeString(Period p, TimeZone tz)","methodAccessSpecifier":"NONE","methodBody":"{\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n}","methodRange":"(line 386,col 3)-(line 394,col 3)","methodTokenRange":"static String rangeString(Period p, TimeZone tz) {\n    tf.setTimeZone(tz);\n    DateTime pstart = p.getStart();\n    DateTime pend = p.getEnd();\n    String rangeString = tf.format(pstart) + \" to \" + tf.format(pend);\n    rangeString = rangeString.replace(\" AM\", \"am\");\n    rangeString = rangeString.replace(\" PM\", \"pm\");\n    return rangeString;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Period","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Period p","parameterName":"p"},{"parameterType":"TimeZone","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"TimeZone tz","parameterName":"tz"}],"methodName":"rangeString","methodQualifiedSignature":"plume.ICalAvailable.rangeString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 390,col 46)-(line 390,col 51)","literalExprId":1,"literalExpr":"\" to \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 391,col 39)-(line 391,col 43)","literalExprId":2,"literalExpr":"\" AM\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 391,col 46)-(line 391,col 49)","literalExprId":3,"literalExpr":"\"am\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 392,col 39)-(line 392,col 43)","literalExprId":4,"literalExpr":"\" PM\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 392,col 46)-(line 392,col 49)","literalExprId":5,"literalExpr":"\"pm\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"methodDeclaration":" static String periodListString(PeriodList pl, TimeZone tz)","methodAccessSpecifier":"NONE","methodBody":"{\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    for (Object p : pl) {\n        assert p != null : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n        result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n}","methodRange":"(line 396,col 3)-(line 407,col 3)","methodTokenRange":"static String periodListString(PeriodList pl, TimeZone tz) {\n    tf.setTimeZone(tz);\n    StringBuilder result = new StringBuilder();\n    \/\/ \"Object\" because PeriodList extends TreeSet, but it really ought to\n    \/\/ extend TreeSet<\/*@NonNull*\/ Period>\n    for (Object p : pl) {\n      assert p != null\n          : \"@AssumeAssertion(nullness): non-generic container class; elements are non-null\";\n      result.append(rangeString((Period) p, tz) + \"\\n\");\n    }\n    return result.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"PeriodList","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"PeriodList pl","parameterName":"pl"},{"parameterType":"TimeZone","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"TimeZone tz","parameterName":"tz"}],"methodName":"periodListString","methodQualifiedSignature":"plume.ICalAvailable.periodListString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 402,col 19)-(line 402,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 403,col 13)-(line 403,col 92)","literalExprId":2,"literalExpr":"\"@AssumeAssertion(nullness): non-generic container class; elements are non-null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 404,col 51)-(line 404,col 54)","literalExprId":3,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the merged DateTime","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the merged DateTime'}]}', name=Optional.empty}"}],"methodDeclaration":" static DateTime mergeDateAndTime(DateTime date, DateTime time)","methodAccessSpecifier":"NONE","methodBody":"{\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n        throw new Error(String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n}","methodRange":"(line 414,col 3)-(line 425,col 3)","methodTokenRange":"@SuppressWarnings(\"deprecation\") \/\/ for iCal4j\n  static DateTime mergeDateAndTime(DateTime date, DateTime time) {\n    if (!date.getTimeZone().equals(time.getTimeZone())) {\n      throw new Error(\n          String.format(\"non-matching timezones: %s %s\", date.getTimeZone(), time.getTimeZone()));\n    }\n    DateTime result = new DateTime(date);\n    result.setHours(time.getHours());\n    result.setMinutes(time.getMinutes());\n    result.setSeconds(time.getSeconds());\n    return result;\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * Creates a new DateTime with date taken from the first argument and\n   * time taken from the second argument.\n   * @return the merged DateTime\n   ","methodParameters":[{"parameterType":"DateTime","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"DateTime date","parameterName":"date"},{"parameterType":"DateTime","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"DateTime time","parameterName":"time"}],"methodName":"mergeDateAndTime","methodQualifiedSignature":"plume.ICalAvailable.mergeDateAndTime","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a new DateTime with date taken from the first argument and\ntime taken from the second argument.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the merged DateTime'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"DateTime","literalExprs":[{"literalExprRange":"(line 414,col 21)-(line 414,col 33)","literalExprId":1,"literalExpr":"\"deprecation\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 418,col 25)-(line 418,col 55)","literalExprId":2,"literalExpr":"\"non-matching timezones: %s %s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"methodDeclaration":" static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars)","methodAccessSpecifier":"NONE","methodBody":"{\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    @SuppressWarnings(\"deprecation\")\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n        return result;\n    }\n    for (Period bh : businessHours) {\n        DateTime start = mergeDateAndTime(day, bh.getStart());\n        DateTime end = mergeDateAndTime(day, bh.getEnd());\n        VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n        if (debug) {\n            System.out.println(\"Request = \" + request);\n        }\n        ComponentList busyTimes = new ComponentList();\n        for (Calendar calendar : calendars) {\n            ArrayList<Component> clist = calendar.getComponents();\n            for (Component c : clist) {\n                if (c instanceof VEvent) {\n                    VEvent v = (VEvent) c;\n                    DtStart dts = v.getStartDate();\n                    Parameter dtsValue = dts.getParameter(\"VALUE\");\n                    boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n                }\n                busyTimes.add(c);\n            }\n        }\n        VFreeBusy response = new VFreeBusy(request, busyTimes);\n        if (debug) {\n            System.out.println(\"Response = \" + response);\n        }\n        FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n        if (freefb == null) {\n            if (debug) {\n                System.out.println(\"FREEBUSY property is null\");\n            }\n            continue;\n        }\n        @SuppressWarnings(\"interning\")\n        boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n        assert isFree;\n        PeriodList freePeriods = freefb.getPeriods();\n        if (debug) {\n            System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n        }\n        result.addAll(freePeriods);\n    }\n    if (debug) {\n        System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n}","methodRange":"(line 430,col 3)-(line 495,col 3)","methodTokenRange":"@SuppressWarnings(\"unchecked\") \/\/ for iCal4j\n  \/*@RequiresNonNull(\"tz1\")*\/\n  static List<Period> oneDayAvailable(DateTime day, List<Calendar> calendars) {\n    if (debug) {\n      System.err.printf(\"oneDayAvailable(%s, ...)%n\", day);\n    }\n    List<Period> result = new ArrayList<Period>();\n    @SuppressWarnings(\"deprecation\") \/\/ for iCal4j\n    int dayOfWeek = day.getDay();\n    if (!businessDays.contains(dayOfWeek)) {\n      return result;\n    }\n\n    for (Period bh : businessHours) {\n      DateTime start = mergeDateAndTime(day, bh.getStart());\n      DateTime end = mergeDateAndTime(day, bh.getEnd());\n\n      VFreeBusy request = new VFreeBusy(start, end, new Dur(0, 0, 0, 1));\n      if (debug) {\n        System.out.println(\"Request = \" + request);\n      }\n      ComponentList busyTimes = new ComponentList();\n      \/\/ Problem:  any all-day events will be treated as UTC.\n      \/\/ Instead, they should be converted to local time (tz1).\n      \/\/ But VFreeBusy does not support this, so I may need to convert\n      \/\/ daily events into a different format before inserting them.\n      for (Calendar calendar : calendars) {\n        \/\/ getComponents() returns a raw ArrayList.  Expose its element type.\n        ArrayList<\/*@NonNull*\/ Component> clist = calendar.getComponents();\n        for (Component c : clist) {\n          if (c instanceof VEvent) {\n            VEvent v = (VEvent) c;\n            DtStart dts = v.getStartDate();\n            Parameter dtsValue = dts.getParameter(\"VALUE\");\n            boolean allDay = (dtsValue != null) && dtsValue.getValue().equals(\"DATE\");\n            \/\/ TODO: convert to the proper timezone.\n            \/\/ Tricky: must deal with the possibility of RRULE:FREQ=\n          }\n          busyTimes.add(c);\n        }\n      }\n      VFreeBusy response = new VFreeBusy(request, busyTimes);\n      if (debug) {\n        System.out.println(\"Response = \" + response);\n      }\n      FreeBusy freefb = (FreeBusy) response.getProperty(\"FREEBUSY\");\n      if (freefb == null) {\n        if (debug) {\n          System.out.println(\"FREEBUSY property is null\");\n        }\n        continue;\n      }\n      @SuppressWarnings(\"interning\") \/\/ interned fields from a library, but not annotated so\n      boolean isFree = (freefb.getParameter(Parameter.FBTYPE) == FbType.FREE);\n      assert isFree;\n      PeriodList freePeriods = freefb.getPeriods();\n      if (debug) {\n        System.out.printf(\"Free periods: %n%s%n\", periodListString(freePeriods, tz1));\n      }\n      result.addAll(freePeriods);\n    }\n    if (debug) {\n      System.err.printf(\"oneDayAvailable(%s, ...) => %s elements%n\", day, result.size());\n    }\n    return result;\n  }","methodReturnTypeResolved":"","methodJavadocComment":" Process day-by-day because otherwise weekends and evenings are included.","methodParameters":[{"parameterType":"DateTime","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"DateTime day","parameterName":"day"},{"parameterType":"List<Calendar>","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"List<Calendar> calendars","parameterName":"calendars"}],"methodName":"oneDayAvailable","methodQualifiedSignature":"plume.ICalAvailable.oneDayAvailable","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"List<Period>","literalExprs":[{"literalExprRange":"(line 430,col 21)-(line 430,col 31)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 434,col 25)-(line 434,col 52)","literalExprId":2,"literalExpr":"\"oneDayAvailable(%s, ...)%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 437,col 23)-(line 437,col 35)","literalExprId":3,"literalExpr":"\"deprecation\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 447,col 61)-(line 447,col 61)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 64)-(line 447,col 64)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 67)-(line 447,col 67)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 70)-(line 447,col 70)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 28)-(line 449,col 39)","literalExprId":8,"literalExpr":"\"Request = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 463,col 51)-(line 463,col 57)","literalExprId":9,"literalExpr":"\"VALUE\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 464,col 43)-(line 464,col 46)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 464,col 79)-(line 464,col 84)","literalExprId":11,"literalExpr":"\"DATE\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 473,col 28)-(line 473,col 40)","literalExprId":12,"literalExpr":"\"Response = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 475,col 57)-(line 475,col 66)","literalExprId":13,"literalExpr":"\"FREEBUSY\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 476,col 21)-(line 476,col 24)","literalExprId":14,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 478,col 30)-(line 478,col 56)","literalExprId":15,"literalExpr":"\"FREEBUSY property is null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 482,col 25)-(line 482,col 35)","literalExprId":16,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 487,col 27)-(line 487,col 48)","literalExprId":17,"literalExpr":"\"Free periods: %n%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 492,col 25)-(line 492,col 67)","literalExprId":18,"literalExpr":"\"oneDayAvailable(%s, ...) => %s elements%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a Date read from the given string","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Date read from the given string'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"dateFormats","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='dateFormats'}]}', name=Optional.empty}"}],"methodDeclaration":" static java.util.Date parseDate(String strDate) throws ParseException","methodAccessSpecifier":"NONE","methodBody":"{\n    if (Pattern.matches(\"^[0-9][0-9]?\/[0-9][0-9]?$\", date)) {\n        @SuppressWarnings(\"deprecation\")\n        int year = new Date().getYear() + 1900;\n        strDate = strDate + \"\/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n        this_df.setLenient(false);\n        try {\n            java.util.Date result = this_df.parse(strDate);\n            return result;\n        } catch (ParseException e) {\n        }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n}","methodRange":"(line 510,col 3)-(line 526,col 3)","methodTokenRange":"static java.util.Date parseDate(String strDate) throws ParseException {\n    if (Pattern.matches(\"^[0-9][0-9]?\/[0-9][0-9]?$\", date)) {\n      @SuppressWarnings(\"deprecation\") \/\/ for iCal4j\n      int year = new Date().getYear() + 1900;\n      strDate = strDate + \"\/\" + year;\n    }\n    for (DateFormat this_df : dateFormats) {\n      this_df.setLenient(false);\n      try {\n        java.util.Date result = this_df.parse(strDate);\n        return result;\n      } catch (ParseException e) {\n        \/\/ Try the next format in the list.\n      }\n    }\n    throw new ParseException(\"bad date \" + strDate, 0);\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Date, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Parses a date when formatted in several common formats.\n   * @return a Date read from the given string\n   * @see dateFormats\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String strDate","parameterName":"strDate"}],"methodName":"parseDate","methodQualifiedSignature":"plume.ICalAvailable.parseDate","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Parses a date when formatted in several common formats.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a Date read from the given string'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='dateFormats'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Date","methodType":"java.util.Date","literalExprs":[{"literalExprRange":"(line 511,col 25)-(line 511,col 51)","literalExprId":1,"literalExpr":"\"^[0-9][0-9]?\/[0-9][0-9]?$\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 512,col 25)-(line 512,col 37)","literalExprId":2,"literalExpr":"\"deprecation\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 513,col 41)-(line 513,col 44)","literalExprId":3,"literalExpr":"1900","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 27)-(line 514,col 29)","literalExprId":4,"literalExpr":"\"\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 517,col 26)-(line 517,col 30)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 525,col 30)-(line 525,col 40)","literalExprId":6,"literalExpr":"\"bad date \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 525,col 53)-(line 525,col 53)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ICalAvailable.parseDate(java.lang.String)"},{"methodDeclaration":" static String formatDate(DateTime d, TimeZone tz)","methodAccessSpecifier":"NONE","methodBody":"{\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n}","methodRange":"(line 528,col 3)-(line 537,col 3)","methodTokenRange":"static String formatDate(DateTime d, TimeZone tz) {\n    df.setTimeZone(tz);\n    String result = df.format(d);\n    \/\/ Don't remove trailing year; it's a good double-check.\n    \/\/ Remove trailing year, such as \", 1952\".\n    \/\/ result = result.substring(0, result.length() - 6);\n    \/\/ Prepend day of week.\n    result = dffull.format(d).substring(0, 3) + \" \" + result;\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"DateTime","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"DateTime d","parameterName":"d"},{"parameterType":"TimeZone","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"TimeZone tz","parameterName":"tz"}],"methodName":"formatDate","methodQualifiedSignature":"plume.ICalAvailable.formatDate","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 535,col 41)-(line 535,col 41)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 535,col 44)-(line 535,col 44)","literalExprId":2,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 535,col 49)-(line 535,col 51)","literalExprId":3,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""}],"classJavadoc":"\/**\n * Given one or more calendars in <a href=\"https:\/\/en.wikipedia.org\/wiki\/ICalendar\">iCalendar format<\/a>, produces a textual summary\n * of available times.\n * This is useful for sending someone a list of acceptable times for a meeting.\n * Also see the <code>ical-available<\/code> Emacs function, which inserts the\n * output of this program.\n *\n * The command-line options are as follows:\n * <!-- start options doc (DO NOT EDIT BY HAND) -->\n * <ul>\n *   <li id=\"option:date\"><b>--date=<\/b><i>string<\/i>.\n *    first date to summarize [default today]<\/li>\n *   <li id=\"option:days\"><b>--days=<\/b><i>int<\/i>.\n *    number of calendar days to summarize [default 8]<\/li>\n *   <li id=\"option:iCal-URL\"><b>--iCal-URL=<\/b><i>url<\/i> <code>[+]<\/code>.\n *    For a Google calendar:  go to settings, then click on the green \"ICAL\"\n *  icon for the \"private address\".<\/li>\n *   <li id=\"option:business-hours\"><b>--business-hours=<\/b><i>string<\/i>.\n *    A list of time ranges, expressed as a String.\n *  Example: 9am-5pm,7:30pm-9:30pm [default 9am-5pm]<\/li>\n *   <li id=\"option:timezone1\"><b>--timezone1=<\/b><i>timezone<\/i>.\n *    Time zone as an Olson timezone ID, e.g.: America\/New_York.\n *  Available times are printed in this time zone.  It defaults to the\n *  system time zone.<\/li>\n *   <li id=\"option:timezone2\"><b>--timezone2=<\/b><i>timezone<\/i>.\n *    Time zone as an Olson timezone ID, e.g.: America\/New_York.\n *  If set, then free times are printed in two time zones.<\/li>\n *   <li id=\"option:debug\"><b>--debug=<\/b><i>boolean<\/i>.\n *    enable debugging output [default false]<\/li>\n * <\/ul>\n * <code>[+]<\/code> marked option can be specified multiple times\n * <!-- end options doc -->\n *\/\n","className":"ICalAvailable","fields":[{"fieldRange":"(line 90,col 3)-(line 91,col 38)","fieldName":"date","fieldJavadocComment":"","fieldTokenRange":"@Option(\"first date to summarize\")\n  public static String date = \"today\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 90,col 11)-(line 90,col 35)","literalExprId":1,"literalExpr":"\"first date to summarize\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 91,col 31)-(line 91,col 37)","literalExprId":2,"literalExpr":"\"today\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"today\"]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 93,col 3)-(line 93,col 53)","fieldName":"start_date","fieldJavadocComment":"","fieldTokenRange":"public static DateTime start_date = new DateTime();","fieldTypeResolved":"","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"Optional[new DateTime()]","fieldType":"DateTime","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 95,col 3)-(line 96,col 29)","fieldName":"days","fieldJavadocComment":"","fieldTokenRange":"@Option(\"number of calendar days to summarize\")\n  public static int days = 8;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 95,col 11)-(line 95,col 48)","literalExprId":1,"literalExpr":"\"number of calendar days to summarize\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 96,col 28)-(line 96,col 28)","literalExprId":2,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[8]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 102,col 3)-(line 103,col 64)","fieldName":"iCal_URL","fieldJavadocComment":"\n   * For a Google calendar:  go to settings, then click on the green \"ICAL\"\n   * icon for the \"private address\".\n   ","fieldTokenRange":"@Option(\"<url> schedule in iCal format\")\n  public static List<String> iCal_URL = new ArrayList<String>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 102,col 11)-(line 102,col 41)","literalExprId":1,"literalExpr":"\"<url> schedule in iCal format\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[new ArrayList<String>()]","fieldType":"List<String>","fieldJavadoc":"For a Google calendar:  go to settings, then click on the green \"ICAL\"\nicon for the \"private address\".\n","fieldTypeResolvedDescribed":"java.util.List<java.lang.String>"},{"fieldRange":"(line 108,col 3)-(line 109,col 50)","fieldName":"business_hours","fieldJavadocComment":"\n   * A list of time ranges, expressed as a String.\n   * Example: 9am-5pm,7:30pm-9:30pm ","fieldTokenRange":"@Option(\"time ranges during which appointments are permitted\")\n  public static String business_hours = \"9am-5pm\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 108,col 11)-(line 108,col 63)","literalExprId":1,"literalExpr":"\"time ranges during which appointments are permitted\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 109,col 41)-(line 109,col 49)","literalExprId":2,"literalExpr":"\"9am-5pm\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"9am-5pm\"]","fieldType":"String","fieldJavadoc":"A list of time ranges, expressed as a String.\nExample: 9am-5pm,7:30pm-9:30pm\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 111,col 3)-(line 111,col 62)","fieldName":"businessHours","fieldJavadocComment":" initialize to 9am-5pm","fieldTokenRange":"static List<Period> businessHours = new ArrayList<Period>();","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<Period>()]","fieldType":"List<Period>","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 112,col 3)-(line 112,col 63)","fieldName":"businessDays","fieldJavadocComment":" initialize to Mon-Fri","fieldTokenRange":"static List<Integer> businessDays = new ArrayList<Integer>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<Integer>()]","fieldType":"List<Integer>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.List<java.lang.Integer>"},{"fieldRange":"(line 122,col 3)-(line 122,col 94)","fieldName":"tzRegistry","fieldJavadocComment":"","fieldTokenRange":"static TimeZoneRegistry tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry();","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[TimeZoneRegistryFactory.getInstance().createRegistry()]","fieldType":"TimeZoneRegistry","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 129,col 3)-(line 130,col 65)","fieldName":"timezone1","fieldJavadocComment":" don't need \"e.g.: America\/New_York\" in message:  the default is an example","fieldTokenRange":"@Option(value = \"<timezone> time zone, e.g.: America\/New_York\", noDocDefault = true)\n  public static String timezone1 = TimeZone.getDefault().getID();","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 129,col 19)-(line 129,col 64)","literalExprId":1,"literalExpr":"\"<timezone> time zone, e.g.: America\/New_York\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 129,col 82)-(line 129,col 85)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[TimeZone.getDefault().getID()]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 135,col 3)-(line 135,col 44)","fieldName":"tz1","fieldJavadocComment":" static TimeZone tz1 = tzRegistry.getTimeZone(canonicalizeTimezone(timezone1));","fieldTokenRange":"static \/*@MonotonicNonNull*\/ TimeZone tz1;","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"TimeZone","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 142,col 3)-(line 143,col 47)","fieldName":"timezone2","fieldJavadocComment":"\n   * Time zone as an Olson timezone ID, e.g.: America\/New_York.\n   * If set, then free times are printed in two time zones. ","fieldTokenRange":"@Option(\"<timezone> optional second time zone, e.g.: America\/New_York\")\n  public static \/*@Nullable*\/ String timezone2;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 142,col 11)-(line 142,col 72)","literalExprId":1,"literalExpr":"\"<timezone> optional second time zone, e.g.: America\/New_York\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"","fieldType":"String","fieldJavadoc":"Time zone as an Olson timezone ID, e.g.: America\/New_York.\nIf set, then free times are printed in two time zones.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 145,col 3)-(line 145,col 36)","fieldName":"tz2","fieldJavadocComment":"","fieldTokenRange":"static \/*@Nullable*\/ TimeZone tz2;","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"TimeZone","fieldJavadoc":"","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 149,col 3)-(line 150,col 38)","fieldName":"debug","fieldJavadocComment":"","fieldTokenRange":"@Option(\"enable debugging output\")\n  public static boolean debug = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 149,col 11)-(line 149,col 35)","literalExprId":1,"literalExpr":"\"enable debugging output\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 150,col 33)-(line 150,col 37)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 153,col 3)-(line 153,col 62)","fieldName":"calendars","fieldJavadocComment":" The appointments (the times that are unavailable for a meeting). ","fieldTokenRange":"static List<Calendar> calendars = new ArrayList<Calendar>();","fieldTypeResolved":"","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<Calendar>()]","fieldType":"List<Calendar>","fieldJavadoc":"The appointments (the times that are unavailable for a meeting).\n","fieldTypeResolvedDescribed":""},{"fieldRange":"(line 155,col 3)-(line 155,col 81)","fieldName":"tf","fieldJavadocComment":"","fieldTokenRange":"static DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US);","fieldTypeResolved":"ReferenceType{java.text.DateFormat, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[DateFormat.getTimeInstance(DateFormat.SHORT, Locale.US)]","fieldType":"DateFormat","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.text.DateFormat"},{"fieldRange":"(line 156,col 3)-(line 156,col 82)","fieldName":"df","fieldJavadocComment":"","fieldTokenRange":"static DateFormat df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US);","fieldTypeResolved":"ReferenceType{java.text.DateFormat, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.US)]","fieldType":"DateFormat","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.text.DateFormat"},{"fieldRange":"(line 157,col 3)-(line 157,col 84)","fieldName":"dffull","fieldJavadocComment":"","fieldTokenRange":"static DateFormat dffull = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);","fieldTypeResolved":"ReferenceType{java.text.DateFormat, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[DateFormat.getDateInstance(DateFormat.FULL, Locale.US)]","fieldType":"DateFormat","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.text.DateFormat"},{"fieldRange":"(line 258,col 3)-(line 258,col 80)","fieldName":"canonicalTimezones","fieldJavadocComment":"","fieldTokenRange":"static Map<String, String> canonicalTimezones = new HashMap<String, String>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<String, String>()]","fieldType":"Map<String, String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<java.lang.String, java.lang.String>"},{"fieldRange":"(line 259,col 3)-(line 259,col 78)","fieldName":"printedTimezones","fieldJavadocComment":"","fieldTokenRange":"static Map<String, String> printedTimezones = new HashMap<String, String>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<String, String>()]","fieldType":"Map<String, String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<java.lang.String, java.lang.String>"},{"fieldRange":"(line 299,col 3)-(line 300,col 68)","fieldName":"timeRegexp","fieldJavadocComment":"","fieldTokenRange":"static \/*@Regex(4)*\/ Pattern timeRegexp =\n      Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 300,col 23)-(line 300,col 66)","literalExprId":1,"literalExpr":"\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"([0-2]?[0-9])(:([0-5][0-9]))?([aApP][mM])?\")]","fieldType":"Pattern","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 497,col 3)-(line 503,col 4)","fieldName":"dateFormats","fieldJavadocComment":"","fieldTokenRange":"static SimpleDateFormat[] dateFormats = {\n    new SimpleDateFormat(\"yyyy\/MM\/dd\"),\n    new SimpleDateFormat(\"MM\/dd\/yyyy\"),\n    new SimpleDateFormat(\"MM\/dd\/yy\"),\n    \/\/ Bad idea:  sets year to 1970.  So require the year, at least for now.\n    \/\/ new SimpleDateFormat(\"MM\/dd\"),\n  };","fieldTypeResolved":"ResolvedArrayType{ReferenceType{java.text.SimpleDateFormat, typeParametersMap=TypeParametersMap{nameToValue={}}}}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 498,col 26)-(line 498,col 37)","literalExprId":1,"literalExpr":"\"yyyy\/MM\/dd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 499,col 26)-(line 499,col 37)","literalExprId":2,"literalExpr":"\"MM\/dd\/yyyy\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 500,col 26)-(line 500,col 35)","literalExprId":3,"literalExpr":"\"MM\/dd\/yy\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[{ new SimpleDateFormat(\"yyyy\/MM\/dd\"), new SimpleDateFormat(\"MM\/dd\/yyyy\"), new SimpleDateFormat(\"MM\/dd\/yy\") }]","fieldType":"SimpleDateFormat[]","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.text.SimpleDateFormat[]"}]}],"sourceFileId":32,"packageName":"plume"},{"sourceFileName":"plume.RandomSelector","imports":[{"importId":1,"import":"import java.util.ArrayList;\n"},{"importId":2,"import":"import java.util.List;\n"},{"importId":3,"import":"import java.util.Random;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of elements intended to be selected\nfrom the input elements\n\nSets 'number_to_take' = num_elts","javadocBlockTagName":"num_elts","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of elements intended to be selected\nfrom the input elements\n\nSets 'number_to_take' = num_elts'}]}', name=Optional[num_elts]}"}],"constructorQualifiedSignature":"plume.RandomSelector.RandomSelector(int)","variableDeclarationExprs":[],"constructorRange":"(line 80,col 3)-(line 82,col 3)","constructorJavadocComment":" @param num_elts the number of elements intended to be selected\n   * from the input elements\n   *\n   * Sets 'number_to_take' = num_elts\n   ","constructorDeclaration":"public RandomSelector(int num_elts)","constructorBody":"{\n    this(num_elts, new Random());\n}","constructorName":"RandomSelector","constructorQualifiedName":"plume.RandomSelector.RandomSelector","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num_elts","parameterName":"num_elts"}],"literalExprs":[],"constructorTokenRange":"public RandomSelector(int num_elts) {\n    this(num_elts, new Random());\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of elements intended to be selected\nfrom the input elements\n\nSets 'number_to_take' = num_elts'}]}', name=Optional[num_elts]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the number of elements intended to be selected\nfrom the input elements","javadocBlockTagName":"num_elts","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of elements intended to be selected\nfrom the input elements'}]}', name=Optional[num_elts]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the seed to give for random number generation.\n\nSets 'number_to_take' = num_elts","javadocBlockTagName":"r","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the seed to give for random number generation.\n\nSets 'number_to_take' = num_elts'}]}', name=Optional[r]}"}],"constructorQualifiedSignature":"plume.RandomSelector.RandomSelector(int, java.util.Random)","variableDeclarationExprs":[],"constructorRange":"(line 90,col 3)-(line 95,col 3)","constructorJavadocComment":" @param num_elts the number of elements intended to be selected\n   * from the input elements\n   * @param r the seed to give for random number generation.\n   *\n   * Sets 'number_to_take' = num_elts\n   ","constructorDeclaration":"public RandomSelector(int num_elts, Random r)","constructorBody":"{\n    values = new ArrayList<T>();\n    this.num_elts = num_elts;\n    observed = 0;\n    generator = r;\n}","constructorName":"RandomSelector","constructorQualifiedName":"plume.RandomSelector.RandomSelector","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num_elts","parameterName":"num_elts"},{"parameterType":"Random","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Random","parameter":"Random r","parameterName":"r"}],"literalExprs":[{"literalExprRange":"(line 93,col 16)-(line 93,col 16)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public RandomSelector(int num_elts, Random r) {\n    values = new ArrayList<T>();\n    this.num_elts = num_elts;\n    observed = 0;\n    generator = r;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the number of elements intended to be selected\nfrom the input elements'}]}', name=Optional[num_elts]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the seed to give for random number generation.\n\nSets 'number_to_take' = num_elts'}]}', name=Optional[r]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the probability that each element is\nselected from the oncoming Iteration","javadocBlockTagName":"keep_probability","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the probability that each element is\nselected from the oncoming Iteration'}]}', name=Optional[keep_probability]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the seed to give for random number generation","javadocBlockTagName":"r","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the seed to give for random number generation'}]}', name=Optional[r]}"}],"constructorQualifiedSignature":"plume.RandomSelector.RandomSelector(double, java.util.Random)","variableDeclarationExprs":[],"constructorRange":"(line 101,col 3)-(line 107,col 3)","constructorJavadocComment":" @param keep_probability the probability that each element is\n   * selected from the oncoming Iteration\n   * @param r the seed to give for random number generation\n   ","constructorDeclaration":"public RandomSelector(double keep_probability, Random r)","constructorBody":"{\n    values = new ArrayList<T>();\n    this.keep_probability = keep_probability;\n    coin_toss_mode = true;\n    observed = 0;\n    generator = r;\n}","constructorName":"RandomSelector","constructorQualifiedName":"plume.RandomSelector.RandomSelector","constructorParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double keep_probability","parameterName":"keep_probability"},{"parameterType":"Random","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Random","parameter":"Random r","parameterName":"r"}],"literalExprs":[{"literalExprRange":"(line 104,col 22)-(line 104,col 25)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 105,col 16)-(line 105,col 16)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public RandomSelector(double keep_probability, Random r) {\n    values = new ArrayList<T>();\n    this.keep_probability = keep_probability;\n    coin_toss_mode = true;\n    observed = 0;\n    generator = r;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the probability that each element is\nselected from the oncoming Iteration'}]}', name=Optional[keep_probability]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the seed to give for random number generation'}]}', name=Optional[r]}]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be added to this selector","javadocBlockTagName":"next","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be added to this selector'}]}', name=Optional[next]}"}],"methodDeclaration":"public void accept(T next)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (coin_toss_mode) {\n        if (generator.nextDouble() < keep_probability) {\n            values.add(next);\n        } else {\n        }\n        return;\n    }\n    if (generator.nextDouble() < ((double) num_elts \/ (++observed))) {\n        if (values.size() < num_elts) {\n            values.add(next);\n        } else {\n            int rem = generator.nextInt(values.size());\n            values.set(rem, next);\n        }\n    }\n}","methodRange":"(line 122,col 3)-(line 147,col 3)","methodTokenRange":"public void accept(T next) {\n\n    \/\/ if we are in coin toss mode, then we want to keep\n    \/\/ with probability == keep_probability.\n    if (coin_toss_mode) {\n      if (generator.nextDouble() < keep_probability) {\n        values.add(next);\n        \/\/ System.out.println (\"ACCEPTED \" + keep_probability );\n      } else {\n        \/\/ System.out.println (\"didn't accept \" + keep_probability );\n      }\n      return;\n    }\n\n    \/\/ in fixed sample mode, the i-th element has a k\/i chance\n    \/\/ of being accepted where k is number_to_take.\n    if (generator.nextDouble() < ((double) num_elts \/ (++observed))) {\n      if (values.size() < num_elts) {\n        values.add(next);\n      } else {\n        int rem = generator.nextInt(values.size());\n        values.set(rem, next);\n      }\n    }\n    \/\/ do nothing if the probability condition is not met\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" <P>When in fixed sample mode, increments the number of\n   * observed elements i by 1, then with probability k \/ i, the\n   * Object 'next' will be added to the currently selected values\n   * 'current_values' where k is equal to 'number_to_take'. If the\n   * size of current_values exceeds number_to_take, then one of the\n   * existing elements in current_values will be removed at random.\n   *\n   *\n   * <P>When in probability mode, adds next to 'current_values' with\n   * probability equal to 'keep_probability'.\n   *\n   * @param next value to be added to this selector\n   ","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T next","parameterName":"next"}],"methodName":"accept","methodQualifiedSignature":"plume.RandomSelector.accept","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='<P>When in fixed sample mode, increments the number of\nobserved elements i by 1, then with probability k \/ i, the\nObject 'next' will be added to the currently selected values\n'current_values' where k is equal to 'number_to_take'. If the\nsize of current_values exceeds number_to_take, then one of the\nexisting elements in current_values will be removed at random.\n\n\n<P>When in probability mode, adds next to 'current_values' with\nprobability equal to 'keep_probability'.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be added to this selector'}]}', name=Optional[next]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.RandomSelector.accept(T)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"current_values","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current_values'}]}', name=Optional.empty}"}],"methodDeclaration":"public List<T> getValues()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ArrayList<T> ret = new ArrayList<T>();\n    ret.addAll(values);\n    return ret;\n}","methodRange":"(line 152,col 3)-(line 157,col 3)","methodTokenRange":"public List<T> getValues() {\n    \/\/ avoid concurrent mod errors and rep exposure\n    ArrayList<T> ret = new ArrayList<T>();\n    ret.addAll(values);\n    return ret;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":" Returns current_values, modifies none.\n   * @return current_values\n   ","methodParameters":[],"methodName":"getValues","methodQualifiedSignature":"plume.RandomSelector.getValues","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns current_values, modifies none.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='current_values'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<T>","methodType":"List<T>","literalExprs":[],"methodQualifiedName":"plume.RandomSelector.getValues()"}],"classJavadoc":"\/**\n * RandomSelector selects k elements uniformly at random from\n * an arbitrary iterator, using O(k) space.  A naive algorithm would use O(n)\n * space.  For example, selecting 1 element from a FileStream\n * containing 1000 elements will take O(1) space. The class takes as\n * input the number k during initialization and then can accept() any\n * number of Objects in the future.  At any point in time, getValues()\n * will either return k randomly selected elements from the elements\n * previous accepted or if accept() was called fewer than k times, will\n * return all elements previously accepted.\n *\n * <p>The random selection is independent between every constructed\n * instance of RandomSelector objects, but for the same instance,\n * multiple calls to getValues() are not independent. Making two calls\n * to consecutive getValues() without an accept() in between will\n * return two new Lists containing the same elements.\n *\n * <p>A second mode allows for a fixed probability of randomly keeping\n *  each item as opposed to a fixed number of samples.\n *\n * <P>SPECFIELDS:\n * <BR>current_values  : Set : The values chosen based on the Objects observed\n * <BR>number_observed : int : The number of Objects observed\n * <BR>number_to_take  : int : The number of elements to choose ('k' above)\n * <BR>keep_probability: double :  The percentage of elements to keep\n * <BR>selector_mode :\n *       {FIXED,PERCENT}  : either fixed amount of samples or fixed percent.\n *\n * <P>Example use:\n * <br> \/\/ randomly selects 100 lines of text from a file\n * <pre>\n *  List selectedLines = null;\n *  try {\n *     BufferedReader br = new BufferedReader\n *       (new FileReader (\"myfile.txt\"));\n *     RandomSelector selector = new RandomSelector (100);\n *     while (br.ready()) {\n *       selector.accept (br.readLine());\n *     }\n *     selectedLines = selector.getValues();\n *   }\n *   catch (IOException e2) { e2.printStackTrace(); }\n * <\/pre>\n *\n * @param <T> the type of elements being selected over\n *\/\n","className":"RandomSelector","fields":[{"fieldRange":"(line 68,col 3)-(line 68,col 28)","fieldName":"num_elts","fieldJavadocComment":"","fieldTokenRange":"private int num_elts = -1;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 68,col 27)-(line 68,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[-1]","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 69,col 3)-(line 69,col 23)","fieldName":"observed","fieldJavadocComment":"","fieldTokenRange":"private int observed;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"","fieldTypeResolvedDescribed":"int"},{"fieldRange":"(line 70,col 3)-(line 70,col 27)","fieldName":"generator","fieldJavadocComment":"","fieldTokenRange":"private Random generator;","fieldTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Random","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Random"},{"fieldRange":"(line 71,col 3)-(line 71,col 30)","fieldName":"values","fieldJavadocComment":"","fieldTokenRange":"private ArrayList<T> values;","fieldTypeResolved":"ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"ArrayList<T>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.ArrayList<T>"},{"fieldRange":"(line 72,col 3)-(line 72,col 41)","fieldName":"coin_toss_mode","fieldJavadocComment":"","fieldTokenRange":"private boolean coin_toss_mode = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 72,col 36)-(line 72,col 40)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 73,col 3)-(line 73,col 41)","fieldName":"keep_probability","fieldJavadocComment":"","fieldTokenRange":"private double keep_probability = -1.0;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 73,col 38)-(line 73,col 40)","literalExprId":1,"literalExpr":"1.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[-1.0]","fieldType":"double","fieldJavadoc":"","fieldTypeResolvedDescribed":"double"}]}],"sourceFileId":33,"packageName":"plume"},{"sourceFileName":"plume.BCELUtil","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.PrintStream;\n"},{"importId":3,"import":"import java.util.Formatter;\n"},{"importId":4,"import":"import java.util.Iterator;\n"},{"importId":5,"import":"import org.apache.commons.bcel6.Const;\n"},{"importId":6,"import":"import org.apache.commons.bcel6.classfile.Attribute;\n"},{"importId":7,"import":"import org.apache.commons.bcel6.classfile.Code;\n"},{"importId":8,"import":"import org.apache.commons.bcel6.classfile.Constant;\n"},{"importId":9,"import":"import org.apache.commons.bcel6.classfile.ConstantClass;\n"},{"importId":10,"import":"import org.apache.commons.bcel6.classfile.ConstantPool;\n"},{"importId":11,"import":"import org.apache.commons.bcel6.classfile.ConstantUtf8;\n"},{"importId":12,"import":"import org.apache.commons.bcel6.classfile.Field;\n"},{"importId":13,"import":"import org.apache.commons.bcel6.classfile.JavaClass;\n"},{"importId":14,"import":"import org.apache.commons.bcel6.classfile.Method;\n"},{"importId":15,"import":"import org.apache.commons.bcel6.generic.ArrayType;\n"},{"importId":16,"import":"import org.apache.commons.bcel6.generic.ClassGen;\n"},{"importId":17,"import":"import org.apache.commons.bcel6.generic.CodeExceptionGen;\n"},{"importId":18,"import":"import org.apache.commons.bcel6.generic.ConstantPoolGen;\n"},{"importId":19,"import":"import org.apache.commons.bcel6.generic.InstructionHandle;\n"},{"importId":20,"import":"import org.apache.commons.bcel6.generic.InstructionList;\n"},{"importId":21,"import":"import org.apache.commons.bcel6.generic.InstructionTargeter;\n"},{"importId":22,"import":"import org.apache.commons.bcel6.generic.LineNumberGen;\n"},{"importId":23,"import":"import org.apache.commons.bcel6.generic.LocalVariableGen;\n"},{"importId":24,"import":"import org.apache.commons.bcel6.generic.MethodGen;\n"},{"importId":25,"import":"import org.apache.commons.bcel6.generic.ObjectType;\n"},{"importId":26,"import":"import org.apache.commons.bcel6.generic.RETURN;\n"},{"importId":27,"import":"import org.apache.commons.bcel6.generic.Type;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.BCELUtil.BCELUtil()","variableDeclarationExprs":[],"constructorRange":"(line 41,col 3)-(line 43,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private BCELUtil()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"BCELUtil","constructorQualifiedName":"plume.BCELUtil.BCELUtil","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 42,col 21)-(line 42,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private BCELUtil() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class whose methods to print","javadocBlockTagName":"gen","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class whose methods to print'}]}', name=Optional[gen]}"}],"methodDeclaration":" static void dump_method_declarations(ClassGen gen)","methodAccessSpecifier":"NONE","methodBody":"{\n    System.out.printf(\"method signatures for class %s%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n        System.out.printf(\"  %s%n\", get_method_declaration(m));\n    }\n}","methodRange":"(line 54,col 3)-(line 59,col 3)","methodTokenRange":"static void dump_method_declarations(ClassGen gen) {\n    System.out.printf(\"method signatures for class %s%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", get_method_declaration(m));\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Prints method declarations to System.out.\n   * @param gen class whose methods to print\n   ","methodParameters":[{"parameterType":"ClassGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ClassGen gen","parameterName":"gen"}],"methodName":"dump_method_declarations","methodQualifiedSignature":"plume.BCELUtil.dump_method_declarations","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prints method declarations to System.out.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class whose methods to print'}]}', name=Optional[gen]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 55,col 23)-(line 55,col 56)","literalExprId":1,"literalExpr":"\"method signatures for class %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 57,col 25)-(line 57,col 32)","literalExprId":2,"literalExpr":"\"  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method'}]}', name=Optional[m]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string describing the method declaration","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string describing the method declaration'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String get_method_declaration(Method m)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n        f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n}","methodRange":"(line 68,col 3)-(line 79,col 3)","methodTokenRange":"public static String get_method_declaration(Method m) {\n\n    StringBuilder sb = new StringBuilder();\n    Formatter f = new Formatter(sb);\n\n    f.format(\"%s %s %s (\", get_access_flags(m), m.getReturnType(), m.getName());\n    for (Type at : m.getArgumentTypes()) {\n      f.format(\"%s, \", at);\n    }\n    f.format(\")\");\n    return (sb.toString().replace(\", )\", \")\"));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a string describing a method declaration. It contains the access\n   * flags (public, private, static, etc), the return type, the method name, and\n   * the types of each of its arguments.\n   * @param m the method\n   * @return a string describing the method declaration\n   ","methodParameters":[{"parameterType":"Method","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Method m","parameterName":"m"}],"methodName":"get_method_declaration","methodQualifiedSignature":"plume.BCELUtil.get_method_declaration","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string describing a method declaration. It contains the access\nflags (public, private, static, etc), the return type, the method name, and\nthe types of each of its arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method'}]}', name=Optional[m]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string describing the method declaration'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 73,col 14)-(line 73,col 25)","literalExprId":1,"literalExpr":"\"%s %s %s (\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 75,col 16)-(line 75,col 21)","literalExprId":2,"literalExpr":"\"%s, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 77,col 14)-(line 77,col 16)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 35)-(line 78,col 39)","literalExprId":4,"literalExpr":"\", )\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 42)-(line 78,col 44)","literalExprId":5,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method whose access flags to retrieve","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose access flags to retrieve'}]}', name=Optional[m]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the access flags of method m","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the access flags of method m'}]}', name=Optional.empty}"}],"methodDeclaration":" static String get_access_flags(Method m)","methodAccessSpecifier":"NONE","methodBody":"{\n    int flags = m.getAccessFlags();\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n        if ((flags & pow) != 0) {\n            if (buf.length() > 0) {\n                buf.append(\" \");\n            }\n            if (i < Const.ACCESS_NAMES_LENGTH) {\n                buf.append(Const.getAccessName(i));\n            } else {\n                buf.append(String.format(\"ACC_BIT %x\", pow));\n            }\n        }\n        pow <<= 1;\n    }\n    return (buf.toString());\n}","methodRange":"(line 85,col 3)-(line 105,col 3)","methodTokenRange":"static String get_access_flags(Method m) {\n\n    int flags = m.getAccessFlags();\n\n    StringBuffer buf = new StringBuffer();\n    for (int i = 0, pow = 1; i <= Const.MAX_ACC_FLAG; i++) {\n      if ((flags & pow) != 0) {\n        if (buf.length() > 0) {\n          buf.append(\" \");\n        }\n        if (i < Const.ACCESS_NAMES_LENGTH) {\n          buf.append(Const.getAccessName(i));\n        } else {\n          buf.append(String.format(\"ACC_BIT %x\", pow));\n        }\n      }\n      pow <<= 1;\n    }\n\n    return (buf.toString());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Return a string representation of the access flags of method m.\n   * @param m the method whose access flags to retrieve\n   * @return a string representation of the access flags of method m\n   ","methodParameters":[{"parameterType":"Method","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Method m","parameterName":"m"}],"methodName":"get_access_flags","methodQualifiedSignature":"plume.BCELUtil.get_access_flags","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the access flags of method m.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose access flags to retrieve'}]}', name=Optional[m]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the access flags of method m'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 90,col 18)-(line 90,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 90,col 27)-(line 90,col 27)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 91,col 28)-(line 91,col 28)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 28)-(line 92,col 28)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 93,col 22)-(line 93,col 24)","literalExprId":5,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 98,col 36)-(line 98,col 47)","literalExprId":6,"literalExpr":"\"ACC_BIT %x\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 101,col 15)-(line 101,col 15)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the attribute","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the attribute name for the specified attribute","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute name for the specified attribute'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String get_attribute_name(Attribute a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}","methodRange":"(line 112,col 3)-(line 119,col 3)","methodTokenRange":"public static String get_attribute_name(Attribute a) {\n\n    ConstantPool pool = a.getConstantPool();\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @return the attribute name for the specified attribute\n   ","methodParameters":[{"parameterType":"Attribute","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Attribute a","parameterName":"a"}],"methodName":"get_attribute_name","methodQualifiedSignature":"plume.BCELUtil.get_attribute_name","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the attribute name for the specified attribute.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute name for the specified attribute'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the constant pool","javadocBlockTagName":"pool","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the constant pool'}]}', name=Optional[pool]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the index in the constant pool","javadocBlockTagName":"index","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index in the constant pool'}]}', name=Optional[index]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the constant string at the specified offset in the constant pool","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the constant string at the specified offset in the constant pool'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String get_constant_str(ConstantPool pool, int index)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n        return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n        ConstantClass cc = (ConstantClass) c;\n        return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n        throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n}","methodRange":"(line 127,col 3)-(line 139,col 3)","methodTokenRange":"public static String get_constant_str(ConstantPool pool, int index) {\n\n    Constant c = pool.getConstant(index);\n    assert c != null : \"Bad index \" + index + \" into pool\";\n    if (c instanceof ConstantUtf8) {\n      return ((ConstantUtf8) c).getBytes();\n    } else if (c instanceof ConstantClass) {\n      ConstantClass cc = (ConstantClass) c;\n      return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";\n    } else {\n      throw new Error(\"unexpected constant \" + c + \" class \" + c.getClass());\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the constant string at the specified offset.\n   * @param pool the constant pool\n   * @param index the index in the constant pool\n   * @return the constant string at the specified offset in the constant pool\n   ","methodParameters":[{"parameterType":"ConstantPool","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ConstantPool pool","parameterName":"pool"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int index","parameterName":"index"}],"methodName":"get_constant_str","methodQualifiedSignature":"plume.BCELUtil.get_constant_str","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the constant string at the specified offset.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the constant pool'}]}', name=Optional[pool]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the index in the constant pool'}]}', name=Optional[index]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the constant string at the specified offset in the constant pool'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 130,col 17)-(line 130,col 20)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 130,col 24)-(line 130,col 35)","literalExprId":2,"literalExpr":"\"Bad index \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 130,col 47)-(line 130,col 58)","literalExprId":3,"literalExpr":"\" into pool\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 135,col 34)-(line 135,col 37)","literalExprId":4,"literalExpr":"\" [\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 135,col 61)-(line 135,col 63)","literalExprId":5,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 137,col 23)-(line 137,col 44)","literalExprId":6,"literalExpr":"\"unexpected constant \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 137,col 52)-(line 137,col 60)","literalExprId":7,"literalExpr":"\" class \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to test","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[mg]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the method is a constructor","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a constructor'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean is_constructor(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n}","methodRange":"(line 145,col 3)-(line 147,col 3)","methodTokenRange":"public static boolean is_constructor(MethodGen mg) {\n    return (mg.getName().equals(\"<init>\") || mg.getName().equals(\"\"));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the method is a constructor.\n   * @param mg the method to test\n   * @return true iff the method is a constructor\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"is_constructor","methodQualifiedSignature":"plume.BCELUtil.is_constructor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the method is a constructor.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[mg]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a constructor'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 146,col 33)-(line 146,col 40)","literalExprId":1,"literalExpr":"\"<init>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 146,col 66)-(line 146,col 67)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to test","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[m]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the method is a constructor","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a constructor'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean is_constructor(Method m)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n}","methodRange":"(line 153,col 3)-(line 155,col 3)","methodTokenRange":"public static boolean is_constructor(Method m) {\n    return (m.getName().equals(\"<init>\") || m.getName().equals(\"\"));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the method is a constructor.\n   * @param m the method to test\n   * @return true iff the method is a constructor\n   ","methodParameters":[{"parameterType":"Method","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Method m","parameterName":"m"}],"methodName":"is_constructor","methodQualifiedSignature":"plume.BCELUtil.is_constructor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the method is a constructor.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[m]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a constructor'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 154,col 32)-(line 154,col 39)","literalExprId":1,"literalExpr":"\"<init>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 154,col 64)-(line 154,col 65)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to test","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[mg]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the method is a class initializer","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a class initializer'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean is_clinit(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (mg.getName().equals(\"<clinit>\"));\n}","methodRange":"(line 161,col 3)-(line 163,col 3)","methodTokenRange":"public static boolean is_clinit(MethodGen mg) {\n    return (mg.getName().equals(\"<clinit>\"));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the method is a class initializer.\n   * @param mg the method to test\n   * @return true iff the method is a class initializer\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"is_clinit","methodQualifiedSignature":"plume.BCELUtil.is_clinit","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the method is a class initializer.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[mg]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a class initializer'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 162,col 33)-(line 162,col 42)","literalExprId":1,"literalExpr":"\"<clinit>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to test","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[m]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the method is a class initializer","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a class initializer'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean is_clinit(Method m)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (m.getName().equals(\"<clinit>\"));\n}","methodRange":"(line 169,col 3)-(line 171,col 3)","methodTokenRange":"public static boolean is_clinit(Method m) {\n    return (m.getName().equals(\"<clinit>\"));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the method is a class initializer.\n   * @param m the method to test\n   * @return true iff the method is a class initializer\n   ","methodParameters":[{"parameterType":"Method","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Method m","parameterName":"m"}],"methodName":"is_clinit","methodQualifiedSignature":"plume.BCELUtil.is_clinit","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the method is a class initializer.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to test'}]}', name=Optional[m]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a class initializer'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 170,col 32)-(line 170,col 41)","literalExprId":1,"literalExpr":"\"<clinit>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class to test","javadocBlockTagName":"gen","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to test'}]}', name=Optional[gen]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the class is part of the JDK (rt.jar)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the class is part of the JDK (rt.jar)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean in_jdk(ClassGen gen)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (in_jdk(gen.getClassName()));\n}","methodRange":"(line 177,col 3)-(line 179,col 3)","methodTokenRange":"public static boolean in_jdk(ClassGen gen) {\n    return (in_jdk(gen.getClassName()));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the class is part of the JDK (rt.jar).\n   * @param gen the class to test\n   * @return true iff the class is part of the JDK (rt.jar)\n   ","methodParameters":[{"parameterType":"ClassGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ClassGen gen","parameterName":"gen"}],"methodName":"in_jdk","methodQualifiedSignature":"plume.BCELUtil.in_jdk","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the class is part of the JDK (rt.jar).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to test'}]}', name=Optional[gen]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the class is part of the JDK (rt.jar)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class to test, in the format of Class.getName();\n  the class should not be an array","javadocBlockTagName":"classname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to test, in the format of Class.getName();\n  the class should not be an array'}]}', name=Optional[classname]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the class is part of the JDK (rt.jar)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the class is part of the JDK (rt.jar)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean in_jdk(String classname)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return classname.startsWith(\"java.\") || classname.startsWith(\"com.\") || classname.startsWith(\"javax.\") || classname.startsWith(\"org.\") || classname.startsWith(\"sun.\") || classname.startsWith(\"sunw.\");\n}","methodRange":"(line 186,col 3)-(line 193,col 3)","methodTokenRange":"public static boolean in_jdk(\/*@ClassGetName*\/ String classname) {\n    return classname.startsWith(\"java.\")\n        || classname.startsWith(\"com.\")\n        || classname.startsWith(\"javax.\")\n        || classname.startsWith(\"org.\")\n        || classname.startsWith(\"sun.\")\n        || classname.startsWith(\"sunw.\");\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in the format of Class.getName();\n   *   the class should not be an array\n   * @return true iff the class is part of the JDK (rt.jar)\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classname","parameterName":"classname"}],"methodName":"in_jdk","methodQualifiedSignature":"plume.BCELUtil.in_jdk","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the class is part of the JDK (rt.jar).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to test, in the format of Class.getName();\n  the class should not be an array'}]}', name=Optional[classname]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the class is part of the JDK (rt.jar)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 187,col 33)-(line 187,col 39)","literalExprId":1,"literalExpr":"\"java.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 188,col 33)-(line 188,col 38)","literalExprId":2,"literalExpr":"\"com.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 189,col 33)-(line 189,col 40)","literalExprId":3,"literalExpr":"\"javax.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 190,col 33)-(line 190,col 38)","literalExprId":4,"literalExpr":"\"org.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 191,col 33)-(line 191,col 38)","literalExprId":5,"literalExpr":"\"sun.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 192,col 33)-(line 192,col 39)","literalExprId":6,"literalExpr":"\"sunw.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.BCELUtil.in_jdk(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class to test, in internal form","javadocBlockTagName":"classname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to test, in internal form'}]}', name=Optional[classname]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the class is part of the JDK (rt.jar)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the class is part of the JDK (rt.jar)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean in_jdk_internalform(String classname)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return classname.startsWith(\"java\/\") || classname.startsWith(\"com\/\") || classname.startsWith(\"javax\/\") || classname.startsWith(\"org\/\") || classname.startsWith(\"sun\/\") || classname.startsWith(\"sunw\/\");\n}","methodRange":"(line 199,col 3)-(line 206,col 3)","methodTokenRange":"public static boolean in_jdk_internalform(\/*@InternalForm*\/ String classname) {\n    return classname.startsWith(\"java\/\")\n        || classname.startsWith(\"com\/\")\n        || classname.startsWith(\"javax\/\")\n        || classname.startsWith(\"org\/\")\n        || classname.startsWith(\"sun\/\")\n        || classname.startsWith(\"sunw\/\");\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":" Returns whether or not the class is part of the JDK (rt.jar).\n   * @param classname the class to test, in internal form\n   * @return true iff the class is part of the JDK (rt.jar)\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classname","parameterName":"classname"}],"methodName":"in_jdk_internalform","methodQualifiedSignature":"plume.BCELUtil.in_jdk_internalform","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the class is part of the JDK (rt.jar).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to test, in internal form'}]}', name=Optional[classname]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the class is part of the JDK (rt.jar)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 200,col 33)-(line 200,col 39)","literalExprId":1,"literalExpr":"\"java\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 201,col 33)-(line 201,col 38)","literalExprId":2,"literalExpr":"\"com\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 202,col 33)-(line 202,col 40)","literalExprId":3,"literalExpr":"\"javax\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 203,col 33)-(line 203,col 38)","literalExprId":4,"literalExpr":"\"org\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 204,col 33)-(line 204,col 38)","literalExprId":5,"literalExpr":"\"sun\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 205,col 33)-(line 205,col 39)","literalExprId":6,"literalExpr":"\"sunw\/\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.BCELUtil.in_jdk_internalform(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class whose methods to print","javadocBlockTagName":"gen","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class whose methods to print'}]}', name=Optional[gen]}"}],"methodDeclaration":" static void dump_methods(ClassGen gen)","methodAccessSpecifier":"NONE","methodBody":"{\n    System.out.printf(\"Class %s methods:%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n        System.out.printf(\"  %s%n\", m);\n    }\n}","methodRange":"(line 212,col 3)-(line 218,col 3)","methodTokenRange":"static void dump_methods(ClassGen gen) {\n\n    System.out.printf(\"Class %s methods:%n\", gen.getClassName());\n    for (Method m : gen.getMethods()) {\n      System.out.printf(\"  %s%n\", m);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Print the methods in the class, to standard output.\n   * @param gen the class whose methods to print\n   ","methodParameters":[{"parameterType":"ClassGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ClassGen gen","parameterName":"gen"}],"methodName":"dump_methods","methodQualifiedSignature":"plume.BCELUtil.dump_methods","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print the methods in the class, to standard output.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class whose methods to print'}]}', name=Optional[gen]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 214,col 23)-(line 214,col 43)","literalExprId":1,"literalExpr":"\"Class %s methods:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 216,col 25)-(line 216,col 32)","literalExprId":2,"literalExpr":"\"  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class to check","javadocBlockTagName":"mgen","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to check'}]}', name=Optional[mgen]}"}],"methodDeclaration":"public static void checkMgen(MethodGen mgen)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (skip_checks) {\n        return;\n    }\n    try {\n        mgen.toString();\n        mgen.getLineNumberTable(mgen.getConstantPool());\n        InstructionList ilist = mgen.getInstructionList();\n        if (ilist == null || ilist.getStart() == null) {\n            return;\n        }\n        CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n        for (CodeExceptionGen gen : exceptionHandlers) {\n            assert ilist.contains(gen.getStartPC()) : \"exception handler \" + gen + \" has been forgotten in \" + mgen.getClassName() + \".\" + mgen.getName();\n        }\n        MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n        nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n        System.out.printf(\"failure in method %s.%s%n\", mgen.getClassName(), mgen.getName());\n        t.printStackTrace();\n        throw new Error(t);\n    }\n}","methodRange":"(line 224,col 3)-(line 255,col 3)","methodTokenRange":"public static void checkMgen(MethodGen mgen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    try {\n      mgen.toString(); \/\/ ensure it can be formatted without exceptions\n      mgen.getLineNumberTable(mgen.getConstantPool());\n\n      InstructionList ilist = mgen.getInstructionList();\n      if (ilist == null || ilist.getStart() == null) {\n        return;\n      }\n      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();\n      for (CodeExceptionGen gen : exceptionHandlers) {\n        assert ilist.contains(gen.getStartPC())\n            : \"exception handler \"\n                + gen\n                + \" has been forgotten in \"\n                + mgen.getClassName()\n                + \".\"\n                + mgen.getName();\n      }\n      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());\n      nmg.getLineNumberTable(mgen.getConstantPool());\n    } catch (Throwable t) {\n      System.out.printf(\"failure in method %s.%s%n\", mgen.getClassName(), mgen.getName());\n      t.printStackTrace();\n      throw new Error(t);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Checks the specific method for consistency.\n   * @param mgen the class to check\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mgen","parameterName":"mgen"}],"methodName":"checkMgen","methodQualifiedSignature":"plume.BCELUtil.checkMgen","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks the specific method for consistency.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to check'}]}', name=Optional[mgen]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 235,col 20)-(line 235,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 235,col 48)-(line 235,col 51)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 241,col 15)-(line 241,col 34)","literalExprId":3,"literalExpr":"\"exception handler \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 243,col 19)-(line 243,col 43)","literalExprId":4,"literalExpr":"\" has been forgotten in \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 245,col 19)-(line 245,col 21)","literalExprId":5,"literalExpr":"\".\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 251,col 25)-(line 251,col 51)","literalExprId":6,"literalExpr":"\"failure in method %s.%s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class to check","javadocBlockTagName":"gen","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to check'}]}', name=Optional[gen]}"}],"methodDeclaration":"public static void checkMgens(final ClassGen gen)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (skip_checks) {\n        return;\n    }\n    Method[] methods = gen.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n        Method method = methods[i];\n        checkMgen(new MethodGen(method, gen.getClassName(), gen.getConstantPool()));\n    }\n    if (false) {\n        Throwable t = new Throwable();\n        t.fillInStackTrace();\n        StackTraceElement[] ste = t.getStackTrace();\n        StackTraceElement caller = ste[1];\n        System.out.printf(\"%s.%s (%s line %d)\", caller.getClassName(), caller.getMethodName(), caller.getFileName(), caller.getLineNumber());\n        for (int ii = 2; ii < ste.length; ii++) {\n            System.out.printf(\" [%s line %d]\", ste[ii].getFileName(), ste[ii].getLineNumber());\n        }\n        System.out.printf(\"%n\");\n        dump_methods(gen);\n    }\n}","methodRange":"(line 261,col 3)-(line 292,col 3)","methodTokenRange":"public static void checkMgens(final ClassGen gen) {\n\n    if (skip_checks) {\n      return;\n    }\n\n    Method[] methods = gen.getMethods();\n    for (int i = 0; i < methods.length; i++) {\n      Method method = methods[i];\n      \/\/ System.out.println (\"Checking method \" + method + \" in class \"\n      \/\/ + gen.getClassName());\n      checkMgen(new MethodGen(method, gen.getClassName(), gen.getConstantPool()));\n    }\n\n    if (false) {\n      Throwable t = new Throwable();\n      t.fillInStackTrace();\n      StackTraceElement[] ste = t.getStackTrace();\n      StackTraceElement caller = ste[1];\n      System.out.printf(\n          \"%s.%s (%s line %d)\",\n          caller.getClassName(),\n          caller.getMethodName(),\n          caller.getFileName(),\n          caller.getLineNumber());\n      for (int ii = 2; ii < ste.length; ii++) {\n        System.out.printf(\" [%s line %d]\", ste[ii].getFileName(), ste[ii].getLineNumber());\n      }\n      System.out.printf(\"%n\");\n      dump_methods(gen);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Checks all of the methods in gen for consistency.\n   * @param gen the class to check\n   ","methodParameters":[{"parameterType":"ClassGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"final ClassGen gen","parameterName":"gen"}],"methodName":"checkMgens","methodQualifiedSignature":"plume.BCELUtil.checkMgens","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Checks all of the methods in gen for consistency.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to check'}]}', name=Optional[gen]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 268,col 18)-(line 268,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 275,col 9)-(line 275,col 13)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 279,col 38)-(line 279,col 38)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 281,col 11)-(line 281,col 30)","literalExprId":4,"literalExpr":"\"%s.%s (%s line %d)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 286,col 21)-(line 286,col 21)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 27)-(line 287,col 41)","literalExprId":6,"literalExpr":"\" [%s line %d]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 289,col 25)-(line 289,col 28)","literalExprId":7,"literalExpr":"\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"method to be augmented","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='method to be augmented'}]}', name=Optional[mg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"instructions to prepend to the method","javadocBlockTagName":"nl","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='instructions to prepend to the method'}]}', name=Optional[nl]}"}],"methodDeclaration":"public static void add_to_start(MethodGen mg, InstructionList nl)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    InstructionList il = mg.getInstructionList();\n    InstructionHandle old_start = il.getStart();\n    InstructionHandle new_start = il.insert(nl);\n    if (old_start.hasTargeters()) {\n        for (InstructionTargeter it : old_start.getTargeters()) {\n            if ((it instanceof LineNumberGen) || (it instanceof LocalVariableGen)) {\n                it.updateTarget(old_start, new_start);\n            }\n        }\n    }\n    mg.setMaxStack();\n    mg.setMaxLocals();\n}","methodRange":"(line 298,col 3)-(line 319,col 3)","methodTokenRange":"public static void add_to_start(MethodGen mg, InstructionList nl) {\n\n    \/\/ Add the code before the first instruction\n    InstructionList il = mg.getInstructionList();\n    InstructionHandle old_start = il.getStart();\n    InstructionHandle new_start = il.insert(nl);\n\n    \/\/ Move any LineNumbers and local variable that currently point to\n    \/\/ the first instruction to include the new instructions. Other\n    \/\/ targeters (branches, exceptions) should not include the new\n    \/\/ code\n    if (old_start.hasTargeters()) {\n      \/\/ getTargeters() returns non-null because hasTargeters => true\n      for (InstructionTargeter it : old_start.getTargeters()) {\n        if ((it instanceof LineNumberGen) || (it instanceof LocalVariableGen)) {\n          it.updateTarget(old_start, new_start);\n        }\n      }\n    }\n    mg.setMaxStack();\n    mg.setMaxLocals();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Adds code in nl to start of method mg.\n   * @param mg method to be augmented\n   * @param nl instructions to prepend to the method\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"},{"parameterType":"InstructionList","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"InstructionList nl","parameterName":"nl"}],"methodName":"add_to_start","methodQualifiedSignature":"plume.BCELUtil.add_to_start","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Adds code in nl to start of method mg.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='method to be augmented'}]}', name=Optional[mg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='instructions to prepend to the method'}]}', name=Optional[nl]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"javaclass to dump","javadocBlockTagName":"jc","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='javaclass to dump'}]}', name=Optional[jc]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"directory in which to write the file","javadocBlockTagName":"dump_dir","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='directory in which to write the file'}]}', name=Optional[dump_dir]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#dump(JavaClass, File)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#dump(JavaClass, File)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static void dump(JavaClass jc, String dump_dir)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    dump(jc, new File(dump_dir));\n}","methodRange":"(line 329,col 3)-(line 332,col 3)","methodTokenRange":"public static void dump(JavaClass jc, String dump_dir) {\n\n    dump(jc, new File(dump_dir));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir\/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   * @see #dump(JavaClass, File)\n   ","methodParameters":[{"parameterType":"JavaClass","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"JavaClass jc","parameterName":"jc"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String dump_dir","parameterName":"dump_dir"}],"methodName":"dump","methodQualifiedSignature":"plume.BCELUtil.dump","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Dumps the contents of the specified class to the specified directory.\nThe file is named dump_dir\/[class].bcel.  It contains a synopsis\nof the fields and methods followed by the jvm code for each method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='javaclass to dump'}]}', name=Optional[jc]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='directory in which to write the file'}]}', name=Optional[dump_dir]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#dump(JavaClass, File)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"javaclass to dump","javadocBlockTagName":"jc","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='javaclass to dump'}]}', name=Optional[jc]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"directory in which to write the file","javadocBlockTagName":"dump_dir","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='directory in which to write the file'}]}', name=Optional[dump_dir]}"}],"methodDeclaration":"public static void dump(JavaClass jc, File dump_dir)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        dump_dir.mkdir();\n        File path = new File(dump_dir, jc.getClassName() + \".bcel\");\n        PrintStream p = new PrintStream(path);\n        p.printf(\"class %s extends %s%n\", jc.getClassName(), jc.getSuperclassName());\n        String[] inames = jc.getInterfaceNames();\n        if ((inames != null) && (inames.length > 0)) {\n            p.printf(\"   \");\n            for (String iname : inames) {\n                p.printf(\"implements %s \", iname);\n            }\n            p.printf(\"%n\");\n        }\n        p.printf(\"%nFields%n\");\n        for (Field f : jc.getFields()) {\n            p.printf(\"  %s%n\", f);\n        }\n        p.printf(\"%nMethods%n\");\n        for (Method m : jc.getMethods()) {\n            p.printf(\"  %s%n\", m);\n        }\n        if (!jc.isInterface()) {\n            for (Method m : jc.getMethods()) {\n                p.printf(\"%nMethod %s%n\", m);\n                Code code = m.getCode();\n                if (code != null) {\n                    p.printf(\"  %s%n\", code.toString().replace(\"\\n\", \"\\n  \"));\n                }\n            }\n        }\n        p.printf(\"Constant Pool:%n\");\n        ConstantPool cp = jc.getConstantPool();\n        Constant[] constants = cp.getConstantPool();\n        for (int ii = 0; ii < constants.length; ii++) {\n            p.printf(\"  %d %s%n\", ii, constants[ii]);\n        }\n        p.close();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error dumping javaclass\", e);\n    }\n}","methodRange":"(line 342,col 3)-(line 396,col 3)","methodTokenRange":"public static void dump(JavaClass jc, File dump_dir) {\n\n    try {\n      dump_dir.mkdir();\n      File path = new File(dump_dir, jc.getClassName() + \".bcel\");\n      PrintStream p = new PrintStream(path);\n\n      \/\/ Print the class, super class and interfaces\n      p.printf(\"class %s extends %s%n\", jc.getClassName(), jc.getSuperclassName());\n      String[] inames = jc.getInterfaceNames();\n      if ((inames != null) && (inames.length > 0)) {\n        p.printf(\"   \");\n        for (String iname : inames) {\n          p.printf(\"implements %s \", iname);\n        }\n        p.printf(\"%n\");\n      }\n\n      \/\/ Print each field\n      p.printf(\"%nFields%n\");\n      for (Field f : jc.getFields()) {\n        p.printf(\"  %s%n\", f);\n      }\n\n      \/\/ Print the signature of each method\n      p.printf(\"%nMethods%n\");\n      for (Method m : jc.getMethods()) {\n        p.printf(\"  %s%n\", m);\n      }\n\n      \/\/ If this is not an interface, print the code for each method\n      if (!jc.isInterface()) {\n        for (Method m : jc.getMethods()) {\n          p.printf(\"%nMethod %s%n\", m);\n          Code code = m.getCode();\n          if (code != null) {\n            p.printf(\"  %s%n\", code.toString().replace(\"\\n\", \"\\n  \"));\n          }\n        }\n      }\n\n      \/\/ Print the details of the constant pool.\n      p.printf(\"Constant Pool:%n\");\n      ConstantPool cp = jc.getConstantPool();\n      Constant[] constants = cp.getConstantPool();\n      for (int ii = 0; ii < constants.length; ii++) {\n        p.printf(\"  %d %s%n\", ii, constants[ii]);\n      }\n\n      p.close();\n\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error dumping javaclass\", e);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Dumps the contents of the specified class to the specified directory.\n   * The file is named dump_dir\/[class].bcel.  It contains a synopsis\n   * of the fields and methods followed by the jvm code for each method.\n   *\n   * @param jc javaclass to dump\n   * @param dump_dir directory in which to write the file\n   ","methodParameters":[{"parameterType":"JavaClass","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"JavaClass jc","parameterName":"jc"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dump_dir","parameterName":"dump_dir"}],"methodName":"dump","methodQualifiedSignature":"plume.BCELUtil.dump","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Dumps the contents of the specified class to the specified directory.\nThe file is named dump_dir\/[class].bcel.  It contains a synopsis\nof the fields and methods followed by the jvm code for each method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='javaclass to dump'}]}', name=Optional[jc]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='directory in which to write the file'}]}', name=Optional[dump_dir]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 346,col 58)-(line 346,col 64)","literalExprId":1,"literalExpr":"\".bcel\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 350,col 16)-(line 350,col 38)","literalExprId":2,"literalExpr":"\"class %s extends %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 352,col 22)-(line 352,col 25)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 352,col 48)-(line 352,col 48)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 18)-(line 353,col 22)","literalExprId":5,"literalExpr":"\"   \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 355,col 20)-(line 355,col 35)","literalExprId":6,"literalExpr":"\"implements %s \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 357,col 18)-(line 357,col 21)","literalExprId":7,"literalExpr":"\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 361,col 16)-(line 361,col 27)","literalExprId":8,"literalExpr":"\"%nFields%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 363,col 18)-(line 363,col 25)","literalExprId":9,"literalExpr":"\"  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 367,col 16)-(line 367,col 28)","literalExprId":10,"literalExpr":"\"%nMethods%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 369,col 18)-(line 369,col 25)","literalExprId":11,"literalExpr":"\"  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 375,col 20)-(line 375,col 34)","literalExprId":12,"literalExpr":"\"%nMethod %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 377,col 23)-(line 377,col 26)","literalExprId":13,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 378,col 22)-(line 378,col 29)","literalExprId":14,"literalExpr":"\"  %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 378,col 56)-(line 378,col 59)","literalExprId":15,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 378,col 62)-(line 378,col 67)","literalExprId":16,"literalExpr":"\"\\n  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 384,col 16)-(line 384,col 33)","literalExprId":17,"literalExpr":"\"Constant Pool:%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 387,col 21)-(line 387,col 21)","literalExprId":18,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 388,col 18)-(line 388,col 28)","literalExprId":19,"literalExpr":"\"  %d %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 394,col 23)-(line 394,col 58)","literalExprId":20,"literalExpr":"\"Unexpected error dumping javaclass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"methodDeclaration":"public static String instruction_descr(InstructionList il, ConstantPoolGen pool)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder out = new StringBuilder();\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n        @SuppressWarnings(\"nullness\")\n        InstructionHandle handle = (InstructionHandle) i.next();\n        out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n}","methodRange":"(line 399,col 3)-(line 411,col 3)","methodTokenRange":"@SuppressWarnings(\"rawtypes\")\n  public static String instruction_descr(InstructionList il, ConstantPoolGen pool) {\n\n    StringBuilder out = new StringBuilder();\n    \/\/ not generic because BCEL is not generic\n    for (Iterator i = il.iterator(); i.hasNext(); ) {\n      @SuppressWarnings(\n          \"nullness\") \/\/ BCEL's InstructionList is raw (non-generic) but contains only non-null elements\n      \/*@NonNull*\/ InstructionHandle handle = (InstructionHandle) i.next();\n      out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");\n    }\n    return (out.toString());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" TODO: write Javadoc","methodParameters":[{"parameterType":"InstructionList","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"InstructionList il","parameterName":"il"},{"parameterType":"ConstantPoolGen","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ConstantPoolGen pool","parameterName":"pool"}],"methodName":"instruction_descr","methodQualifiedSignature":"plume.BCELUtil.instruction_descr","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 399,col 21)-(line 399,col 30)","literalExprId":1,"literalExpr":"\"rawtypes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 406,col 11)-(line 406,col 20)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 408,col 77)-(line 408,col 80)","literalExprId":3,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method whose local variables to describe","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose local variables to describe'}]}', name=Optional[mg]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a description of the local variables (one per line)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a description of the local variables (one per line)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String local_var_descr(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n        for (LocalVariableGen lvg : lvgs) {\n            out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n        }\n    }\n    return (out.toString());\n}","methodRange":"(line 418,col 3)-(line 429,col 3)","methodTokenRange":"public static String local_var_descr(MethodGen mg) {\n\n    StringBuilder out = new StringBuilder();\n    out.append(String.format(\"Locals for %s [cnt %d]%n\", mg, mg.getMaxLocals()));\n    LocalVariableGen[] lvgs = mg.getLocalVariables();\n    if ((lvgs != null) && (lvgs.length > 0)) {\n      for (LocalVariableGen lvg : lvgs) {\n        out.append(String.format(\"  %s [index %d]%n\", lvg, lvg.getIndex()));\n      }\n    }\n    return (out.toString());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a description of the local variables (one per line).\n   * @param mg the method whose local variables to describe\n   * @return a description of the local variables (one per line)\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"local_var_descr","methodQualifiedSignature":"plume.BCELUtil.local_var_descr","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a description of the local variables (one per line).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose local variables to describe'}]}', name=Optional[mg]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a description of the local variables (one per line)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 421,col 30)-(line 421,col 55)","literalExprId":1,"literalExpr":"\"Locals for %s [cnt %d]%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 423,col 18)-(line 423,col 21)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 423,col 42)-(line 423,col 42)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 34)-(line 425,col 52)","literalExprId":4,"literalExpr":"\"  %s [index %d]%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method whose line numbers to extract","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose line numbers to extract'}]}', name=Optional[mg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the instruction list to augment with line numbers","javadocBlockTagName":"il","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the instruction list to augment with line numbers'}]}', name=Optional[il]}"}],"methodDeclaration":"public static void add_line_numbers(MethodGen mg, InstructionList il)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    il.setPositions(true);\n    for (InstructionHandle ih : il.getInstructionHandles()) {\n        mg.addLineNumber(ih, 1000 + ih.getPosition());\n    }\n}","methodRange":"(line 437,col 3)-(line 443,col 3)","methodTokenRange":"public static void add_line_numbers(MethodGen mg, InstructionList il) {\n\n    il.setPositions(true);\n    for (InstructionHandle ih : il.getInstructionHandles()) {\n      mg.addLineNumber(ih, 1000 + ih.getPosition());\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Builds an array of line numbers for the specified instruction list. Each\n   * opcode is assigned the next source line number starting at 1000.\n   * @param mg the method whose line numbers to extract\n   * @param il the instruction list to augment with line numbers\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"},{"parameterType":"InstructionList","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"InstructionList il","parameterName":"il"}],"methodName":"add_line_numbers","methodQualifiedSignature":"plume.BCELUtil.add_line_numbers","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Builds an array of line numbers for the specified instruction list. Each\nopcode is assigned the next source line number starting at 1000.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose line numbers to extract'}]}', name=Optional[mg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the instruction list to augment with line numbers'}]}', name=Optional[il]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 439,col 21)-(line 439,col 24)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 441,col 28)-(line 441,col 31)","literalExprId":2,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method whose locals to set","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose locals to set'}]}', name=Optional[mg]}"}],"methodDeclaration":"public static void setup_init_locals(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Type[] arg_types = mg.getArgumentTypes();\n    String[] arg_names = mg.getArgumentNames();\n    mg.setMaxLocals(0);\n    mg.removeLocalVariables();\n    if (!mg.isStatic()) {\n        mg.addLocalVariable(\"this\", new ObjectType(mg.getClassName()), null, null);\n    }\n    for (int ii = 0; ii < arg_names.length; ii++) {\n        mg.addLocalVariable(arg_names[ii], arg_types[ii], null, null);\n    }\n    mg.setMaxLocals();\n    return;\n}","methodRange":"(line 450,col 3)-(line 476,col 3)","methodTokenRange":"@SuppressWarnings(\"nullness\")\n  public static void setup_init_locals(MethodGen mg) {\n\n    \/\/ Get the parameter types and names.\n    Type[] arg_types = mg.getArgumentTypes();\n    String[] arg_names = mg.getArgumentNames();\n\n    \/\/ Remove any existing locals\n    mg.setMaxLocals(0);\n    mg.removeLocalVariables();\n\n    \/\/ Add a local for the instance variable (this)\n    if (!mg.isStatic()) {\n      mg.addLocalVariable(\"this\", new ObjectType(mg.getClassName()), null, null);\n    }\n\n    \/\/ Add a local for each parameter\n    for (int ii = 0; ii < arg_names.length; ii++) {\n      mg.addLocalVariable(arg_names[ii], arg_types[ii], null, null);\n    }\n\n    \/\/ Reset the current number of locals so that when other locals\n    \/\/ are added they get added at the correct offset\n    mg.setMaxLocals();\n\n    return;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Sets the locals to 'this' and each of the arguments. Any other locals are\n   * removed. An instruction list with at least one instruction must exist.\n   * @param mg the method whose locals to set\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"setup_init_locals","methodQualifiedSignature":"plume.BCELUtil.setup_init_locals","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the locals to 'this' and each of the arguments. Any other locals are\nremoved. An instruction list with at least one instruction must exist.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method whose locals to set'}]}', name=Optional[mg]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 450,col 21)-(line 450,col 30)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 458,col 21)-(line 458,col 21)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 463,col 27)-(line 463,col 32)","literalExprId":3,"literalExpr":"\"this\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 463,col 70)-(line 463,col 73)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 463,col 76)-(line 463,col 79)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 467,col 19)-(line 467,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 468,col 57)-(line 468,col 60)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 468,col 63)-(line 468,col 66)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to clear out","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to clear out'}]}', name=Optional[mg]}"}],"methodDeclaration":"public static void empty_method(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    mg.setInstructionList(new InstructionList(new RETURN()));\n    mg.removeExceptionHandlers();\n    mg.removeLineNumbers();\n    mg.removeLocalVariables();\n    mg.setMaxLocals();\n}","methodRange":"(line 483,col 3)-(line 490,col 3)","methodTokenRange":"public static void empty_method(MethodGen mg) {\n\n    mg.setInstructionList(new InstructionList(new RETURN()));\n    mg.removeExceptionHandlers();\n    mg.removeLineNumbers();\n    mg.removeLocalVariables();\n    mg.setMaxLocals();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Empties the method of all code (except for a return).  This\n   * includes line numbers, exceptions, local variables, etc.\n   * @param mg the method to clear out\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"empty_method","methodQualifiedSignature":"plume.BCELUtil.empty_method","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Empties the method of all code (except for a return).  This\nincludes line numbers, exceptions, local variables, etc.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to clear out'}]}', name=Optional[mg]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to clear out","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to clear out'}]}', name=Optional[mg]}"}],"methodDeclaration":"public static void remove_local_variable_type_tables(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (Attribute a : mg.getCodeAttributes()) {\n        if (is_local_variable_type_table(a, mg.getConstantPool())) {\n            mg.removeCodeAttribute(a);\n        }\n    }\n}","methodRange":"(line 499,col 3)-(line 506,col 3)","methodTokenRange":"public static void remove_local_variable_type_tables(MethodGen mg) {\n\n    for (Attribute a : mg.getCodeAttributes()) {\n      if (is_local_variable_type_table(a, mg.getConstantPool())) {\n        mg.removeCodeAttribute(a);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Remove the local variable type table attribute (LVTT) from mg.\n   * Evidently some changes require this to be updated, but without\n   * BCEL support that would be hard to do.  It should be safe to just delete\n   * it since it is optional and really only of use to a debugger.\n   * @param mg the method to clear out\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"remove_local_variable_type_tables","methodQualifiedSignature":"plume.BCELUtil.remove_local_variable_type_tables","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Remove the local variable type table attribute (LVTT) from mg.\nEvidently some changes require this to be updated, but without\nBCEL support that would be hard to do.  It should be safe to just delete\nit since it is optional and really only of use to a debugger.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to clear out'}]}', name=Optional[mg]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the attribute","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the constant pool","javadocBlockTagName":"pool","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the constant pool'}]}', name=Optional[pool]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the attribute is a local variable type table","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the attribute is a local variable type table'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n}","methodRange":"(line 515,col 3)-(line 517,col 3)","methodTokenRange":"public static boolean is_local_variable_type_table(Attribute a, ConstantPoolGen pool) {\n    return (get_attribute_name(a, pool).equals(\"LocalVariableTypeTable\"));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns whether or not the specified attribute is a local variable type\n   * table.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return true iff the attribute is a local variable type table\n   ","methodParameters":[{"parameterType":"Attribute","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Attribute a","parameterName":"a"},{"parameterType":"ConstantPoolGen","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ConstantPoolGen pool","parameterName":"pool"}],"methodName":"is_local_variable_type_table","methodQualifiedSignature":"plume.BCELUtil.is_local_variable_type_table","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not the specified attribute is a local variable type\ntable.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the constant pool'}]}', name=Optional[pool]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the attribute is a local variable type table'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 516,col 48)-(line 516,col 71)","literalExprId":1,"literalExpr":"\"LocalVariableTypeTable\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the attribute","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the constant pool","javadocBlockTagName":"pool","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the constant pool'}]}', name=Optional[pool]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the attribute name for the specified attribute","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute name for the specified attribute'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String get_attribute_name(Attribute a, ConstantPoolGen pool)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n}","methodRange":"(line 525,col 3)-(line 531,col 3)","methodTokenRange":"public static String get_attribute_name(Attribute a, ConstantPoolGen pool) {\n\n    int con_index = a.getNameIndex();\n    Constant c = pool.getConstant(con_index);\n    String att_name = ((ConstantUtf8) c).getBytes();\n    return (att_name);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the attribute name for the specified attribute.\n   * @param a the attribute\n   * @param pool the constant pool\n   * @return the attribute name for the specified attribute\n   ","methodParameters":[{"parameterType":"Attribute","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Attribute a","parameterName":"a"},{"parameterType":"ConstantPoolGen","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"ConstantPoolGen pool","parameterName":"pool"}],"methodName":"get_attribute_name","methodQualifiedSignature":"plume.BCELUtil.get_attribute_name","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the attribute name for the specified attribute.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the constant pool'}]}', name=Optional[pool]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the attribute name for the specified attribute'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method to check","javadocBlockTagName":"mg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to check'}]}', name=Optional[mg]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the method is a main method","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a main method'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean is_main(MethodGen mg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic() && mg.getName().equals(\"main\") && (arg_types.length == 1) && arg_types[0].equals(string_array));\n}","methodRange":"(line 539,col 3)-(line 545,col 3)","methodTokenRange":"public static boolean is_main(MethodGen mg) {\n    Type[] arg_types = mg.getArgumentTypes();\n    return (mg.isStatic()\n        && mg.getName().equals(\"main\")\n        && (arg_types.length == 1)\n        && arg_types[0].equals(string_array));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns whether or not this is a standard main method (static,\n   * name is 'main', and one argument of string array).\n   * @param mg the method to check\n   * @return true iff the method is a main method\n   ","methodParameters":[{"parameterType":"MethodGen","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"MethodGen mg","parameterName":"mg"}],"methodName":"is_main","methodQualifiedSignature":"plume.BCELUtil.is_main","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not this is a standard main method (static,\nname is 'main', and one argument of string array).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method to check'}]}', name=Optional[mg]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the method is a main method'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 542,col 32)-(line 542,col 37)","literalExprId":1,"literalExpr":"\"main\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 543,col 33)-(line 543,col 33)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 544,col 22)-(line 544,col 22)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type'}]}', name=Optional[type]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the Java classname that corresponds to type","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the Java classname that corresponds to type'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String type_to_classgetname(Type type)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n}","methodRange":"(line 553,col 3)-(line 556,col 3)","methodTokenRange":"public static \/*@ClassGetName*\/ String type_to_classgetname(Type type) {\n    String signature = type.getSignature();\n    return UtilMDE.fieldDescriptorToClassGetName(signature);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the Java class name, in the format of {@link Class#getName()},\n   * that corresponds to type.\n   * @param type the type\n   * @return the Java classname that corresponds to type\n   ","methodParameters":[{"parameterType":"Type","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Type type","parameterName":"type"}],"methodName":"type_to_classgetname","methodQualifiedSignature":"plume.BCELUtil.type_to_classgetname","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the Java class name, in the format of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Class#getName()'}, JavadocSnippet{text=',\nthat corresponds to type.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type'}]}', name=Optional[type]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the Java classname that corresponds to type'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type","javadocBlockTagName":"type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type'}]}', name=Optional[type]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the Java class that corresponds to type","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the Java class that corresponds to type'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Class<?> type_to_class(Type type)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String classname = type_to_classgetname(type);\n    try {\n        Class<?> c = UtilMDE.classForName(classname);\n        return c;\n    } catch (Exception e) {\n        throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n}","methodRange":"(line 563,col 3)-(line 572,col 3)","methodTokenRange":"public static Class<?> type_to_class(Type type) {\n\n    String classname = type_to_classgetname(type);\n    try {\n      Class<?> c = UtilMDE.classForName(classname);\n      return c;\n    } catch (Exception e) {\n      throw new RuntimeException(\"can't find class for \" + classname, e);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","methodJavadocComment":"\n   * Returns the class that corresponds to type.\n   * @param type the type\n   * @return the Java class that corresponds to type\n   ","methodParameters":[{"parameterType":"Type","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Type type","parameterName":"type"}],"methodName":"type_to_class","methodQualifiedSignature":"plume.BCELUtil.type_to_class","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the class that corresponds to type.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type'}]}', name=Optional[type]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the Java class that corresponds to type'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Class<?>","methodType":"Class<?>","literalExprs":[{"literalExprRange":"(line 570,col 34)-(line 570,col 56)","literalExprId":1,"literalExpr":"\"can't find class for \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to extend","javadocBlockTagName":"types","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to extend'}]}', name=Optional[types]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the element to add to the end of the types array","javadocBlockTagName":"new_type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the element to add to the end of the types array'}]}', name=Optional[new_type]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the array (or a new one), with new_type at the end","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the array (or a new one), with new_type at the end'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Type[] add_type(Type[] types, Type new_type)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}","methodRange":"(line 580,col 3)-(line 586,col 3)","methodTokenRange":"public static Type[] add_type(Type[] types, Type new_type) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 0, types.length);\n    new_types[types.length] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * Returns a type array with new_type added to the end of types.\n   * @param types the array to extend\n   * @param new_type the element to add to the end of the types array\n   * @return the array (or a new one), with new_type at the end\n   ","methodParameters":[{"parameterType":"Type[]","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Type[] types","parameterName":"types"},{"parameterType":"Type","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Type new_type","parameterName":"new_type"}],"methodName":"add_type","methodQualifiedSignature":"plume.BCELUtil.add_type","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a type array with new_type added to the end of types.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to extend'}]}', name=Optional[types]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the element to add to the end of the types array'}]}', name=Optional[new_type]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the array (or a new one), with new_type at the end'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"Type[]","literalExprs":[{"literalExprRange":"(line 581,col 48)-(line 581,col 48)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 582,col 29)-(line 582,col 29)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 582,col 43)-(line 582,col 43)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the array to extend","javadocBlockTagName":"types","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to extend'}]}', name=Optional[types]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the element to add to the beginning of the types array","javadocBlockTagName":"new_type","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the element to add to the beginning of the types array'}]}', name=Optional[new_type]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the array (or a new one), with new_type at the beginning","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the array (or a new one), with new_type at the beginning'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Type[] insert_type(Type new_type, Type[] types)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n}","methodRange":"(line 594,col 3)-(line 600,col 3)","methodTokenRange":"public static Type[] insert_type(Type new_type, Type[] types) {\n    Type[] new_types = new Type[types.length + 1];\n    System.arraycopy(types, 0, new_types, 1, types.length);\n    new_types[0] = new_type;\n    Type[] new_types_cast = new_types;\n    return (new_types_cast);\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * Returns a type array with new_type inserted at the beginning.\n   * @param types the array to extend\n   * @param new_type the element to add to the beginning of the types array\n   * @return the array (or a new one), with new_type at the beginning\n   ","methodParameters":[{"parameterType":"Type","parameterId":1,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Type new_type","parameterName":"new_type"},{"parameterType":"Type[]","parameterId":2,"parameterTypeResolved":"","parameterTypeResolvedDescribed":"","parameter":"Type[] types","parameterName":"types"}],"methodName":"insert_type","methodQualifiedSignature":"plume.BCELUtil.insert_type","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a type array with new_type inserted at the beginning.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the array to extend'}]}', name=Optional[types]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the element to add to the beginning of the types array'}]}', name=Optional[new_type]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the array (or a new one), with new_type at the beginning'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"Type[]","literalExprs":[{"literalExprRange":"(line 595,col 48)-(line 595,col 48)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 596,col 29)-(line 596,col 29)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 596,col 43)-(line 596,col 43)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 597,col 15)-(line 597,col 15)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":""},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class to convert to a type","javadocBlockTagName":"classname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to convert to a type'}]}', name=Optional[classname]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the type corresponding to the given class name","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the type corresponding to the given class name'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Type classname_to_type(String classname)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n        classname = classname.substring(0, classname.length() - 2);\n        array_depth++;\n    }\n    classname = classname.intern();\n    Type t = null;\n    if (classname == \"int\") {\n        t = Type.INT;\n    } else if (classname == \"boolean\") {\n        t = Type.BOOLEAN;\n    } else if (classname == \"byte\") {\n        t = Type.BYTE;\n    } else if (classname == \"char\") {\n        t = Type.CHAR;\n    } else if (classname == \"double\") {\n        t = Type.DOUBLE;\n    } else if (classname == \"float\") {\n        t = Type.FLOAT;\n    } else if (classname == \"long\") {\n        t = Type.LONG;\n    } else if (classname == \"short\") {\n        t = Type.SHORT;\n    } else {\n        t = new ObjectType(classname);\n    }\n    if (array_depth > 0) {\n        t = new ArrayType(t, array_depth);\n    }\n    return t;\n}","methodRange":"(line 607,col 3)-(line 645,col 3)","methodTokenRange":"public static Type classname_to_type(String classname) {\n\n    \/\/ Get the array depth (if any)\n    int array_depth = 0;\n    while (classname.endsWith(\"[]\")) {\n      classname = classname.substring(0, classname.length() - 2);\n      array_depth++;\n    }\n    classname = classname.intern();\n\n    \/\/ Get the base type\n    Type t = null;\n    if (classname == \"int\") { \/\/ interned\n      t = Type.INT;\n    } else if (classname == \"boolean\") { \/\/ interned\n      t = Type.BOOLEAN;\n    } else if (classname == \"byte\") { \/\/ interned\n      t = Type.BYTE;\n    } else if (classname == \"char\") { \/\/ interned\n      t = Type.CHAR;\n    } else if (classname == \"double\") { \/\/ interned\n      t = Type.DOUBLE;\n    } else if (classname == \"float\") { \/\/ interned\n      t = Type.FLOAT;\n    } else if (classname == \"long\") { \/\/ interned\n      t = Type.LONG;\n    } else if (classname == \"short\") { \/\/ interned\n      t = Type.SHORT;\n    } else { \/\/ must be a non-primitive\n      t = new ObjectType(classname);\n    }\n\n    \/\/ If there was an array, build the array type\n    if (array_depth > 0) {\n      t = new ArrayType(t, array_depth);\n    }\n\n    return t;\n  }","methodReturnTypeResolved":"","methodJavadocComment":"\n   * Return the type corresponding to a given class name.\n   * @param classname the class to convert to a type\n   * @return the type corresponding to the given class name\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classname","parameterName":"classname"}],"methodName":"classname_to_type","methodQualifiedSignature":"plume.BCELUtil.classname_to_type","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the type corresponding to a given class name.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class to convert to a type'}]}', name=Optional[classname]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the type corresponding to the given class name'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"","methodType":"Type","literalExprs":[{"literalExprRange":"(line 610,col 23)-(line 610,col 23)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 611,col 31)-(line 611,col 34)","literalExprId":2,"literalExpr":"\"[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 612,col 39)-(line 612,col 39)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 612,col 63)-(line 612,col 63)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 618,col 14)-(line 618,col 17)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 619,col 22)-(line 619,col 26)","literalExprId":6,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 621,col 29)-(line 621,col 37)","literalExprId":7,"literalExpr":"\"boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 623,col 29)-(line 623,col 34)","literalExprId":8,"literalExpr":"\"byte\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 625,col 29)-(line 625,col 34)","literalExprId":9,"literalExpr":"\"char\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 627,col 29)-(line 627,col 36)","literalExprId":10,"literalExpr":"\"double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 629,col 29)-(line 629,col 35)","literalExprId":11,"literalExpr":"\"float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 631,col 29)-(line 631,col 34)","literalExprId":12,"literalExpr":"\"long\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 633,col 29)-(line 633,col 35)","literalExprId":13,"literalExpr":"\"short\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 640,col 23)-(line 640,col 23)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.BCELUtil.classname_to_type(java.lang.String)"}],"classJavadoc":"\/**\n * Static utility methods for working with BCEL.\n *\/\n","className":"BCELUtil","fields":[{"fieldRange":"(line 46,col 3)-(line 46,col 44)","fieldName":"skip_checks","fieldJavadocComment":" Controls whether the checks in checkMgen are actually performed. ","fieldTokenRange":"public static boolean skip_checks = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 46,col 39)-(line 46,col 43)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"Controls whether the checks in checkMgen are actually performed.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 49,col 3)-(line 49,col 79)","fieldName":"string_array","fieldJavadocComment":" The type that represents String[]. ","fieldTokenRange":"private static final Type string_array = Type.getType(\"[Ljava.lang.String;\");","fieldTypeResolved":"","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 49,col 57)-(line 49,col 77)","literalExprId":1,"literalExpr":"\"[Ljava.lang.String;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Type.getType(\"[Ljava.lang.String;\")]","fieldType":"Type","fieldJavadoc":"The type that represents String[].\n","fieldTypeResolvedDescribed":""}]}],"sourceFileId":34,"packageName":"plume"},{"sourceFileName":"plume.UtilMDE","imports":[{"importId":1,"import":"import java.io.BufferedInputStream;\n"},{"importId":2,"import":"import java.io.BufferedOutputStream;\n"},{"importId":3,"import":"import java.io.BufferedReader;\n"},{"importId":4,"import":"import java.io.BufferedWriter;\n"},{"importId":5,"import":"import java.io.ByteArrayOutputStream;\n"},{"importId":6,"import":"import java.io.File;\n"},{"importId":7,"import":"import java.io.FileInputStream;\n"},{"importId":8,"import":"import java.io.FileNotFoundException;\n"},{"importId":9,"import":"import java.io.FileOutputStream;\n"},{"importId":10,"import":"import java.io.FileWriter;\n"},{"importId":11,"import":"import java.io.FilenameFilter;\n"},{"importId":12,"import":"import java.io.IOException;\n"},{"importId":13,"import":"import java.io.InputStream;\n"},{"importId":14,"import":"import java.io.InputStreamReader;\n"},{"importId":15,"import":"import java.io.LineNumberReader;\n"},{"importId":16,"import":"import java.io.ObjectInputStream;\n"},{"importId":17,"import":"import java.io.ObjectOutputStream;\n"},{"importId":18,"import":"import java.io.OutputStream;\n"},{"importId":19,"import":"import java.io.OutputStreamWriter;\n"},{"importId":20,"import":"import java.io.PrintWriter;\n"},{"importId":21,"import":"import java.io.Reader;\n"},{"importId":22,"import":"import java.io.Serializable;\n"},{"importId":23,"import":"import java.io.StringWriter;\n"},{"importId":24,"import":"import java.io.Writer;\n"},{"importId":25,"import":"import java.lang.reflect.Field;\n"},{"importId":26,"import":"import java.lang.reflect.Method;\n"},{"importId":27,"import":"import java.util.ArrayList;\n"},{"importId":28,"import":"import java.util.Arrays;\n"},{"importId":29,"import":"import java.util.BitSet;\n"},{"importId":30,"import":"import java.util.Collection;\n"},{"importId":31,"import":"import java.util.Collections;\n"},{"importId":32,"import":"import java.util.Comparator;\n"},{"importId":33,"import":"import java.util.Enumeration;\n"},{"importId":34,"import":"import java.util.HashMap;\n"},{"importId":35,"import":"import java.util.HashSet;\n"},{"importId":36,"import":"import java.util.Iterator;\n"},{"importId":37,"import":"import java.util.LinkedHashSet;\n"},{"importId":38,"import":"import java.util.List;\n"},{"importId":39,"import":"import java.util.Map;\n"},{"importId":40,"import":"import java.util.NoSuchElementException;\n"},{"importId":41,"import":"import java.util.Objects;\n"},{"importId":42,"import":"import java.util.Properties;\n"},{"importId":43,"import":"import java.util.Random;\n"},{"importId":44,"import":"import java.util.Set;\n"},{"importId":45,"import":"import java.util.StringTokenizer;\n"},{"importId":46,"import":"import java.util.Vector;\n"},{"importId":47,"import":"import java.util.regex.Pattern;\n"},{"importId":48,"import":"import java.util.zip.GZIPInputStream;\n"},{"importId":49,"import":"import java.util.zip.GZIPOutputStream;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.UtilMDE.UtilMDE()","variableDeclarationExprs":[],"constructorRange":"(line 67,col 3)-(line 69,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private UtilMDE()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"UtilMDE","constructorQualifiedName":"plume.UtilMDE.UtilMDE","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 68,col 21)-(line 68,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private UtilMDE() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 764,col 3)-(line 791,col 3)","classOrInterfaceTokenRange":"private static class PromiscuousLoader extends ClassLoader {\n    \/**\n     * Converts the bytes in a file into an instance of\n     * class Class, and also resolves (links) the class.\n     * Delegates the real work to defineClass.\n     * @see ClassLoader#defineClass(String,byte[],int,int)\n     * @param className the expected binary name of the class to define, or null if not known\n     * @param pathname the file from which to load the class\n     * @return the <code>Class<\/code> object that was created\n     *\/\n    public Class<?> defineClassFromFile(\n        \/*@BinaryName*\/ String className, String pathname)\n        throws FileNotFoundException, IOException {\n      FileInputStream fi = new FileInputStream(pathname);\n      int numbytes = fi.available();\n      byte[] classBytes = new byte[numbytes];\n      int bytesRead = fi.read(classBytes);\n      fi.close();\n      if (bytesRead < numbytes) {\n        throw new Error(\n            String.format(\n                \"Expected to read %d bytes from %s, got %d\", numbytes, pathname, bytesRead));\n      }\n      Class<?> return_class = defineClass(className, classBytes, 0, numbytes);\n      resolveClass(return_class); \/\/ link the class\n      return return_class;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * This static nested class has no purpose but to define defineClassFromFile.\n   * ClassLoader.defineClass is protected, so I subclass ClassLoader in\n   * order to call defineClass.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This static nested class has no purpose but to define defineClassFromFile.\nClassLoader.defineClass is protected, so I subclass ClassLoader in\norder to call defineClass.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1066,col 3)-(line 1085,col 3)","classOrInterfaceTokenRange":"public static final class WildcardFilter implements FilenameFilter {\n    String prefix;\n    String suffix;\n\n    public WildcardFilter(String filename) {\n      int astloc = filename.indexOf(\"*\");\n      if (astloc == -1) {\n        throw new Error(\"No asterisk in wildcard argument: \" + filename);\n      }\n      prefix = filename.substring(0, astloc);\n      suffix = filename.substring(astloc + 1);\n      if (filename.indexOf(\"*\") != -1) {\n        throw new Error(\"Multiple asterisks in wildcard argument: \" + filename);\n      }\n    }\n\n    public boolean accept(File dir, String name) {\n      return name.startsWith(prefix) && name.endsWith(suffix);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * A FilenameFilter that accepts files whose name matches the given wildcard.\n   * The wildcard may contain exactly one \"*\".\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A FilenameFilter that accepts files whose name matches the given wildcard.\nThe wildcard may contain exactly one \"*\".'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1457,col 3)-(line 1475,col 3)","classOrInterfaceTokenRange":"public static final class EnumerationIterator<T> implements Iterator<T> {\n    Enumeration<T> e;\n\n    public EnumerationIterator(Enumeration<T> e) {\n      this.e = e;\n    }\n\n    public boolean hasNext() {\n      return e.hasMoreElements();\n    }\n\n    public T next() {\n      return e.nextElement();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":" Converts an Enumeration into an Iterator. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts an Enumeration into an Iterator.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1478,col 3)-(line 1492,col 3)","classOrInterfaceTokenRange":"public static final class IteratorEnumeration<T> implements Enumeration<T> {\n    Iterator<T> itor;\n\n    public IteratorEnumeration(Iterator<T> itor) {\n      this.itor = itor;\n    }\n\n    public boolean hasMoreElements() {\n      return itor.hasNext();\n    }\n\n    public T nextElement() {\n      return itor.next();\n    }\n  }","classOrInterfaceJavadocComment":" Converts an Iterator into an Enumeration. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts an Iterator into an Enumeration.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1500,col 3)-(line 1525,col 3)","classOrInterfaceTokenRange":"public static final class MergedIterator2<T> implements Iterator<T> {\n    Iterator<T> itor1, itor2;\n\n    public MergedIterator2(Iterator<T> itor1_, Iterator<T> itor2_) {\n      this.itor1 = itor1_;\n      this.itor2 = itor2_;\n    }\n\n    public boolean hasNext() {\n      return (itor1.hasNext() || itor2.hasNext());\n    }\n\n    public T next() {\n      if (itor1.hasNext()) {\n        return itor1.next();\n      } else if (itor2.hasNext()) {\n        return itor2.next();\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * An Iterator that returns first the elements returned by its first\n   * argument, then the elements returned by its second argument.\n   * Like MergedIterator, but specialized for the case of two arguments.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An Iterator that returns first the elements returned by its first\nargument, then the elements returned by its second argument.\nLike MergedIterator, but specialized for the case of two arguments.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1533,col 3)-(line 1558,col 3)","classOrInterfaceTokenRange":"public static final class MergedIterator<T> implements Iterator<T> {\n    Iterator<Iterator<T>> itorOfItors;\n\n    public MergedIterator(Iterator<Iterator<T>> itorOfItors) {\n      this.itorOfItors = itorOfItors;\n    }\n\n    \/\/ an empty iterator to prime the pump\n    Iterator<T> current = new ArrayList<T>().iterator();\n\n    public boolean hasNext() {\n      while ((!current.hasNext()) && (itorOfItors.hasNext())) {\n        current = itorOfItors.next();\n      }\n      return current.hasNext();\n    }\n\n    public T next() {\n      hasNext(); \/\/ for side effect\n      return current.next();\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * An Iterator that returns the elements in each of its argument\n   * Iterators, in turn.  The argument is an Iterator of Iterators.\n   * Like MergedIterator2, but generalized to arbitrary number of iterators.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An Iterator that returns the elements in each of its argument\nIterators, in turn.  The argument is an Iterator of Iterators.\nLike MergedIterator2, but generalized to arbitrary number of iterators.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1561,col 3)-(line 1600,col 3)","classOrInterfaceTokenRange":"@SuppressWarnings(\"assignment.type.incompatible\") \/\/ problems in DFF branch\n  public static final class FilteredIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    Filter<T> filter;\n\n    public FilteredIterator(Iterator<T> itor, Filter<T> filter) {\n      this.itor = itor;\n      this.filter = filter;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T invalid_t = (T) new Object();\n\n    T current = invalid_t;\n    boolean current_valid = false;\n\n    public boolean hasNext() {\n      while ((!current_valid) && itor.hasNext()) {\n        current = itor.next();\n        current_valid = filter.accept(current);\n      }\n      return current_valid;\n    }\n\n    public T next() {\n      if (hasNext()) {\n        current_valid = false;\n        @SuppressWarnings(\"interning\")\n        boolean ok = (current != invalid_t);\n        assert ok;\n        return current;\n      } else {\n        throw new NoSuchElementException();\n      }\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":" An iterator that only returns elements that match the given Filter. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An iterator that only returns elements that match the given Filter.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1607,col 3)-(line 1663,col 3)","classOrInterfaceTokenRange":"@SuppressWarnings(\"assignment.type.incompatible\") \/\/ problems in DFF branch\n  public static final class RemoveFirstAndLastIterator<T> implements Iterator<T> {\n    Iterator<T> itor;\n    \/\/ I don't think this works, because the iterator might itself return null\n    \/\/ \/*@Nullable*\/ T nothing = (\/*@Nullable*\/ T) null;\n    @SuppressWarnings(\"unchecked\")\n    T nothing = (T) new Object();\n\n    T first = nothing;\n    T current = nothing;\n\n    public RemoveFirstAndLastIterator(Iterator<T> itor) {\n      this.itor = itor;\n      if (itor.hasNext()) {\n        first = itor.next();\n      }\n      if (itor.hasNext()) {\n        current = itor.next();\n      }\n    }\n\n    public boolean hasNext() {\n      return itor.hasNext();\n    }\n\n    public T next() {\n      if (!itor.hasNext()) {\n        throw new NoSuchElementException();\n      }\n      T tmp = current;\n      current = itor.next();\n      return tmp;\n    }\n\n    public T getFirst() {\n      @SuppressWarnings(\"interning\") \/\/ check for equality to a special value\n      boolean invalid = (first == nothing);\n      if (invalid) {\n        throw new NoSuchElementException();\n      }\n      return first;\n    }\n\n    \/\/ Throws an error unless the RemoveFirstAndLastIterator has already\n    \/\/ been iterated all the way to its end (so the delegate is pointing to\n    \/\/ the last element).  Also, this is buggy when the delegate is empty.\n    public T getLast() {\n      if (itor.hasNext()) {\n        throw new Error();\n      }\n      return current;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Returns an iterator just like its argument, except that the first and\n   * last elements are removed.  They can be accessed via the getFirst and\n   * getLast methods.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an iterator just like its argument, except that the first and\nlast elements are removed.  They can be accessed via the getFirst and\ngetLast methods.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2672,col 3)-(line 2688,col 3)","classOrInterfaceTokenRange":"public static class NullableStringComparator implements Comparator<String>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/*@Pure*\/\n    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) {\n        return 0;\n      }\n      if (s1 == null && s2 != null) {\n        return 1;\n      }\n      if (s1 != null && s2 == null) {\n        return -1;\n      }\n      return s1.compareTo(s2);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Same as built-in String comparison, but accept null arguments,\n   * and place them at the beginning.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Same as built-in String comparison, but accept null arguments,\nand place them at the beginning.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first BitSet to intersect","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second BitSet to intersect","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the cardinality bound","javadocBlockTagName":"i","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the cardinality bound'}]}', name=Optional[i]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff size(a intersect b) &ge; i","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff size(a intersect b) &ge; i'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b) >= i);\n}","methodRange":"(line 91,col 3)-(line 115,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (BitSet)\n  \/*@Pure*\/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, int i) {\n    \/\/ Here are three implementation strategies to determine the\n    \/\/ cardinality of the intersection:\n    \/\/ 1. a.clone().and(b).cardinality()\n    \/\/ 2. do the above, but copy only a subset of the bits initially -- enough\n    \/\/    that it should exceed the given number -- and if that fails, do the\n    \/\/    whole thing.  Unfortunately, bits.get(int, int) isn't optimized\n    \/\/    for the case where the indices line up, so I'm not sure at what\n    \/\/    point this approach begins to dominate #1.\n    \/\/ 3. iterate through both sets with nextSetBit()\n\n    int size = Math.min(a.length(), b.length());\n    if (size > 10 * i) {\n      \/\/ The size is more than 10 times the limit.  So first try processing\n      \/\/ just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b) >= i);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true if the cardinality of the intersection of the two\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b) &ge; i\n   ","methodParameters":[{"parameterType":"BitSet","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet a","parameterName":"a"},{"parameterType":"BitSet","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet b","parameterName":"b"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int i","parameterName":"i"}],"methodName":"intersectionCardinalityAtLeast","methodQualifiedSignature":"plume.UtilMDE.intersectionCardinalityAtLeast","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the cardinality of the intersection of the two\nBitSets is at least the given value.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the cardinality bound'}]}', name=Optional[i]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff size(a intersect b) &ge; i'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 91,col 21)-(line 91,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 105,col 16)-(line 105,col 17)","literalExprId":2,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 35)-(line 108,col 35)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 108,col 38)-(line 108,col 38)","literalExprId":4,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 111,col 16)-(line 111,col 19)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.intersectionCardinalityAtLeast(java.util.BitSet, java.util.BitSet, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first BitSet to intersect","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second BitSet to intersect","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the third BitSet to intersect","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the third BitSet to intersect'}]}', name=Optional[c]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the cardinality bound","javadocBlockTagName":"i","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the cardinality bound'}]}', name=Optional[i]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff size(a intersect b intersect c) &ge; i","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff size(a intersect b intersect c) &ge; i'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n        BitSet intersection = a.get(0, 4 * i);\n        intersection.and(b);\n        intersection.and(c);\n        if (intersection.cardinality() >= i) {\n            return true;\n        }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n}","methodRange":"(line 126,col 3)-(line 145,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (BitSet)\n  \/*@Pure*\/\n  public static boolean intersectionCardinalityAtLeast(BitSet a, BitSet b, BitSet c, int i) {\n    \/\/ See comments in intersectionCardinalityAtLeast(BitSet, BitSet, int).\n    \/\/ This is a copy of that.\n\n    int size = Math.min(a.length(), b.length());\n    size = Math.min(size, c.length());\n    if (size > 10 * i) {\n      \/\/ The size is more than 10 times the limit.  So first try processing\n      \/\/ just a subset of the bits (4 times the limit).\n      BitSet intersection = a.get(0, 4 * i);\n      intersection.and(b);\n      intersection.and(c);\n      if (intersection.cardinality() >= i) {\n        return true;\n      }\n    }\n    return (intersectionCardinality(a, b, c) >= i);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true if the cardinality of the intersection of the three\n   * BitSets is at least the given value.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @param i the cardinality bound\n   * @return true iff size(a intersect b intersect c) &ge; i\n   ","methodParameters":[{"parameterType":"BitSet","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet a","parameterName":"a"},{"parameterType":"BitSet","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet b","parameterName":"b"},{"parameterType":"BitSet","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet c","parameterName":"c"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int i","parameterName":"i"}],"methodName":"intersectionCardinalityAtLeast","methodQualifiedSignature":"plume.UtilMDE.intersectionCardinalityAtLeast","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the cardinality of the intersection of the three\nBitSets is at least the given value.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the third BitSet to intersect'}]}', name=Optional[c]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the cardinality bound'}]}', name=Optional[i]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff size(a intersect b intersect c) &ge; i'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 126,col 21)-(line 126,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 134,col 16)-(line 134,col 17)","literalExprId":2,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 137,col 35)-(line 137,col 35)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 137,col 38)-(line 137,col 38)","literalExprId":4,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 141,col 16)-(line 141,col 19)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.intersectionCardinalityAtLeast(java.util.BitSet, java.util.BitSet, java.util.BitSet, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first BitSet to intersect","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second BitSet to intersect","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"size(a intersect b)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='size(a intersect b)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int intersectionCardinality(BitSet a, BitSet b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n}","methodRange":"(line 152,col 3)-(line 158,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (BitSet)\n  \/*@Pure*\/\n  public static int intersectionCardinality(BitSet a, BitSet b) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    return intersection.cardinality();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns the cardinality of the intersection of the two BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @return size(a intersect b)\n   ","methodParameters":[{"parameterType":"BitSet","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet a","parameterName":"a"},{"parameterType":"BitSet","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet b","parameterName":"b"}],"methodName":"intersectionCardinality","methodQualifiedSignature":"plume.UtilMDE.intersectionCardinality","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the cardinality of the intersection of the two BitSets.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='size(a intersect b)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 152,col 21)-(line 152,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.intersectionCardinality(java.util.BitSet, java.util.BitSet)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first BitSet to intersect","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second BitSet to intersect","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the third BitSet to intersect","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the third BitSet to intersect'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"size(a intersect b intersect c)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='size(a intersect b intersect c)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int intersectionCardinality(BitSet a, BitSet b, BitSet c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n}","methodRange":"(line 166,col 3)-(line 173,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (BitSet)\n  \/*@Pure*\/\n  public static int intersectionCardinality(BitSet a, BitSet b, BitSet c) {\n    BitSet intersection = (BitSet) a.clone();\n    intersection.and(b);\n    intersection.and(c);\n    return intersection.cardinality();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Returns the cardinality of the intersection of the three BitSets.\n   * @param a the first BitSet to intersect\n   * @param b the second BitSet to intersect\n   * @param c the third BitSet to intersect\n   * @return size(a intersect b intersect c)\n   ","methodParameters":[{"parameterType":"BitSet","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet a","parameterName":"a"},{"parameterType":"BitSet","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet b","parameterName":"b"},{"parameterType":"BitSet","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.BitSet","parameter":"BitSet c","parameterName":"c"}],"methodName":"intersectionCardinality","methodQualifiedSignature":"plume.UtilMDE.intersectionCardinality","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the cardinality of the intersection of the three BitSets.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first BitSet to intersect'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second BitSet to intersect'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the third BitSet to intersect'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='size(a intersect b intersect c)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 166,col 21)-(line 166,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.intersectionCardinality(java.util.BitSet, java.util.BitSet, java.util.BitSet)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an InputStream for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStream for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static InputStream fileInputStream(File file) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            in = new GZIPInputStream(new FileInputStream(file));\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        in = new FileInputStream(file);\n    }\n    return in;\n}","methodRange":"(line 194,col 3)-(line 206,col 3)","methodTokenRange":"public static InputStream fileInputStream(File file) throws IOException {\n    InputStream in;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        in = new GZIPInputStream(new FileInputStream(file));\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      in = new FileInputStream(file);\n    }\n    return in;\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns an InputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStream for file\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"fileInputStream","methodQualifiedSignature":"plume.UtilMDE.fileInputStream","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns an InputStream for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStream for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.InputStream","methodType":"InputStream","literalExprs":[{"literalExprRange":"(line 196,col 33)-(line 196,col 37)","literalExprId":1,"literalExpr":"\".gz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 200,col 31)-(line 200,col 54)","literalExprId":2,"literalExpr":"\"Problem while reading \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fileInputStream(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an InputStream for filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStream for filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file is not found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file is not found'}]}', name=Optional[FileNotFoundException]}"}],"methodDeclaration":"public static InputStreamReader fileReader(String filename) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return fileReader(new File(filename), null);\n}","methodRange":"(line 222,col 3)-(line 226,col 3)","methodTokenRange":"public static InputStreamReader fileReader(String filename)\n      throws FileNotFoundException, IOException {\n    \/\/ return fileReader(filename, \"ISO-8859-1\");\n    return fileReader(new File(filename), null);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStreamReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return an InputStream for filename\n   * @throws IOException if there is trouble reading the file\n   * @throws FileNotFoundException if the file is not found\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"methodName":"fileReader","methodQualifiedSignature":"plume.UtilMDE.fileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a Reader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStream for filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file is not found'}]}', name=Optional[FileNotFoundException]}]}","methodReturnTypeDescribed":"java.io.InputStreamReader","methodType":"InputStreamReader","literalExprs":[{"literalExprRange":"(line 225,col 43)-(line 225,col 46)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fileReader(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an InputStreamReader for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStreamReader for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return fileReader(file, null);\n}","methodRange":"(line 242,col 3)-(line 244,col 3)","methodTokenRange":"public static InputStreamReader fileReader(File file) throws FileNotFoundException, IOException {\n    return fileReader(file, null);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStreamReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"fileReader","methodQualifiedSignature":"plume.UtilMDE.fileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a Reader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStreamReader for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.InputStreamReader","methodType":"InputStreamReader","literalExprs":[{"literalExprRange":"(line 243,col 29)-(line 243,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fileReader(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"null, or the name of a Charset to use when reading the file","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='null, or the name of a Charset to use when reading the file'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an InputStreamReader for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStreamReader for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static InputStreamReader fileReader(File file, String charsetName) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n        file_reader = new InputStreamReader(in);\n    } else {\n        file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n}","methodRange":"(line 261,col 3)-(line 271,col 3)","methodTokenRange":"public static InputStreamReader fileReader(File file, \/*@Nullable*\/ String charsetName)\n      throws FileNotFoundException, IOException {\n    InputStream in = new FileInputStream(file);\n    InputStreamReader file_reader;\n    if (charsetName == null) {\n      file_reader = new InputStreamReader(in);\n    } else {\n      file_reader = new InputStreamReader(in, charsetName);\n    }\n    return file_reader;\n  }","methodReturnTypeResolved":"ReferenceType{java.io.InputStreamReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a Reader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName null, or the name of a Charset to use when reading the file\n   * @return an InputStreamReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"}],"methodName":"fileReader","methodQualifiedSignature":"plume.UtilMDE.fileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a Reader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='null, or the name of a Charset to use when reading the file'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an InputStreamReader for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.InputStreamReader","methodType":"InputStreamReader","literalExprs":[{"literalExprRange":"(line 265,col 24)-(line 265,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fileReader(java.io.File, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a BufferedReader for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static BufferedReader bufferedFileReader(String filename) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return bufferedFileReader(new File(filename));\n}","methodRange":"(line 287,col 3)-(line 290,col 3)","methodTokenRange":"public static BufferedReader bufferedFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename));\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"methodName":"bufferedFileReader","methodQualifiedSignature":"plume.UtilMDE.bufferedFileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a BufferedReader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.BufferedReader","methodType":"BufferedReader","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.bufferedFileReader(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibility-compressed file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibility-compressed file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a BufferedReader for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static BufferedReader bufferedFileReader(File file) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (bufferedFileReader(file, null));\n}","methodRange":"(line 306,col 3)-(line 309,col 3)","methodTokenRange":"public static BufferedReader bufferedFileReader(File file)\n      throws FileNotFoundException, IOException {\n    return (bufferedFileReader(file, null));\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibility-compressed file to read\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"bufferedFileReader","methodQualifiedSignature":"plume.UtilMDE.bufferedFileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a BufferedReader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibility-compressed file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.BufferedReader","methodType":"BufferedReader","literalExprs":[{"literalExprRange":"(line 308,col 38)-(line 308,col 41)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.bufferedFileReader(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the character set to use when reading the file","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use when reading the file'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a BufferedReader for filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static BufferedReader bufferedFileReader(String filename, String charsetName) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return bufferedFileReader(new File(filename), charsetName);\n}","methodRange":"(line 326,col 3)-(line 329,col 3)","methodTokenRange":"public static BufferedReader bufferedFileReader(String filename, \/*@Nullable*\/ String charsetName)\n      throws FileNotFoundException, IOException {\n    return bufferedFileReader(new File(filename), charsetName);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"}],"methodName":"bufferedFileReader","methodQualifiedSignature":"plume.UtilMDE.bufferedFileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a BufferedReader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use when reading the file'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.BufferedReader","methodType":"BufferedReader","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.bufferedFileReader(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the character set to use when reading the file","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use when reading the file'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a BufferedReader for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static BufferedReader bufferedFileReader(File file, String charsetName) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n}","methodRange":"(line 346,col 3)-(line 350,col 3)","methodTokenRange":"public static BufferedReader bufferedFileReader(File file, \/*@Nullable*\/ String charsetName)\n      throws FileNotFoundException, IOException {\n    Reader file_reader = fileReader(file, charsetName);\n    return new BufferedReader(file_reader);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a BufferedReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @param charsetName the character set to use when reading the file\n   * @return a BufferedReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"}],"methodName":"bufferedFileReader","methodQualifiedSignature":"plume.UtilMDE.bufferedFileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a BufferedReader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use when reading the file'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedReader for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.BufferedReader","methodType":"BufferedReader","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.bufferedFileReader(java.io.File, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a LineNumberReader for filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LineNumberReader for filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static LineNumberReader lineNumberFileReader(String filename) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return lineNumberFileReader(new File(filename));\n}","methodRange":"(line 366,col 3)-(line 369,col 3)","methodTokenRange":"public static LineNumberReader lineNumberFileReader(String filename)\n      throws FileNotFoundException, IOException {\n    return lineNumberFileReader(new File(filename));\n  }","methodReturnTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to read\n   * @return a LineNumberReader for filename\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"methodName":"lineNumberFileReader","methodQualifiedSignature":"plume.UtilMDE.lineNumberFileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a LineNumberReader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[filename]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LineNumberReader for filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.LineNumberReader","methodType":"LineNumberReader","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.lineNumberFileReader(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a LineNumberReader for file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LineNumberReader for file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the file cannot be found","javadocBlockTagName":"FileNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static LineNumberReader lineNumberFileReader(File file) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            file_reader = new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    } else {\n        file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n}","methodRange":"(line 385,col 3)-(line 399,col 3)","methodTokenRange":"public static LineNumberReader lineNumberFileReader(File file)\n      throws FileNotFoundException, IOException {\n    Reader file_reader;\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        file_reader =\n            new InputStreamReader(new GZIPInputStream(new FileInputStream(file)), \"ISO-8859-1\");\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    } else {\n      file_reader = new InputStreamReader(new FileInputStream(file), \"ISO-8859-1\");\n    }\n    return new LineNumberReader(file_reader);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.LineNumberReader, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a LineNumberReader for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param file the possibly-compressed file to read\n   * @return a LineNumberReader for file\n   * @throws FileNotFoundException if the file cannot be found\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"lineNumberFileReader","methodQualifiedSignature":"plume.UtilMDE.lineNumberFileReader","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a LineNumberReader for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LineNumberReader for file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the file cannot be found'}]}', name=Optional[FileNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.LineNumberReader","methodType":"LineNumberReader","literalExprs":[{"literalExprRange":"(line 388,col 33)-(line 388,col 37)","literalExprId":1,"literalExpr":"\".gz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 391,col 83)-(line 391,col 94)","literalExprId":2,"literalExpr":"\"ISO-8859-1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 393,col 31)-(line 393,col 54)","literalExprId":3,"literalExpr":"\"Problem while reading \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 396,col 70)-(line 396,col 81)","literalExprId":4,"literalExpr":"\"ISO-8859-1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.lineNumberFileReader(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to write","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to write'}]}', name=Optional[filename]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a BufferedWriter for filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedWriter for filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble writing the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble writing the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static BufferedWriter bufferedFileWriter(String filename) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return bufferedFileWriter(filename, false);\n}","methodRange":"(line 414,col 3)-(line 416,col 3)","methodTokenRange":"public static BufferedWriter bufferedFileWriter(String filename) throws IOException {\n    return bufferedFileWriter(filename, false);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedWriter, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a BufferedWriter for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @return a BufferedWriter for filename\n   * @throws IOException if there is trouble writing the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"methodName":"bufferedFileWriter","methodQualifiedSignature":"plume.UtilMDE.bufferedFileWriter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a BufferedWriter for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to write'}]}', name=Optional[filename]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedWriter for filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble writing the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.BufferedWriter","methodType":"BufferedWriter","literalExprs":[{"literalExprRange":"(line 415,col 41)-(line 415,col 45)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.bufferedFileWriter(java.lang.String)"},{"methodDeclaration":"public static BufferedWriter bufferedFileWriter(String filename, boolean append) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n        file_writer = new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n        file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n}","methodRange":"(line 434,col 3)-(line 444,col 3)","methodTokenRange":"public static BufferedWriter bufferedFileWriter(String filename, boolean append)\n      throws IOException {\n    Writer file_writer;\n    if (filename.endsWith(\".gz\")) {\n      file_writer =\n          new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(filename, append)));\n    } else {\n      file_writer = new FileWriter(filename, append);\n    }\n    return new BufferedWriter(file_writer);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedWriter, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Question:  should this be rewritten as a wrapper around bufferedFileOutputStream?","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean append","parameterName":"append"}],"methodName":"bufferedFileWriter","methodQualifiedSignature":"plume.UtilMDE.bufferedFileWriter","methodJavadoc":"","methodReturnTypeDescribed":"java.io.BufferedWriter","methodType":"BufferedWriter","literalExprs":[{"literalExprRange":"(line 437,col 27)-(line 437,col 31)","literalExprId":1,"literalExpr":"\".gz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.bufferedFileWriter(java.lang.String, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-compressed file to write","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to write'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, the resulting BufferedOutputStream appends to the end\nof the file instead of the beginning","javadocBlockTagName":"append","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the resulting BufferedOutputStream appends to the end\nof the file instead of the beginning'}]}', name=Optional[append]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a BufferedOutputStream for filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedOutputStream for filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble writing the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble writing the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n        os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n}","methodRange":"(line 461,col 3)-(line 468,col 3)","methodTokenRange":"public static BufferedOutputStream bufferedFileOutputStream(String filename, boolean append)\n      throws IOException {\n    OutputStream os = new FileOutputStream(filename, append);\n    if (filename.endsWith(\".gz\")) {\n      os = new GZIPOutputStream(os);\n    }\n    return new BufferedOutputStream(os);\n  }","methodReturnTypeResolved":"ReferenceType{java.io.BufferedOutputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a BufferedOutputStream for the file, accounting for the possibility\n   * that the file is compressed.\n   * (A file whose name ends with \".gz\" is treated as compressed.)\n   * <p>\n   * Warning: The \"gzip\" program writes and reads files containing\n   * concatenated gzip files.  As of Java 1.4, Java reads\n   * just the first one:  it silently discards all characters (including\n   * gzipped files) after the first gzipped file.\n   * @param filename the possibly-compressed file to write\n   * @param append if true, the resulting BufferedOutputStream appends to the end\n   * of the file instead of the beginning\n   * @return a BufferedOutputStream for filename\n   * @throws IOException if there is trouble writing the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean append","parameterName":"append"}],"methodName":"bufferedFileOutputStream","methodQualifiedSignature":"plume.UtilMDE.bufferedFileOutputStream","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a BufferedOutputStream for the file, accounting for the possibility\nthat the file is compressed.\n(A file whose name ends with \".gz\" is treated as compressed.)\n<p>\nWarning: The \"gzip\" program writes and reads files containing\nconcatenated gzip files.  As of Java 1.4, Java reads\njust the first one:  it silently discards all characters (including\ngzipped files) after the first gzipped file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-compressed file to write'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, the resulting BufferedOutputStream appends to the end\nof the file instead of the beginning'}]}', name=Optional[append]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a BufferedOutputStream for filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble writing the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.io.BufferedOutputStream","methodType":"BufferedOutputStream","literalExprs":[{"literalExprRange":"(line 464,col 27)-(line 464,col 31)","literalExprId":1,"literalExpr":"\".gz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.bufferedFileOutputStream(java.lang.String, boolean)"},{"methodDeclaration":"public static boolean isSubtype(Class<?> sub, Class<?> sup)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (sub == sup) {\n        return true;\n    }\n    Class<?> parent = sub.getSuperclass();\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n        return true;\n    }\n    for (Class<?> ifc : sub.getInterfaces()) {\n        if (ifc == sup || isSubtype(ifc, sup)) {\n            return true;\n        }\n    }\n    return false;\n}","methodRange":"(line 483,col 3)-(line 503,col 3)","methodTokenRange":"public static boolean isSubtype(Class<?> sub, Class<?> sup) {\n    if (sub == sup) {\n      return true;\n    }\n\n    \/\/ Handle superclasses\n    Class<?> parent = sub.getSuperclass();\n    \/\/ If parent == null, sub == Object\n    if ((parent != null) && (parent == sup || isSubtype(parent, sup))) {\n      return true;\n    }\n\n    \/\/ Handle interfaces\n    for (Class<?> ifc : sub.getInterfaces()) {\n      if (ifc == sup || isSubtype(ifc, sup)) {\n        return true;\n      }\n    }\n\n    return false;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Class<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.lang.Class<?>","parameter":"Class<?> sub","parameterName":"sub"},{"parameterType":"Class<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.lang.Class<?>","parameter":"Class<?> sup","parameterName":"sup"}],"methodName":"isSubtype","methodQualifiedSignature":"plume.UtilMDE.isSubtype","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 485,col 14)-(line 485,col 17)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 491,col 20)-(line 491,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 492,col 14)-(line 492,col 17)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 498,col 16)-(line 498,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 502,col 12)-(line 502,col 16)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.isSubtype(java.lang.Class<?>, java.lang.Class<?>)"},{"methodDeclaration":"public static Class<?> classForName(String className) throws ClassNotFoundException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            return Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            int pos = className.lastIndexOf('.');\n            if (pos < 0) {\n                throw e;\n            }\n            @SuppressWarnings(\"signature\")\n            String inner_name = className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n            try {\n                return Class.forName(inner_name);\n            } catch (ClassNotFoundException ee) {\n                throw e;\n            }\n        }\n    }\n}","methodRange":"(line 537,col 3)-(line 560,col 3)","methodTokenRange":"public static Class<?> classForName(\n      \/*@ClassGetName*\/ String className) throws ClassNotFoundException {\n    Class<?> result = primitiveClasses.get(className);\n    if (result != null) {\n      return result;\n    } else {\n      try {\n        return Class.forName(className);\n      } catch (ClassNotFoundException e) {\n        int pos = className.lastIndexOf('.');\n        if (pos < 0) {\n          throw e;\n        }\n        @SuppressWarnings(\"signature\") \/\/ checked below & exception is handled\n        \/*@ClassGetName*\/ String inner_name =\n            className.substring(0, pos) + \"$\" + className.substring(pos + 1);\n        try {\n          return Class.forName(inner_name);\n        } catch (ClassNotFoundException ee) {\n          throw e;\n        }\n      }\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","methodJavadocComment":" fully-qualified name (only for a non-array).","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String className","parameterName":"className"}],"methodName":"classForName","methodQualifiedSignature":"plume.UtilMDE.classForName","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Class<?>","methodType":"Class<?>","literalExprs":[{"literalExprRange":"(line 540,col 19)-(line 540,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 546,col 41)-(line 546,col 43)","literalExprId":2,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 547,col 19)-(line 547,col 19)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 550,col 27)-(line 550,col 37)","literalExprId":4,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 552,col 33)-(line 552,col 33)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 552,col 43)-(line 552,col 45)","literalExprId":6,"literalExpr":"\"$\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 552,col 75)-(line 552,col 75)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.classForName(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the class, in binary class name format","javadocBlockTagName":"classname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the class, in binary class name format'}]}', name=Optional[classname]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"name of the class, in field descriptor format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='name of the class, in field descriptor format'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String binaryNameToFieldDescriptor(String classname)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n        dims++;\n        sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n        result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n        result = \"[\" + result;\n    }\n    return result.replace('.', '\/');\n}","methodRange":"(line 584,col 3)-(line 601,col 3)","methodTokenRange":"@SuppressWarnings(\"signature\") \/\/ conversion routine\n  public static \/*@FieldDescriptor*\/ String binaryNameToFieldDescriptor(\n      \/*@BinaryName*\/ String classname) {\n    int dims = 0;\n    String sans_array = classname;\n    while (sans_array.endsWith(\"[]\")) {\n      dims++;\n      sans_array = sans_array.substring(0, sans_array.length() - 2);\n    }\n    String result = primitiveClassesJvm.get(sans_array);\n    if (result == null) {\n      result = \"L\" + sans_array + \";\";\n    }\n    for (int i = 0; i < dims; i++) {\n      result = \"[\" + result;\n    }\n    return result.replace('.', '\/');\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convert a binary name to a field descriptor.\n   * For example, convert \"java.lang.Object[]\" to \"[Ljava\/lang\/Object;\"\n   * or \"int\" to \"I\".\n   * @param classname name of the class, in binary class name format\n   * @return name of the class, in field descriptor format\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classname","parameterName":"classname"}],"methodName":"binaryNameToFieldDescriptor","methodQualifiedSignature":"plume.UtilMDE.binaryNameToFieldDescriptor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert a binary name to a field descriptor.\nFor example, convert \"java.lang.Object[]\" to \"[Ljava\/lang\/Object;\"\nor \"int\" to \"I\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the class, in binary class name format'}]}', name=Optional[classname]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='name of the class, in field descriptor format'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 584,col 21)-(line 584,col 31)","literalExprId":1,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 587,col 16)-(line 587,col 16)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 589,col 32)-(line 589,col 35)","literalExprId":3,"literalExpr":"\"[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 591,col 41)-(line 591,col 41)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 591,col 66)-(line 591,col 66)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 594,col 19)-(line 594,col 22)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 595,col 16)-(line 595,col 18)","literalExprId":7,"literalExpr":"\"L\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 595,col 35)-(line 595,col 37)","literalExprId":8,"literalExpr":"\";\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 597,col 18)-(line 597,col 18)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 598,col 16)-(line 598,col 18)","literalExprId":10,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 600,col 27)-(line 600,col 29)","literalExprId":11,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 600,col 32)-(line 600,col 34)","literalExprId":12,"literalExpr":"'\/'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.binaryNameToFieldDescriptor(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the type, in Java format","javadocBlockTagName":"primitive_name","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in Java format'}]}', name=Optional[primitive_name]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"name of the type, in field descriptor format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in field descriptor format'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if primitive_name is not a valid primitive type name.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if primitive_name is not a valid primitive type name.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":"public static String primitiveTypeNameToFieldDescriptor(String primitive_name)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n        throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n}","methodRange":"(line 610,col 3)-(line 617,col 3)","methodTokenRange":"public static \/*@FieldDescriptor*\/ String primitiveTypeNameToFieldDescriptor(\n      String primitive_name) {\n    String result = primitiveClassesJvm.get(primitive_name);\n    if (result == null) {\n      throw new IllegalArgumentException(\"Not the name of a primitive type: \" + primitive_name);\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\n   * a field descriptor (e.g., \"I\", \"D\", etc.).\n   * @param primitive_name name of the type, in Java format\n   * @return name of the type, in field descriptor format\n   * @throws IllegalArgumentException if primitive_name is not a valid primitive type name.\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String primitive_name","parameterName":"primitive_name"}],"methodName":"primitiveTypeNameToFieldDescriptor","methodQualifiedSignature":"plume.UtilMDE.primitiveTypeNameToFieldDescriptor","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert a primitive java type name (e.g., \"int\", \"double\", etc.) to\na field descriptor (e.g., \"I\", \"D\", etc.).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in Java format'}]}', name=Optional[primitive_name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in field descriptor format'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if primitive_name is not a valid primitive type name.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 613,col 19)-(line 613,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 614,col 42)-(line 614,col 77)","literalExprId":2,"literalExpr":"\"Not the name of a primitive type: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.primitiveTypeNameToFieldDescriptor(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the binary name to convert","javadocBlockTagName":"bn","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the binary name to convert'}]}', name=Optional[bn]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the class name, in Class.getName format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the class name, in Class.getName format'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String binaryNameToClassGetName(String bn)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (bn.endsWith(\"[]\")) {\n        return binaryNameToFieldDescriptor(bn).replace('\/', '.');\n    } else {\n        return bn;\n    }\n}","methodRange":"(line 623,col 3)-(line 630,col 3)","methodTokenRange":"@SuppressWarnings(\"signature\") \/\/ conversion routine\n  public static \/*@ClassGetName*\/ String binaryNameToClassGetName(\/*BinaryName*\/ String bn) {\n    if (bn.endsWith(\"[]\")) {\n      return binaryNameToFieldDescriptor(bn).replace('\/', '.');\n    } else {\n      return bn;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Convert from a BinaryName to the format of {@link Class#getName()}.\n   * @param bn the binary name to convert\n   * @return the class name, in Class.getName format\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String bn","parameterName":"bn"}],"methodName":"binaryNameToClassGetName","methodQualifiedSignature":"plume.UtilMDE.binaryNameToClassGetName","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert from a BinaryName to the format of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Class#getName()'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the binary name to convert'}]}', name=Optional[bn]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the class name, in Class.getName format'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 623,col 21)-(line 623,col 31)","literalExprId":1,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 625,col 21)-(line 625,col 24)","literalExprId":2,"literalExpr":"\"[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 626,col 54)-(line 626,col 56)","literalExprId":3,"literalExpr":"'\/'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 626,col 59)-(line 626,col 61)","literalExprId":4,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.binaryNameToClassGetName(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the class, in field descriptor format","javadocBlockTagName":"fd","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class, in field descriptor format'}]}', name=Optional[fd]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the class name, in Class.getName format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the class name, in Class.getName format'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String fieldDescriptorToClassGetName(String fd)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (fd.startsWith(\"[\")) {\n        return fd.replace('\/', '.');\n    } else {\n        return fieldDescriptorToBinaryName(fd);\n    }\n}","methodRange":"(line 636,col 3)-(line 644,col 3)","methodTokenRange":"@SuppressWarnings(\"signature\") \/\/ conversion routine\n  public static \/*@ClassGetName*\/ String fieldDescriptorToClassGetName(\n      \/*FieldDescriptor*\/ String fd) {\n    if (fd.startsWith(\"[\")) {\n      return fd.replace('\/', '.');\n    } else {\n      return fieldDescriptorToBinaryName(fd);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Convert from a FieldDescriptor to the format of {@link Class#getName()}.\n   * @param fd the class, in field descriptor format\n   * @return the class name, in Class.getName format\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fd","parameterName":"fd"}],"methodName":"fieldDescriptorToClassGetName","methodQualifiedSignature":"plume.UtilMDE.fieldDescriptorToClassGetName","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert from a FieldDescriptor to the format of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Class#getName()'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the class, in field descriptor format'}]}', name=Optional[fd]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the class name, in Class.getName format'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 636,col 21)-(line 636,col 31)","literalExprId":1,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 639,col 23)-(line 639,col 25)","literalExprId":2,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 640,col 25)-(line 640,col 27)","literalExprId":3,"literalExpr":"'\/'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 640,col 30)-(line 640,col 32)","literalExprId":4,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fieldDescriptorToClassGetName(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an argument list, in Java format","javadocBlockTagName":"arglist","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an argument list, in Java format'}]}', name=Optional[arglist]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"argument list, in JVML format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='argument list, in JVML format'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String arglistToJvm(String arglist)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n        @SuppressWarnings(\"signature\")\n        String arg = args_tokenizer.nextToken().trim();\n        result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    return result;\n}","methodRange":"(line 653,col 3)-(line 668,col 3)","methodTokenRange":"public static String arglistToJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    String comma_sep_args = arglist.substring(1, arglist.length() - 1);\n    StringTokenizer args_tokenizer = new StringTokenizer(comma_sep_args, \",\", false);\n    while (args_tokenizer.hasMoreTokens()) {\n      @SuppressWarnings(\"signature\") \/\/ substring\n      \/*@BinaryName*\/ String arg = args_tokenizer.nextToken().trim();\n      result += binaryNameToFieldDescriptor(arg);\n    }\n    result += \")\";\n    \/\/ System.out.println(\"arglistToJvm: \" + arglist + \" => \" + result);\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convert a fully-qualified argument list from Java format to JVML format.\n   * For example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\n   * to \"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\".\n   * @param arglist an argument list, in Java format\n   * @return argument list, in JVML format\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arglist","parameterName":"arglist"}],"methodName":"arglistToJvm","methodQualifiedSignature":"plume.UtilMDE.arglistToJvm","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert a fully-qualified argument list from Java format to JVML format.\nFor example, convert \"(java.lang.Integer[], int, java.lang.Integer[][])\"\nto \"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an argument list, in Java format'}]}', name=Optional[arglist]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='argument list, in JVML format'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 654,col 30)-(line 654,col 32)","literalExprId":1,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 654,col 55)-(line 654,col 57)","literalExprId":2,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 655,col 23)-(line 655,col 43)","literalExprId":3,"literalExpr":"\"Malformed arglist: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 657,col 21)-(line 657,col 23)","literalExprId":4,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 658,col 47)-(line 658,col 47)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 658,col 69)-(line 658,col 69)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 659,col 74)-(line 659,col 76)","literalExprId":7,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 659,col 79)-(line 659,col 83)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 661,col 25)-(line 661,col 35)","literalExprId":9,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 665,col 15)-(line 665,col 17)","literalExprId":10,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.arglistToJvm(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the type, in JVML format","javadocBlockTagName":"classname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in JVML format'}]}', name=Optional[classname]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"name of the type, in Java format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in Java format'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String fieldDescriptorToBinaryName(String classname)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (classname.equals(\"\")) {\n        throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n        dims++;\n        classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n        result = classname.substring(1, classname.length() - 1);\n    } else {\n        result = primitiveClassesFromJvm.get(classname);\n        if (result == null) {\n            throw new Error(\"Malformed base class: \" + classname);\n        }\n    }\n    for (int i = 0; i < dims; i++) {\n        result += \"[]\";\n    }\n    return result.replace('\/', '.');\n}","methodRange":"(line 691,col 3)-(line 714,col 3)","methodTokenRange":"@SuppressWarnings(\"signature\") \/\/ conversion routine\n  public static \/*@BinaryName*\/ String fieldDescriptorToBinaryName(String classname) {\n    if (classname.equals(\"\")) {\n      throw new Error(\"Empty string passed to fieldDescriptorToBinaryName\");\n    }\n    int dims = 0;\n    while (classname.startsWith(\"[\")) {\n      dims++;\n      classname = classname.substring(1);\n    }\n    String result;\n    if (classname.startsWith(\"L\") && classname.endsWith(\";\")) {\n      result = classname.substring(1, classname.length() - 1);\n    } else {\n      result = primitiveClassesFromJvm.get(classname);\n      if (result == null) {\n        throw new Error(\"Malformed base class: \" + classname);\n      }\n    }\n    for (int i = 0; i < dims; i++) {\n      result += \"[]\";\n    }\n    return result.replace('\/', '.');\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convert a field descriptor to a binary name.\n   * For example, convert \"[Ljava\/lang\/Object;\" to \"java.lang.Object[]\"\n   * or \"I\" to \"int\".\n   * @param classname name of the type, in JVML format\n   * @return name of the type, in Java format\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classname","parameterName":"classname"}],"methodName":"fieldDescriptorToBinaryName","methodQualifiedSignature":"plume.UtilMDE.fieldDescriptorToBinaryName","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert a field descriptor to a binary name.\nFor example, convert \"[Ljava\/lang\/Object;\" to \"java.lang.Object[]\"\nor \"I\" to \"int\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in JVML format'}]}', name=Optional[classname]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='name of the type, in Java format'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 691,col 21)-(line 691,col 31)","literalExprId":1,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 693,col 26)-(line 693,col 27)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 694,col 23)-(line 694,col 74)","literalExprId":3,"literalExpr":"\"Empty string passed to fieldDescriptorToBinaryName\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 696,col 16)-(line 696,col 16)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 697,col 33)-(line 697,col 35)","literalExprId":5,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 699,col 39)-(line 699,col 39)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 702,col 30)-(line 702,col 32)","literalExprId":7,"literalExpr":"\"L\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 702,col 57)-(line 702,col 59)","literalExprId":8,"literalExpr":"\";\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 703,col 36)-(line 703,col 36)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 703,col 60)-(line 703,col 60)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 706,col 21)-(line 706,col 24)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 707,col 25)-(line 707,col 48)","literalExprId":12,"literalExpr":"\"Malformed base class: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 710,col 18)-(line 710,col 18)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 711,col 17)-(line 711,col 20)","literalExprId":14,"literalExpr":"\"[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 713,col 27)-(line 713,col 29)","literalExprId":15,"literalExpr":"'\/'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 713,col 32)-(line 713,col 34)","literalExprId":16,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fieldDescriptorToBinaryName(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an argument list, in JVML format","javadocBlockTagName":"arglist","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an argument list, in JVML format'}]}', name=Optional[arglist]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"argument list, in Java format","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='argument list, in Java format'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String arglistFromJvm(String arglist)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n        throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n        if (pos > 1) {\n            result += \", \";\n        }\n        int nonarray_pos = pos;\n        while (arglist.charAt(nonarray_pos) == '[') {\n            nonarray_pos++;\n        }\n        char c = arglist.charAt(nonarray_pos);\n        if (c == 'L') {\n            int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n            result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n            pos = semi_pos + 1;\n        } else {\n            String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n            if (maybe == null) {\n                throw new Error(\"Malformed arglist: \" + arglist);\n            }\n            result += maybe;\n            pos = nonarray_pos + 1;\n        }\n    }\n    return result + \")\";\n}","methodRange":"(line 723,col 3)-(line 753,col 3)","methodTokenRange":"public static String arglistFromJvm(String arglist) {\n    if (!(arglist.startsWith(\"(\") && arglist.endsWith(\")\"))) {\n      throw new Error(\"Malformed arglist: \" + arglist);\n    }\n    String result = \"(\";\n    int pos = 1;\n    while (pos < arglist.length() - 1) {\n      if (pos > 1) {\n        result += \", \";\n      }\n      int nonarray_pos = pos;\n      while (arglist.charAt(nonarray_pos) == '[') {\n        nonarray_pos++;\n      }\n      char c = arglist.charAt(nonarray_pos);\n      if (c == 'L') {\n        int semi_pos = arglist.indexOf(\";\", nonarray_pos);\n        result += fieldDescriptorToBinaryName(arglist.substring(pos, semi_pos + 1));\n        pos = semi_pos + 1;\n      } else {\n        String maybe = fieldDescriptorToBinaryName(arglist.substring(pos, nonarray_pos + 1));\n        if (maybe == null) {\n          \/\/ return null;\n          throw new Error(\"Malformed arglist: \" + arglist);\n        }\n        result += maybe;\n        pos = nonarray_pos + 1;\n      }\n    }\n    return result + \")\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convert an argument list from JVML format to Java format.\n   * For example, convert \"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\"\n   * to \"(java.lang.Integer[], int, java.lang.Integer[][])\".\n   * @param arglist an argument list, in JVML format\n   * @return argument list, in Java format\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arglist","parameterName":"arglist"}],"methodName":"arglistFromJvm","methodQualifiedSignature":"plume.UtilMDE.arglistFromJvm","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert an argument list from JVML format to Java format.\nFor example, convert \"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\"\nto \"(java.lang.Integer[], int, java.lang.Integer[][])\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an argument list, in JVML format'}]}', name=Optional[arglist]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='argument list, in Java format'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 724,col 30)-(line 724,col 32)","literalExprId":1,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 724,col 55)-(line 724,col 57)","literalExprId":2,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 725,col 23)-(line 725,col 43)","literalExprId":3,"literalExpr":"\"Malformed arglist: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 727,col 21)-(line 727,col 23)","literalExprId":4,"literalExpr":"\"(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 728,col 15)-(line 728,col 15)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 729,col 37)-(line 729,col 37)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 730,col 17)-(line 730,col 17)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 731,col 19)-(line 731,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 734,col 46)-(line 734,col 48)","literalExprId":9,"literalExpr":"'['","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 738,col 16)-(line 738,col 18)","literalExprId":10,"literalExpr":"'L'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 739,col 40)-(line 739,col 42)","literalExprId":11,"literalExpr":"\";\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 740,col 81)-(line 740,col 81)","literalExprId":12,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 741,col 26)-(line 741,col 26)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 743,col 90)-(line 743,col 90)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 744,col 22)-(line 744,col 25)","literalExprId":15,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 746,col 27)-(line 746,col 47)","literalExprId":16,"literalExpr":"\"Malformed arglist: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 749,col 30)-(line 749,col 30)","literalExprId":17,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 752,col 21)-(line 752,col 23)","literalExprId":18,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.arglistFromJvm(java.lang.String)"},{"methodDeclaration":"public static Class<?> defineClassFromFile(String className, String pathname) throws FileNotFoundException, IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n}","methodRange":"(line 809,col 3)-(line 812,col 3)","methodTokenRange":"public static Class<?> defineClassFromFile(\n      \/*@BinaryName*\/ String className, String pathname) throws FileNotFoundException, IOException {\n    return thePromiscuousLoader.defineClassFromFile(className, pathname);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","methodJavadocComment":" Also throws UnsupportedClassVersionError and some other exceptions.","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String className","parameterName":"className"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String pathname","parameterName":"pathname"}],"methodName":"defineClassFromFile","methodQualifiedSignature":"plume.UtilMDE.defineClassFromFile","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Class<?>","methodType":"Class<?>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.defineClassFromFile(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"directory to add to the system classpath","javadocBlockTagName":"dir","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='directory to add to the system classpath'}]}', name=Optional[dir]}"}],"methodDeclaration":"public static void addToClasspath(String dir)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String pathSep = System.getProperty(\"path.separator\");\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '\/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n        found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n        System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n}","methodRange":"(line 822,col 3)-(line 835,col 3)","methodTokenRange":"public static void addToClasspath(String dir) {\n    \/\/ If the dir isn't on CLASSPATH, add it.\n    String pathSep = System.getProperty(\"path.separator\");\n    \/\/ what is the point of the \"replace()\" call?\n    String cp = System.getProperty(\"java.class.path\", \".\").replace('\\\\', '\/');\n    StringTokenizer tokenizer = new StringTokenizer(cp, pathSep, false);\n    boolean found = false;\n    while (tokenizer.hasMoreTokens() && !found) {\n      found = tokenizer.nextToken().equals(dir);\n    }\n    if (!found) {\n      System.setProperty(\"java.class.path\", dir + pathSep + cp);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Add the directory to the system classpath.\n   * @param dir directory to add to the system classpath\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String dir","parameterName":"dir"}],"methodName":"addToClasspath","methodQualifiedSignature":"plume.UtilMDE.addToClasspath","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Add the directory to the system classpath.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='directory to add to the system classpath'}]}', name=Optional[dir]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 824,col 41)-(line 824,col 56)","literalExprId":1,"literalExpr":"\"path.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 826,col 36)-(line 826,col 52)","literalExprId":2,"literalExpr":"\"java.class.path\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 826,col 55)-(line 826,col 57)","literalExprId":3,"literalExpr":"\".\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 826,col 68)-(line 826,col 71)","literalExprId":4,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 826,col 74)-(line 826,col 76)","literalExprId":5,"literalExpr":"'\/'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 827,col 66)-(line 827,col 70)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 828,col 21)-(line 828,col 25)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 833,col 26)-(line 833,col 42)","literalExprId":8,"literalExpr":"\"java.class.path\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.addToClasspath(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"file whose size to count","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file whose size to count'}]}', name=Optional[filename]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of lines in filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of lines in filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static long count_lines(String filename) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n        while (reader.readLine() != null) {\n            count++;\n        }\n    }\n    return count;\n}","methodRange":"(line 846,col 3)-(line 854,col 3)","methodTokenRange":"public static long count_lines(String filename) throws IOException {\n    long count = 0;\n    try (LineNumberReader reader = UtilMDE.lineNumberFileReader(filename)) {\n      while (reader.readLine() != null) {\n        count++;\n      }\n    }\n    return count;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Count the number of lines in the specified file.\n   * @param filename file whose size to count\n   * @return number of lines in filename\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"methodName":"count_lines","methodQualifiedSignature":"plume.UtilMDE.count_lines","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Count the number of lines in the specified file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file whose size to count'}]}', name=Optional[filename]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of lines in filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 847,col 18)-(line 847,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 849,col 35)-(line 849,col 38)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.count_lines(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to infer a line separator from","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to infer a line separator from'}]}', name=Optional[filename]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the inferred line separator used in filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the inferred line separator used in filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static String inferLineSeparator(String filename) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return inferLineSeparator(new File(filename));\n}","methodRange":"(line 861,col 3)-(line 863,col 3)","methodTokenRange":"public static String inferLineSeparator(String filename) throws IOException {\n    return inferLineSeparator(new File(filename));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Tries to infer the line separator used in a file.\n   * @param filename the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"methodName":"inferLineSeparator","methodQualifiedSignature":"plume.UtilMDE.inferLineSeparator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tries to infer the line separator used in a file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to infer a line separator from'}]}', name=Optional[filename]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the inferred line separator used in filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.inferLineSeparator(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to infer a line separator from","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to infer a line separator from'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the inferred line separator used in filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the inferred line separator used in filename'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static String inferLineSeparator(File file) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n        int unix = 0;\n        int dos = 0;\n        int mac = 0;\n        while (true) {\n            String s = r.readLine();\n            if (s == null) {\n                break;\n            }\n            if (s.endsWith(\"\\r\\n\")) {\n                dos++;\n            } else if (s.endsWith(\"\\r\")) {\n                mac++;\n            } else if (s.endsWith(\"\\n\")) {\n                unix++;\n            } else {\n            }\n        }\n        if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n            return \"\\r\\n\";\n        }\n        if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n            return \"\\r\";\n        }\n        if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n            return \"\\n\";\n        }\n        return lineSep;\n    }\n}","methodRange":"(line 870,col 3)-(line 904,col 3)","methodTokenRange":"public static String inferLineSeparator(File file) throws IOException {\n    try (BufferedReader r = UtilMDE.bufferedFileReader(file)) {\n      int unix = 0;\n      int dos = 0;\n      int mac = 0;\n      while (true) {\n        String s = r.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.endsWith(\"\\r\\n\")) {\n          dos++;\n        } else if (s.endsWith(\"\\r\")) {\n          mac++;\n        } else if (s.endsWith(\"\\n\")) {\n          unix++;\n        } else {\n          \/\/ This can happen only if the last line is not terminated.\n        }\n      }\n      if ((dos > mac && dos > unix) || (lineSep.equals(\"\\r\\n\") && dos >= unix && dos >= mac)) {\n        return \"\\r\\n\";\n      }\n      if ((mac > dos && mac > unix) || (lineSep.equals(\"\\r\") && mac >= dos && mac >= unix)) {\n        return \"\\r\";\n      }\n      if ((unix > dos && unix > mac) || (lineSep.equals(\"\\n\") && unix >= dos && unix >= mac)) {\n        return \"\\n\";\n      }\n      \/\/ The two non-preferred line endings are tied and have more votes than\n      \/\/ the preferred line ending.  Give up and return the line separator\n      \/\/ for the system on which Java is currently running.\n      return lineSep;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Tries to infer the line separator used in a file.\n   * @param file the file to infer a line separator from\n   * @return the inferred line separator used in filename\n   * @throws IOException if there is trouble reading the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"inferLineSeparator","methodQualifiedSignature":"plume.UtilMDE.inferLineSeparator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tries to infer the line separator used in a file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to infer a line separator from'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the inferred line separator used in filename'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 872,col 18)-(line 872,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 873,col 17)-(line 873,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 874,col 17)-(line 874,col 17)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 875,col 14)-(line 875,col 17)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 877,col 18)-(line 877,col 21)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 880,col 24)-(line 880,col 29)","literalExprId":6,"literalExpr":"\"\\r\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 882,col 31)-(line 882,col 34)","literalExprId":7,"literalExpr":"\"\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 884,col 31)-(line 884,col 34)","literalExprId":8,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 890,col 56)-(line 890,col 61)","literalExprId":9,"literalExpr":"\"\\r\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 891,col 16)-(line 891,col 21)","literalExprId":10,"literalExpr":"\"\\r\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 893,col 56)-(line 893,col 59)","literalExprId":11,"literalExpr":"\"\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 894,col 16)-(line 894,col 19)","literalExprId":12,"literalExpr":"\"\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 896,col 57)-(line 896,col 60)","literalExprId":13,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 897,col 16)-(line 897,col 19)","literalExprId":14,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.inferLineSeparator(java.io.File)"},{"methodDeclaration":"public static boolean equalFiles(String file1, String file2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return equalFiles(file1, file2, false);\n}","methodRange":"(line 913,col 3)-(line 915,col 3)","methodTokenRange":"public static boolean equalFiles(String file1, String file2) {\n    return equalFiles(file1, file2, false);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String file1","parameterName":"file1"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String file2","parameterName":"file2"}],"methodName":"equalFiles","methodQualifiedSignature":"plume.UtilMDE.equalFiles","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 914,col 37)-(line 914,col 41)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.equalFiles(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first file to compare","javadocBlockTagName":"file1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first file to compare'}]}', name=Optional[file1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second file to compare","javadocBlockTagName":"file2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second file to compare'}]}', name=Optional[file2]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, call String.trim on each line before comparing","javadocBlockTagName":"trimLines","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, call String.trim on each line before comparing'}]}', name=Optional[trimLines]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the files have the same contents","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the files have the same contents'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean equalFiles(String file1, String file2, boolean trimLines)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2)) {\n        String line1 = reader1.readLine();\n        String line2 = reader2.readLine();\n        while (line1 != null && line2 != null) {\n            if (trimLines) {\n                line1 = line1.trim();\n                line2 = line2.trim();\n            }\n            if (!(line1.equals(line2))) {\n                return false;\n            }\n            line1 = reader1.readLine();\n            line2 = reader2.readLine();\n        }\n        if (line1 == null && line2 == null) {\n            return true;\n        }\n        return false;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}","methodRange":"(line 924,col 3)-(line 949,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ reads files, side effects local state\n  \/*@Pure*\/\n  public static boolean equalFiles(String file1, String file2, boolean trimLines) {\n    try (LineNumberReader reader1 = UtilMDE.lineNumberFileReader(file1);\n        LineNumberReader reader2 = UtilMDE.lineNumberFileReader(file2); ) {\n      String line1 = reader1.readLine();\n      String line2 = reader2.readLine();\n      while (line1 != null && line2 != null) {\n        if (trimLines) {\n          line1 = line1.trim();\n          line2 = line2.trim();\n        }\n        if (!(line1.equals(line2))) {\n          return false;\n        }\n        line1 = reader1.readLine();\n        line2 = reader2.readLine();\n      }\n      if (line1 == null && line2 == null) {\n        return true;\n      }\n      return false;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff the files have the same contents.\n   * @param file1 first file to compare\n   * @param file2 second file to compare\n   * @param trimLines if true, call String.trim on each line before comparing\n   * @return true iff the files have the same contents\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String file1","parameterName":"file1"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String file2","parameterName":"file2"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean trimLines","parameterName":"trimLines"}],"methodName":"equalFiles","methodQualifiedSignature":"plume.UtilMDE.equalFiles","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff the files have the same contents.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first file to compare'}]}', name=Optional[file1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second file to compare'}]}', name=Optional[file2]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, call String.trim on each line before comparing'}]}', name=Optional[trimLines]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the files have the same contents'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 924,col 21)-(line 924,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 931,col 23)-(line 931,col 26)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 931,col 40)-(line 931,col 43)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 937,col 18)-(line 937,col 22)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 942,col 20)-(line 942,col 23)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 942,col 37)-(line 942,col 40)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 943,col 16)-(line 943,col 19)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 945,col 14)-(line 945,col 18)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.equalFiles(java.lang.String, java.lang.String, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to create and write","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to create and write'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the file can be created and written","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the file can be created and written'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean canCreateAndWrite(File file)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (file.exists()) {\n        return file.canWrite();\n    } else {\n        File directory = file.getParentFile();\n        if (directory == null) {\n            directory = new File(\".\");\n        }\n        return directory.canWrite();\n    }\n}","methodRange":"(line 958,col 3)-(line 982,col 3)","methodTokenRange":"public static boolean canCreateAndWrite(File file) {\n    if (file.exists()) {\n      return file.canWrite();\n    } else {\n      File directory = file.getParentFile();\n      if (directory == null) {\n        directory = new File(\".\");\n      }\n      \/\/ Does this test need \"directory.canRead()\" also?\n      return directory.canWrite();\n    }\n\n    \/\/\/ Old implementation; is this equivalent to the new one, above??\n    \/\/ try {\n    \/\/   if (file.exists()) {\n    \/\/     return file.canWrite();\n    \/\/   } else {\n    \/\/     file.createNewFile();\n    \/\/     file.delete();\n    \/\/     return true;\n    \/\/   }\n    \/\/ } catch (IOException e) {\n    \/\/   return false;\n    \/\/ }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true\n   *  if the file exists and is writable, or\n   *  if the file can be created.\n   * @param file the file to create and write\n   * @return true iff the file can be created and written\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"canCreateAndWrite","methodQualifiedSignature":"plume.UtilMDE.canCreateAndWrite","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true\n if the file exists and is writable, or\n if the file can be created.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to create and write'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the file can be created and written'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 963,col 24)-(line 963,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 964,col 30)-(line 964,col 32)","literalExprId":2,"literalExpr":"\".\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.canCreateAndWrite(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the prefix string to be used in generating the file's\n name; must be at least three characters long","javadocBlockTagName":"prefix","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the prefix string to be used in generating the file's\n name; must be at least three characters long'}]}', name=Optional[prefix]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the suffix string to be used in generating the file's\n name; may be null, in which case the suffix \".tmp\" will be used Returns:\n An abstract pathname denoting a newly-created empty file","javadocBlockTagName":"suffix","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the suffix string to be used in generating the file's\n name; may be null, in which case the suffix \".tmp\" will be used Returns:\n An abstract pathname denoting a newly-created empty file'}]}', name=Optional[suffix]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a File representing the newly-created temporary directory","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a File representing the newly-created temporary directory'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If the prefix argument contains fewer\n than three characters","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the prefix argument contains fewer\n than three characters'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If a file could not be created","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If a file could not be created'}]}', name=Optional[IOException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"If a security manager exists and its\n SecurityManager.checkWrite(java.lang.String) method does not allow a\n file to be created","javadocBlockTagName":"SecurityException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If a security manager exists and its\n SecurityManager.checkWrite(java.lang.String) method does not allow a\n file to be created'}]}', name=Optional[SecurityException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.io.File#createTempFile(String, String, File)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.io.File#createTempFile(String, String, File)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static File createTempDir(String prefix, String suffix) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n        if (!pathFile.mkdirs()) {\n            throw new IOException(\"Could not create directory: \" + pathFile);\n        }\n    }\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    tmpfile.delete();\n    return tmpDir;\n}","methodRange":"(line 1009,col 3)-(line 1029,col 3)","methodTokenRange":"public static File createTempDir(String prefix, String suffix) throws IOException {\n    String fs = File.separator;\n    String path = System.getProperty(\"java.io.tmpdir\") + fs + System.getProperty(\"user.name\") + fs;\n    File pathFile = new File(path);\n    if (!pathFile.isDirectory()) {\n      if (!pathFile.mkdirs()) {\n        throw new IOException(\"Could not create directory: \" + pathFile);\n      }\n    }\n    \/\/ Call Java runtime to create a file with a unique name\n    File tmpfile = File.createTempFile(prefix + \"_\", \"_\", pathFile);\n    String tmpDirPath = tmpfile.getPath() + suffix;\n    File tmpDir = new File(tmpDirPath);\n    if (!tmpDir.mkdirs()) {\n      throw new IOException(\"Could not create directory: \" + tmpDir);\n    }\n    \/\/ Now that we have created our directory, we should get rid\n    \/\/ of the intermediate TempFile we created.\n    tmpfile.delete();\n    return tmpDir;\n  }","methodReturnTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Creates an empty directory in the default temporary-file directory,\n   * using the given prefix and suffix to generate its name. For example,\n   * calling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\n   * directory: temporaryFileDirectory\/myUserName\/myPrefix_someString_suffix.\n   * someString is internally generated to ensure no temporary files of the\n   * same name are generated.\n   * @param prefix the prefix string to be used in generating the file's\n   *  name; must be at least three characters long\n   * @param suffix the suffix string to be used in generating the file's\n   *  name; may be null, in which case the suffix \".tmp\" will be used Returns:\n   *  An abstract pathname denoting a newly-created empty file\n   * @return a File representing the newly-created temporary directory\n   * @throws IllegalArgumentException If the prefix argument contains fewer\n   *  than three characters\n   * @throws IOException If a file could not be created\n   * @throws SecurityException If a security manager exists and its\n   *  SecurityManager.checkWrite(java.lang.String) method does not allow a\n   *  file to be created\n   * @see java.io.File#createTempFile(String, String, File)\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String prefix","parameterName":"prefix"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String suffix","parameterName":"suffix"}],"methodName":"createTempDir","methodQualifiedSignature":"plume.UtilMDE.createTempDir","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates an empty directory in the default temporary-file directory,\nusing the given prefix and suffix to generate its name. For example,\ncalling createTempDir(\"myPrefix\", \"mySuffix\") will create the following\ndirectory: temporaryFileDirectory\/myUserName\/myPrefix_someString_suffix.\nsomeString is internally generated to ensure no temporary files of the\nsame name are generated.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the prefix string to be used in generating the file's\n name; must be at least three characters long'}]}', name=Optional[prefix]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the suffix string to be used in generating the file's\n name; may be null, in which case the suffix \".tmp\" will be used Returns:\n An abstract pathname denoting a newly-created empty file'}]}', name=Optional[suffix]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a File representing the newly-created temporary directory'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If the prefix argument contains fewer\n than three characters'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If a file could not be created'}]}', name=Optional[IOException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='If a security manager exists and its\n SecurityManager.checkWrite(java.lang.String) method does not allow a\n file to be created'}]}', name=Optional[SecurityException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.io.File#createTempFile(String, String, File)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.io.File","methodType":"File","literalExprs":[{"literalExprRange":"(line 1011,col 38)-(line 1011,col 53)","literalExprId":1,"literalExpr":"\"java.io.tmpdir\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1011,col 82)-(line 1011,col 92)","literalExprId":2,"literalExpr":"\"user.name\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1015,col 31)-(line 1015,col 60)","literalExprId":3,"literalExpr":"\"Could not create directory: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1019,col 49)-(line 1019,col 51)","literalExprId":4,"literalExpr":"\"_\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1019,col 54)-(line 1019,col 56)","literalExprId":5,"literalExpr":"\"_\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1023,col 29)-(line 1023,col 58)","literalExprId":6,"literalExpr":"\"Could not create directory: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.createTempDir(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the directory to delete","javadocBlockTagName":"dirName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directory to delete'}]}', name=Optional[dirName]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if and only if the file or directory is successfully deleted; false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if and only if the file or directory is successfully deleted; false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean deleteDir(String dirName)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return deleteDir(new File(dirName));\n}","methodRange":"(line 1036,col 3)-(line 1038,col 3)","methodTokenRange":"public static boolean deleteDir(String dirName) {\n    return deleteDir(new File(dirName));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Deletes the directory at dirName and all its files.\n   * @param dirName the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String dirName","parameterName":"dirName"}],"methodName":"deleteDir","methodQualifiedSignature":"plume.UtilMDE.deleteDir","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes the directory at dirName and all its files.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directory to delete'}]}', name=Optional[dirName]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if and only if the file or directory is successfully deleted; false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.deleteDir(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the directory to delete","javadocBlockTagName":"dir","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directory to delete'}]}', name=Optional[dir]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if and only if the file or directory is successfully deleted; false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if and only if the file or directory is successfully deleted; false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean deleteDir(File dir)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    File[] files = dir.listFiles();\n    if (files == null) {\n        return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n        files[i].delete();\n    }\n    return dir.delete();\n}","methodRange":"(line 1045,col 3)-(line 1054,col 3)","methodTokenRange":"public static boolean deleteDir(File dir) {\n    File[] files = dir.listFiles();\n    if (files == null) {\n      return false;\n    }\n    for (int i = 0; i < files.length; i++) {\n      files[i].delete();\n    }\n    return dir.delete();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Deletes the directory at dir and all its files.\n   * @param dir the directory to delete\n   * @return true if and only if the file or directory is successfully deleted; false otherwise\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File dir","parameterName":"dir"}],"methodName":"deleteDir","methodQualifiedSignature":"plume.UtilMDE.deleteDir","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Deletes the directory at dir and all its files.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the directory to delete'}]}', name=Optional[dir]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if and only if the file or directory is successfully deleted; false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1047,col 18)-(line 1047,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1048,col 14)-(line 1048,col 18)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1050,col 18)-(line 1050,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.deleteDir(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"file whose name to expand","javadocBlockTagName":"name","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file whose name to expand'}]}', name=Optional[name]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"file with expanded file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='file with expanded file'}]}', name=Optional.empty}"}],"methodDeclaration":"public static File expandFilename(File name)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n        return new File(newname);\n    } else {\n        return name;\n    }\n}","methodRange":"(line 1094,col 3)-(line 1104,col 3)","methodTokenRange":"public static File expandFilename(File name) {\n    String path = name.getPath();\n    String newname = expandFilename(path);\n    @SuppressWarnings(\"interning\")\n    boolean changed = (newname != path);\n    if (changed) {\n      return new File(newname);\n    } else {\n      return name;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name file whose name to expand\n   * @return file with expanded file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File name","parameterName":"name"}],"methodName":"expandFilename","methodQualifiedSignature":"plume.UtilMDE.expandFilename","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Does tilde expansion on a file name (to the user's home directory).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file whose name to expand'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='file with expanded file'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.io.File","methodType":"File","literalExprs":[{"literalExprRange":"(line 1097,col 23)-(line 1097,col 33)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.expandFilename(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"filename to expand","javadocBlockTagName":"name","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='filename to expand'}]}', name=Optional[name]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"expanded filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='expanded filename'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String expandFilename(String name)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (name.contains(\"~\")) {\n        return (name.replace(\"~\", userHome));\n    } else {\n        return name;\n    }\n}","methodRange":"(line 1111,col 3)-(line 1117,col 3)","methodTokenRange":"public static String expandFilename(String name) {\n    if (name.contains(\"~\")) {\n      return (name.replace(\"~\", userHome));\n    } else {\n      return name;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Does tilde expansion on a file name (to the user's home directory).\n   * @param name filename to expand\n   * @return expanded filename\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String name","parameterName":"name"}],"methodName":"expandFilename","methodQualifiedSignature":"plume.UtilMDE.expandFilename","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Does tilde expansion on a file name (to the user's home directory).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='filename to expand'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='expanded filename'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1112,col 23)-(line 1112,col 25)","literalExprId":1,"literalExpr":"\"~\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1113,col 28)-(line 1113,col 30)","literalExprId":2,"literalExpr":"\"~\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.expandFilename(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"file to quote","javadocBlockTagName":"name","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file to quote'}]}', name=Optional[name]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string version of the name that can be used in Java source","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string version of the name that can be used in Java source'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String java_source(File name)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n}","methodRange":"(line 1132,col 3)-(line 1135,col 3)","methodTokenRange":"public static String java_source(File name) {\n\n    return name.getPath().replace(\"\\\\\", \"\\\\\\\\\");\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string version of the name that can be used in Java source.\n   * On Windows, the file will return a backslash separated string.  Since\n   * backslash is an escape character, it must be quoted itself inside\n   * the string.\n   * <p>\n   * The current implementation presumes that backslashes don't appear\n   * in filenames except as windows path separators.  That seems like a\n   * reasonable assumption.\n   *\n   * @param name file to quote\n   * @return a string version of the name that can be used in Java source\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File name","parameterName":"name"}],"methodName":"java_source","methodQualifiedSignature":"plume.UtilMDE.java_source","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string version of the name that can be used in Java source.\nOn Windows, the file will return a backslash separated string.  Since\nbackslash is an escape character, it must be quoted itself inside\nthe string.\n<p>\nThe current implementation presumes that backslashes don't appear\nin filenames except as windows path separators.  That seems like a\nreasonable assumption.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file to quote'}]}', name=Optional[name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string version of the name that can be used in Java source'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1134,col 35)-(line 1134,col 38)","literalExprId":1,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1134,col 41)-(line 1134,col 46)","literalExprId":2,"literalExpr":"\"\\\\\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.java_source(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the object to write","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to write'}]}', name=Optional[o]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to which to write the object","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to which to write the object'}]}', name=Optional[file]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble writing the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble writing the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static void writeObject(Object o, File file) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n}","methodRange":"(line 1147,col 3)-(line 1156,col 3)","methodTokenRange":"public static void writeObject(Object o, File file) throws IOException {\n    \/\/ 8192 is the buffer size in BufferedReader\n    OutputStream bytes = new BufferedOutputStream(new FileOutputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      bytes = new GZIPOutputStream(bytes);\n    }\n    ObjectOutputStream objs = new ObjectOutputStream(bytes);\n    objs.writeObject(o);\n    objs.close();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Writes an Object to a File.\n   * @param o the object to write\n   * @param file the file to which to write the object\n   * @throws IOException if there is trouble writing the file\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"},{"parameterType":"File","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"writeObject","methodQualifiedSignature":"plume.UtilMDE.writeObject","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Writes an Object to a File.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to write'}]}', name=Optional[o]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to which to write the object'}]}', name=Optional[file]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble writing the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1149,col 79)-(line 1149,col 82)","literalExprId":1,"literalExpr":"8192","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1150,col 33)-(line 1150,col 37)","literalExprId":2,"literalExpr":"\".gz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.writeObject(java.lang.Object, java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file from which to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file from which to read'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the object read from the file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the object read from the file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is trouble reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the object's class cannot be found","javadocBlockTagName":"ClassNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the object's class cannot be found'}]}', name=Optional[ClassNotFoundException]}"}],"methodDeclaration":"public static Object readObject(File file) throws IOException, ClassNotFoundException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n        try {\n            istream = new GZIPInputStream(istream);\n        } catch (IOException e) {\n            throw new IOException(\"Problem while reading \" + file, e);\n        }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n}","methodRange":"(line 1165,col 3)-(line 1177,col 3)","methodTokenRange":"public static Object readObject(File file) throws IOException, ClassNotFoundException {\n    \/\/ 8192 is the buffer size in BufferedReader\n    InputStream istream = new BufferedInputStream(new FileInputStream(file), 8192);\n    if (file.getName().endsWith(\".gz\")) {\n      try {\n        istream = new GZIPInputStream(istream);\n      } catch (IOException e) {\n        throw new IOException(\"Problem while reading \" + file, e);\n      }\n    }\n    ObjectInputStream objs = new ObjectInputStream(istream);\n    return objs.readObject();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Reads an Object from a File.\n   * @param file the file from which to read\n   * @return the object read from the file\n   * @throws IOException if there is trouble reading the file\n   * @throws ClassNotFoundException if the object's class cannot be found\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"readObject","methodQualifiedSignature":"plume.UtilMDE.readObject","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads an Object from a File.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file from which to read'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the object read from the file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is trouble reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the object's class cannot be found'}]}', name=Optional[ClassNotFoundException]}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 1167,col 78)-(line 1167,col 81)","literalExprId":1,"literalExpr":"8192","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1168,col 33)-(line 1168,col 37)","literalExprId":2,"literalExpr":"\".gz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1172,col 31)-(line 1172,col 54)","literalExprId":3,"literalExpr":"\"Problem while reading \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.readObject(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Reader to read","javadocBlockTagName":"r","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Reader to read'}]}', name=Optional[r]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the entire contents of the reader, as a string","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the entire contents of the reader, as a string'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String readerContents(Reader r)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        StringBuilder contents = new StringBuilder();\n        int ch;\n        while ((ch = r.read()) != -1) {\n            contents.append((char) ch);\n        }\n        r.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n}","methodRange":"(line 1185,col 3)-(line 1197,col 3)","methodTokenRange":"public static String readerContents(Reader r) {\n    try {\n      StringBuilder contents = new StringBuilder();\n      int ch;\n      while ((ch = r.read()) != -1) {\n        contents.append((char) ch);\n      }\n      r.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readerContents(\" + r + \")\", e);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Reads the entire contents of the reader and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param r the Reader to read\n   * @return the entire contents of the reader, as a string\n   ","methodParameters":[{"parameterType":"Reader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Reader","parameter":"Reader r","parameterName":"r"}],"methodName":"readerContents","methodQualifiedSignature":"plume.UtilMDE.readerContents","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the entire contents of the reader and returns it as a string.\nAny IOException encountered will be turned into an Error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Reader to read'}]}', name=Optional[r]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the entire contents of the reader, as a string'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1189,col 34)-(line 1189,col 34)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1195,col 23)-(line 1195,col 59)","literalExprId":2,"literalExpr":"\"Unexpected error in readerContents(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1195,col 67)-(line 1195,col 69)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.readerContents(java.io.Reader)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the entire contents of the reader, as a string","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the entire contents of the reader, as a string'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String readFile(File file)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        BufferedReader reader = UtilMDE.bufferedFileReader(file);\n        StringBuilder contents = new StringBuilder();\n        String line = reader.readLine();\n        while (line != null) {\n            contents.append(line);\n            contents.append(lineSep);\n            line = reader.readLine();\n        }\n        reader.close();\n        return contents.toString();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n}","methodRange":"(line 1206,col 3)-(line 1223,col 3)","methodTokenRange":"public static String readFile(File file) {\n\n    try {\n      BufferedReader reader = UtilMDE.bufferedFileReader(file);\n      StringBuilder contents = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        contents.append(line);\n        \/\/ Note that this converts line terminators!\n        contents.append(lineSep);\n        line = reader.readLine();\n      }\n      reader.close();\n      return contents.toString();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in readFile(\" + file + \")\", e);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Reads the entire contents of the file and returns it as a string.\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to read\n   * @return the entire contents of the reader, as a string\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"methodName":"readFile","methodQualifiedSignature":"plume.UtilMDE.readFile","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the entire contents of the file and returns it as a string.\nAny IOException encountered will be turned into an Error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the entire contents of the reader, as a string'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1212,col 22)-(line 1212,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1221,col 23)-(line 1221,col 53)","literalExprId":2,"literalExpr":"\"Unexpected error in readFile(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1221,col 64)-(line 1221,col 66)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.readFile(java.io.File)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to write to","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to write to'}]}', name=Optional[file]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the text to put in the file","javadocBlockTagName":"contents","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the text to put in the file'}]}', name=Optional[contents]}"}],"methodDeclaration":"public static void writeFile(File file, String contents)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        FileWriter writer = new FileWriter(file);\n        writer.write(contents, 0, contents.length());\n        writer.close();\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n}","methodRange":"(line 1232,col 3)-(line 1241,col 3)","methodTokenRange":"public static void writeFile(File file, String contents) {\n\n    try {\n      FileWriter writer = new FileWriter(file);\n      writer.write(contents, 0, contents.length());\n      writer.close();\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error in writeFile(\" + file + \")\", e);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Creates a file with the given name and writes the specified string\n   * to it.  If the file currently exists (and is writable) it is overwritten\n   * Any IOException encountered will be turned into an Error.\n   * @param file the file to write to\n   * @param contents the text to put in the file\n   ","methodParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String contents","parameterName":"contents"}],"methodName":"writeFile","methodQualifiedSignature":"plume.UtilMDE.writeFile","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a file with the given name and writes the specified string\nto it.  If the file currently exists (and is writable) it is overwritten\nAny IOException encountered will be turned into an Error.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to write to'}]}', name=Optional[file]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the text to put in the file'}]}', name=Optional[contents]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1236,col 30)-(line 1236,col 30)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 23)-(line 1239,col 54)","literalExprId":2,"literalExpr":"\"Unexpected error in writeFile(\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1239,col 65)-(line 1239,col 67)","literalExprId":3,"literalExpr":"\")\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.writeFile(java.io.File, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"x","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[x]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(double x)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return hash(Double.doubleToLongBits(x));\n}","methodRange":"(line 1273,col 3)-(line 1275,col 3)","methodTokenRange":"public static int hash(double x) {\n    return hash(Double.doubleToLongBits(x));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Double#hashCode()}.\n   * @param x value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double x","parameterName":"x"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.\nNote that this differs from the result of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Double#hashCode()'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[x]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.hash(double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(double a, double b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}","methodRange":"(line 1282,col 3)-(line 1287,col 3)","methodTokenRange":"public static int hash(double a, double b) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double a","parameterName":"a"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double b","parameterName":"b"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1283,col 21)-(line 1283,col 22)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1284,col 23)-(line 1284,col 24)","literalExprId":2,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1285,col 23)-(line 1285,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(double, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(double a, double b, double c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}","methodRange":"(line 1295,col 3)-(line 1301,col 3)","methodTokenRange":"public static int hash(double a, double b, double c) {\n    double result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double a","parameterName":"a"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double b","parameterName":"b"},{"parameterType":"double","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double c","parameterName":"c"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1296,col 21)-(line 1296,col 22)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1297,col 23)-(line 1297,col 24)","literalExprId":2,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1298,col 23)-(line 1298,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1299,col 23)-(line 1299,col 24)","literalExprId":4,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(double, double, double)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}","methodRange":"(line 1307,col 3)-(line 1316,col 3)","methodTokenRange":"public static int hash(double \/*@Nullable*\/ [] a) {\n    double result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1308,col 21)-(line 1308,col 22)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1309,col 14)-(line 1309,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1310,col 25)-(line 1310,col 26)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1311,col 20)-(line 1311,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1312,col 27)-(line 1312,col 28)","literalExprId":5,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(double[] a, double[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return hash(hash(a), hash(b));\n}","methodRange":"(line 1323,col 3)-(line 1325,col 3)","methodTokenRange":"public static int hash(double \/*@Nullable*\/ [] a, double \/*@Nullable*\/ [] b) {\n    return hash(hash(a), hash(b));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] b","parameterName":"b"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.hash(double[], double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[l]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(long l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n        return (int) l;\n    }\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n}","methodRange":"(line 1336,col 3)-(line 1348,col 3)","methodTokenRange":"public static int hash(long l) {\n    \/\/ If possible, use the value itself.\n    if (l >= Integer.MIN_VALUE && l <= Integer.MAX_VALUE) {\n      return (int) l;\n    }\n\n    int result = 17;\n    int hibits = (int) (l >> 32);\n    int lobits = (int) l;\n    result = result * 37 + hibits;\n    result = result * 37 + lobits;\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return a hash of the arguments.\n   * Note that this differs from the result of {@link Long#hashCode()}.\n   * But it doesn't map -1 and 0 to the same value.\n   * @param l value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long l","parameterName":"l"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.\nNote that this differs from the result of '}, JavadocInlineTag{tagName='link', type=LINK, content=' Long#hashCode()'}, JavadocSnippet{text='.\nBut it doesn't map -1 and 0 to the same value.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[l]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1342,col 18)-(line 1342,col 19)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 30)-(line 1343,col 31)","literalExprId":2,"literalExpr":"32","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 23)-(line 1345,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 23)-(line 1346,col 24)","literalExprId":4,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(long a, long b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n}","methodRange":"(line 1355,col 3)-(line 1360,col 3)","methodTokenRange":"public static int hash(long a, long b) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long a","parameterName":"a"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long b","parameterName":"b"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1356,col 19)-(line 1356,col 20)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1357,col 23)-(line 1357,col 24)","literalExprId":2,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1358,col 23)-(line 1358,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(long a, long b, long c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n}","methodRange":"(line 1368,col 3)-(line 1374,col 3)","methodTokenRange":"public static int hash(long a, long b, long c) {\n    long result = 17;\n    result = result * 37 + a;\n    result = result * 37 + b;\n    result = result * 37 + c;\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long a","parameterName":"a"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long b","parameterName":"b"},{"parameterType":"long","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long c","parameterName":"c"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1369,col 19)-(line 1369,col 20)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1370,col 23)-(line 1370,col 24)","literalExprId":2,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1371,col 23)-(line 1371,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1372,col 23)-(line 1372,col 24)","literalExprId":4,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(long, long, long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + a[i];\n        }\n    }\n    return hash(result);\n}","methodRange":"(line 1380,col 3)-(line 1389,col 3)","methodTokenRange":"public static int hash(long \/*@Nullable*\/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + a[i];\n      }\n    }\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1381,col 19)-(line 1381,col 20)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1382,col 14)-(line 1382,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1383,col 25)-(line 1383,col 26)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1384,col 20)-(line 1384,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1385,col 27)-(line 1385,col 28)","literalExprId":5,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(long[] a, long[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return hash(hash(a), hash(b));\n}","methodRange":"(line 1396,col 3)-(line 1398,col 3)","methodTokenRange":"public static int hash(long \/*@Nullable*\/ [] a, long \/*@Nullable*\/ [] b) {\n    return hash(hash(a), hash(b));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"long[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] b","parameterName":"b"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.hash(long[], long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(String a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (a == null) ? 0 : a.hashCode();\n}","methodRange":"(line 1404,col 3)-(line 1406,col 3)","methodTokenRange":"public static int hash(\/*@Nullable*\/ String a) {\n    return (a == null) ? 0 : a.hashCode();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String a","parameterName":"a"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1405,col 18)-(line 1405,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1405,col 26)-(line 1405,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(String a, String b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n}","methodRange":"(line 1413,col 3)-(line 1418,col 3)","methodTokenRange":"public static int hash(\/*@Nullable*\/ String a, \/*@Nullable*\/ String b) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String a","parameterName":"a"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String b","parameterName":"b"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1414,col 19)-(line 1414,col 20)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1415,col 23)-(line 1415,col 24)","literalExprId":2,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1416,col 23)-(line 1416,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(String a, String b, String c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n}","methodRange":"(line 1426,col 3)-(line 1432,col 3)","methodTokenRange":"public static int hash(\/*@Nullable*\/ String a, \/*@Nullable*\/ String b, \/*@Nullable*\/ String c) {\n    long result = 17;\n    result = result * 37 + hash(a);\n    result = result * 37 + hash(b);\n    result = result * 37 + hash(c);\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @param b value to be hashed\n   * @param c value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String a","parameterName":"a"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String b","parameterName":"b"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String c","parameterName":"c"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1427,col 19)-(line 1427,col 20)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1428,col 23)-(line 1428,col 24)","literalExprId":2,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1429,col 23)-(line 1429,col 24)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1430,col 23)-(line 1430,col 24)","literalExprId":4,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(java.lang.String, java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to be hashed","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a hash of the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int hash(String[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long result = 17;\n    if (a != null) {\n        result = result * 37 + a.length;\n        for (int i = 0; i < a.length; i++) {\n            result = result * 37 + hash(a[i]);\n        }\n    }\n    return hash(result);\n}","methodRange":"(line 1438,col 3)-(line 1447,col 3)","methodTokenRange":"public static int hash(\/*@Nullable*\/ String \/*@Nullable*\/ [] a) {\n    long result = 17;\n    if (a != null) {\n      result = result * 37 + a.length;\n      for (int i = 0; i < a.length; i++) {\n        result = result * 37 + hash(a[i]);\n      }\n    }\n    return hash(result);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return a hash of the arguments.\n   * @param a value to be hashed\n   * @return a hash of the arguments\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] a","parameterName":"a"}],"methodName":"hash","methodQualifiedSignature":"plume.UtilMDE.hash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a hash of the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to be hashed'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a hash of the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1439,col 19)-(line 1439,col 20)","literalExprId":1,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 14)-(line 1440,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1441,col 25)-(line 1441,col 26)","literalExprId":3,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1442,col 20)-(line 1442,col 20)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1443,col 27)-(line 1443,col 28)","literalExprId":5,"literalExpr":"37","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.hash(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the iterator elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the iterator elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"elements to be randomly selected from","javadocBlockTagName":"itor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='elements to be randomly selected from'}]}', name=Optional[itor]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of elements to select","javadocBlockTagName":"num_elts","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of elements to select'}]}', name=Optional[num_elts]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of num_elts elements from itor","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of num_elts elements from itor'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<T> randomElements(Iterator<T> itor, int num_elts)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return randomElements(itor, num_elts, r);\n}","methodRange":"(line 1675,col 3)-(line 1677,col 3)","methodTokenRange":"public static <T> List<T> randomElements(Iterator<T> itor, int num_elts) {\n    return randomElements(itor, num_elts, r);\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @return list of num_elts elements from itor\n   ","methodParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor","parameterName":"itor"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num_elts","parameterName":"num_elts"}],"methodName":"randomElements","methodQualifiedSignature":"plume.UtilMDE.randomElements","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a List containing num_elts randomly chosen\nelements from the iterator, or all the elements of the iterator if\nthere are fewer.  It examines every element of the iterator, but does\nnot keep them all in memory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the iterator elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='elements to be randomly selected from'}]}', name=Optional[itor]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of elements to select'}]}', name=Optional[num_elts]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of num_elts elements from itor'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<T>","methodType":"List<T>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.randomElements(java.util.Iterator<T>, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the iterator elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the iterator elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"elements to be randomly selected from","javadocBlockTagName":"itor","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='elements to be randomly selected from'}]}', name=Optional[itor]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of elements to select","javadocBlockTagName":"num_elts","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of elements to select'}]}', name=Optional[num_elts]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Random instance to use to make selections","javadocBlockTagName":"random","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Random instance to use to make selections'}]}', name=Optional[random]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of num_elts elements from itor","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of num_elts elements from itor'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<T> randomElements(Iterator<T> itor, int num_elts, Random random)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n    while (itor.hasNext()) {\n        rs.accept(itor.next());\n    }\n    return rs.getValues();\n}","methodRange":"(line 1692,col 3)-(line 1721,col 3)","methodTokenRange":"public static <T> List<T> randomElements(Iterator<T> itor, int num_elts, Random random) {\n    \/\/ The elements are chosen with the following probabilities,\n    \/\/ where n == num_elts:\n    \/\/   n n\/2 n\/3 n\/4 n\/5 ...\n\n    RandomSelector<T> rs = new RandomSelector<T>(num_elts, random);\n\n    while (itor.hasNext()) {\n      rs.accept(itor.next());\n    }\n    return rs.getValues();\n\n    \/*\n    ArrayList<T> result = new ArrayList<T>(num_elts);\n    int i=1;\n    for (int n=0; n<num_elts && itor.hasNext(); n++, i++) {\n      result.add(itor.next());\n    }\n    for (; itor.hasNext(); i++) {\n      T o = itor.next();\n      \/\/ test random < num_elts\/i\n      if (random.nextDouble() * i < num_elts) {\n        \/\/ This element will replace one of the existing elements.\n        result.set(random.nextInt(num_elts), o);\n      }\n    }\n    return result;\n\n    *\/\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n   * Return a List containing num_elts randomly chosen\n   * elements from the iterator, or all the elements of the iterator if\n   * there are fewer.  It examines every element of the iterator, but does\n   * not keep them all in memory.\n   * @param <T> type of the iterator elements\n   * @param itor elements to be randomly selected from\n   * @param num_elts number of elements to select\n   * @param random the Random instance to use to make selections\n   * @return list of num_elts elements from itor\n   ","methodParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor","parameterName":"itor"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num_elts","parameterName":"num_elts"},{"parameterType":"Random","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Random","parameter":"Random random","parameterName":"random"}],"methodName":"randomElements","methodQualifiedSignature":"plume.UtilMDE.randomElements","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a List containing num_elts randomly chosen\nelements from the iterator, or all the elements of the iterator if\nthere are fewer.  It examines every element of the iterator, but does\nnot keep them all in memory.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the iterator elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='elements to be randomly selected from'}]}', name=Optional[itor]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of elements to select'}]}', name=Optional[num_elts]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Random instance to use to make selections'}]}', name=Optional[random]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of num_elts elements from itor'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<T>","methodType":"List<T>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.randomElements(java.util.Iterator<T>, int, java.util.Random)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of keys in the map","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of keys in the map'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"map to have one of its values incremented","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='map to have one of its values incremented'}]}', name=Optional[m]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the key for the element whose value will be incremented","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the key for the element whose value will be incremented'}]}', name=Optional[key]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"how much to increment the value by","javadocBlockTagName":"count","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='how much to increment the value by'}]}', name=Optional[count]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the old value, before it was incremented","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the old value, before it was incremented'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the key is in the Map but maps to a non-Integer.","javadocBlockTagName":"Error","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the key is in the Map but maps to a non-Integer.'}]}', name=Optional[Error]}"}],"methodDeclaration":"public static Integer incrementMap(Map<T, Integer> m, T key, int count)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n        new_total = count;\n    } else {\n        new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n}","methodRange":"(line 1739,col 3)-(line 1748,col 3)","methodTokenRange":"public static <T> \/*@Nullable*\/ Integer incrementMap(Map<T, Integer> m, T key, int count) {\n    Integer old = m.get(key);\n    int new_total;\n    if (old == null) {\n      new_total = count;\n    } else {\n      new_total = old.intValue() + count;\n    }\n    return m.put(key, new Integer(new_total));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Increment the Integer which is indexed by key in the Map.\n   * If the key isn't in the Map, it is added.\n   * @param <T> type of keys in the map\n   * @param m map to have one of its values incremented\n   * @param key the key for the element whose value will be incremented\n   * @param count how much to increment the value by\n   * @return the old value, before it was incremented\n   * @throws Error if the key is in the Map but maps to a non-Integer.\n   ","methodParameters":[{"parameterType":"Map<T, Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(T, bounds=[])}, java.util.Map.V=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Map<T, java.lang.Integer>","parameter":"Map<T, Integer> m","parameterName":"m"},{"parameterType":"T","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T key","parameterName":"key"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int count","parameterName":"count"}],"methodName":"incrementMap","methodQualifiedSignature":"plume.UtilMDE.incrementMap","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Increment the Integer which is indexed by key in the Map.\nIf the key isn't in the Map, it is added.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of keys in the map'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='map to have one of its values incremented'}]}', name=Optional[m]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the key for the element whose value will be incremented'}]}', name=Optional[key]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='how much to increment the value by'}]}', name=Optional[count]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the old value, before it was incremented'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the key is in the Map but maps to a non-Integer.'}]}', name=Optional[Error]}]}","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 1742,col 16)-(line 1742,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.incrementMap(java.util.Map<T, java.lang.Integer>, T, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of map keys","javadocBlockTagName":"<K>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map keys'}]}', name=Optional[<K>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of map values","javadocBlockTagName":"<V>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map values'}]}', name=Optional[<V>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"map to be converted to a string","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='map to be converted to a string'}]}', name=Optional[m]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a multi-line string representation of m","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a multi-line string representation of m'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String mapToString(Map<K, V> m)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n}","methodRange":"(line 1756,col 3)-(line 1760,col 3)","methodTokenRange":"public static <K, V> String mapToString(Map<K, V> m) {\n    StringBuilder sb = new StringBuilder();\n    mapToString(sb, m, \"\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Returns a multi-line string representation of a map.\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param m map to be converted to a string\n   * @return a multi-line string representation of m\n   ","methodParameters":[{"parameterType":"Map<K, V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<K, V>","parameter":"Map<K, V> m","parameterName":"m"}],"methodName":"mapToString","methodQualifiedSignature":"plume.UtilMDE.mapToString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a multi-line string representation of a map.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map keys'}]}', name=Optional[<K>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map values'}]}', name=Optional[<V>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='map to be converted to a string'}]}', name=Optional[m]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a multi-line string representation of m'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1758,col 24)-(line 1758,col 25)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.mapToString(java.util.Map<K, V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of map keys","javadocBlockTagName":"<K>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map keys'}]}', name=Optional[<K>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of map values","javadocBlockTagName":"<V>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map values'}]}', name=Optional[<V>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"an Appendable (such as StringBuilder) to which to write a multi-line string representation of m","javadocBlockTagName":"sb","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an Appendable (such as StringBuilder) to which to write a multi-line string representation of m'}]}', name=Optional[sb]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"map to be converted to a string","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='map to be converted to a string'}]}', name=Optional[m]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"prefix to write at the beginning of each line","javadocBlockTagName":"linePrefix","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='prefix to write at the beginning of each line'}]}', name=Optional[linePrefix]}"}],"methodDeclaration":"public static void mapToString(Appendable sb, Map<K, V> m, String linePrefix)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        for (Map.Entry<K, V> entry : m.entrySet()) {\n            sb.append(linePrefix);\n            sb.append(Objects.toString(entry.getKey()));\n            sb.append(\" => \");\n            sb.append(Objects.toString(entry.getValue()));\n            sb.append(lineSep);\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}","methodRange":"(line 1771,col 3)-(line 1783,col 3)","methodTokenRange":"public static <K, V> void mapToString(Appendable sb, Map<K, V> m, String linePrefix) {\n    try {\n      for (Map.Entry<K, V> entry : m.entrySet()) {\n        sb.append(linePrefix);\n        sb.append(Objects.toString(entry.getKey()));\n        sb.append(\" => \");\n        sb.append(Objects.toString(entry.getValue()));\n        sb.append(lineSep);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Write a multi-line representation of the map into the given Appendable\n   * (e.g., a StringBuilder).\n   * @param <K> type of map keys\n   * @param <V> type of map values\n   * @param sb an Appendable (such as StringBuilder) to which to write a multi-line string representation of m\n   * @param m map to be converted to a string\n   * @param linePrefix prefix to write at the beginning of each line\n   ","methodParameters":[{"parameterType":"Appendable","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Appendable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Appendable","parameter":"Appendable sb","parameterName":"sb"},{"parameterType":"Map<K, V>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<K, V>","parameter":"Map<K, V> m","parameterName":"m"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String linePrefix","parameterName":"linePrefix"}],"methodName":"mapToString","methodQualifiedSignature":"plume.UtilMDE.mapToString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Write a multi-line representation of the map into the given Appendable\n(e.g., a StringBuilder).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map keys'}]}', name=Optional[<K>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of map values'}]}', name=Optional[<V>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an Appendable (such as StringBuilder) to which to write a multi-line string representation of m'}]}', name=Optional[sb]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='map to be converted to a string'}]}', name=Optional[m]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='prefix to write at the beginning of each line'}]}', name=Optional[linePrefix]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1776,col 19)-(line 1776,col 24)","literalExprId":1,"literalExpr":"\" => \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.mapToString(java.lang.Appendable, java.util.Map<K, V>, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the map keys","javadocBlockTagName":"<K>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map keys'}]}', name=Optional[<K>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the map values","javadocBlockTagName":"<V>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map values'}]}', name=Optional[<V>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a map whose keyset will be sorted","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a map whose keyset will be sorted'}]}', name=Optional[m]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a sorted version of m.keySet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of m.keySet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Collection<K> sortedKeySet(Map<K, V> m)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ArrayList<K> theKeys = new ArrayList<K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n}","methodRange":"(line 1791,col 3)-(line 1796,col 3)","methodTokenRange":"public static <K extends Comparable<? super K>, V> Collection<\/*@KeyFor(\"#1\")*\/ K> sortedKeySet(\n      Map<K, V> m) {\n    ArrayList<\/*@KeyFor(\"#1\")*\/ K> theKeys = new ArrayList<\/*@KeyFor(\"#1\")*\/ K>(m.keySet());\n    Collections.sort(theKeys);\n    return theKeys;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=TypeVariable {JPTypeParameter(K, bounds=[Comparable<? super K>])}}}}","methodJavadocComment":" Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @return a sorted version of m.keySet()\n   ","methodParameters":[{"parameterType":"Map<K, V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(K, bounds=[Comparable<? super K>])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<K, V>","parameter":"Map<K, V> m","parameterName":"m"}],"methodName":"sortedKeySet","methodQualifiedSignature":"plume.UtilMDE.sortedKeySet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a sorted version of m.keySet().'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map keys'}]}', name=Optional[<K>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map values'}]}', name=Optional[<V>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a map whose keyset will be sorted'}]}', name=Optional[m]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of m.keySet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Collection<K>","methodType":"Collection<K>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.sortedKeySet(java.util.Map<K, V>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the map keys","javadocBlockTagName":"<K>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map keys'}]}', name=Optional[<K>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the map values","javadocBlockTagName":"<V>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map values'}]}', name=Optional[<V>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a map whose keyset will be sorted","javadocBlockTagName":"m","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a map whose keyset will be sorted'}]}', name=Optional[m]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Comparator to use for sorting","javadocBlockTagName":"comparator","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Comparator to use for sorting'}]}', name=Optional[comparator]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a sorted version of m.keySet()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of m.keySet()'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Collection<K> sortedKeySet(Map<K, V> m, Comparator<K> comparator)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ArrayList<K> theKeys = new ArrayList<K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n}","methodRange":"(line 1805,col 3)-(line 1810,col 3)","methodTokenRange":"public static <K, V> Collection<\/*@KeyFor(\"#1\")*\/ K> sortedKeySet(\n      Map<K, V> m, Comparator<K> comparator) {\n    ArrayList<\/*@KeyFor(\"#1\")*\/ K> theKeys = new ArrayList<\/*@KeyFor(\"#1\")*\/ K>(m.keySet());\n    Collections.sort(theKeys, comparator);\n    return theKeys;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","methodJavadocComment":" Returns a sorted version of m.keySet().\n   * @param <K> type of the map keys\n   * @param <V> type of the map values\n   * @param m a map whose keyset will be sorted\n   * @param comparator the Comparator to use for sorting\n   * @return a sorted version of m.keySet()\n   ","methodParameters":[{"parameterType":"Map<K, V>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=TypeVariable {JPTypeParameter(K, bounds=[])}, java.util.Map.V=TypeVariable {JPTypeParameter(V, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Map<K, V>","parameter":"Map<K, V> m","parameterName":"m"},{"parameterType":"Comparator<K>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=TypeVariable {JPTypeParameter(K, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<K>","parameter":"Comparator<K> comparator","parameterName":"comparator"}],"methodName":"sortedKeySet","methodQualifiedSignature":"plume.UtilMDE.sortedKeySet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a sorted version of m.keySet().'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map keys'}]}', name=Optional[<K>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the map values'}]}', name=Optional[<V>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a map whose keyset will be sorted'}]}', name=Optional[m]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Comparator to use for sorting'}]}', name=Optional[comparator]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of m.keySet()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Collection<K>","methodType":"Collection<K>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.sortedKeySet(java.util.Map<K, V>, java.util.Comparator<K>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a method signature","javadocBlockTagName":"method","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a method signature'}]}', name=Optional[method]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the method corresponding to the given signature","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the method corresponding to the given signature'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the class is not found","javadocBlockTagName":"ClassNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the class is not found'}]}', name=Optional[ClassNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the method is not found","javadocBlockTagName":"NoSuchMethodException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the method is not found'}]}', name=Optional[NoSuchMethodException]}"}],"methodDeclaration":"public static Method methodForName(String method) throws ClassNotFoundException, NoSuchMethodException, SecurityException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n        throw new Error(\"malformed method name should contain a period, open paren, and close paren: \" + method + \" <<\" + dotpos + \",\" + oparenpos + \",\" + cparenpos + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n        if (!Character.isWhitespace(method.charAt(i))) {\n            throw new Error(\"malformed method name should contain only whitespace following close paren\");\n        }\n    }\n    @SuppressWarnings(\"signature\")\n    String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n        String[] argnames;\n        if (all_argnames.equals(\"\")) {\n            argnames = new String[0];\n        } else {\n            argnames = split(all_argnames, ',');\n        }\n        Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n        for (int i = 0; i < argnames.length; i++) {\n            String bnArgname = argnames[i].trim();\n            String cgnArgname = binaryNameToClassGetName(bnArgname);\n            argclasses_tmp[i] = classForName(cgnArgname);\n        }\n        @SuppressWarnings(\"cast\")\n        Class<?>[] argclasses_res = (Class<?>[]) argclasses_tmp;\n        argclasses = argclasses_res;\n        args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n}","methodRange":"(line 1837,col 3)-(line 1887,col 3)","methodTokenRange":"public static Method methodForName(String method)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    int oparenpos = method.indexOf('(');\n    int dotpos = method.lastIndexOf('.', oparenpos);\n    int cparenpos = method.indexOf(')', oparenpos);\n    if ((dotpos == -1) || (oparenpos == -1) || (cparenpos == -1)) {\n      throw new Error(\n          \"malformed method name should contain a period, open paren, and close paren: \"\n              + method\n              + \" <<\"\n              + dotpos\n              + \",\"\n              + oparenpos\n              + \",\"\n              + cparenpos\n              + \">>\");\n    }\n    for (int i = cparenpos + 1; i < method.length(); i++) {\n      if (!Character.isWhitespace(method.charAt(i))) {\n        throw new Error(\n            \"malformed method name should contain only whitespace following close paren\");\n      }\n    }\n\n    @SuppressWarnings(\"signature\") \/\/ throws exception if class does not exist\n    \/*@BinaryNameForNonArray*\/ String classname = method.substring(0, dotpos);\n    String methodname = method.substring(dotpos + 1, oparenpos);\n    String all_argnames = method.substring(oparenpos + 1, cparenpos).trim();\n    Class<?>[] argclasses = args_seen.get(all_argnames);\n    if (argclasses == null) {\n      String[] argnames;\n      if (all_argnames.equals(\"\")) {\n        argnames = new String[0];\n      } else {\n        argnames = split(all_argnames, ',');\n      }\n\n      \/*@MonotonicNonNull*\/ Class<?>[] argclasses_tmp = new Class<?>[argnames.length];\n      for (int i = 0; i < argnames.length; i++) {\n        String bnArgname = argnames[i].trim();\n        \/*@ClassGetName*\/ String cgnArgname = binaryNameToClassGetName(bnArgname);\n        argclasses_tmp[i] = classForName(cgnArgname);\n      }\n      @SuppressWarnings(\"cast\")\n      Class<?>[] argclasses_res = (\/*@NonNull*\/ Class<?>[]) argclasses_tmp;\n      argclasses = argclasses_res;\n      args_seen.put(all_argnames, argclasses_res);\n    }\n    return methodForName(classname, methodname, argclasses);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Given a method signature, return the method.\n   * Example calls are:\n   * <pre>\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\n   * UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\n   * UtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n   * <\/pre>\n   * @param method a method signature\n   * @return the method corresponding to the given signature\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String method","parameterName":"method"}],"methodName":"methodForName","methodQualifiedSignature":"plume.UtilMDE.methodForName","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a method signature, return the method.\nExample calls are:\n<pre>\nUtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\")\nUtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\")\nUtilMDE.methodForName(\"java.lang.Math.min(int,int)\")\n<\/pre>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a method signature'}]}', name=Optional[method]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the method corresponding to the given signature'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the class is not found'}]}', name=Optional[ClassNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the method is not found'}]}', name=Optional[NoSuchMethodException]}]}","methodReturnTypeDescribed":"java.lang.reflect.Method","methodType":"Method","literalExprs":[{"literalExprRange":"(line 1840,col 36)-(line 1840,col 38)","literalExprId":1,"literalExpr":"'('","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1841,col 37)-(line 1841,col 39)","literalExprId":2,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1842,col 36)-(line 1842,col 38)","literalExprId":3,"literalExpr":"')'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1843,col 21)-(line 1843,col 21)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1843,col 42)-(line 1843,col 42)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1843,col 63)-(line 1843,col 63)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1845,col 11)-(line 1845,col 88)","literalExprId":7,"literalExpr":"\"malformed method name should contain a period, open paren, and close paren: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1847,col 17)-(line 1847,col 21)","literalExprId":8,"literalExpr":"\" <<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1849,col 17)-(line 1849,col 19)","literalExprId":9,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1851,col 17)-(line 1851,col 19)","literalExprId":10,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1853,col 17)-(line 1853,col 20)","literalExprId":11,"literalExpr":"\">>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1855,col 30)-(line 1855,col 30)","literalExprId":12,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1858,col 13)-(line 1858,col 88)","literalExprId":13,"literalExpr":"\"malformed method name should contain only whitespace following close paren\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1862,col 23)-(line 1862,col 33)","literalExprId":14,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1863,col 68)-(line 1863,col 68)","literalExprId":15,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1864,col 51)-(line 1864,col 51)","literalExprId":16,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1865,col 56)-(line 1865,col 56)","literalExprId":17,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1867,col 23)-(line 1867,col 26)","literalExprId":18,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1869,col 31)-(line 1869,col 32)","literalExprId":19,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1870,col 31)-(line 1870,col 31)","literalExprId":20,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1872,col 40)-(line 1872,col 42)","literalExprId":21,"literalExpr":"','","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1876,col 20)-(line 1876,col 20)","literalExprId":22,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1881,col 25)-(line 1881,col 30)","literalExprId":23,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.methodForName(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"class in which to find the method","javadocBlockTagName":"classname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class in which to find the method'}]}', name=Optional[classname]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the method name","javadocBlockTagName":"methodname","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method name'}]}', name=Optional[methodname]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the parameters of the method","javadocBlockTagName":"params","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the parameters of the method'}]}', name=Optional[params]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the method named classname.methodname with parameters params","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the method named classname.methodname with parameters params'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the class is not found","javadocBlockTagName":"ClassNotFoundException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the class is not found'}]}', name=Optional[ClassNotFoundException]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the method is not found","javadocBlockTagName":"NoSuchMethodException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the method is not found'}]}', name=Optional[NoSuchMethodException]}"}],"methodDeclaration":"public static Method methodForName(String classname, String methodname, Class<?>[] params) throws ClassNotFoundException, NoSuchMethodException, SecurityException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n}","methodRange":"(line 1897,col 3)-(line 1904,col 3)","methodTokenRange":"public static Method methodForName(\n      \/*@BinaryNameForNonArray*\/ String classname, String methodname, Class<?>[] params)\n      throws ClassNotFoundException, NoSuchMethodException, SecurityException {\n\n    Class<?> c = Class.forName(classname);\n    Method m = c.getDeclaredMethod(methodname, params);\n    return m;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.reflect.Method, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Given a class name and a method name in that class, return the method.\n   * @param classname class in which to find the method\n   * @param methodname the method name\n   * @param params the parameters of the method\n   * @return the method named classname.methodname with parameters params\n   * @throws ClassNotFoundException if the class is not found\n   * @throws NoSuchMethodException if the method is not found\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String classname","parameterName":"classname"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String methodname","parameterName":"methodname"},{"parameterType":"Class<?>[]","parameterId":3,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}}","parameterTypeResolvedDescribed":"java.lang.Class<?>[]","parameter":"Class<?>[] params","parameterName":"params"}],"methodName":"methodForName","methodQualifiedSignature":"plume.UtilMDE.methodForName","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Given a class name and a method name in that class, return the method.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='class in which to find the method'}]}', name=Optional[classname]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the method name'}]}', name=Optional[methodname]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the parameters of the method'}]}', name=Optional[params]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the method named classname.methodname with parameters params'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the class is not found'}]}', name=Optional[ClassNotFoundException]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the method is not found'}]}', name=Optional[NoSuchMethodException]}]}","methodReturnTypeDescribed":"java.lang.reflect.Method","methodType":"Method","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class<?>[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a command to execute on the command line","javadocBlockTagName":"command","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a command to execute on the command line'}]}', name=Optional[command]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all the output of the command","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all the output of the command'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String backticks(String... command)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return backticks(Arrays.asList(command));\n}","methodRange":"(line 1915,col 3)-(line 1917,col 3)","methodTokenRange":"public static String backticks(String... command) {\n    return backticks(Arrays.asList(command));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line\n   * @return all the output of the command\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String...","parameter":"String... command","parameterName":"command"}],"methodName":"backticks","methodQualifiedSignature":"plume.UtilMDE.backticks","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Execute the given command, and return all its output as a string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a command to execute on the command line'}]}', name=Optional[command]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all the output of the command'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.backticks(java.lang.String...)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a command to execute on the command line, as a list of\nstrings (the command, then its arguments)","javadocBlockTagName":"command","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a command to execute on the command line, as a list of\nstrings (the command, then its arguments)'}]}', name=Optional[command]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all the output of the command","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all the output of the command'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String backticks(List<String> command)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    try {\n        Process p = pb.start();\n        @SuppressWarnings(\"nullness\")\n        String output = UtilMDE.streamString(p.getInputStream());\n        return output;\n    } catch (IOException e) {\n        return \"IOException: \" + e.getMessage();\n    }\n}","methodRange":"(line 1925,col 3)-(line 1938,col 3)","methodTokenRange":"public static String backticks(List<String> command) {\n    ProcessBuilder pb = new ProcessBuilder(command);\n    pb.redirectErrorStream(true);\n    \/\/ TimeLimitProcess p = new TimeLimitProcess(pb.start(), TIMEOUT_SEC * 1000);\n    try {\n      Process p = pb.start();\n      @SuppressWarnings(\n          \"nullness\") \/\/ input stream is non-null because we didn't redirect the input stream\n      String output = UtilMDE.streamString(p.getInputStream());\n      return output;\n    } catch (IOException e) {\n      return \"IOException: \" + e.getMessage();\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Execute the given command, and return all its output as a string.\n   * @param command a command to execute on the command line, as a list of\n   * strings (the command, then its arguments)\n   * @return all the output of the command\n   ","methodParameters":[{"parameterType":"List<String>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.String>","parameter":"List<String> command","parameterName":"command"}],"methodName":"backticks","methodQualifiedSignature":"plume.UtilMDE.backticks","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Execute the given command, and return all its output as a string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a command to execute on the command line, as a list of\nstrings (the command, then its arguments)'}]}', name=Optional[command]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all the output of the command'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1927,col 28)-(line 1927,col 31)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1932,col 11)-(line 1932,col 20)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1936,col 14)-(line 1936,col 28)","literalExprId":3,"literalExpr":"\"IOException: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.backticks(java.util.List<java.lang.String>)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Properties#getProperty","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#getProperty'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a Properties object in which to look up the property","javadocBlockTagName":"p","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Properties object in which to look up the property'}]}', name=Optional[p]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the property to look up","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the property to look up'}]}', name=Optional[key]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff the property has value \"true\", \"yes\", or \"1\"","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the property has value \"true\", \"yes\", or \"1\"'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean propertyIsTrue(Properties p, String key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n        return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n}","methodRange":"(line 1951,col 3)-(line 1960,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ does not depend on object identity\n  \/*@Pure*\/\n  public static boolean propertyIsTrue(Properties p, String key) {\n    String pvalue = p.getProperty(key);\n    if (pvalue == null) {\n      return false;\n    }\n    pvalue = pvalue.toLowerCase();\n    return (pvalue.equals(\"true\") || pvalue.equals(\"yes\") || pvalue.equals(\"1\"));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Determines whether a property has value \"true\", \"yes\", or \"1\".\n   * @see Properties#getProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @return true iff the property has value \"true\", \"yes\", or \"1\"\n   ","methodParameters":[{"parameterType":"Properties","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Properties, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Properties","parameter":"Properties p","parameterName":"p"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String key","parameterName":"key"}],"methodName":"propertyIsTrue","methodQualifiedSignature":"plume.UtilMDE.propertyIsTrue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determines whether a property has value \"true\", \"yes\", or \"1\".'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#getProperty'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Properties object in which to look up the property'}]}', name=Optional[p]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the property to look up'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff the property has value \"true\", \"yes\", or \"1\"'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1951,col 21)-(line 1951,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1955,col 19)-(line 1955,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1956,col 14)-(line 1956,col 18)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1959,col 27)-(line 1959,col 32)","literalExprId":4,"literalExpr":"\"true\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1959,col 52)-(line 1959,col 56)","literalExprId":5,"literalExpr":"\"yes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1959,col 76)-(line 1959,col 78)","literalExprId":6,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.propertyIsTrue(java.util.Properties, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a Properties object in which to look up the property","javadocBlockTagName":"p","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Properties object in which to look up the property'}]}', name=Optional[p]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the property to look up","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the property to look up'}]}', name=Optional[key]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to concatenate to the previous value of the property","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to concatenate to the previous value of the property'}]}', name=Optional[value]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the previous value of the property","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the previous value of the property'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Properties#getProperty","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#getProperty'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Properties#setProperty","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#setProperty'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String appendProperty(Properties p, String key, String value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n}","methodRange":"(line 1972,col 3)-(line 1974,col 3)","methodTokenRange":"public static \/*@Nullable*\/ String appendProperty(Properties p, String key, String value) {\n    return (String) p.setProperty(key, p.getProperty(key, \"\") + value);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Set the property to its previous value concatenated to the given value.\n   * Return the previous value.\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to concatenate to the previous value of the property\n   * @return the previous value of the property\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   ","methodParameters":[{"parameterType":"Properties","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Properties, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Properties","parameter":"Properties p","parameterName":"p"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String key","parameterName":"key"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String value","parameterName":"value"}],"methodName":"appendProperty","methodQualifiedSignature":"plume.UtilMDE.appendProperty","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the property to its previous value concatenated to the given value.\nReturn the previous value.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Properties object in which to look up the property'}]}', name=Optional[p]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the property to look up'}]}', name=Optional[key]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to concatenate to the previous value of the property'}]}', name=Optional[value]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the previous value of the property'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#getProperty'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#setProperty'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1973,col 59)-(line 1973,col 60)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.appendProperty(java.util.Properties, java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"Properties#getProperty","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#getProperty'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"Properties#setProperty","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#setProperty'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a Properties object in which to look up the property","javadocBlockTagName":"p","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Properties object in which to look up the property'}]}', name=Optional[p]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of the property to look up","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the property to look up'}]}', name=Optional[key]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"value to set the property to, if it is not already set","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to set the property to, if it is not already set'}]}', name=Optional[value]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the previous value of the property","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the previous value of the property'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String setDefaultMaybe(Properties p, String key, String value)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n        p.setProperty(key, value);\n    }\n    return currentValue;\n}","methodRange":"(line 1985,col 3)-(line 1991,col 3)","methodTokenRange":"public static \/*@Nullable*\/ String setDefaultMaybe(Properties p, String key, String value) {\n    String currentValue = p.getProperty(key);\n    if (currentValue == null) {\n      p.setProperty(key, value);\n    }\n    return currentValue;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Set the property only if it was not previously set.\n   * @see Properties#getProperty\n   * @see Properties#setProperty\n   * @param p a Properties object in which to look up the property\n   * @param key name of the property to look up\n   * @param value value to set the property to, if it is not already set\n   * @return the previous value of the property\n   ","methodParameters":[{"parameterType":"Properties","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Properties, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Properties","parameter":"Properties p","parameterName":"p"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String key","parameterName":"key"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String value","parameterName":"value"}],"methodName":"setDefaultMaybe","methodQualifiedSignature":"plume.UtilMDE.setDefaultMaybe","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the property only if it was not previously set.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#getProperty'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='Properties#setProperty'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a Properties object in which to look up the property'}]}', name=Optional[p]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of the property to look up'}]}', name=Optional[key]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='value to set the property to, if it is not already set'}]}', name=Optional[value]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the previous value of the property'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1987,col 25)-(line 1987,col 28)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.setDefaultMaybe(java.util.Properties, java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"object in which to set the field","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object in which to set the field'}]}', name=Optional[o]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of field to set","javadocBlockTagName":"fieldName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of field to set'}]}', name=Optional[fieldName]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"new value of field","javadocBlockTagName":"value","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new value of field'}]}', name=Optional[value]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the field does not exist in the object","javadocBlockTagName":"NoSuchFieldException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the field does not exist in the object'}]}', name=Optional[NoSuchFieldException]}"}],"methodDeclaration":"public static void setFinalField(Object o, String fieldName, Object value) throws NoSuchFieldException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            f.set(o, value);\n            return;\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                throw e;\n            }\n        } catch (IllegalAccessException e) {\n            throw new Error(\"This can't happen: \" + e);\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}","methodRange":"(line 2018,col 3)-(line 2039,col 3)","methodTokenRange":"public static void setFinalField(Object o, String fieldName, \/*@Nullable*\/ Object value)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { \/\/ Class is interned\n      \/\/ System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        f.set(o, value);\n        return;\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { \/\/ Class is interned\n          throw e;\n        }\n      } catch (IllegalAccessException e) {\n        throw new Error(\"This can't happen: \" + e);\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Sets the given field, which may be final and\/or private.\n   * Leaves the field accessible.\n   * Intended for use in readObject and nowhere else!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @param value new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fieldName","parameterName":"fieldName"},{"parameterType":"Object","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object value","parameterName":"value"}],"methodName":"setFinalField","methodQualifiedSignature":"plume.UtilMDE.setFinalField","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Sets the given field, which may be final and\/or private.\nLeaves the field accessible.\nIntended for use in readObject and nowhere else!'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object in which to set the field'}]}', name=Optional[o]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of field to set'}]}', name=Optional[fieldName]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new value of field'}]}', name=Optional[value]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the field does not exist in the object'}]}', name=Optional[NoSuchFieldException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2025,col 25)-(line 2025,col 28)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2033,col 25)-(line 2033,col 45)","literalExprId":2,"literalExpr":"\"This can't happen: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2036,col 19)-(line 2036,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2036,col 26)-(line 2036,col 91)","literalExprId":4,"literalExpr":"\"@AssumeAssertion(nullness): c was not Object, so is not null now\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.setFinalField(java.lang.Object, java.lang.String, java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"object in which to set the field","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object in which to set the field'}]}', name=Optional[o]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"name of field to set","javadocBlockTagName":"fieldName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of field to set'}]}', name=Optional[fieldName]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"new value of field","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new value of field'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the field does not exist in the object","javadocBlockTagName":"NoSuchFieldException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the field does not exist in the object'}]}', name=Optional[NoSuchFieldException]}"}],"methodDeclaration":"public static Object getPrivateField(Object o, String fieldName) throws NoSuchFieldException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Class<?> c = o.getClass();\n    while (c != Object.class) {\n        try {\n            Field f = c.getDeclaredField(fieldName);\n            f.setAccessible(true);\n            return f.get(o);\n        } catch (IllegalAccessException e) {\n            System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n            throw new Error(\"This can't happen: \" + e);\n        } catch (NoSuchFieldException e) {\n            if (c.getSuperclass() == Object.class) {\n                throw e;\n            }\n        }\n        c = c.getSuperclass();\n        assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n}","methodRange":"(line 2051,col 3)-(line 2073,col 3)","methodTokenRange":"public static \/*@Nullable*\/ Object getPrivateField(Object o, String fieldName)\n      throws NoSuchFieldException {\n    Class<?> c = o.getClass();\n    while (c != Object.class) { \/\/ Class is interned\n      \/\/ System.out.printf (\"Setting field %s in %s%n\", fieldName, c);\n      try {\n        Field f = c.getDeclaredField(fieldName);\n        f.setAccessible(true);\n        return f.get(o);\n      } catch (IllegalAccessException e) {\n        System.out.println(\"in getPrivateField, IllegalAccessException: \" + e);\n        throw new Error(\"This can't happen: \" + e);\n      } catch (NoSuchFieldException e) {\n        if (c.getSuperclass() == Object.class) { \/\/ Class is interned\n          throw e;\n        }\n        \/\/ nothing to do; will now examine superclass\n      }\n      c = c.getSuperclass();\n      assert c != null : \"@AssumeAssertion(nullness): c was not Object, so is not null now\";\n    }\n    throw new NoSuchFieldException(fieldName);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Reads the given field, which may be private.\n   * Leaves the field accessible.\n   * Use with care!\n   * @param o object in which to set the field\n   * @param fieldName name of field to set\n   * @return new value of field\n   * @throws NoSuchFieldException if the field does not exist in the object\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fieldName","parameterName":"fieldName"}],"methodName":"getPrivateField","methodQualifiedSignature":"plume.UtilMDE.getPrivateField","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the given field, which may be private.\nLeaves the field accessible.\nUse with care!'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object in which to set the field'}]}', name=Optional[o]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='name of field to set'}]}', name=Optional[fieldName]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='new value of field'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the field does not exist in the object'}]}', name=Optional[NoSuchFieldException]}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 2058,col 25)-(line 2058,col 28)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2061,col 28)-(line 2061,col 73)","literalExprId":2,"literalExpr":"\"in getPrivateField, IllegalAccessException: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2062,col 25)-(line 2062,col 45)","literalExprId":3,"literalExpr":"\"This can't happen: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2070,col 19)-(line 2070,col 22)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2070,col 26)-(line 2070,col 91)","literalExprId":5,"literalExpr":"\"@AssumeAssertion(nullness): c was not Object, so is not null now\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.getPrivateField(java.lang.Object, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a set in which to look up the value","javadocBlockTagName":"set","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a set in which to look up the value'}]}', name=Optional[set]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the value to look up in the set","javadocBlockTagName":"key","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to look up in the set'}]}', name=Optional[key]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the object in this set that is equal to key, or null","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the object in this set that is equal to key, or null'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Object getFromSet(Set<?> set, Object key)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (key == null) {\n        return null;\n    }\n    for (Object elt : set) {\n        if (key.equals(elt)) {\n            return elt;\n        }\n    }\n    return null;\n}","methodRange":"(line 2087,col 3)-(line 2097,col 3)","methodTokenRange":"public static \/*@Nullable*\/ Object getFromSet(Set<?> set, Object key) {\n    if (key == null) {\n      return null;\n    }\n    for (Object elt : set) {\n      if (key.equals(elt)) {\n        return elt;\n      }\n    }\n    return null;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the object in this set that is equal to key.\n   * The Set abstraction doesn't provide this; it only provides \"contains\".\n   * Returns null if the argument is null, or if it isn't in the set.\n   * @param set a set in which to look up the value\n   * @param key the value to look up in the set\n   * @return the object in this set that is equal to key, or null\n   ","methodParameters":[{"parameterType":"Set<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Set, typeParametersMap=TypeParametersMap{nameToValue={java.util.Set.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.Set<?>","parameter":"Set<?> set","parameterName":"set"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object key","parameterName":"key"}],"methodName":"getFromSet","methodQualifiedSignature":"plume.UtilMDE.getFromSet","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the object in this set that is equal to key.\nThe Set abstraction doesn't provide this; it only provides \"contains\".\nReturns null if the argument is null, or if it isn't in the set.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a set in which to look up the value'}]}', name=Optional[set]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the value to look up in the set'}]}', name=Optional[key]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the object in this set that is equal to key, or null'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 2088,col 16)-(line 2088,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2089,col 14)-(line 2089,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2096,col 12)-(line 2096,col 15)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.getFromSet(java.util.Set<?>, java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"input stream","javadocBlockTagName":"from","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream'}]}', name=Optional[from]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"output stream","javadocBlockTagName":"to","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='output stream'}]}', name=Optional[to]}"}],"methodDeclaration":"public static void streamCopy(InputStream from, OutputStream to)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n        while (true) {\n            bytes = from.read(buffer);\n            if (bytes == -1) {\n                return;\n            }\n            to.write(buffer, 0, bytes);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        throw new Error(e);\n    }\n}","methodRange":"(line 2107,col 3)-(line 2122,col 3)","methodTokenRange":"public static void streamCopy(InputStream from, OutputStream to) {\n    byte[] buffer = new byte[1024];\n    int bytes;\n    try {\n      while (true) {\n        bytes = from.read(buffer);\n        if (bytes == -1) {\n          return;\n        }\n        to.write(buffer, 0, bytes);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Copy the contents of the input stream to the output stream.\n   * @param from input stream\n   * @param to output stream\n   ","methodParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream from","parameterName":"from"},{"parameterType":"OutputStream","parameterId":2,"parameterTypeResolved":"ReferenceType{java.io.OutputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.OutputStream","parameter":"OutputStream to","parameterName":"to"}],"methodName":"streamCopy","methodQualifiedSignature":"plume.UtilMDE.streamCopy","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Copy the contents of the input stream to the output stream.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream'}]}', name=Optional[from]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='output stream'}]}', name=Optional[to]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2108,col 30)-(line 2108,col 33)","literalExprId":1,"literalExpr":"1024","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2111,col 14)-(line 2111,col 17)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2113,col 23)-(line 2113,col 23)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2116,col 26)-(line 2116,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.streamCopy(java.io.InputStream, java.io.OutputStream)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"input stream to read","javadocBlockTagName":"is","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream to read'}]}', name=Optional[is]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a String containing all the characters from the input stream","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String containing all the characters from the input stream'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String streamString(InputStream is)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n}","methodRange":"(line 2128,col 3)-(line 2132,col 3)","methodTokenRange":"public static String streamString(InputStream is) {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    streamCopy(is, baos);\n    return baos.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Return a String containing all the characters from the input stream.\n   * @param is input stream to read\n   * @return a String containing all the characters from the input stream\n   ","methodParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream is","parameterName":"is"}],"methodName":"streamString","methodQualifiedSignature":"plume.UtilMDE.streamString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a String containing all the characters from the input stream.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='input stream to read'}]}', name=Optional[is]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String containing all the characters from the input stream'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.streamString(java.io.InputStream)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to do replacement in","javadocBlockTagName":"target","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to do replacement in'}]}', name=Optional[target]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the substring to replace","javadocBlockTagName":"oldStr","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the substring to replace'}]}', name=Optional[oldStr]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the replacement","javadocBlockTagName":"newStr","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the replacement'}]}', name=Optional[newStr]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"target with all instances of oldStr replaced by newStr","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='target with all instances of oldStr replaced by newStr'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String replaceString(String target, String oldStr, String newStr)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (oldStr.equals(\"\")) {\n        throw new IllegalArgumentException();\n    }\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n        result.append(target.substring(lastend, pos));\n        result.append(newStr);\n        lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n}","methodRange":"(line 2146,col 3)-(line 2161,col 3)","methodTokenRange":"public static String replaceString(String target, String oldStr, String newStr) {\n    if (oldStr.equals(\"\")) {\n      throw new IllegalArgumentException();\n    }\n\n    StringBuffer result = new StringBuffer();\n    int lastend = 0;\n    int pos;\n    while ((pos = target.indexOf(oldStr, lastend)) != -1) {\n      result.append(target.substring(lastend, pos));\n      result.append(newStr);\n      lastend = pos + oldStr.length();\n    }\n    result.append(target.substring(lastend));\n    return result.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a new string which is the text of target with all instances of\n   * oldStr replaced by newStr.\n   * @param target the string to do replacement in\n   * @param oldStr the substring to replace\n   * @param newStr the replacement\n   * @return target with all instances of oldStr replaced by newStr\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String target","parameterName":"target"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String oldStr","parameterName":"oldStr"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String newStr","parameterName":"newStr"}],"methodName":"replaceString","methodQualifiedSignature":"plume.UtilMDE.replaceString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a new string which is the text of target with all instances of\noldStr replaced by newStr.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to do replacement in'}]}', name=Optional[target]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the substring to replace'}]}', name=Optional[oldStr]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the replacement'}]}', name=Optional[newStr]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='target with all instances of oldStr replaced by newStr'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2147,col 23)-(line 2147,col 24)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2152,col 19)-(line 2152,col 19)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2154,col 56)-(line 2154,col 56)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.replaceString(java.lang.String, java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"#split(String s, String delim)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#split(String s, String delim)'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to split","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to split'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"delimiter to split the string on","javadocBlockTagName":"delim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to split the string on'}]}', name=Optional[delim]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"array of length at least 1, containing s split on delimiter","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='array of length at least 1, containing s split on delimiter'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] split(String s, char delim)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new String[result_list.size()]);\n    return result;\n}","methodRange":"(line 2173,col 3)-(line 2184,col 3)","methodTokenRange":"public static String[] split(String s, char delim) {\n    ArrayList<String> result_list = new ArrayList<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + 1);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") \/\/ Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new \/*@NonNull*\/ String[result_list.size()]);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter character.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, String delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"char","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='char'}","parameterTypeResolvedDescribed":"char","parameter":"char delim","parameterName":"delim"}],"methodName":"split","methodQualifiedSignature":"plume.UtilMDE.split","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of Strings representing the characters between\nsuccessive instances of the delimiter character.\nAlways returns an array of length at least 1 (it might contain only the\nempty string).'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#split(String s, String delim)'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to split'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to split the string on'}]}', name=Optional[delim]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='array of length at least 1, containing s split on delimiter'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 2175,col 56)-(line 2175,col 56)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2176,col 35)-(line 2176,col 35)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2177,col 34)-(line 2177,col 34)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2181,col 9)-(line 2181,col 41)","literalExprId":4,"literalExpr":"\"nullness:new.array.type.invalid\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.split(java.lang.String, char)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"#split(String s, char delim)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#split(String s, char delim)'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to split","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to split'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"delimiter to split the string on","javadocBlockTagName":"delim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to split the string on'}]}', name=Optional[delim]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"array of length at least 1, containing s split on delimiter","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='array of length at least 1, containing s split on delimiter'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] split(String s, String delim)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n        throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n        result_list.add(s.substring(0, delimpos));\n        s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\"nullness:new.array.type.invalid\")\n    String[] result = result_list.toArray(new String[result_list.size()]);\n    return result;\n}","methodRange":"(line 2196,col 3)-(line 2211,col 3)","methodTokenRange":"public static String[] split(String s, String delim) {\n    int delimlen = delim.length();\n    if (delimlen == 0) {\n      throw new Error(\"Second argument to split was empty.\");\n    }\n    Vector<String> result_list = new Vector<String>();\n    for (int delimpos = s.indexOf(delim); delimpos != -1; delimpos = s.indexOf(delim)) {\n      result_list.add(s.substring(0, delimpos));\n      s = s.substring(delimpos + delimlen);\n    }\n    result_list.add(s);\n    @SuppressWarnings(\n        \"nullness:new.array.type.invalid\") \/\/ Checker Framework bug: issue 153 (also @NonNull annotation on next line)\n    String[] result = result_list.toArray(new \/*@NonNull*\/ String[result_list.size()]);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Return an array of Strings representing the characters between\n   * successive instances of the delimiter String.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @param delim delimiter to split the string on\n   * @return array of length at least 1, containing s split on delimiter\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delim","parameterName":"delim"}],"methodName":"split","methodQualifiedSignature":"plume.UtilMDE.split","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of Strings representing the characters between\nsuccessive instances of the delimiter String.\nAlways returns an array of length at least 1 (it might contain only the\nempty string).'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#split(String s, char delim)'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to split'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to split the string on'}]}', name=Optional[delim]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='array of length at least 1, containing s split on delimiter'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 2198,col 21)-(line 2198,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2199,col 23)-(line 2199,col 59)","literalExprId":2,"literalExpr":"\"Second argument to split was empty.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2202,col 56)-(line 2202,col 56)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2203,col 35)-(line 2203,col 35)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2208,col 9)-(line 2208,col 41)","literalExprId":5,"literalExpr":"\"nullness:new.array.type.invalid\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.split(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"#split(String s, char delim)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#split(String s, char delim)'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the string to split","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to split'}]}', name=Optional[s]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array of Strings, one for each line in the argument","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of Strings, one for each line in the argument'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] splitLines(String s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n}","methodRange":"(line 2223,col 3)-(line 2225,col 3)","methodTokenRange":"public static String[] splitLines(String s) {\n    return s.split(\"\\r\\n?|\\n\\r?\", -1);\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Return an array of Strings, one for each line in the argument.\n   * Always returns an array of length at least 1 (it might contain only the\n   * empty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\n   * are supported.  Note that a string that ends with a line separator\n   * will return an empty string as the last element of the array.\n   * @see #split(String s, char delim)\n   * @param s the string to split\n   * @return an array of Strings, one for each line in the argument\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"methodName":"splitLines","methodQualifiedSignature":"plume.UtilMDE.splitLines","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array of Strings, one for each line in the argument.\nAlways returns an array of length at least 1 (it might contain only the\nempty string).  All common line separators (cr, lf, cr-lf, or lf-cr)\nare supported.  Note that a string that ends with a line separator\nwill return an empty string as the last element of the array.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#split(String s, char delim)'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the string to split'}]}', name=Optional[s]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array of Strings, one for each line in the argument'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 2224,col 20)-(line 2224,col 32)","literalExprId":1,"literalExpr":"\"\\r\\n?|\\n\\r?\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2224,col 36)-(line 2224,col 36)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.splitLines(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"plume.ArraysMDE#toString(int[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='plume.ArraysMDE#toString(int[])'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of values to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of values to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"delimiter to place between printed representations","javadocBlockTagName":"delim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to place between printed representations'}]}', name=Optional[delim]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the concatenation of the string representations of the values, with the delimiter between","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, with the delimiter between'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String join(Object[] a, String delim)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        return \"\";\n    }\n    if (a.length == 1) {\n        return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n        sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n}","methodRange":"(line 2235,col 3)-(line 2247,col 3)","methodTokenRange":"public static String join(Object[] a, String delim) {\n    if (a.length == 0) {\n      return \"\";\n    }\n    if (a.length == 1) {\n      return String.valueOf(a[0]);\n    }\n    StringBuffer sb = new StringBuffer(String.valueOf(a[0]));\n    for (int i = 1; i < a.length; i++) {\n      sb.append(delim).append(a[i]);\n    }\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Concatenate the string representations of the array elements, placing the\n   * delimiter between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   ","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delim","parameterName":"delim"}],"methodName":"join","methodQualifiedSignature":"plume.UtilMDE.join","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Concatenate the string representations of the array elements, placing the\ndelimiter between them.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='plume.ArraysMDE#toString(int[])'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of values to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to place between printed representations'}]}', name=Optional[delim]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, with the delimiter between'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2236,col 21)-(line 2236,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2237,col 14)-(line 2237,col 15)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2239,col 21)-(line 2239,col 21)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2240,col 31)-(line 2240,col 31)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2242,col 57)-(line 2242,col 57)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2243,col 18)-(line 2243,col 18)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.join(java.lang.Object[], java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"plume.ArraysMDE#toString(int[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='plume.ArraysMDE#toString(int[])'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"array of values to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of values to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the concatenation of the string representations of the values, each on its own line","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, each on its own line'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String joinLines(Object... a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return join(a, lineSep);\n}","methodRange":"(line 2256,col 3)-(line 2258,col 3)","methodTokenRange":"public static String joinLines(Object... a) {\n    return join(a, lineSep);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see plume.ArraysMDE#toString(int[])\n   * @param a array of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... a","parameterName":"a"}],"methodName":"joinLines","methodQualifiedSignature":"plume.UtilMDE.joinLines","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Concatenate the string representations of the objects, placing the\nsystem-specific line separator between them.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='plume.ArraysMDE#toString(int[])'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='array of values to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, each on its own line'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.joinLines(java.lang.Object...)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.AbstractCollection#toString()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.AbstractCollection#toString()'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"list of values to concatenate","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of values to concatenate'}]}', name=Optional[v]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"delimiter to place between printed representations","javadocBlockTagName":"delim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to place between printed representations'}]}', name=Optional[delim]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the concatenation of the string representations of the values, with the delimiter between","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, with the delimiter between'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String join(List<?> v, String delim)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (v.size() == 0) {\n        return \"\";\n    }\n    if (v.size() == 1) {\n        return Objects.toString(v.get(0));\n    }\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n        sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n}","methodRange":"(line 2268,col 3)-(line 2281,col 3)","methodTokenRange":"public static String join(List<?> v, String delim) {\n    if (v.size() == 0) {\n      return \"\";\n    }\n    if (v.size() == 1) {\n      return Objects.toString(v.get(0));\n    }\n    \/\/ This should perhaps use an iterator rather than get(), for efficiency.\n    StringBuffer sb = new StringBuffer(Objects.toString(v.get(0)));\n    for (int i = 1; i < v.size(); i++) {\n      sb.append(delim).append(v.get(i));\n    }\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Concatenate the string representations of the objects, placing the\n   * delimiter between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @param delim delimiter to place between printed representations\n   * @return the concatenation of the string representations of the values, with the delimiter between\n   ","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> v","parameterName":"v"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delim","parameterName":"delim"}],"methodName":"join","methodQualifiedSignature":"plume.UtilMDE.join","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Concatenate the string representations of the objects, placing the\ndelimiter between them.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.AbstractCollection#toString()'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of values to concatenate'}]}', name=Optional[v]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='delimiter to place between printed representations'}]}', name=Optional[delim]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, with the delimiter between'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2269,col 21)-(line 2269,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2270,col 14)-(line 2270,col 15)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2272,col 21)-(line 2272,col 21)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2273,col 37)-(line 2273,col 37)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2276,col 63)-(line 2276,col 63)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2277,col 18)-(line 2277,col 18)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.join(java.util.List<?>, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.AbstractCollection#toString()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.AbstractCollection#toString()'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"list of values to concatenate","javadocBlockTagName":"v","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of values to concatenate'}]}', name=Optional[v]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the concatenation of the string representations of the values, each on its own line","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, each on its own line'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String joinLines(List<String> v)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return join(v, lineSep);\n}","methodRange":"(line 2290,col 3)-(line 2292,col 3)","methodTokenRange":"public static String joinLines(List<String> v) {\n    return join(v, lineSep);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Concatenate the string representations of the objects, placing the\n   * system-specific line separator between them.\n   * @see java.util.AbstractCollection#toString()\n   * @param v list of values to concatenate\n   * @return the concatenation of the string representations of the values, each on its own line\n   ","methodParameters":[{"parameterType":"List<String>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<java.lang.String>","parameter":"List<String> v","parameterName":"v"}],"methodName":"joinLines","methodQualifiedSignature":"plume.UtilMDE.joinLines","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Concatenate the string representations of the objects, placing the\nsystem-specific line separator between them.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.AbstractCollection#toString()'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of values to concatenate'}]}', name=Optional[v]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the concatenation of the string representations of the values, each on its own line'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.joinLines(java.util.List<java.lang.String>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to quote","javadocBlockTagName":"orig","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to quote'}]}', name=Optional[orig]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"quoted version of orig","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of orig'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String escapeNonJava(String orig)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuffer sb = new StringBuffer();\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        switch(c) {\n            case '\\\"':\n            case '\\\\':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append('\\\\');\n                post_esc = i;\n                break;\n            case '\\n':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\n\");\n                post_esc = i + 1;\n                break;\n            case '\\r':\n                if (post_esc < i) {\n                    sb.append(orig.substring(post_esc, i));\n                }\n                sb.append(\"\\\\r\");\n                post_esc = i + 1;\n                break;\n            default:\n        }\n    }\n    if (sb.length() == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}","methodRange":"(line 2303,col 3)-(line 2342,col 3)","methodTokenRange":"public static String escapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    \/\/ The previous escape character was seen right before this position.\n    int post_esc = 0;\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      switch (c) {\n        case '\\\"':\n        case '\\\\':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append('\\\\');\n          post_esc = i;\n          break;\n        case '\\n': \/\/ not lineSep\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\n\"); \/\/ not lineSep\n          post_esc = i + 1;\n          break;\n        case '\\r':\n          if (post_esc < i) {\n            sb.append(orig.substring(post_esc, i));\n          }\n          sb.append(\"\\\\r\");\n          post_esc = i + 1;\n          break;\n        default:\n          \/\/ Nothing to do: i gets incremented\n      }\n    }\n    if (sb.length() == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Escape \\, \", newline, and carriage-return characters in the\n   * target as \\\\, \\\", \\n, and \\r; return a new string if any\n   * modifications were necessary.  The intent is that by surrounding\n   * the return value with double quote marks, the result will be a\n   * Java string literal denoting the original string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String orig","parameterName":"orig"}],"methodName":"escapeNonJava","methodQualifiedSignature":"plume.UtilMDE.escapeNonJava","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Escape \\, \", newline, and carriage-return characters in the\ntarget as \\\\, \\\", \\n, and \\r; return a new string if any\nmodifications were necessary.  The intent is that by surrounding\nthe return value with double quote marks, the result will be a\nJava string literal denoting the original string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to quote'}]}', name=Optional[orig]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of orig'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2306,col 20)-(line 2306,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2308,col 18)-(line 2308,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2311,col 14)-(line 2311,col 17)","literalExprId":3,"literalExpr":"'\\\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2312,col 14)-(line 2312,col 17)","literalExprId":4,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2316,col 21)-(line 2316,col 24)","literalExprId":5,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2319,col 14)-(line 2319,col 17)","literalExprId":6,"literalExpr":"'\\n'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2323,col 21)-(line 2323,col 25)","literalExprId":7,"literalExpr":"\"\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2324,col 26)-(line 2324,col 26)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2326,col 14)-(line 2326,col 17)","literalExprId":9,"literalExpr":"'\\r'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2330,col 21)-(line 2330,col 25)","literalExprId":10,"literalExpr":"\"\\\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2331,col 26)-(line 2331,col 26)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2337,col 24)-(line 2337,col 24)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.escapeNonJava(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"character to quote","javadocBlockTagName":"ch","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character to quote'}]}', name=Optional[ch]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"quoted version och ch","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version och ch'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String escapeNonJava(Character ch)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    char c = ch.charValue();\n    switch(c) {\n        case '\\\"':\n            return \"\\\\\\\"\";\n        case '\\\\':\n            return \"\\\\\\\\\";\n        case '\\n':\n            return \"\\\\n\";\n        case '\\r':\n            return \"\\\\r\";\n        default:\n            return new String(new char[] { c });\n    }\n}","methodRange":"(line 2350,col 3)-(line 2364,col 3)","methodTokenRange":"public static String escapeNonJava(Character ch) {\n    char c = ch.charValue();\n    switch (c) {\n      case '\\\"':\n        return \"\\\\\\\"\";\n      case '\\\\':\n        return \"\\\\\\\\\";\n      case '\\n': \/\/ not lineSep\n        return \"\\\\n\"; \/\/ not lineSep\n      case '\\r':\n        return \"\\\\r\";\n      default:\n        return new String(new char[] {c});\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Like {@link #escapeNonJava(String)}, but for a single character.\n   * @param ch character to quote\n   * @return quoted version och ch\n   ","methodParameters":[{"parameterType":"Character","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Character, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Character","parameter":"Character ch","parameterName":"ch"}],"methodName":"escapeNonJava","methodQualifiedSignature":"plume.UtilMDE.escapeNonJava","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Like '}, JavadocInlineTag{tagName='link', type=LINK, content=' #escapeNonJava(String)'}, JavadocSnippet{text=', but for a single character.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character to quote'}]}', name=Optional[ch]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version och ch'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2353,col 12)-(line 2353,col 15)","literalExprId":1,"literalExpr":"'\\\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2354,col 16)-(line 2354,col 21)","literalExprId":2,"literalExpr":"\"\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2355,col 12)-(line 2355,col 15)","literalExprId":3,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2356,col 16)-(line 2356,col 21)","literalExprId":4,"literalExpr":"\"\\\\\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2357,col 12)-(line 2357,col 15)","literalExprId":5,"literalExpr":"'\\n'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2358,col 16)-(line 2358,col 20)","literalExprId":6,"literalExpr":"\"\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2359,col 12)-(line 2359,col 15)","literalExprId":7,"literalExpr":"'\\r'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2360,col 16)-(line 2360,col 20)","literalExprId":8,"literalExpr":"\"\\\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.escapeNonJava(java.lang.Character)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to quote","javadocBlockTagName":"orig","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to quote'}]}', name=Optional[orig]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"quoted version of orig","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of orig'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String escapeNonASCII(String orig)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n        char c = orig.charAt(i);\n        sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n}","methodRange":"(line 2373,col 3)-(line 2381,col 3)","methodTokenRange":"public static String escapeNonASCII(String orig) {\n    StringBuffer sb = new StringBuffer();\n    int orig_len = orig.length();\n    for (int i = 0; i < orig_len; i++) {\n      char c = orig.charAt(i);\n      sb.append(escapeNonASCII(c));\n    }\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Escape unprintable characters in the target, following the usual\n   * Java backslash conventions, so that the result is sure to be\n   * printable ASCII.  Returns a new string.\n   * @param orig string to quote\n   * @return quoted version of orig\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String orig","parameterName":"orig"}],"methodName":"escapeNonASCII","methodQualifiedSignature":"plume.UtilMDE.escapeNonASCII","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Escape unprintable characters in the target, following the usual\nJava backslash conventions, so that the result is sure to be\nprintable ASCII.  Returns a new string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to quote'}]}', name=Optional[orig]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of orig'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2376,col 18)-(line 2376,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.escapeNonASCII(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"character to quote","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character to quote'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"quoted version of c","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of c'}]}', name=Optional.empty}"}],"methodDeclaration":"private static String escapeNonASCII(char c)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (c == '\"') {\n        return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n        return \"\\\\\\\\\";\n    } else if (c == '\\n') {\n        return \"\\\\n\";\n    } else if (c == '\\r') {\n        return \"\\\\r\";\n    } else if (c == '\\t') {\n        return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n        return new String(new char[] { c });\n    } else if (c < 256) {\n        String octal = Integer.toOctalString(c);\n        while (octal.length() < 3) {\n            octal = '0' + octal;\n        }\n        return \"\\\\\" + octal;\n    } else {\n        String hex = Integer.toHexString(c);\n        while (hex.length() < 4) {\n            hex = \"0\" + hex;\n        }\n        return \"\\\\u\" + hex;\n    }\n}","methodRange":"(line 2389,col 3)-(line 2415,col 3)","methodTokenRange":"private static String escapeNonASCII(char c) {\n    if (c == '\"') {\n      return \"\\\\\\\"\";\n    } else if (c == '\\\\') {\n      return \"\\\\\\\\\";\n    } else if (c == '\\n') { \/\/ not lineSep\n      return \"\\\\n\"; \/\/ not lineSep\n    } else if (c == '\\r') {\n      return \"\\\\r\";\n    } else if (c == '\\t') {\n      return \"\\\\t\";\n    } else if (c >= ' ' && c <= '~') {\n      return new String(new char[] {c});\n    } else if (c < 256) {\n      String octal = Integer.toOctalString(c);\n      while (octal.length() < 3) {\n        octal = '0' + octal;\n      }\n      return \"\\\\\" + octal;\n    } else {\n      String hex = Integer.toHexString(c);\n      while (hex.length() < 4) {\n        hex = \"0\" + hex;\n      }\n      return \"\\\\u\" + hex;\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Like escapeNonJava(), but quote more characters so that the\n   * result is sure to be printable ASCII. Not particularly optimized.\n   * @param c character to quote\n   * @return quoted version of c\n   ","methodParameters":[{"parameterType":"char","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='char'}","parameterTypeResolvedDescribed":"char","parameter":"char c","parameterName":"c"}],"methodName":"escapeNonASCII","methodQualifiedSignature":"plume.UtilMDE.escapeNonASCII","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Like escapeNonJava(), but quote more characters so that the\nresult is sure to be printable ASCII. Not particularly optimized.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character to quote'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of c'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2390,col 14)-(line 2390,col 16)","literalExprId":1,"literalExpr":"'\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2391,col 14)-(line 2391,col 19)","literalExprId":2,"literalExpr":"\"\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2392,col 21)-(line 2392,col 24)","literalExprId":3,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2393,col 14)-(line 2393,col 19)","literalExprId":4,"literalExpr":"\"\\\\\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2394,col 21)-(line 2394,col 24)","literalExprId":5,"literalExpr":"'\\n'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2395,col 14)-(line 2395,col 18)","literalExprId":6,"literalExpr":"\"\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2396,col 21)-(line 2396,col 24)","literalExprId":7,"literalExpr":"'\\r'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2397,col 14)-(line 2397,col 18)","literalExprId":8,"literalExpr":"\"\\\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2398,col 21)-(line 2398,col 24)","literalExprId":9,"literalExpr":"'\\t'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2399,col 14)-(line 2399,col 18)","literalExprId":10,"literalExpr":"\"\\\\t\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2400,col 21)-(line 2400,col 23)","literalExprId":11,"literalExpr":"' '","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2400,col 33)-(line 2400,col 35)","literalExprId":12,"literalExpr":"'~'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2402,col 20)-(line 2402,col 22)","literalExprId":13,"literalExpr":"256","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2404,col 31)-(line 2404,col 31)","literalExprId":14,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2405,col 17)-(line 2405,col 19)","literalExprId":15,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2407,col 14)-(line 2407,col 17)","literalExprId":16,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2410,col 29)-(line 2410,col 29)","literalExprId":17,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2411,col 15)-(line 2411,col 17)","literalExprId":18,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2413,col 14)-(line 2413,col 18)","literalExprId":19,"literalExpr":"\"\\\\u\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.escapeNonASCII(char)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to quoto","javadocBlockTagName":"orig","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to quoto'}]}', name=Optional[orig]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"quoted version of orig","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of orig'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String unescapeNonJava(String orig)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuffer sb = new StringBuffer();\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n        if (this_esc == orig.length() - 1) {\n            sb.append(orig.substring(post_esc, this_esc + 1));\n            post_esc = this_esc + 1;\n            break;\n        }\n        switch(orig.charAt(this_esc + 1)) {\n            case 'n':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\n');\n                post_esc = this_esc + 2;\n                break;\n            case 'r':\n                sb.append(orig.substring(post_esc, this_esc));\n                sb.append('\\r');\n                post_esc = this_esc + 2;\n                break;\n            case '\\\\':\n                sb.append(orig.substring(post_esc, this_esc + 1));\n                post_esc = this_esc + 2;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                sb.append(orig.substring(post_esc, this_esc));\n                char octal_char = 0;\n                int ii = this_esc + 1;\n                while (ii < orig.length()) {\n                    char ch = orig.charAt(ii++);\n                    if ((ch < '0') || (ch > '8')) {\n                        break;\n                    }\n                    octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n                }\n                sb.append(octal_char);\n                post_esc = ii - 1;\n                break;\n            default:\n                sb.append(orig.substring(post_esc, this_esc));\n                post_esc = this_esc + 1;\n                break;\n        }\n        this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n        return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n}","methodRange":"(line 2426,col 3)-(line 2494,col 3)","methodTokenRange":"public static String unescapeNonJava(String orig) {\n    StringBuffer sb = new StringBuffer();\n    \/\/ The previous escape character was seen just before this position.\n    int post_esc = 0;\n    int this_esc = orig.indexOf('\\\\');\n    while (this_esc != -1) {\n      if (this_esc == orig.length() - 1) {\n        sb.append(orig.substring(post_esc, this_esc + 1));\n        post_esc = this_esc + 1;\n        break;\n      }\n      switch (orig.charAt(this_esc + 1)) {\n        case 'n':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\n'); \/\/ not lineSep\n          post_esc = this_esc + 2;\n          break;\n        case 'r':\n          sb.append(orig.substring(post_esc, this_esc));\n          sb.append('\\r');\n          post_esc = this_esc + 2;\n          break;\n        case '\\\\':\n          \/\/ This is not in the default case because the search would find\n          \/\/ the quoted backslash.  Here we incluce the first backslash in\n          \/\/ the output, but not the first.\n          sb.append(orig.substring(post_esc, this_esc + 1));\n          post_esc = this_esc + 2;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          sb.append(orig.substring(post_esc, this_esc));\n          char octal_char = 0;\n          int ii = this_esc + 1;\n          while (ii < orig.length()) {\n            char ch = orig.charAt(ii++);\n            if ((ch < '0') || (ch > '8')) {\n              break;\n            }\n            octal_char = (char) ((octal_char * 8) + Character.digit(ch, 8));\n          }\n          sb.append(octal_char);\n          post_esc = ii - 1;\n          break;\n\n        default:\n          \/\/ In the default case, retain the character following the backslash,\n          \/\/ but discard the backslash itself.  \"\\*\" is just a one-character string.\n          sb.append(orig.substring(post_esc, this_esc));\n          post_esc = this_esc + 1;\n          break;\n      }\n      this_esc = orig.indexOf('\\\\', post_esc);\n    }\n    if (post_esc == 0) {\n      return orig;\n    }\n    sb.append(orig.substring(post_esc));\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\n   * one-character equivalents.  All other backslashes are removed\n   * (for instance, octal\/hex escape sequences are not turned into\n   * their respective characters). This is the inverse operation of\n   * escapeNonJava(). Previously known as unquote().\n   * @param orig string to quoto\n   * @return quoted version of orig\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String orig","parameterName":"orig"}],"methodName":"unescapeNonJava","methodQualifiedSignature":"plume.UtilMDE.unescapeNonJava","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Replace \"\\\\\", \"\\\"\", \"\\n\", and \"\\r\" sequences by their\none-character equivalents.  All other backslashes are removed\n(for instance, octal\/hex escape sequences are not turned into\ntheir respective characters). This is the inverse operation of\nescapeNonJava(). Previously known as unquote().'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to quoto'}]}', name=Optional[orig]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='quoted version of orig'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2429,col 20)-(line 2429,col 20)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2430,col 33)-(line 2430,col 36)","literalExprId":2,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2431,col 25)-(line 2431,col 25)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2432,col 39)-(line 2432,col 39)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2433,col 55)-(line 2433,col 55)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2434,col 31)-(line 2434,col 31)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2437,col 38)-(line 2437,col 38)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2438,col 14)-(line 2438,col 16)","literalExprId":8,"literalExpr":"'n'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2440,col 21)-(line 2440,col 24)","literalExprId":9,"literalExpr":"'\\n'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2441,col 33)-(line 2441,col 33)","literalExprId":10,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2443,col 14)-(line 2443,col 16)","literalExprId":11,"literalExpr":"'r'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2445,col 21)-(line 2445,col 24)","literalExprId":12,"literalExpr":"'\\r'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2446,col 33)-(line 2446,col 33)","literalExprId":13,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2448,col 14)-(line 2448,col 17)","literalExprId":14,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2452,col 57)-(line 2452,col 57)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2453,col 33)-(line 2453,col 33)","literalExprId":16,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2456,col 14)-(line 2456,col 16)","literalExprId":17,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2457,col 14)-(line 2457,col 16)","literalExprId":18,"literalExpr":"'1'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2458,col 14)-(line 2458,col 16)","literalExprId":19,"literalExpr":"'2'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2459,col 14)-(line 2459,col 16)","literalExprId":20,"literalExpr":"'3'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2460,col 14)-(line 2460,col 16)","literalExprId":21,"literalExpr":"'4'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2461,col 14)-(line 2461,col 16)","literalExprId":22,"literalExpr":"'5'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2462,col 14)-(line 2462,col 16)","literalExprId":23,"literalExpr":"'6'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2463,col 14)-(line 2463,col 16)","literalExprId":24,"literalExpr":"'7'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2464,col 14)-(line 2464,col 16)","literalExprId":25,"literalExpr":"'8'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2465,col 14)-(line 2465,col 16)","literalExprId":26,"literalExpr":"'9'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2467,col 29)-(line 2467,col 29)","literalExprId":27,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2468,col 31)-(line 2468,col 31)","literalExprId":28,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2471,col 23)-(line 2471,col 25)","literalExprId":29,"literalExpr":"'0'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2471,col 37)-(line 2471,col 39)","literalExprId":30,"literalExpr":"'8'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2474,col 48)-(line 2474,col 48)","literalExprId":31,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2474,col 73)-(line 2474,col 73)","literalExprId":32,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2477,col 27)-(line 2477,col 27)","literalExprId":33,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2484,col 33)-(line 2484,col 33)","literalExprId":34,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2487,col 31)-(line 2487,col 34)","literalExprId":35,"literalExpr":"'\\\\'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2489,col 21)-(line 2489,col 21)","literalExprId":36,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.unescapeNonJava(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to remove whitespace in","javadocBlockTagName":"arg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace in'}]}', name=Optional[arg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to remove whitespace abutting","javadocBlockTagName":"delimiter","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace abutting'}]}', name=Optional[delimiter]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"version of arg, with whitespace abutting delimiter removed","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='version of arg, with whitespace abutting delimiter removed'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String removeWhitespaceAround(String arg, String delimiter)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n}","methodRange":"(line 2532,col 3)-(line 2536,col 3)","methodTokenRange":"public static String removeWhitespaceAround(String arg, String delimiter) {\n    arg = removeWhitespaceBefore(arg, delimiter);\n    arg = removeWhitespaceAfter(arg, delimiter);\n    return arg;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Remove all whitespace before or after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace abutting\n   * @return version of arg, with whitespace abutting delimiter removed\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg","parameterName":"arg"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delimiter","parameterName":"delimiter"}],"methodName":"removeWhitespaceAround","methodQualifiedSignature":"plume.UtilMDE.removeWhitespaceAround","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Remove all whitespace before or after instances of delimiter.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace in'}]}', name=Optional[arg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace abutting'}]}', name=Optional[delimiter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='version of arg, with whitespace abutting delimiter removed'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.removeWhitespaceAround(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to remove whitespace in","javadocBlockTagName":"arg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace in'}]}', name=Optional[arg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to remove whitespace after","javadocBlockTagName":"delimiter","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace after'}]}', name=Optional[delimiter]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"version of arg, with whitespace after delimiter removed","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='version of arg, with whitespace after delimiter removed'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String removeWhitespaceAfter(String arg, String delimiter)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index + delim_len;\n        while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index++;\n        }\n        if (non_ws_index != delim_index + delim_len) {\n            arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n        }\n        delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n}","methodRange":"(line 2543,col 3)-(line 2563,col 3)","methodTokenRange":"public static String removeWhitespaceAfter(String arg, String delimiter) {\n    \/\/ String orig = arg;\n    int delim_len = delimiter.length();\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index + delim_len;\n      while ((non_ws_index < arg.length()) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index++;\n      }\n      \/\/ if (non_ws_index == arg.length()) {\n      \/\/   System.out.println(\"No nonspace character at end of: \" + arg);\n      \/\/ } else {\n      \/\/   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      \/\/ }\n      if (non_ws_index != delim_index + delim_len) {\n        arg = arg.substring(0, delim_index + delim_len) + arg.substring(non_ws_index);\n      }\n      delim_index = arg.indexOf(delimiter, delim_index + 1);\n    }\n    return arg;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Remove all whitespace after instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace after\n   * @return version of arg, with whitespace after delimiter removed\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg","parameterName":"arg"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delimiter","parameterName":"delimiter"}],"methodName":"removeWhitespaceAfter","methodQualifiedSignature":"plume.UtilMDE.removeWhitespaceAfter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Remove all whitespace after instances of delimiter.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace in'}]}', name=Optional[arg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace after'}]}', name=Optional[delimiter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='version of arg, with whitespace after delimiter removed'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2547,col 27)-(line 2547,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2558,col 29)-(line 2558,col 29)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2560,col 58)-(line 2560,col 58)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.removeWhitespaceAfter(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to remove whitespace in","javadocBlockTagName":"arg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace in'}]}', name=Optional[arg]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to remove whitespace before","javadocBlockTagName":"delimiter","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace before'}]}', name=Optional[delimiter]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"version of arg, with whitespace before delimiter removed","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='version of arg, with whitespace before delimiter removed'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String removeWhitespaceBefore(String arg, String delimiter)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n        int non_ws_index = delim_index - 1;\n        while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n            non_ws_index--;\n        }\n        if (non_ws_index != delim_index - 1) {\n            arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n        }\n        delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n}","methodRange":"(line 2570,col 3)-(line 2590,col 3)","methodTokenRange":"public static String removeWhitespaceBefore(String arg, String delimiter) {\n    \/\/ System.out.println(\"removeWhitespaceBefore(\\\"\" + arg + \"\\\", \\\"\" + delimiter + \"\\\")\");\n    \/\/ String orig = arg;\n    int delim_index = arg.indexOf(delimiter);\n    while (delim_index > -1) {\n      int non_ws_index = delim_index - 1;\n      while ((non_ws_index >= 0) && (Character.isWhitespace(arg.charAt(non_ws_index)))) {\n        non_ws_index--;\n      }\n      \/\/ if (non_ws_index == -1) {\n      \/\/   System.out.println(\"No nonspace character at front of: \" + arg);\n      \/\/ } else {\n      \/\/   System.out.println(\"'\" + arg.charAt(non_ws_index) + \"' not a space character at \" + non_ws_index + \" in: \" + arg);\n      \/\/ }\n      if (non_ws_index != delim_index - 1) {\n        arg = arg.substring(0, non_ws_index + 1) + arg.substring(delim_index);\n      }\n      delim_index = arg.indexOf(delimiter, non_ws_index + 2);\n    }\n    return arg;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Remove all whitespace before instances of delimiter.\n   * @param arg string to remove whitespace in\n   * @param delimiter string to remove whitespace before\n   * @return version of arg, with whitespace before delimiter removed\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg","parameterName":"arg"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delimiter","parameterName":"delimiter"}],"methodName":"removeWhitespaceBefore","methodQualifiedSignature":"plume.UtilMDE.removeWhitespaceBefore","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Remove all whitespace before instances of delimiter.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace in'}]}', name=Optional[arg]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to remove whitespace before'}]}', name=Optional[delimiter]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='version of arg, with whitespace before delimiter removed'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2574,col 27)-(line 2574,col 27)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2575,col 40)-(line 2575,col 40)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2576,col 31)-(line 2576,col 31)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2584,col 41)-(line 2584,col 41)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2585,col 29)-(line 2585,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2585,col 47)-(line 2585,col 47)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2587,col 59)-(line 2587,col 59)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.removeWhitespaceBefore(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"count of nouns","javadocBlockTagName":"n","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='count of nouns'}]}', name=Optional[n]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"word being counted","javadocBlockTagName":"noun","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='word being counted'}]}', name=Optional[noun]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"noun, if n==1; otherwise, pluralization of noun","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='noun, if n==1; otherwise, pluralization of noun'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String nplural(int n, String noun)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (n == 1) {\n        return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\") || noun.endsWith(\"s\") || noun.endsWith(\"sh\") || noun.endsWith(\"x\")) {\n        return n + \" \" + noun + \"es\";\n    } else {\n        return n + \" \" + noun + \"s\";\n    }\n}","methodRange":"(line 2599,col 3)-(line 2610,col 3)","methodTokenRange":"public static String nplural(int n, String noun) {\n    if (n == 1) {\n      return n + \" \" + noun;\n    } else if (noun.endsWith(\"ch\")\n        || noun.endsWith(\"s\")\n        || noun.endsWith(\"sh\")\n        || noun.endsWith(\"x\")) {\n      return n + \" \" + noun + \"es\";\n    } else {\n      return n + \" \" + noun + \"s\";\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return either \"n <em>noun<\/em>\" or \"n <em>noun<\/em>s\" depending on n.\n   * Adds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".\n   * @param n count of nouns\n   * @param noun word being counted\n   * @return noun, if n==1; otherwise, pluralization of noun\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int n","parameterName":"n"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String noun","parameterName":"noun"}],"methodName":"nplural","methodQualifiedSignature":"plume.UtilMDE.nplural","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return either \"n <em>noun<\/em>\" or \"n <em>noun<\/em>s\" depending on n.\nAdds \"es\" to words ending with \"ch\", \"s\", \"sh\", or \"x\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='count of nouns'}]}', name=Optional[n]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='word being counted'}]}', name=Optional[noun]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='noun, if n==1; otherwise, pluralization of noun'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2600,col 14)-(line 2600,col 14)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2601,col 18)-(line 2601,col 20)","literalExprId":2,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2602,col 30)-(line 2602,col 33)","literalExprId":3,"literalExpr":"\"ch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2603,col 26)-(line 2603,col 28)","literalExprId":4,"literalExpr":"\"s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2604,col 26)-(line 2604,col 29)","literalExprId":5,"literalExpr":"\"sh\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2605,col 26)-(line 2605,col 28)","literalExprId":6,"literalExpr":"\"x\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2606,col 18)-(line 2606,col 20)","literalExprId":7,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2606,col 31)-(line 2606,col 34)","literalExprId":8,"literalExpr":"\"es\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2608,col 18)-(line 2608,col 20)","literalExprId":9,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2608,col 31)-(line 2608,col 33)","literalExprId":10,"literalExpr":"\"s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.nplural(int, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to truncate or pad","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to truncate or pad'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"goal length","javadocBlockTagName":"length","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"s truncated or padded to length characters","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='s truncated or padded to length characters'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String lpad(String s, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString() + s;\n    } else {\n        return s.substring(0, length);\n    }\n}","methodRange":"(line 2619,col 3)-(line 2629,col 3)","methodTokenRange":"public static String lpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer();\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString() + s;\n    } else {\n      return s.substring(0, length);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the left if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"lpad","methodQualifiedSignature":"plume.UtilMDE.lpad","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string of the specified length, truncated if necessary,\nand padded with spaces to the left if necessary.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to truncate or pad'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='s truncated or padded to length characters'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2623,col 20)-(line 2623,col 22)","literalExprId":1,"literalExpr":"' '","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2627,col 26)-(line 2627,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.lpad(java.lang.String, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to truncate or pad","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to truncate or pad'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"goal length","javadocBlockTagName":"length","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"s truncated or padded to length characters","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='s truncated or padded to length characters'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String rpad(String s, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (s.length() < length) {\n        StringBuffer buf = new StringBuffer(s);\n        for (int i = s.length(); i < length; i++) {\n            buf.append(' ');\n        }\n        return buf.toString();\n    } else {\n        return s.substring(0, length);\n    }\n}","methodRange":"(line 2638,col 3)-(line 2648,col 3)","methodTokenRange":"public static String rpad(String s, int length) {\n    if (s.length() < length) {\n      StringBuffer buf = new StringBuffer(s);\n      for (int i = s.length(); i < length; i++) {\n        buf.append(' ');\n      }\n      return buf.toString();\n    } else {\n      return s.substring(0, length);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a string of the specified length, truncated if necessary,\n   * and padded with spaces to the right if necessary.\n   * @param s string to truncate or pad\n   * @param length goal length\n   * @return s truncated or padded to length characters\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"rpad","methodQualifiedSignature":"plume.UtilMDE.rpad","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string of the specified length, truncated if necessary,\nand padded with spaces to the right if necessary.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to truncate or pad'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='s truncated or padded to length characters'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2642,col 20)-(line 2642,col 22)","literalExprId":1,"literalExpr":"' '","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2646,col 26)-(line 2646,col 26)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.rpad(java.lang.String, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"int whose string representation to truncate or pad","javadocBlockTagName":"num","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='int whose string representation to truncate or pad'}]}', name=Optional[num]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"goal length","javadocBlockTagName":"length","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of num truncated or padded to length characters","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of num truncated or padded to length characters'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String rpad(int num, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return rpad(String.valueOf(num), length);\n}","methodRange":"(line 2655,col 3)-(line 2657,col 3)","methodTokenRange":"public static String rpad(int num, int length) {\n    return rpad(String.valueOf(num), length);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Converts the int to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num int whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int num","parameterName":"num"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"rpad","methodQualifiedSignature":"plume.UtilMDE.rpad","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts the int to a String, then formats it using '}, JavadocInlineTag{tagName='link', type=LINK, content=' #rpad(String,int)'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='int whose string representation to truncate or pad'}]}', name=Optional[num]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of num truncated or padded to length characters'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.rpad(int, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"double whose string representation to truncate or pad","javadocBlockTagName":"num","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='double whose string representation to truncate or pad'}]}', name=Optional[num]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"goal length","javadocBlockTagName":"length","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of num truncated or padded to length characters","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of num truncated or padded to length characters'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String rpad(double num, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return rpad(String.valueOf(num), length);\n}","methodRange":"(line 2664,col 3)-(line 2666,col 3)","methodTokenRange":"public static String rpad(double num, int length) {\n    return rpad(String.valueOf(num), length);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" Converts the double to a String, then formats it using {@link #rpad(String,int)}.\n   * @param num double whose string representation to truncate or pad\n   * @param length goal length\n   * @return a string representation of num truncated or padded to length characters\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double num","parameterName":"num"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"rpad","methodQualifiedSignature":"plume.UtilMDE.rpad","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Converts the double to a String, then formats it using '}, JavadocInlineTag{tagName='link', type=LINK, content=' #rpad(String,int)'}, JavadocSnippet{text='.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='double whose string representation to truncate or pad'}]}', name=Optional[num]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='goal length'}]}', name=Optional[length]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of num truncated or padded to length characters'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.rpad(double, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to search in","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to search in'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"character to search for","javadocBlockTagName":"ch","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character to search for'}]}', name=Optional[ch]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of times the character appears in the string","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of times the character appears in the string'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int count(String s, int ch)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n}","methodRange":"(line 2695,col 3)-(line 2703,col 3)","methodTokenRange":"public static int count(String s, int ch) {\n    int result = 0;\n    int pos = s.indexOf(ch);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(ch, pos + 1);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return the number of times the character appears in the string.\n   * @param s string to search in\n   * @param ch character to search for\n   * @return number of times the character appears in the string\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int ch","parameterName":"ch"}],"methodName":"count","methodQualifiedSignature":"plume.UtilMDE.count","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the number of times the character appears in the string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to search in'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='character to search for'}]}', name=Optional[ch]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of times the character appears in the string'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 2696,col 18)-(line 2696,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2698,col 19)-(line 2698,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2700,col 33)-(line 2700,col 33)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.count(java.lang.String, int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to search in","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to search in'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to search for","javadocBlockTagName":"sub","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to search for'}]}', name=Optional[sub]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"number of times the substring appears in the string","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of times the substring appears in the string'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int count(String s, String sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n        result++;\n        pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n}","methodRange":"(line 2710,col 3)-(line 2718,col 3)","methodTokenRange":"public static int count(String s, String sub) {\n    int result = 0;\n    int pos = s.indexOf(sub);\n    while (pos > -1) {\n      result++;\n      pos = s.indexOf(sub, pos + 1);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Return the number of times the second string appears in the first.\n   * @param s string to search in\n   * @param sub string to search for\n   * @return number of times the substring appears in the string\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String sub","parameterName":"sub"}],"methodName":"count","methodQualifiedSignature":"plume.UtilMDE.count","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the number of times the second string appears in the first.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to search in'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to search for'}]}', name=Optional[sub]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='number of times the substring appears in the string'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 2711,col 18)-(line 2711,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2713,col 19)-(line 2713,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2715,col 34)-(line 2715,col 34)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.count(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a string to be parsed","javadocBlockTagName":"str","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a string to be parsed'}]}', name=Optional[str]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the delimiters","javadocBlockTagName":"delim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the delimiters'}]}', name=Optional[delim]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"flag indicating whether to return the delimiters as tokens","javadocBlockTagName":"returnDelims","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='flag indicating whether to return the delimiters as tokens'}]}', name=Optional[returnDelims]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"vector of strings resulting from tokenization","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vector of strings resulting from tokenization'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Vector<Object> tokens(String str, String delim, boolean returnDelims)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n}","methodRange":"(line 2736,col 3)-(line 2738,col 3)","methodTokenRange":"public static Vector<Object> tokens(String str, String delim, boolean returnDelims) {\n    return makeVector(new StringTokenizer(str, delim, returnDelims));\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String,boolean)} with the given arguments.\n   * <p>\n   * The static type is Vector&lt;Object&gt; because StringTokenizer extends\n   * Enumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n   * (probably due to backward-compatibility).\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @param returnDelims flag indicating whether to return the delimiters as tokens\n   * @return vector of strings resulting from tokenization\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String str","parameterName":"str"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delim","parameterName":"delim"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean returnDelims","parameterName":"returnDelims"}],"methodName":"tokens","methodQualifiedSignature":"plume.UtilMDE.tokens","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a Vector of the Strings returned by\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' java.util.StringTokenizer#StringTokenizer(String,String,boolean)'}, JavadocSnippet{text=' with the given arguments.\n<p>\nThe static type is Vector&lt;Object&gt; because StringTokenizer extends\nEnumeration&lt;Object&gt; instead of Enumeration&lt;String&gt; as it should\n(probably due to backward-compatibility).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a string to be parsed'}]}', name=Optional[str]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the delimiters'}]}', name=Optional[delim]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='flag indicating whether to return the delimiters as tokens'}]}', name=Optional[returnDelims]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vector of strings resulting from tokenization'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Vector<java.lang.Object>","methodType":"Vector<Object>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.tokens(java.lang.String, java.lang.String, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a string to be parsed","javadocBlockTagName":"str","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a string to be parsed'}]}', name=Optional[str]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the delimiters","javadocBlockTagName":"delim","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the delimiters'}]}', name=Optional[delim]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"vector of strings resulting from tokenization","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vector of strings resulting from tokenization'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Vector<Object> tokens(String str, String delim)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return makeVector(new StringTokenizer(str, delim));\n}","methodRange":"(line 2747,col 3)-(line 2749,col 3)","methodTokenRange":"public static Vector<Object> tokens(String str, String delim) {\n    return makeVector(new StringTokenizer(str, delim));\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String,String)} with the given arguments.\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return vector of strings resulting from tokenization\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String str","parameterName":"str"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String delim","parameterName":"delim"}],"methodName":"tokens","methodQualifiedSignature":"plume.UtilMDE.tokens","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a Vector of the Strings returned by\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' java.util.StringTokenizer#StringTokenizer(String,String)'}, JavadocSnippet{text=' with the given arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a string to be parsed'}]}', name=Optional[str]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the delimiters'}]}', name=Optional[delim]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vector of strings resulting from tokenization'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Vector<java.lang.Object>","methodType":"Vector<Object>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.tokens(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a string to be parsed","javadocBlockTagName":"str","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a string to be parsed'}]}', name=Optional[str]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"vector of strings resulting from tokenization","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vector of strings resulting from tokenization'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Vector<Object> tokens(String str)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return makeVector(new StringTokenizer(str));\n}","methodRange":"(line 2757,col 3)-(line 2759,col 3)","methodTokenRange":"public static Vector<Object> tokens(String str) {\n    return makeVector(new StringTokenizer(str));\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n   * Return a Vector of the Strings returned by\n   * {@link java.util.StringTokenizer#StringTokenizer(String)} with the given arguments.\n   * @param str a string to be parsed\n   * @return vector of strings resulting from tokenization\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String str","parameterName":"str"}],"methodName":"tokens","methodQualifiedSignature":"plume.UtilMDE.tokens","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a Vector of the Strings returned by\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' java.util.StringTokenizer#StringTokenizer(String)'}, JavadocSnippet{text=' with the given arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a string to be parsed'}]}', name=Optional[str]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='vector of strings resulting from tokenization'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Vector<java.lang.Object>","methodType":"Vector<Object>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.tokens(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Throwable to obtain a backtrace of","javadocBlockTagName":"t","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Throwable to obtain a backtrace of'}]}', name=Optional[t]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a String representation of the backtrace of the given Throwable","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String representation of the backtrace of the given Throwable'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String backTrace(Throwable t)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n}","methodRange":"(line 2771,col 3)-(line 2778,col 3)","methodTokenRange":"public static String backTrace(Throwable t) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    t.printStackTrace(pw);\n    pw.close();\n    String result = sw.toString();\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a String representation of the backtrace of the given Throwable.\n   * To see a backtrace at the the current location, do \"backtrace(new Throwable())\".\n   * @param t the Throwable to obtain a backtrace of\n   * @return a String representation of the backtrace of the given Throwable\n   ","methodParameters":[{"parameterType":"Throwable","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Throwable, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Throwable","parameter":"Throwable t","parameterName":"t"}],"methodName":"backTrace","methodQualifiedSignature":"plume.UtilMDE.backTrace","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a String representation of the backtrace of the given Throwable.\nTo see a backtrace at the the current location, do \"backtrace(new Throwable())\".'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Throwable to obtain a backtrace of'}]}', name=Optional[t]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a String representation of the backtrace of the given Throwable'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.backTrace(java.lang.Throwable)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a sorted version of the list","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of the list'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of elements of the list","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of elements of the list'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list to sort","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list to sort'}]}', name=Optional[l]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a sorted version of the list","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of the list'}]}', name=Optional[c]}"}],"methodDeclaration":"public static List<T> sortList(List<T> l, Comparator<? super T> c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n}","methodRange":"(line 2792,col 3)-(line 2796,col 3)","methodTokenRange":"public static <T> List<T> sortList(List<T> l, Comparator<? super T> c) {\n    List<T> result = new ArrayList<T>(l);\n    Collections.sort(result, c);\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n   * Return the sorted version of the list.  Does not alter the list.\n   * Simply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).\n   * @return a sorted version of the list\n   * @param <T> type of elements of the list\n   * @param l a list to sort\n   * @param c a sorted version of the list\n   ","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> l","parameterName":"l"},{"parameterType":"Comparator<? super T>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Comparator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Comparator.T=WildcardUsage{type=SUPER, boundedType=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}","parameterTypeResolvedDescribed":"java.util.Comparator<? super T>","parameter":"Comparator<? super T> c","parameterName":"c"}],"methodName":"sortList","methodQualifiedSignature":"plume.UtilMDE.sortList","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the sorted version of the list.  Does not alter the list.\nSimply calls Collections.sort(List&lt;T&gt;, Comparator&lt;? super T&gt;).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of the list'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of elements of the list'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list to sort'}]}', name=Optional[l]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a sorted version of the list'}]}', name=Optional[c]}]}","methodReturnTypeDescribed":"java.util.List<T>","methodType":"List<T>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.sortList(java.util.List<T>, java.util.Comparator<? super T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of elements of the list","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of elements of the list'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list to remove duplicates from","javadocBlockTagName":"l","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list to remove duplicates from'}]}', name=Optional[l]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a copy of the list with duplicates removed","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a copy of the list with duplicates removed'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<T> removeDuplicates(List<T> l)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n}","methodRange":"(line 2807,col 3)-(line 2811,col 3)","methodTokenRange":"public static <T> List<T> removeDuplicates(List<T> l) {\n    HashSet<T> hs = new LinkedHashSet<T>(l);\n    List<T> result = new ArrayList<T>(hs);\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n   * Return a copy of the list with duplicates removed.\n   * Retains the original order.\n   * @param <T> type of elements of the list\n   * @param l a list to remove duplicates from\n   * @return a copy of the list with duplicates removed\n   ","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> l","parameterName":"l"}],"methodName":"removeDuplicates","methodQualifiedSignature":"plume.UtilMDE.removeDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a copy of the list with duplicates removed.\nRetains the original order.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of elements of the list'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list to remove duplicates from'}]}', name=Optional[l]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a copy of the list with duplicates removed'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<T>","methodType":"List<T>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.removeDuplicates(java.util.List<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first value to compare","javadocBlockTagName":"o1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first value to compare'}]}', name=Optional[o1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second value to comare","javadocBlockTagName":"o2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second value to comare'}]}', name=Optional[o2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff o1 and o2 are deeply equal","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff o1 and o2 are deeply equal'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean deepEquals(Object o1, Object o2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n        return true;\n    }\n    if (o1 == null || o2 == null) {\n        return false;\n    }\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    @SuppressWarnings(\"purity\")\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n        return true;\n    }\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n        return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n        List<?> l1 = (List<?>) o1;\n        List<?> l2 = (List<?>) o2;\n        if (l1.size() != l2.size()) {\n            return false;\n        }\n        try {\n            deepEqualsUnderway.add(mypair);\n            for (int i = 0; i < l1.size(); i++) {\n                Object e1 = l1.get(i);\n                Object e2 = l2.get(i);\n                if (!deepEquals(e1, e2)) {\n                    return false;\n                }\n            }\n        } finally {\n            deepEqualsUnderway.remove(mypair);\n        }\n        return true;\n    }\n    return o1.equals(o2);\n}","methodRange":"(line 2831,col 3)-(line 2901,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to static field deepEqualsUnderway\n  \/*@Pure*\/\n  public static boolean deepEquals(\/*@Nullable*\/ Object o1, \/*@Nullable*\/ Object o2) {\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (o1 == o2);\n    if (sameObject) {\n      return true;\n    }\n    if (o1 == null || o2 == null) {\n      return false;\n    }\n\n    if (o1 instanceof boolean[] && o2 instanceof boolean[]) {\n      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    if (o1 instanceof byte[] && o2 instanceof byte[]) {\n      return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (o1 instanceof char[] && o2 instanceof char[]) {\n      return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (o1 instanceof double[] && o2 instanceof double[]) {\n      return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (o1 instanceof float[] && o2 instanceof float[]) {\n      return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (o1 instanceof int[] && o2 instanceof int[]) {\n      return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (o1 instanceof long[] && o2 instanceof long[]) {\n      return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (o1 instanceof short[] && o2 instanceof short[]) {\n      return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n\n    @SuppressWarnings(\"purity\") \/\/ creates local state\n    WeakIdentityPair<Object, Object> mypair = new WeakIdentityPair<Object, Object>(o1, o2);\n    if (deepEqualsUnderway.contains(mypair)) {\n      return true;\n    }\n\n    if (o1 instanceof Object[] && o2 instanceof Object[]) {\n      return Arrays.deepEquals((Object[]) o1, (Object[]) o2);\n    }\n\n    if (o1 instanceof List<?> && o2 instanceof List<?>) {\n      List<?> l1 = (List<?>) o1;\n      List<?> l2 = (List<?>) o2;\n      if (l1.size() != l2.size()) {\n        return false;\n      }\n      try {\n        deepEqualsUnderway.add(mypair);\n        for (int i = 0; i < l1.size(); i++) {\n          Object e1 = l1.get(i);\n          Object e2 = l2.get(i);\n          if (!deepEquals(e1, e2)) {\n            return false;\n          }\n        }\n      } finally {\n        deepEqualsUnderway.remove(mypair);\n      }\n\n      return true;\n    }\n\n    return o1.equals(o2);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Determines deep equality for the elements.\n   * <ul>\n   * <li>If both are primitive arrays, uses java.util.Arrays.equals.\n   * <li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n   * <li>If both are lists, uses deepEquals recursively on each element.\n   * <li>For other types, just uses equals() and does not recursively call this method.\n   * <\/ul>\n   * @param o1 first value to compare\n   * @param o2 second value to comare\n   * @return true iff o1 and o2 are deeply equal\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o1","parameterName":"o1"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o2","parameterName":"o2"}],"methodName":"deepEquals","methodQualifiedSignature":"plume.UtilMDE.deepEquals","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determines deep equality for the elements.\n<ul>\n<li>If both are primitive arrays, uses java.util.Arrays.equals.\n<li>If both are Object[], uses java.util.Arrays.deepEquals and does not recursively call this method.\n<li>If both are lists, uses deepEquals recursively on each element.\n<li>For other types, just uses equals() and does not recursively call this method.\n<\/ul>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first value to compare'}]}', name=Optional[o1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second value to comare'}]}', name=Optional[o2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff o1 and o2 are deeply equal'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2831,col 21)-(line 2831,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2834,col 23)-(line 2834,col 33)","literalExprId":2,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2837,col 14)-(line 2837,col 17)","literalExprId":3,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2839,col 15)-(line 2839,col 18)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2839,col 29)-(line 2839,col 32)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2840,col 14)-(line 2840,col 18)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2868,col 23)-(line 2868,col 30)","literalExprId":7,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2871,col 14)-(line 2871,col 17)","literalExprId":8,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2882,col 16)-(line 2882,col 20)","literalExprId":9,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2886,col 22)-(line 2886,col 22)","literalExprId":10,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2890,col 20)-(line 2890,col 24)","literalExprId":11,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2897,col 14)-(line 2897,col 17)","literalExprId":12,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.deepEquals(java.lang.Object, java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the enumeration and vector elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the enumeration and vector elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"an enumeration to convert to a Vector","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an enumeration to convert to a Vector'}]}', name=Optional[e]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a vector containing the elements of the enumeration","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a vector containing the elements of the enumeration'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Vector<T> makeVector(Enumeration<T> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n        result.addElement(e.nextElement());\n    }\n    return result;\n}","methodRange":"(line 2912,col 3)-(line 2918,col 3)","methodTokenRange":"public static <T> Vector<T> makeVector(Enumeration<T> e) {\n    Vector<T> result = new Vector<T>();\n    while (e.hasMoreElements()) {\n      result.addElement(e.nextElement());\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":" Returns a vector containing the elements of the enumeration.\n   * @param <T> type of the enumeration and vector elements\n   * @param e an enumeration to convert to a Vector\n   * @return a vector containing the elements of the enumeration\n   ","methodParameters":[{"parameterType":"Enumeration<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Enumeration, typeParametersMap=TypeParametersMap{nameToValue={java.util.Enumeration.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Enumeration<T>","parameter":"Enumeration<T> e","parameterName":"e"}],"methodName":"makeVector","methodQualifiedSignature":"plume.UtilMDE.makeVector","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a vector containing the elements of the enumeration.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the enumeration and vector elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an enumeration to convert to a Vector'}]}', name=Optional[e]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a vector containing the elements of the enumeration'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Vector<T>","methodType":"Vector<T>","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.makeVector(java.util.Enumeration<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of the input list elements, and type of the innermost output list elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the input list elements, and type of the innermost output list elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"number of dimensions:  that is, size of each innermost list","javadocBlockTagName":"dims","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of dimensions:  that is, size of each innermost list'}]}', name=Optional[dims]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"initial index","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial index'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"list of elements to","javadocBlockTagName":"objs","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of elements to'}]}', name=Optional[objs]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of lists of length dims, each of which combines elements from objs","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of lists of length dims, each of which combines elements from objs'}]}', name=Optional.empty}"}],"methodDeclaration":"public static List<List<T>> create_combinations(int dims, int start, List<T> objs)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (dims < 1) {\n        throw new IllegalArgumentException();\n    }\n    List<List<T>> results = new ArrayList<List<T>>();\n    for (int i = start; i < objs.size(); i++) {\n        if (dims == 1) {\n            List<T> simple = new ArrayList<T>();\n            simple.add(objs.get(i));\n            results.add(simple);\n        } else {\n            List<List<T>> combos = create_combinations(dims - 1, i, objs);\n            for (List<T> lt : combos) {\n                List<T> simple = new ArrayList<T>();\n                simple.add(objs.get(i));\n                simple.addAll(lt);\n                results.add(simple);\n            }\n        }\n    }\n    return (results);\n}","methodRange":"(line 2944,col 3)-(line 2969,col 3)","methodTokenRange":"public static <T> List<List<T>> create_combinations(int dims, int start, List<T> objs) {\n\n    if (dims < 1) {\n      throw new IllegalArgumentException();\n    }\n\n    List<List<T>> results = new ArrayList<List<T>>();\n\n    for (int i = start; i < objs.size(); i++) {\n      if (dims == 1) {\n        List<T> simple = new ArrayList<T>();\n        simple.add(objs.get(i));\n        results.add(simple);\n      } else {\n        List<List<T>> combos = create_combinations(dims - 1, i, objs);\n        for (List<T> lt : combos) {\n          List<T> simple = new ArrayList<T>();\n          simple.add(objs.get(i));\n          simple.addAll(lt);\n          results.add(simple);\n        }\n      }\n    }\n\n    return (results);\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}}}","methodJavadocComment":"\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of the specified objects starting at index\n   * start over dims dimensions, for dims &gt; 0.\n   * <p>\n   * For example, create_combinations (1, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a}, {b}, {c}\n   * <\/pre>\n   * And create_combinations (2, 0, {a, b, c}) returns:\n   * <pre>\n   *    {a, a}, {a, b}, {a, c}\n   *    {b, b}, {b, c},\n   *    {c, c}\n   * <\/pre>\n   * @param <T> type of the input list elements, and type of the innermost output list elements\n   * @param dims number of dimensions:  that is, size of each innermost list\n   * @param start initial index\n   * @param objs list of elements to\n   * @return list of lists of length dims, each of which combines elements from objs\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int dims","parameterName":"dims"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"List<T>","parameterId":3,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> objs","parameterName":"objs"}],"methodName":"create_combinations","methodQualifiedSignature":"plume.UtilMDE.create_combinations","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of lists of each combination (with repetition, but\nnot permutations) of the specified objects starting at index\nstart over dims dimensions, for dims &gt; 0.\n<p>\nFor example, create_combinations (1, 0, {a, b, c}) returns:\n<pre>\n   {a}, {b}, {c}\n<\/pre>\nAnd create_combinations (2, 0, {a, b, c}) returns:\n<pre>\n   {a, a}, {a, b}, {a, c}\n   {b, b}, {b, c},\n   {c, c}\n<\/pre>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of the input list elements, and type of the innermost output list elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='number of dimensions:  that is, size of each innermost list'}]}', name=Optional[dims]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial index'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='list of elements to'}]}', name=Optional[objs]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of lists of length dims, each of which combines elements from objs'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.List<java.util.List<T>>","methodType":"List<List<T>>","literalExprs":[{"literalExprRange":"(line 2946,col 16)-(line 2946,col 16)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2953,col 19)-(line 2953,col 19)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2958,col 59)-(line 2958,col 59)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.create_combinations(int, int, java.util.List<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"size of each innermost list","javadocBlockTagName":"arity","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='size of each innermost list'}]}', name=Optional[arity]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"initial value","javadocBlockTagName":"start","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial value'}]}', name=Optional[start]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"maximum element value","javadocBlockTagName":"cnt","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum element value'}]}', name=Optional[cnt]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"list of lists of length arity, each of which combines integers from start to cnt","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of lists of length arity, each of which combines integers from start to cnt'}]}', name=Optional.empty}"}],"methodDeclaration":"public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n    if (arity == 0) {\n        results.add(new ArrayList<Integer>());\n        return (results);\n    }\n    for (int i = start; i <= cnt; i++) {\n        ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n        for (ArrayList<Integer> li : combos) {\n            ArrayList<Integer> simple = new ArrayList<Integer>();\n            simple.add(new Integer(i));\n            simple.addAll(li);\n            results.add(simple);\n        }\n    }\n    return (results);\n}","methodRange":"(line 2991,col 3)-(line 3012,col 3)","methodTokenRange":"public static ArrayList<ArrayList<Integer>> create_combinations(int arity, int start, int cnt) {\n\n    ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\n    \/\/ Return a list with one zero length element if arity is zero\n    if (arity == 0) {\n      results.add(new ArrayList<Integer>());\n      return (results);\n    }\n\n    for (int i = start; i <= cnt; i++) {\n      ArrayList<ArrayList<Integer>> combos = create_combinations(arity - 1, i, cnt);\n      for (ArrayList<Integer> li : combos) {\n        ArrayList<Integer> simple = new ArrayList<Integer>();\n        simple.add(new Integer(i));\n        simple.addAll(li);\n        results.add(simple);\n      }\n    }\n\n    return (results);\n  }","methodReturnTypeResolved":"ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=ReferenceType{java.util.ArrayList, typeParametersMap=TypeParametersMap{nameToValue={java.util.ArrayList.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}","methodJavadocComment":"\n   * Returns a list of lists of each combination (with repetition, but\n   * not permutations) of integers from start to cnt (inclusive) over\n   * arity dimensions.\n   * <p>\n   * For example, create_combinations (1, 0, 2) returns:\n   * <pre>\n   *    {0}, {1}, {2}\n   * <\/pre>\n   * And create_combinations (2, 0, 2) returns:\n   * <pre>\n   *    {0, 0}, {0, 1}, {0, 2}\n   *    {1, 1}  {1, 2},\n   *    {2, 2}\n   * <\/pre>\n   * @param arity size of each innermost list\n   * @param start initial value\n   * @param cnt maximum element value\n   * @return list of lists of length arity, each of which combines integers from start to cnt\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int arity","parameterName":"arity"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int start","parameterName":"start"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int cnt","parameterName":"cnt"}],"methodName":"create_combinations","methodQualifiedSignature":"plume.UtilMDE.create_combinations","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a list of lists of each combination (with repetition, but\nnot permutations) of integers from start to cnt (inclusive) over\narity dimensions.\n<p>\nFor example, create_combinations (1, 0, 2) returns:\n<pre>\n   {0}, {1}, {2}\n<\/pre>\nAnd create_combinations (2, 0, 2) returns:\n<pre>\n   {0, 0}, {0, 1}, {0, 2}\n   {1, 1}  {1, 2},\n   {2, 2}\n<\/pre>'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='size of each innermost list'}]}', name=Optional[arity]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial value'}]}', name=Optional[start]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='maximum element value'}]}', name=Optional[cnt]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='list of lists of length arity, each of which combines integers from start to cnt'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.ArrayList<java.util.ArrayList<java.lang.Integer>>","methodType":"ArrayList<ArrayList<Integer>>","literalExprs":[{"literalExprRange":"(line 2996,col 18)-(line 2996,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3002,col 74)-(line 3002,col 74)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.create_combinations(int, int, int)"},{"javadocBlockTags":[{"javadocBlockType":"DEPRECATED","javadocBlockTagContent":"use {@link #fullyQualifiedNameToSimpleName} instead.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='use '}, JavadocInlineTag{tagName='link', type=LINK, content=' #fullyQualifiedNameToSimpleName'}, JavadocSnippet{text=' instead.'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the fully-qualified name of a class","javadocBlockTagName":"qualified_name","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the fully-qualified name of a class'}]}', name=Optional[qualified_name]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the simple unqualified name of the class","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the simple unqualified name of the class'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String unqualified_name(String qualified_name)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return fullyQualifiedNameToSimpleName(qualified_name);\n}","methodRange":"(line 3022,col 3)-(line 3026,col 3)","methodTokenRange":"@Deprecated\n  public static \/*@ClassGetSimpleName*\/ String unqualified_name(\n      \/*@FullyQualifiedName*\/ String qualified_name) {\n    return fullyQualifiedNameToSimpleName(qualified_name);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the simple unqualified class name that corresponds to the\n   * specified fully qualified name.  For example, if qualified_name\n   * is java.lang.String, String will be returned.\n   * @deprecated use {@link #fullyQualifiedNameToSimpleName} instead.\n   * @param qualified_name the fully-qualified name of a class\n   * @return the simple unqualified name of the class\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String qualified_name","parameterName":"qualified_name"}],"methodName":"unqualified_name","methodQualifiedSignature":"plume.UtilMDE.unqualified_name","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the simple unqualified class name that corresponds to the\nspecified fully qualified name.  For example, if qualified_name\nis java.lang.String, String will be returned.'}]}, blockTags=[JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='use '}, JavadocInlineTag{tagName='link', type=LINK, content=' #fullyQualifiedNameToSimpleName'}, JavadocSnippet{text=' instead.'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the fully-qualified name of a class'}]}', name=Optional[qualified_name]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the simple unqualified name of the class'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.unqualified_name(java.lang.String)"},{"methodDeclaration":"public static String fullyQualifiedNameToSimpleName(String qualified_name)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n        return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n}","methodRange":"(line 3037,col 3)-(line 3046,col 3)","methodTokenRange":"@SuppressWarnings(\"signature\") \/\/ string conversion\n  public static \/*@ClassGetSimpleName*\/ String fullyQualifiedNameToSimpleName(\n      \/*@FullyQualifiedName*\/ String qualified_name) {\n\n    int offset = qualified_name.lastIndexOf('.');\n    if (offset == -1) {\n      return (qualified_name);\n    }\n    return (qualified_name.substring(offset + 1));\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":" type name should be empty), but I think this is more informative anyway.","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String qualified_name","parameterName":"qualified_name"}],"methodName":"fullyQualifiedNameToSimpleName","methodQualifiedSignature":"plume.UtilMDE.fullyQualifiedNameToSimpleName","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 3037,col 21)-(line 3037,col 31)","literalExprId":1,"literalExpr":"\"signature\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3041,col 45)-(line 3041,col 47)","literalExprId":2,"literalExpr":"'.'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 3042,col 20)-(line 3042,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3045,col 47)-(line 3045,col 47)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.fullyQualifiedNameToSimpleName(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"DEPRECATED","javadocBlockTagContent":"use {@link Class#getSimpleName()} instead.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='use '}, JavadocInlineTag{tagName='link', type=LINK, content=' Class#getSimpleName()'}, JavadocSnippet{text=' instead.'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a class","javadocBlockTagName":"cls","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a class'}]}', name=Optional[cls]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the simple unqualified name of the class","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the simple unqualified name of the class'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String unqualified_name(Class<?> cls)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return cls.getSimpleName();\n}","methodRange":"(line 3058,col 3)-(line 3061,col 3)","methodTokenRange":"@Deprecated\n  public static \/*@ClassGetSimpleName*\/ String unqualified_name(Class<?> cls) {\n    return cls.getSimpleName();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the simple unqualified class name that corresponds to the\n   * specified class.  For example if qualified name of the class\n   * is java.lang.String, String will be returned.\n   *\n   * @deprecated use {@link Class#getSimpleName()} instead.\n   *\n   * @param cls a class\n   * @return the simple unqualified name of the class\n   ","methodParameters":[{"parameterType":"Class<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.lang.Class<?>","parameter":"Class<?> cls","parameterName":"cls"}],"methodName":"unqualified_name","methodQualifiedSignature":"plume.UtilMDE.unqualified_name","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the simple unqualified class name that corresponds to the\nspecified class.  For example if qualified name of the class\nis java.lang.String, String will be returned.'}]}, blockTags=[JavadocBlockTag{type=DEPRECATED, content='JavadocDescription{elements=[JavadocSnippet{text='use '}, JavadocInlineTag{tagName='link', type=LINK, content=' Class#getSimpleName()'}, JavadocSnippet{text=' instead.'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a class'}]}', name=Optional[cls]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the simple unqualified name of the class'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.UtilMDE.unqualified_name(java.lang.Class<?>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a numeric value","javadocBlockTagName":"val","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a numeric value'}]}', name=Optional[val]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an abbreviated string representation of the value","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an abbreviated string representation of the value'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String abbreviateNumber(long val)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double dval = (double) val;\n    String mag = \"\";\n    if (val < 1000) {\n    } else if (val < 1000000) {\n        dval = val \/ 1000.0;\n        mag = \"K\";\n    } else if (val < 1000000000) {\n        dval = val \/ 1000000.0;\n        mag = \"M\";\n    } else {\n        dval = val \/ 1000000000.0;\n        mag = \"G\";\n    }\n    String precision = \"0\";\n    if (dval < 10) {\n        precision = \"2\";\n    } else if (dval < 100) {\n        precision = \"1\";\n    }\n    @SuppressWarnings(\"formatter\")\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n}","methodRange":"(line 3071,col 3)-(line 3099,col 3)","methodTokenRange":"public static String abbreviateNumber(long val) {\n\n    double dval = (double) val;\n    String mag = \"\";\n\n    if (val < 1000) {\n      \/\/ nothing to do\n    } else if (val < 1000000) {\n      dval = val \/ 1000.0;\n      mag = \"K\";\n    } else if (val < 1000000000) {\n      dval = val \/ 1000000.0;\n      mag = \"M\";\n    } else {\n      dval = val \/ 1000000000.0;\n      mag = \"G\";\n    }\n\n    String precision = \"0\";\n    if (dval < 10) {\n      precision = \"2\";\n    } else if (dval < 100) {\n      precision = \"1\";\n    }\n\n    @SuppressWarnings(\"formatter\") \/\/ format string computed from precision and mag\n    String result = String.format(\"%,1.\" + precision + \"f\" + mag, dval);\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n   * \"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n   * 1000000, not 1048576, etc.  There are always exactly 3 decimal digits\n   * of precision in the result (counting both sides of the decimal point).\n   * @param val a numeric value\n   * @return an abbreviated string representation of the value\n   ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long val","parameterName":"val"}],"methodName":"abbreviateNumber","methodQualifiedSignature":"plume.UtilMDE.abbreviateNumber","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Convert a number into an abbreviation such as \"5.00K\" for 5000 or\n\"65.0M\" for 65000000.  K stands for 1000, not 1024; M stands for\n1000000, not 1048576, etc.  There are always exactly 3 decimal digits\nof precision in the result (counting both sides of the decimal point).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a numeric value'}]}', name=Optional[val]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an abbreviated string representation of the value'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 3074,col 18)-(line 3074,col 19)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3076,col 15)-(line 3076,col 18)","literalExprId":2,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3078,col 22)-(line 3078,col 28)","literalExprId":3,"literalExpr":"1000000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3079,col 20)-(line 3079,col 25)","literalExprId":4,"literalExpr":"1000.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3080,col 13)-(line 3080,col 15)","literalExprId":5,"literalExpr":"\"K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3081,col 22)-(line 3081,col 31)","literalExprId":6,"literalExpr":"1000000000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3082,col 20)-(line 3082,col 28)","literalExprId":7,"literalExpr":"1000000.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3083,col 13)-(line 3083,col 15)","literalExprId":8,"literalExpr":"\"M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3085,col 20)-(line 3085,col 31)","literalExprId":9,"literalExpr":"1000000000.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3086,col 13)-(line 3086,col 15)","literalExprId":10,"literalExpr":"\"G\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3089,col 24)-(line 3089,col 26)","literalExprId":11,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3090,col 16)-(line 3090,col 17)","literalExprId":12,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3091,col 19)-(line 3091,col 21)","literalExprId":13,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3092,col 23)-(line 3092,col 25)","literalExprId":14,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3093,col 19)-(line 3093,col 21)","literalExprId":15,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3096,col 23)-(line 3096,col 33)","literalExprId":16,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3097,col 35)-(line 3097,col 40)","literalExprId":17,"literalExpr":"\"%,1.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3097,col 56)-(line 3097,col 58)","literalExprId":18,"literalExpr":"\"f\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.UtilMDE.abbreviateNumber(long)"}],"classJavadoc":"\/**\n * Utility functions that do not belong elsewhere in the plume package.\n *\/\n","className":"UtilMDE","fields":[{"fieldRange":"(line 71,col 3)-(line 71,col 77)","fieldName":"lineSep","fieldJavadocComment":"","fieldTokenRange":"private static final String lineSep = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 71,col 60)-(line 71,col 75)","literalExprId":1,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 505,col 3)-(line 505,col 95)","fieldName":"primitiveClasses","fieldJavadocComment":"","fieldTokenRange":"private static HashMap<String, Class<?>> primitiveClasses = new HashMap<String, Class<?>>(8);","fieldTypeResolved":"ReferenceType{java.util.HashMap, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashMap.V=ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}, java.util.HashMap.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 505,col 93)-(line 505,col 93)","literalExprId":1,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[new HashMap<String, Class<?>>(8)]","fieldType":"HashMap<String, Class<?>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.HashMap<java.lang.String, java.lang.Class<?>>"},{"fieldRange":"(line 562,col 3)-(line 564,col 97)","fieldName":"primitiveClassesJvm","fieldJavadocComment":"","fieldTokenRange":"private static HashMap<\/*@SourceNameForNonArrayNonInner*\/ String, \/*@FieldDescriptor*\/ String>\n      primitiveClassesJvm =\n          new HashMap<\/*@SourceNameForNonArrayNonInner*\/ String, \/*@FieldDescriptor*\/ String>(8);","fieldTypeResolved":"ReferenceType{java.util.HashMap, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashMap.V=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.HashMap.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 564,col 95)-(line 564,col 95)","literalExprId":1,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[new HashMap<String, String>(8)]","fieldType":"HashMap<String, String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.HashMap<java.lang.String, java.lang.String>"},{"fieldRange":"(line 670,col 3)-(line 670,col 98)","fieldName":"primitiveClassesFromJvm","fieldJavadocComment":"","fieldTokenRange":"private static HashMap<String, String> primitiveClassesFromJvm = new HashMap<String, String>(8);","fieldTypeResolved":"ReferenceType{java.util.HashMap, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashMap.V=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.HashMap.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 670,col 96)-(line 670,col 96)","literalExprId":1,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"fieldInitializer":"Optional[new HashMap<String, String>(8)]","fieldType":"HashMap<String, String>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.HashMap<java.lang.String, java.lang.String>"},{"fieldRange":"(line 793,col 3)-(line 793,col 82)","fieldName":"thePromiscuousLoader","fieldJavadocComment":"","fieldTokenRange":"private static PromiscuousLoader thePromiscuousLoader = new PromiscuousLoader();","fieldTypeResolved":"ReferenceType{plume.UtilMDE.PromiscuousLoader, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new PromiscuousLoader()]","fieldType":"PromiscuousLoader","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.UtilMDE.PromiscuousLoader"},{"fieldRange":"(line 1087,col 3)-(line 1087,col 65)","fieldName":"userHome","fieldJavadocComment":"","fieldTokenRange":"static final String userHome = System.getProperty(\"user.home\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 1087,col 53)-(line 1087,col 63)","literalExprId":1,"literalExpr":"\"user.home\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"user.home\")]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 1679,col 3)-(line 1679,col 41)","fieldName":"r","fieldJavadocComment":"","fieldTokenRange":"private static Random r = new Random();","fieldTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new Random()]","fieldType":"Random","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Random"},{"fieldRange":"(line 1822,col 3)-(line 1822,col 83)","fieldName":"args_seen","fieldJavadocComment":"\n   * Maps from a comma-delimited string of arg types, such as appears in a\n   * method signature, to an array of Class objects, one for each arg\n   * type. Example keys include: \"java.lang.String, java.lang.String,\n   * java.lang.Class[]\" and \"int,int\".\n   ","fieldTokenRange":"static HashMap<String, Class<?>[]> args_seen = new HashMap<String, Class<?>[]>();","fieldTypeResolved":"ReferenceType{java.util.HashMap, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashMap.V=ResolvedArrayType{ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}}, java.util.HashMap.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"Optional[new HashMap<String, Class<?>[]>()]","fieldType":"HashMap<String, Class<?>[]>","fieldJavadoc":"Maps from a comma-delimited string of arg types, such as appears in a\nmethod signature, to an array of Class objects, one for each arg\ntype. Example keys include: \"java.lang.String, java.lang.String,\njava.lang.Class[]\" and \"int,int\".\n","fieldTypeResolvedDescribed":"java.util.HashMap<java.lang.String, java.lang.Class<?>[]>"},{"fieldRange":"(line 2816,col 3)-(line 2817,col 54)","fieldName":"deepEqualsUnderway","fieldJavadocComment":"\n   * All calls to deepEquals that are currently underway.\n   ","fieldTokenRange":"private static HashSet<WeakIdentityPair<Object, Object>> deepEqualsUnderway =\n      new HashSet<WeakIdentityPair<Object, Object>>();","fieldTypeResolved":"ReferenceType{java.util.HashSet, typeParametersMap=TypeParametersMap{nameToValue={java.util.HashSet.E=ReferenceType{plume.WeakIdentityPair, typeParametersMap=TypeParametersMap{nameToValue={plume.WeakIdentityPair.T2=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}, plume.WeakIdentityPair.T1=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new HashSet<WeakIdentityPair<Object, Object>>()]","fieldType":"HashSet<WeakIdentityPair<Object, Object>>","fieldJavadoc":"All calls to deepEquals that are currently underway.\n","fieldTypeResolvedDescribed":"java.util.HashSet<plume.WeakIdentityPair<java.lang.Object, java.lang.Object>>"}]}],"sourceFileId":35,"packageName":"plume"},{"sourceFileName":"plume.Hasher","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"object whose hash code to compute","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object whose hash code to compute'}]}', name=Optional[o]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"o's hash code","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='o's hash code'}]}', name=Optional.empty}"}],"methodDeclaration":" int hashCode(Object o)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 24,col 3)-(line 24,col 25)","methodTokenRange":"int hashCode(Object o);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * hashCode function for objects under consideration (not for Hasher objects).\n   * @param o object whose hash code to compute\n   * @return o's hash code\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o","parameterName":"o"}],"methodName":"hashCode","methodQualifiedSignature":"plume.Hasher.hashCode","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='hashCode function for objects under consideration (not for Hasher objects).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='object whose hash code to compute'}]}', name=Optional[o]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='o's hash code'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.Hasher.hashCode(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first value to test for equality","javadocBlockTagName":"o1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first value to test for equality'}]}', name=Optional[o1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second value to test for equality","javadocBlockTagName":"o2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second value to test for equality'}]}', name=Optional[o2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"whether o1 equals o2","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether o1 equals o2'}]}', name=Optional.empty}"}],"methodDeclaration":" boolean equals(Object o1, Object o2)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 34,col 3)-(line 34,col 39)","methodTokenRange":"boolean equals(Object o1, Object o2);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * The equality function over the objects being hashed.\n   * <p>\n   * Has nothing to do with testing Hashers themselves for equality.\n   * @param o1 the first value to test for equality\n   * @param o2 the second value to test for equality\n   * @return whether o1 equals o2\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o1","parameterName":"o1"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object o2","parameterName":"o2"}],"methodName":"equals","methodQualifiedSignature":"plume.Hasher.equals","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='The equality function over the objects being hashed.\n<p>\nHas nothing to do with testing Hashers themselves for equality.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first value to test for equality'}]}', name=Optional[o1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second value to test for equality'}]}', name=Optional[o2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether o1 equals o2'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.Hasher.equals(java.lang.Object, java.lang.Object)"}],"classJavadoc":"\/**\n * Hasher is intended to work like Comparable:  it is an optional argument\n * to a hashing data structure (such as a HashSet, HashMap, or WeakHashMap)\n * which specifies the hashCode() and equals() methods.\n *\n * If no Hasher is provided, then clients should act as if the following\n * Hasher were provided:\n * <pre>\n *   class DefaultHasher {\n *     int hashCode(Object o) { return o.hashCode(); }\n *     boolean equals(Object o, Object o2) { return o.equals(o2); }\n *   }\n * <\/pre>\n *\/\n","className":"Hasher","fields":[]}],"sourceFileId":36,"packageName":"plume"},{"sourceFileName":"plume.BibtexClean","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.IOException;\n"},{"importId":3,"import":"import java.io.PrintWriter;\n"},{"importId":4,"import":"import java.util.regex.Pattern;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.BibtexClean.BibtexClean()","variableDeclarationExprs":[],"constructorRange":"(line 36,col 3)-(line 38,col 3)","constructorJavadocComment":" This class is a collection of methods; it does not represent anything. ","constructorDeclaration":"private BibtexClean()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"BibtexClean","constructorQualifiedName":"plume.BibtexClean.BibtexClean","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 37,col 21)-(line 37,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private BibtexClean() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collection of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"command-line arguments","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments'}]}', name=Optional[args]}"}],"methodDeclaration":"public static void main(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (String filename : args) {\n        File in = new File(filename);\n        try (PrintWriter out = new PrintWriter(UtilMDE.bufferedFileWriter(in.getName()));\n            EntryReader er = new EntryReader(filename)) {\n            for (String line : er) {\n                if (line.equals(\"\") || line.startsWith(\"%\")) {\n                    out.println(line);\n                } else if (line.startsWith(\"@\")) {\n                    if (stringDef.matcher(line).matches()) {\n                        out.println(line);\n                    } else {\n                        out.println(line);\n                        while (er.hasNext() && ((line = er.next()) != null)) {\n                            out.println(line);\n                            if (entry_end.matcher(line).lookingAt()) {\n                                break;\n                            } else if (line.equals(\"\")) {\n                                System.err.printf(\"%s:%d: unterminated entry%n\", er.getFileName(), er.getLineNumber());\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Problem reading or writing \" + in + \": \" + e.getMessage());\n            System.exit(2);\n        }\n    }\n}","methodRange":"(line 49,col 3)-(line 81,col 3)","methodTokenRange":"public static void main(String[] args) {\n    for (String filename : args) {\n      File in = new File(filename);\n      try (PrintWriter out =\n              new PrintWriter(UtilMDE.bufferedFileWriter(in.getName())); \/\/ in current directory\n          EntryReader er = new EntryReader(filename)) {\n        for (String line : er) {\n          if (line.equals(\"\") || line.startsWith(\"%\")) {\n            out.println(line);\n          } else if (line.startsWith(\"@\")) {\n            if (stringDef.matcher(line).matches()) {\n              out.println(line);\n            } else {\n              out.println(line);\n              while (er.hasNext() && ((line = er.next()) != null)) {\n                out.println(line);\n                if (entry_end.matcher(line).lookingAt()) {\n                  break;\n                } else if (line.equals(\"\")) {\n                  System.err.printf(\n                      \"%s:%d: unterminated entry%n\", er.getFileName(), er.getLineNumber());\n                  break;\n                }\n              }\n            }\n          }\n        }\n      } catch (IOException e) {\n        System.err.println(\"Problem reading or writing \" + in + \": \" + e.getMessage());\n        System.exit(2);\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Main method for the BibtexClean program.\n   * @param args command-line arguments\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.BibtexClean.main","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Main method for the BibtexClean program.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments'}]}', name=Optional[args]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 56,col 27)-(line 56,col 28)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 56,col 50)-(line 56,col 52)","literalExprId":2,"literalExpr":"\"%\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 58,col 38)-(line 58,col 40)","literalExprId":3,"literalExpr":"\"@\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 63,col 61)-(line 63,col 64)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 67,col 40)-(line 67,col 41)","literalExprId":5,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 69,col 23)-(line 69,col 51)","literalExprId":6,"literalExpr":"\"%s:%d: unterminated entry%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 77,col 28)-(line 77,col 56)","literalExprId":7,"literalExpr":"\"Problem reading or writing \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 77,col 65)-(line 77,col 68)","literalExprId":8,"literalExpr":"\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 21)-(line 78,col 21)","literalExprId":9,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.BibtexClean.main(java.lang.String[])"}],"classJavadoc":"","className":"BibtexClean","fields":[{"fieldRange":"(line 41,col 3)-(line 42,col 86)","fieldName":"entry_end","fieldJavadocComment":" Regex for the end of a BibTeX entry. ","fieldTokenRange":"private static Pattern entry_end =\n      Pattern.compile(\"^[ \\t]*(?i)(year[ \\t]*=[ \\t]*[12][0-9][0-9][0-9][ \\t]*)?[)}]\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 42,col 23)-(line 42,col 84)","literalExprId":1,"literalExpr":"\"^[ \\t]*(?i)(year[ \\t]*=[ \\t]*[12][0-9][0-9][0-9][ \\t]*)?[)}]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"^[ \\t]*(?i)(year[ \\t]*=[ \\t]*[12][0-9][0-9][0-9][ \\t]*)?[)}]\")]","fieldType":"Pattern","fieldJavadoc":"Regex for the end of a BibTeX entry.\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 44,col 3)-(line 44,col 89)","fieldName":"stringDef","fieldJavadocComment":" Regex for a BibTeX string definition. ","fieldTokenRange":"private static Pattern stringDef = Pattern.compile(\"^@(?i)string(\\\\{.*\\\\}|\\\\(.*\\\\))$\");","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 44,col 54)-(line 44,col 87)","literalExprId":1,"literalExpr":"\"^@(?i)string(\\\\{.*\\\\}|\\\\(.*\\\\))$\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[Pattern.compile(\"^@(?i)string(\\\\{.*\\\\}|\\\\(.*\\\\))$\")]","fieldType":"Pattern","fieldJavadoc":"Regex for a BibTeX string definition.\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"}]}],"sourceFileId":37,"packageName":"plume"},{"sourceFileName":"plume.LimitedSizeIntSet","imports":[{"importId":1,"import":"import java.io.Serializable;\n"},{"importId":2,"import":"import java.util.List;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum number of values this set will be able to hold","javadocBlockTagName":"max_values","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum number of values this set will be able to hold'}]}', name=Optional[max_values]}"}],"constructorQualifiedSignature":"plume.LimitedSizeIntSet.LimitedSizeIntSet(int)","variableDeclarationExprs":[],"constructorRange":"(line 44,col 3)-(line 49,col 3)","constructorJavadocComment":"\n   * Create a new LimitedSizeIntSet that can hold max_values values.\n   * @param max_values the maximum number of values this set will be able to hold\n   ","constructorDeclaration":"public LimitedSizeIntSet(int max_values)","constructorBody":"{\n    assert max_values > 0;\n    values = new int[max_values];\n    num_values = 0;\n}","constructorName":"LimitedSizeIntSet","constructorQualifiedName":"plume.LimitedSizeIntSet.LimitedSizeIntSet","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int max_values","parameterName":"max_values"}],"literalExprs":[{"literalExprRange":"(line 45,col 25)-(line 45,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 48,col 18)-(line 48,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public LimitedSizeIntSet(int max_values) {\n    assert max_values > 0;\n    \/\/ this.max_values = max_values;\n    values = new int[max_values];\n    num_values = 0;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new LimitedSizeIntSet that can hold max_values values.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum number of values this set will be able to hold'}]}', name=Optional[max_values]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public void add(int elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (values == null) {\n        return;\n    }\n    if (contains(elt)) {\n        return;\n    }\n    if (num_values == values.length) {\n        values = null;\n        num_values++;\n        return;\n    }\n    values[num_values] = elt;\n    num_values++;\n}","methodRange":"(line 51,col 3)-(line 66,col 3)","methodTokenRange":"public void add(int elt) {\n    if (values == null) {\n      return;\n    }\n\n    if (contains(elt)) {\n      return;\n    }\n    if (num_values == values.length) {\n      values = null;\n      num_values++;\n      return;\n    }\n    values[num_values] = elt;\n    num_values++;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int elt","parameterName":"elt"}],"methodName":"add","methodQualifiedSignature":"plume.LimitedSizeIntSet.add","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 52,col 19)-(line 52,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 60,col 16)-(line 60,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.add(int)"},{"methodDeclaration":"public void addAll(LimitedSizeIntSet s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (this == s);\n    if (sameObject) {\n        return;\n    }\n    if (repNulled()) {\n        return;\n    }\n    if (s.repNulled()) {\n        int values_length = values.length;\n        if (s.size() > values_length) {\n            num_values = values_length + 1;\n            values = null;\n            return;\n        } else {\n            throw new Error(\"Arg is rep-nulled, so we don't know its values and can't add them to this.\");\n        }\n    }\n    for (int i = 0; i < s.size(); i++) {\n        assert s.values != null : \"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\";\n        add(s.values[i]);\n        if (repNulled()) {\n            return;\n        }\n    }\n}","methodRange":"(line 68,col 3)-(line 99,col 3)","methodTokenRange":"public void addAll(LimitedSizeIntSet s) {\n    @SuppressWarnings(\"interning\") \/\/ optimization; not a subclass of Collection, though\n    boolean sameObject = (this == s);\n    if (sameObject) {\n      return;\n    }\n    if (repNulled()) {\n      return;\n    }\n    if (s.repNulled()) {\n      int values_length = values.length;\n      \/\/ We don't know whether the elements of this and the argument were\n      \/\/ disjoint.  There might be anywhere from max(size(), s.size()) to\n      \/\/ (size() + s.size()) elements in the resulting set.\n      if (s.size() > values_length) {\n        num_values = values_length + 1;\n        values = null;\n        return;\n      } else {\n        throw new Error(\n            \"Arg is rep-nulled, so we don't know its values and can't add them to this.\");\n      }\n    }\n    for (int i = 0; i < s.size(); i++) {\n      assert s.values != null\n          : \"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\";\n      add(s.values[i]);\n      if (repNulled()) {\n        return; \/\/ optimization, not necessary for correctness\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"LimitedSizeIntSet","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.LimitedSizeIntSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.LimitedSizeIntSet","parameter":"LimitedSizeIntSet s","parameterName":"s"}],"methodName":"addAll","methodQualifiedSignature":"plume.LimitedSizeIntSet.addAll","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 69,col 23)-(line 69,col 33)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 83,col 38)-(line 83,col 38)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 84,col 18)-(line 84,col 21)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 88,col 13)-(line 88,col 88)","literalExprId":4,"literalExpr":"\"Arg is rep-nulled, so we don't know its values and can't add them to this.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 91,col 18)-(line 91,col 18)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 92,col 26)-(line 92,col 29)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 93,col 13)-(line 93,col 109)","literalExprId":7,"literalExpr":"\"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.addAll(plume.LimitedSizeIntSet)"},{"methodDeclaration":"public boolean contains(int elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (values == null) {\n        throw new UnsupportedOperationException();\n    }\n    for (int i = 0; i < num_values; i++) {\n        if (values[i] == elt) {\n            return true;\n        }\n    }\n    return false;\n}","methodRange":"(line 101,col 3)-(line 113,col 3)","methodTokenRange":"@SuppressWarnings(\"deterministic\") \/\/ pure wrt equals() but not ==: throws a new exception\n  \/*@Pure*\/\n  public boolean contains(int elt) {\n    if (values == null) {\n      throw new UnsupportedOperationException();\n    }\n    for (int i = 0; i < num_values; i++) {\n      if (values[i] == elt) {\n        return true;\n      }\n    }\n    return false;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int elt","parameterName":"elt"}],"methodName":"contains","methodQualifiedSignature":"plume.LimitedSizeIntSet.contains","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 101,col 21)-(line 101,col 35)","literalExprId":1,"literalExpr":"\"deterministic\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 104,col 19)-(line 104,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 107,col 18)-(line 107,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 109,col 16)-(line 109,col 19)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 112,col 12)-(line 112,col 16)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.contains(int)"},{"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return num_values;\n}","methodRange":"(line 122,col 3)-(line 124,col 3)","methodTokenRange":"public int size(\/*>>>@GuardSatisfied LimitedSizeIntSet this*\/) {\n    return num_values;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"size","methodQualifiedSignature":"plume.LimitedSizeIntSet.size","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.LimitedSizeIntSet.size()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"maximum capacity of the set representation","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum capacity of the set representation'}]}', name=Optional.empty}"}],"methodDeclaration":"public int max_size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (values == null) {\n        return num_values;\n    } else {\n        return values.length + 1;\n    }\n}","methodRange":"(line 132,col 3)-(line 138,col 3)","methodTokenRange":"public int max_size() {\n    if (values == null) {\n      return num_values;\n    } else {\n      return values.length + 1;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * An upper bound on how many distinct elements can be individually\n   * represented in the set.\n   * Returns max_values+1 (where max_values is the argument to the constructor).\n   * @return maximum capacity of the set representation\n   ","methodParameters":[],"methodName":"max_size","methodQualifiedSignature":"plume.LimitedSizeIntSet.max_size","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An upper bound on how many distinct elements can be individually\nrepresented in the set.\nReturns max_values+1 (where max_values is the argument to the constructor).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum capacity of the set representation'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 133,col 19)-(line 133,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 136,col 30)-(line 136,col 30)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.max_size()"},{"methodDeclaration":"public boolean repNulled()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return values == null;\n}","methodRange":"(line 142,col 3)-(line 144,col 3)","methodTokenRange":"public boolean repNulled() {\n    return values == null;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"repNulled","methodQualifiedSignature":"plume.LimitedSizeIntSet.repNulled","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 143,col 22)-(line 143,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.repNulled()"},{"methodDeclaration":"public LimitedSizeIntSet clone()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    LimitedSizeIntSet result;\n    try {\n        result = (LimitedSizeIntSet) super.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new Error();\n    }\n    if (values != null) {\n        result.values = values.clone();\n    }\n    return result;\n}","methodRange":"(line 146,col 3)-(line 159,col 3)","methodTokenRange":"@SuppressWarnings(\"sideeffectfree\") \/\/ side effect to local state (clone)\n  \/*@SideEffectFree*\/\n  public LimitedSizeIntSet clone(\/*>>>@GuardSatisfied LimitedSizeIntSet this*\/) {\n    LimitedSizeIntSet result;\n    try {\n      result = (LimitedSizeIntSet) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new Error(); \/\/ can't happen\n    }\n    if (values != null) {\n      result.values = values.clone();\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{plume.LimitedSizeIntSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"clone","methodQualifiedSignature":"plume.LimitedSizeIntSet.clone","methodJavadoc":"","methodReturnTypeDescribed":"plume.LimitedSizeIntSet","methodType":"LimitedSizeIntSet","literalExprs":[{"literalExprRange":"(line 146,col 21)-(line 146,col 36)","literalExprId":1,"literalExpr":"\"sideeffectfree\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 155,col 19)-(line 155,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.clone()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum size for the returned LimitedSizeIntSet","javadocBlockTagName":"max_values","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum size for the returned LimitedSizeIntSet'}]}', name=Optional[max_values]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list of LimitedSizeIntSet, whose elements will be merged","javadocBlockTagName":"slist","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list of LimitedSizeIntSet, whose elements will be merged'}]}', name=Optional[slist]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a LimitedSizeIntSet that merges the elements of slist","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LimitedSizeIntSet that merges the elements of slist'}]}', name=Optional.empty}"}],"methodDeclaration":"public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}","methodRange":"(line 169,col 3)-(line 175,col 3)","methodTokenRange":"public static LimitedSizeIntSet merge(int max_values, List<LimitedSizeIntSet> slist) {\n    LimitedSizeIntSet result = new LimitedSizeIntSet(max_values);\n    for (LimitedSizeIntSet s : slist) {\n      result.addAll(s);\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{plume.LimitedSizeIntSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Merges a list of LimitedSizeIntSet objects into a single object that\n   * represents the values seen by the entire list.  Returns the new\n   * object, whose max_values is the given integer.\n   * @param max_values the maximum size for the returned LimitedSizeIntSet\n   * @param slist a list of LimitedSizeIntSet, whose elements will be merged\n   * @return a LimitedSizeIntSet that merges the elements of slist\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int max_values","parameterName":"max_values"},{"parameterType":"List<LimitedSizeIntSet>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.LimitedSizeIntSet, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<plume.LimitedSizeIntSet>","parameter":"List<LimitedSizeIntSet> slist","parameterName":"slist"}],"methodName":"merge","methodQualifiedSignature":"plume.LimitedSizeIntSet.merge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Merges a list of LimitedSizeIntSet objects into a single object that\nrepresents the values seen by the entire list.  Returns the new\nobject, whose max_values is the given integer.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum size for the returned LimitedSizeIntSet'}]}', name=Optional[max_values]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list of LimitedSizeIntSet, whose elements will be merged'}]}', name=Optional[slist]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LimitedSizeIntSet that merges the elements of slist'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.LimitedSizeIntSet","methodType":"LimitedSizeIntSet","literalExprs":[],"methodQualifiedName":"plume.LimitedSizeIntSet.merge(int, java.util.List<plume.LimitedSizeIntSet>)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (\"[size=\" + size() + \"; \" + ((values == null) ? \"null\" : ArraysMDE.toString(values)) + \"]\");\n}","methodRange":"(line 178,col 3)-(line 184,col 3)","methodTokenRange":"public String toString(\/*>>>@GuardSatisfied LimitedSizeIntSet this*\/) {\n    return (\"[size=\"\n        + size()\n        + \"; \"\n        + ((values == null) ? \"null\" : ArraysMDE.toString(values))\n        + \"]\");\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.LimitedSizeIntSet.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 179,col 13)-(line 179,col 20)","literalExprId":1,"literalExpr":"\"[size=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 181,col 11)-(line 181,col 14)","literalExprId":2,"literalExpr":"\"; \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 182,col 23)-(line 182,col 26)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 182,col 31)-(line 182,col 36)","literalExprId":4,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 183,col 11)-(line 183,col 13)","literalExprId":5,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeIntSet.toString()"}],"classJavadoc":"","className":"LimitedSizeIntSet","fields":[{"fieldRange":"(line 28,col 3)-(line 28,col 49)","fieldName":"serialVersionUID","fieldJavadocComment":" remove fields, you should change this number to the current date.","fieldTokenRange":"static final long serialVersionUID = 20031021L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 28,col 40)-(line 28,col 48)","literalExprId":1,"literalExpr":"20031021L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[20031021L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 36,col 3)-(line 36,col 40)","fieldName":"values","fieldJavadocComment":"\n   * If null, then at least num_values distinct values have been seen.\n   * The size is not separately stored, because that would take extra space.\n   ","fieldTokenRange":"protected int \/*@Nullable*\/ [] values;","fieldTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"int[]","fieldJavadoc":"If null, then at least num_values distinct values have been seen.\nThe size is not separately stored, because that would take extra space.\n","fieldTypeResolvedDescribed":"int[]"},{"fieldRange":"(line 38,col 3)-(line 38,col 17)","fieldName":"num_values","fieldJavadocComment":" The number of active elements (equivalently, the first unused index). ","fieldTokenRange":"int num_values;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The number of active elements (equivalently, the first unused index).\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":38,"packageName":"plume"},{"sourceFileName":"plume.Partitioner","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the Object to be assigned to a bucket","javadocBlockTagName":"obj","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Object to be assigned to a bucket'}]}', name=Optional[obj]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a key representing the bucket containing obj","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a key representing the bucket containing obj'}]}', name=Optional.empty}"}],"methodDeclaration":" CLASS assignToBucket(ELEMENT obj)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 19,col 3)-(line 19,col 36)","methodTokenRange":"CLASS assignToBucket(ELEMENT obj);","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(CLASS, bounds=[Object])}","methodJavadocComment":" @param obj the Object to be assigned to a bucket\n   *  @return a key representing the bucket containing obj\n   ","methodParameters":[{"parameterType":"ELEMENT","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(ELEMENT, bounds=[Object])}","parameterTypeResolvedDescribed":"ELEMENT","parameter":"ELEMENT obj","parameterName":"obj"}],"methodName":"assignToBucket","methodQualifiedSignature":"plume.Partitioner.assignToBucket","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the Object to be assigned to a bucket'}]}', name=Optional[obj]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a key representing the bucket containing obj'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"CLASS","methodType":"CLASS","literalExprs":[],"methodQualifiedName":"plume.Partitioner.assignToBucket(ELEMENT)"}],"classJavadoc":"\/**\n * A Partitioner accepts Objects and assigns them to an equivalence\n * class.\n * @param <ELEMENT> the type of elements to be classified\n * @param <CLASS> the type of equivalence classes (classification buckets)\n * @see MultiRandSelector\n *\/\n","className":"Partitioner","fields":[]}],"sourceFileId":39,"packageName":"plume"},{"sourceFileName":"plume.Triple","imports":[],"typeDeclarations":[{"constructors":[{"constructorName":"Triple","constructorQualifiedName":"plume.Triple.Triple","constructorQualifiedSignature":"plume.Triple.Triple(T1, T2, T3)","constructorParameters":[{"parameterType":"T1","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T1, bounds=[])}","parameterTypeResolvedDescribed":"T1","parameter":"T1 a","parameterName":"a"},{"parameterType":"T2","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T2, bounds=[])}","parameterTypeResolvedDescribed":"T2","parameter":"T2 b","parameterName":"b"},{"parameterType":"T3","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T3, bounds=[])}","parameterTypeResolvedDescribed":"T3","parameter":"T3 c","parameterName":"c"}],"literalExprs":[],"constructorTokenRange":"public Triple(T1 a, T2 b, T3 c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }","variableDeclarationExprs":[],"constructorRange":"(line 21,col 3)-(line 25,col 3)","constructorJavadocComment":"","constructorDeclaration":"public Triple(T1 a, T2 b, T3 c)","constructorBody":"{\n    this.a = a;\n    this.b = b;\n    this.c = c;\n}","constructorJavadoc":""}],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of first argument","javadocBlockTagName":"<A>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of first argument'}]}', name=Optional[<A>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of second argument","javadocBlockTagName":"<B>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of second argument'}]}', name=Optional[<B>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"type of third argument","javadocBlockTagName":"<C>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of third argument'}]}', name=Optional[<C>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"first argument","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first argument'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second argument","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second argument'}]}', name=Optional[b]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"third argument","javadocBlockTagName":"c","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='third argument'}]}', name=Optional[c]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a triple of the values (a, b, c)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a triple of the values (a, b, c)'}]}', name=Optional.empty}"}],"methodDeclaration":"public static Triple<A, B, C> of(A a, B b, C c)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return new Triple<A, B, C>(a, b, c);\n}","methodRange":"(line 36,col 3)-(line 38,col 3)","methodTokenRange":"public static <A, B, C> Triple<A, B, C> of(A a, B b, C c) {\n    return new Triple<A, B, C>(a, b, c);\n  }","methodReturnTypeResolved":"ReferenceType{plume.Triple, typeParametersMap=TypeParametersMap{nameToValue={plume.Triple.T2=TypeVariable {JPTypeParameter(B, bounds=[])}, plume.Triple.T1=TypeVariable {JPTypeParameter(A, bounds=[])}, plume.Triple.T3=TypeVariable {JPTypeParameter(C, bounds=[])}}}}","methodJavadocComment":" Factory method with short name and no need to name type parameters.\n   * @param <A> type of first argument\n   * @param <B> type of second argument\n   * @param <C> type of third argument\n   * @param a first argument\n   * @param b second argument\n   * @param c third argument\n   * @return a triple of the values (a, b, c)\n   ","methodParameters":[{"parameterType":"A","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(A, bounds=[])}","parameterTypeResolvedDescribed":"A","parameter":"A a","parameterName":"a"},{"parameterType":"B","parameterId":2,"parameterTypeResolved":"TypeVariable {JPTypeParameter(B, bounds=[])}","parameterTypeResolvedDescribed":"B","parameter":"B b","parameterName":"b"},{"parameterType":"C","parameterId":3,"parameterTypeResolved":"TypeVariable {JPTypeParameter(C, bounds=[])}","parameterTypeResolvedDescribed":"C","parameter":"C c","parameterName":"c"}],"methodName":"of","methodQualifiedSignature":"plume.Triple.of","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Factory method with short name and no need to name type parameters.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of first argument'}]}', name=Optional[<A>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of second argument'}]}', name=Optional[<B>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='type of third argument'}]}', name=Optional[<C>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first argument'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second argument'}]}', name=Optional[b]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='third argument'}]}', name=Optional[c]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a triple of the values (a, b, c)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.Triple<A, B, C>","methodType":"Triple<A, B, C>","literalExprs":[],"methodQualifiedName":"plume.Triple.of(A, B, C)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return \"<\" + String.valueOf(a) + \",\" + String.valueOf(b) + \",\" + String.valueOf(c) + \">\";\n}","methodRange":"(line 41,col 3)-(line 43,col 3)","methodTokenRange":"public String toString(\/*>>>@GuardSatisfied Triple<T1,T2,T3> this*\/) {\n    return \"<\" + String.valueOf(a) + \",\" + String.valueOf(b) + \",\" + String.valueOf(c) + \">\";\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.Triple.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 42,col 12)-(line 42,col 14)","literalExprId":1,"literalExpr":"\"<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 42,col 38)-(line 42,col 40)","literalExprId":2,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 42,col 64)-(line 42,col 66)","literalExprId":3,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 42,col 90)-(line 42,col 92)","literalExprId":4,"literalExpr":"\">\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Triple.toString()"},{"methodDeclaration":"public boolean equals(Object obj)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (obj instanceof Triple<?, ?, ?>) {\n        @SuppressWarnings(\"unchecked\")\n        Triple<T1, T2, T3> other = (Triple<T1, T2, T3>) obj;\n        boolean aEquals = ((this.a == other.a) || (this.a != null && (this.a.equals(other.a))));\n        boolean bEquals = ((this.b == other.b) || (this.b != null && (this.b.equals(other.b))));\n        boolean cEquals = ((this.c == other.c) || (this.c != null && (this.c.equals(other.c))));\n        return aEquals && bEquals && cEquals;\n    } else {\n        return false;\n    }\n}","methodRange":"(line 45,col 3)-(line 60,col 3)","methodTokenRange":"@SuppressWarnings(\"interning\") \/\/ equality testing optimization\n  \/*@Pure*\/\n  public boolean equals(\n      \/*>>>@GuardSatisfied Triple<T1,T2,T3> this,*\/\n      \/*@GuardSatisfied*\/ \/*@Nullable*\/ Object obj) {\n    if (obj instanceof Triple<?, ?, ?>) {\n      @SuppressWarnings(\"unchecked\")\n      Triple<T1, T2, T3> other = (Triple<T1, T2, T3>) obj;\n      boolean aEquals = ((this.a == other.a) || (this.a != null && (this.a.equals(other.a))));\n      boolean bEquals = ((this.b == other.b) || (this.b != null && (this.b.equals(other.b))));\n      boolean cEquals = ((this.c == other.c) || (this.c != null && (this.c.equals(other.c))));\n      return aEquals && bEquals && cEquals;\n    } else {\n      return false;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"equals","methodQualifiedSignature":"plume.Triple.equals","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 45,col 21)-(line 45,col 31)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 51,col 25)-(line 51,col 35)","literalExprId":2,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 53,col 60)-(line 53,col 63)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 54,col 60)-(line 54,col 63)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 55,col 60)-(line 55,col 63)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 58,col 14)-(line 58,col 18)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.Triple.equals(java.lang.Object)"},{"methodDeclaration":"public int hashCode()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (((a == null) ? 0 : a.hashCode()) + ((b == null) ? 0 : b.hashCode()) + ((c == null) ? 0 : c.hashCode()));\n}","methodRange":"(line 64,col 3)-(line 68,col 3)","methodTokenRange":"public int hashCode(\/*>>>@GuardSatisfied Triple<T1,T2,T3> this*\/) {\n    return (((a == null) ? 0 : a.hashCode())\n        + ((b == null) ? 0 : b.hashCode())\n        + ((c == null) ? 0 : c.hashCode()));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"hashCode","methodQualifiedSignature":"plume.Triple.hashCode","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 65,col 20)-(line 65,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 65,col 28)-(line 65,col 28)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 66,col 18)-(line 66,col 21)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 66,col 26)-(line 66,col 26)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 67,col 18)-(line 67,col 21)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 67,col 26)-(line 67,col 26)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Triple.hashCode()"}],"classJavadoc":"\/**\n * Mutable triple class:\n * type-safely holds three objects of possibly-different types.\n * @param <T1> the type of the first element of the triple\n * @param <T2> the type of the second element of the triple\n * @param <T3> the type of the third element of the triple\n *\/\n","className":"Triple","fields":[{"fieldRange":"(line 17,col 3)-(line 17,col 14)","fieldName":"a","fieldJavadocComment":"","fieldTokenRange":"public T1 a;","fieldTypeResolved":"TypeVariable {JPTypeParameter(T1, bounds=[])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"T1","fieldJavadoc":"","fieldTypeResolvedDescribed":"T1"},{"fieldRange":"(line 18,col 3)-(line 18,col 14)","fieldName":"b","fieldJavadocComment":"","fieldTokenRange":"public T2 b;","fieldTypeResolved":"TypeVariable {JPTypeParameter(T2, bounds=[])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"T2","fieldJavadoc":"","fieldTypeResolvedDescribed":"T2"},{"fieldRange":"(line 19,col 3)-(line 19,col 14)","fieldName":"c","fieldJavadocComment":"","fieldTokenRange":"public T3 c;","fieldTypeResolved":"TypeVariable {JPTypeParameter(T3, bounds=[])}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"T3","fieldJavadoc":"","fieldTypeResolvedDescribed":"T3"}]}],"sourceFileId":40,"packageName":"plume"},{"sourceFileName":"plume.Options","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.PrintStream;\n"},{"importId":3,"import":"import java.lang.annotation.Annotation;\n"},{"importId":4,"import":"import java.lang.reflect.Constructor;\n"},{"importId":5,"import":"import java.lang.reflect.Field;\n"},{"importId":6,"import":"import java.lang.reflect.Method;\n"},{"importId":7,"import":"import java.lang.reflect.Modifier;\n"},{"importId":8,"import":"import java.lang.reflect.ParameterizedType;\n"},{"importId":9,"import":"import java.lang.reflect.Type;\n"},{"importId":10,"import":"import java.util.ArrayList;\n"},{"importId":11,"import":"import java.util.Arrays;\n"},{"importId":12,"import":"import java.util.Collection;\n"},{"importId":13,"import":"import java.util.Collections;\n"},{"importId":14,"import":"import java.util.LinkedHashMap;\n"},{"importId":15,"import":"import java.util.List;\n"},{"importId":16,"import":"import java.util.Map;\n"},{"importId":17,"import":"import java.util.Objects;\n"},{"importId":18,"import":"import java.util.regex.Pattern;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the classes whose options to process","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the classes whose options to process'}]}', name=Optional[args]}"}],"constructorQualifiedSignature":"plume.Options.Options(java.lang.Object...)","variableDeclarationExprs":[],"constructorRange":"(line 616,col 3)-(line 618,col 3)","constructorJavadocComment":"\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case its static fields are set.  The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param args the classes whose options to process\n   ","constructorDeclaration":"public Options(Object... args)","constructorBody":"{\n    this(\"\", args);\n}","constructorName":"Options","constructorQualifiedName":"plume.Options.Options","constructorParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"literalExprs":[{"literalExprRange":"(line 617,col 10)-(line 617,col 11)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public Options(\/*@UnknownInitialization*\/ \/*@Raw*\/ Object... args) {\n    this(\"\", args);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prepare for option processing.  Creates an object that will set fields\nin all the given arguments.  An argument to this method may be a\nClass, in which case its static fields are set.  The names of all the\noptions (that is, the fields annotated with &#064;'}, JavadocInlineTag{tagName='link', type=LINK, content=' Option'}, JavadocSnippet{text=') must be\nunique across all the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the classes whose options to process'}]}', name=Optional[args]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a synopsis of how to call your program","javadocBlockTagName":"usage_synopsis","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a synopsis of how to call your program'}]}', name=Optional[usage_synopsis]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the classes whose options to process","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the classes whose options to process'}]}', name=Optional[args]}"}],"constructorQualifiedSignature":"plume.Options.Options(java.lang.String, java.lang.Object...)","variableDeclarationExprs":[{"variableType":"boolean","variableName":"seen_first_opt","variableDeclarationExprId":1,"variableDeclarationExpr":"boolean seen_first_opt = false","variableDeclarationExprRange":"(line 641,col 5)-(line 641,col 34)","variableTypeResolved":"PrimitiveTypeUsage{name='boolean'}","variableRange":"(line 641,col 13)-(line 641,col 34)"},{"variableType":"Object","variableName":"obj","variableDeclarationExprId":2,"variableDeclarationExpr":"Object obj","variableDeclarationExprRange":"(line 644,col 10)-(line 644,col 19)","variableTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 644,col 17)-(line 644,col 19)"},{"variableType":"boolean","variableName":"is_class","variableDeclarationExprId":3,"variableDeclarationExpr":"boolean is_class = obj instanceof Class<?>","variableDeclarationExprRange":"(line 645,col 7)-(line 645,col 48)","variableTypeResolved":"PrimitiveTypeUsage{name='boolean'}","variableRange":"(line 645,col 15)-(line 645,col 48)"},{"variableType":"String","variableName":"current_group","variableDeclarationExprId":4,"variableDeclarationExpr":"String current_group = null","variableDeclarationExprRange":"(line 646,col 7)-(line 646,col 33)","variableTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 646,col 14)-(line 646,col 33)"},{"variableType":"Class<?>","variableName":"clazz","variableDeclarationExprId":5,"variableDeclarationExpr":"@SuppressWarnings({ \"rawness\", \"initialization\" })\nClass<?> clazz = (is_class ? (Class<?>) obj : obj.getClass())","variableDeclarationExprRange":"(line 648,col 7)-(line 653,col 96)","variableTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","variableRange":"(line 652,col 58)-(line 653,col 96)"},{"variableType":"Field[]","variableName":"fields","variableDeclarationExprId":6,"variableDeclarationExpr":"Field[] fields = clazz.getDeclaredFields()","variableDeclarationExprRange":"(line 657,col 7)-(line 657,col 48)","variableTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.reflect.Field, typeParametersMap=TypeParametersMap{nameToValue={}}}}","variableRange":"(line 657,col 15)-(line 657,col 48)"},{"variableType":"Field","variableName":"f","variableDeclarationExprId":7,"variableDeclarationExpr":"Field f","variableDeclarationExprRange":"(line 659,col 12)-(line 659,col 18)","variableTypeResolved":"ReferenceType{java.lang.reflect.Field, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 659,col 18)-(line 659,col 18)"},{"variableType":"Object","variableName":"obj_nonraw","variableDeclarationExprId":8,"variableDeclarationExpr":"@SuppressWarnings(\"cast\")\nObject obj_nonraw = (Object) obj","variableDeclarationExprRange":"(line 662,col 11)-(line 663,col 71)","variableTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 663,col 18)-(line 663,col 71)"},{"variableType":"Option","variableName":"option","variableDeclarationExprId":9,"variableDeclarationExpr":"Option option = safeGetAnnotation(f, Option.class)","variableDeclarationExprRange":"(line 679,col 9)-(line 679,col 58)","variableTypeResolved":"ReferenceType{plume.Option, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 679,col 16)-(line 679,col 58)"},{"variableType":"boolean","variableName":"unpublicized","variableDeclarationExprId":10,"variableDeclarationExpr":"boolean unpublicized = safeGetAnnotation(f, Unpublicized.class) != null","variableDeclarationExprRange":"(line 684,col 9)-(line 684,col 79)","variableTypeResolved":"PrimitiveTypeUsage{name='boolean'}","variableRange":"(line 684,col 17)-(line 684,col 79)"},{"variableType":"OptionInfo","variableName":"oi","variableDeclarationExprId":11,"variableDeclarationExpr":"@SuppressWarnings(\"initialization\")\nOptionInfo oi = new OptionInfo(f, option, is_class ? null : obj, unpublicized)","variableDeclarationExprRange":"(line 690,col 9)-(line 693,col 74)","variableTypeResolved":"ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 692,col 37)-(line 693,col 74)"},{"variableType":"OptionGroup","variableName":"optionGroup","variableDeclarationExprId":12,"variableDeclarationExpr":"OptionGroup optionGroup = safeGetAnnotation(f, OptionGroup.class)","variableDeclarationExprRange":"(line 702,col 9)-(line 702,col 73)","variableTypeResolved":"ReferenceType{plume.OptionGroup, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 702,col 21)-(line 702,col 73)"},{"variableType":"String","variableName":"name","variableDeclarationExprId":13,"variableDeclarationExpr":"String name = optionGroup.value()","variableDeclarationExprRange":"(line 740,col 11)-(line 740,col 43)","variableTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 740,col 18)-(line 740,col 43)"},{"variableType":"OptionGroupInfo","variableName":"gi","variableDeclarationExprId":14,"variableDeclarationExpr":"OptionGroupInfo gi = new OptionGroupInfo(optionGroup)","variableDeclarationExprRange":"(line 744,col 11)-(line 744,col 63)","variableTypeResolved":"ReferenceType{plume.Options.OptionGroupInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 744,col 27)-(line 744,col 63)"},{"variableType":"OptionGroupInfo","variableName":"ogi","variableDeclarationExprId":15,"variableDeclarationExpr":"@SuppressWarnings(\"nullness\")\nOptionGroupInfo ogi = group_map.get(current_group)","variableDeclarationExprRange":"(line 748,col 9)-(line 749,col 71)","variableTypeResolved":"ReferenceType{plume.Options.OptionGroupInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 749,col 38)-(line 749,col 71)"},{"variableType":"String","variableName":"prefix","variableDeclarationExprId":16,"variableDeclarationExpr":"String prefix = use_single_dash ? \"-\" : \"--\"","variableDeclarationExprRange":"(line 754,col 5)-(line 754,col 48)","variableTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 754,col 12)-(line 754,col 48)"},{"variableType":"OptionInfo","variableName":"oi","variableDeclarationExprId":17,"variableDeclarationExpr":"OptionInfo oi","variableDeclarationExprRange":"(line 757,col 10)-(line 757,col 22)","variableTypeResolved":"ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 757,col 21)-(line 757,col 22)"},{"variableType":"String","variableName":"alias","variableDeclarationExprId":18,"variableDeclarationExpr":"String alias","variableDeclarationExprRange":"(line 772,col 14)-(line 772,col 25)","variableTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","variableRange":"(line 772,col 21)-(line 772,col 25)"}],"constructorRange":"(line 630,col 3)-(line 780,col 3)","constructorJavadocComment":"\n   * Prepare for option processing.  Creates an object that will set fields\n   * in all the given arguments.  An argument to this method may be a\n   * Class, in which case it must be fully initalized and its static fields are set.\n   * The names of all the\n   * options (that is, the fields annotated with &#064;{@link Option}) must be\n   * unique across all the arguments.\n   * @param usage_synopsis a synopsis of how to call your program\n   * @param args the classes whose options to process\n   ","constructorDeclaration":"public Options(String usage_synopsis, Object... args)","constructorBody":"{\n    if (args.length == 0) {\n        throw new Error(\"Must pass at least one object to Options constructor\");\n    }\n    this.usage_synopsis = usage_synopsis;\n    this.use_groups = false;\n    boolean seen_first_opt = false;\n    for (Object obj : args) {\n        boolean is_class = obj instanceof Class<?>;\n        String current_group = null;\n        @SuppressWarnings({ \"rawness\", \"initialization\" })\n        Class<?> clazz = (is_class ? (Class<?>) obj : obj.getClass());\n        if (main_class == Void.TYPE) {\n            main_class = clazz;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field f : fields) {\n            try {\n                @SuppressWarnings(\"cast\")\n                Object obj_nonraw = (Object) obj;\n                debug_options.log(\"Considering field %s of object %s%n\", f, obj_nonraw);\n            } catch (Throwable t) {\n                debug_options.log(\"Considering field %s of object of type %s%n\", f, obj.getClass());\n            }\n            try {\n                debug_options.log(\"  with annotations %s%n\", Arrays.toString(f.getDeclaredAnnotations()));\n            } catch (java.lang.ArrayStoreException e) {\n                if (e.getMessage() != null && Objects.equals(e.getMessage(), \"sun.reflect.annotation.TypeNotPresentExceptionProxy\")) {\n                    debug_options.log(\"  with TypeNotPresentExceptionProxy while getting annotations%n\");\n                } else {\n                    throw e;\n                }\n            }\n            Option option = safeGetAnnotation(f, Option.class);\n            if (option == null) {\n                continue;\n            }\n            boolean unpublicized = safeGetAnnotation(f, Unpublicized.class) != null;\n            if (is_class && !Modifier.isStatic(f.getModifiers())) {\n                throw new Error(\"non-static option \" + f + \" in class \" + obj);\n            }\n            @SuppressWarnings(\"initialization\")\n            OptionInfo oi = new OptionInfo(f, option, is_class ? null : obj, unpublicized);\n            options.add(oi);\n            if (oi.list != null && !oi.unpublicized) {\n                print_list_help = true;\n            }\n            OptionGroup optionGroup = safeGetAnnotation(f, OptionGroup.class);\n            if (!seen_first_opt) {\n                seen_first_opt = true;\n                if (optionGroup != null) {\n                    use_groups = true;\n                } else {\n                    continue;\n                }\n            }\n            if (!use_groups) {\n                if (optionGroup != null) {\n                    throw new Error(\"missing @OptionGroup annotation on the first \" + \"@Option-annotated field of class \" + main_class);\n                } else {\n                    continue;\n                }\n            }\n            if (current_group == null && optionGroup == null) {\n                throw new Error(\"missing @OptionGroup annotation in field \" + f + \" of class \" + obj);\n            } else if (optionGroup != null) {\n                String name = optionGroup.value();\n                if (group_map.containsKey(name)) {\n                    throw new Error(\"option group \" + name + \" declared twice\");\n                }\n                OptionGroupInfo gi = new OptionGroupInfo(optionGroup);\n                group_map.put(name, gi);\n                current_group = name;\n            }\n            @SuppressWarnings(\"nullness\")\n            OptionGroupInfo ogi = group_map.get(current_group);\n            ogi.optionList.add(oi);\n        }\n    }\n    String prefix = use_single_dash ? \"-\" : \"--\";\n    for (OptionInfo oi : options) {\n        if (oi.short_name != null) {\n            if (name_map.containsKey(\"-\" + oi.short_name)) {\n                throw new Error(\"short name \" + oi + \" appears twice\");\n            }\n            name_map.put(\"-\" + oi.short_name, oi);\n        }\n        if (name_map.containsKey(prefix + oi.long_name)) {\n            throw new Error(\"long name \" + oi + \" appears twice\");\n        }\n        name_map.put(prefix + oi.long_name, oi);\n        if (use_dashes && oi.long_name.contains(\"-\")) {\n            name_map.put(prefix + oi.long_name.replace('-', '_'), oi);\n        }\n        if (oi.aliases.length > 0) {\n            for (String alias : oi.aliases) {\n                if (name_map.containsKey(alias)) {\n                    throw new Error(\"alias \" + oi + \" appears twice\");\n                }\n                name_map.put(alias, oi);\n            }\n        }\n    }\n}","constructorName":"Options","constructorQualifiedName":"plume.Options.Options","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String usage_synopsis","parameterName":"usage_synopsis"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"literalExprs":[{"literalExprRange":"(line 632,col 24)-(line 632,col 24)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 633,col 23)-(line 633,col 76)","literalExprId":2,"literalExpr":"\"Must pass at least one object to Options constructor\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 638,col 23)-(line 638,col 27)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 641,col 30)-(line 641,col 34)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 646,col 30)-(line 646,col 33)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 649,col 9)-(line 649,col 17)","literalExprId":6,"literalExpr":"\"rawness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 650,col 9)-(line 650,col 24)","literalExprId":7,"literalExpr":"\"initialization\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 662,col 29)-(line 662,col 34)","literalExprId":8,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 664,col 29)-(line 664,col 65)","literalExprId":9,"literalExpr":"\"Considering field %s of object %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 666,col 29)-(line 666,col 73)","literalExprId":10,"literalExpr":"\"Considering field %s of object of type %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 669,col 29)-(line 669,col 53)","literalExprId":11,"literalExpr":"\"  with annotations %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 671,col 33)-(line 671,col 36)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 673,col 35)-(line 673,col 87)","literalExprId":13,"literalExpr":"\"sun.reflect.annotation.TypeNotPresentExceptionProxy\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 674,col 31)-(line 674,col 95)","literalExprId":14,"literalExpr":"\"  with TypeNotPresentExceptionProxy while getting annotations%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 680,col 23)-(line 680,col 26)","literalExprId":15,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 684,col 76)-(line 684,col 79)","literalExprId":16,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 687,col 27)-(line 687,col 46)","literalExprId":17,"literalExpr":"\"non-static option \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 687,col 54)-(line 687,col 65)","literalExprId":18,"literalExpr":"\" in class \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 691,col 13)-(line 691,col 28)","literalExprId":19,"literalExpr":"\"initialization\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 693,col 50)-(line 693,col 53)","literalExprId":20,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 698,col 24)-(line 698,col 27)","literalExprId":21,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 699,col 29)-(line 699,col 32)","literalExprId":22,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 705,col 28)-(line 705,col 31)","literalExprId":23,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 708,col 30)-(line 708,col 33)","literalExprId":24,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 709,col 26)-(line 709,col 29)","literalExprId":25,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 716,col 30)-(line 716,col 33)","literalExprId":26,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 723,col 17)-(line 723,col 63)","literalExprId":27,"literalExpr":"\"missing @OptionGroup annotation on the first \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 724,col 23)-(line 724,col 57)","literalExprId":28,"literalExpr":"\"@Option-annotated field of class \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 736,col 30)-(line 736,col 33)","literalExprId":29,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 736,col 53)-(line 736,col 56)","literalExprId":30,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 738,col 27)-(line 738,col 69)","literalExprId":31,"literalExpr":"\"missing @OptionGroup annotation in field \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 738,col 77)-(line 738,col 88)","literalExprId":32,"literalExpr":"\" of class \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 739,col 35)-(line 739,col 38)","literalExprId":33,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 742,col 29)-(line 742,col 43)","literalExprId":34,"literalExpr":"\"option group \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 742,col 54)-(line 742,col 70)","literalExprId":35,"literalExpr":"\" declared twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 748,col 27)-(line 748,col 36)","literalExprId":36,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 754,col 39)-(line 754,col 41)","literalExprId":37,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 754,col 45)-(line 754,col 48)","literalExprId":38,"literalExpr":"\"--\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 28)-(line 758,col 31)","literalExprId":39,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 759,col 34)-(line 759,col 36)","literalExprId":40,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 27)-(line 760,col 39)","literalExprId":41,"literalExpr":"\"short name \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 48)-(line 760,col 63)","literalExprId":42,"literalExpr":"\" appears twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 762,col 22)-(line 762,col 24)","literalExprId":43,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 765,col 25)-(line 765,col 36)","literalExprId":44,"literalExpr":"\"long name \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 765,col 45)-(line 765,col 60)","literalExprId":45,"literalExpr":"\" appears twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 768,col 47)-(line 768,col 49)","literalExprId":46,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 769,col 52)-(line 769,col 54)","literalExprId":47,"literalExpr":"'-'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 769,col 57)-(line 769,col 59)","literalExprId":48,"literalExpr":"'_'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 771,col 31)-(line 771,col 31)","literalExprId":49,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 774,col 29)-(line 774,col 36)","literalExprId":50,"literalExpr":"\"alias \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 774,col 45)-(line 774,col 60)","literalExprId":51,"literalExpr":"\" appears twice\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"public Options(String usage_synopsis, \/*@UnknownInitialization*\/ \/*@Raw*\/ Object... args) {\n\n    if (args.length == 0) {\n      throw new Error(\"Must pass at least one object to Options constructor\");\n    }\n\n    this.usage_synopsis = usage_synopsis;\n\n    this.use_groups = false;\n\n    \/\/ true once the first @Option annotation is observed, false until then.\n    boolean seen_first_opt = false;\n\n    \/\/ Loop through each specified object or class\n    for (Object obj : args) {\n      boolean is_class = obj instanceof Class<?>;\n      String current_group = null;\n\n      @SuppressWarnings({\n        \"rawness\",\n        \"initialization\"\n      }) \/\/ if is_class is true, obj is a non-null initialized Class\n      \/*@Initialized*\/ \/*@NonRaw*\/ \/*@NonNull*\/ Class<?> clazz =\n          (is_class ? (\/*@Initialized*\/ \/*@NonRaw*\/ \/*@NonNull*\/ Class<?>) obj : obj.getClass());\n      if (main_class == Void.TYPE) {\n        main_class = clazz;\n      }\n      Field[] fields = clazz.getDeclaredFields();\n\n      for (Field f : fields) {\n        try {\n          \/\/ Possible exception because \"obj\" is not yet initialized; catch it and proceed\n          @SuppressWarnings(\"cast\")\n          Object obj_nonraw = (\/*@Initialized*\/ \/*@NonRaw*\/ Object) obj;\n          debug_options.log(\"Considering field %s of object %s%n\", f, obj_nonraw);\n        } catch (Throwable t) {\n          debug_options.log(\"Considering field %s of object of type %s%n\", f, obj.getClass());\n        }\n        try {\n          debug_options.log(\"  with annotations %s%n\", Arrays.toString(f.getDeclaredAnnotations()));\n        } catch (java.lang.ArrayStoreException e) {\n          if (e.getMessage() != null\n              && Objects.equals(\n                  e.getMessage(), \"sun.reflect.annotation.TypeNotPresentExceptionProxy\")) {\n            debug_options.log(\"  with TypeNotPresentExceptionProxy while getting annotations%n\");\n          } else {\n            throw e;\n          }\n        }\n        Option option = safeGetAnnotation(f, Option.class);\n        if (option == null) {\n          continue;\n        }\n\n        boolean unpublicized = safeGetAnnotation(f, Unpublicized.class) != null;\n\n        if (is_class && !Modifier.isStatic(f.getModifiers())) {\n          throw new Error(\"non-static option \" + f + \" in class \" + obj);\n        }\n\n        @SuppressWarnings(\n            \"initialization\") \/\/ \"new MyClass(underInitialization)\" yields @UnderInitialization even when @Initialized would be safe\n        \/*@Initialized*\/ OptionInfo oi =\n            new OptionInfo(f, option, is_class ? null : obj, unpublicized);\n        options.add(oi);\n\n        \/\/ FIXME: should also check that the option does not belong to an\n        \/\/ unpublicized option group\n        if (oi.list != null && !oi.unpublicized) {\n          print_list_help = true;\n        }\n\n        OptionGroup optionGroup = safeGetAnnotation(f, OptionGroup.class);\n\n        if (!seen_first_opt) {\n          seen_first_opt = true;\n          \/\/ This is the first @Option annotation encountered so we can decide\n          \/\/ now if the user intends to use option groups.\n          if (optionGroup != null) {\n            use_groups = true;\n          } else {\n            continue;\n          }\n        }\n\n        if (!use_groups) {\n          if (optionGroup != null) {\n            \/\/ The user included an @OptionGroup annotation in their code\n            \/\/ without including an @OptionGroup annotation on the first\n            \/\/ @Option-annotated field, hence violating the requirement.\n\n            \/\/ NOTE: changing this error string requires changes to TestPlume\n            throw new Error(\n                \"missing @OptionGroup annotation on the first \"\n                    + \"@Option-annotated field of class \"\n                    + main_class);\n          } else {\n            continue;\n          }\n        }\n\n        \/\/ use_groups is true at this point.  The variable current_group is set\n        \/\/ to null at the start of every iteration through 'args'.  This is so\n        \/\/ we can check that the first @Option-annotated field of every\n        \/\/ class\/object in 'args' has an @OptionGroup annotation when use_groups\n        \/\/ is true, as required.\n        if (current_group == null && optionGroup == null) {\n          \/\/ NOTE: changing this error string requires changes to TestPlume\n          throw new Error(\"missing @OptionGroup annotation in field \" + f + \" of class \" + obj);\n        } else if (optionGroup != null) {\n          String name = optionGroup.value();\n          if (group_map.containsKey(name)) {\n            throw new Error(\"option group \" + name + \" declared twice\");\n          }\n          OptionGroupInfo gi = new OptionGroupInfo(optionGroup);\n          group_map.put(name, gi);\n          current_group = name;\n        } \/\/ current_group is non-null at this point\n        @SuppressWarnings(\"nullness\") \/\/ map key\n        \/*@NonNull*\/ OptionGroupInfo ogi = group_map.get(current_group);\n        ogi.optionList.add(oi);\n      } \/\/ loop through fields\n    } \/\/ loop through args\n\n    String prefix = use_single_dash ? \"-\" : \"--\";\n\n    \/\/ Add each option to the option name map\n    for (OptionInfo oi : options) {\n      if (oi.short_name != null) {\n        if (name_map.containsKey(\"-\" + oi.short_name)) {\n          throw new Error(\"short name \" + oi + \" appears twice\");\n        }\n        name_map.put(\"-\" + oi.short_name, oi);\n      }\n      if (name_map.containsKey(prefix + oi.long_name)) {\n        throw new Error(\"long name \" + oi + \" appears twice\");\n      }\n      name_map.put(prefix + oi.long_name, oi);\n      if (use_dashes && oi.long_name.contains(\"-\")) {\n        name_map.put(prefix + oi.long_name.replace('-', '_'), oi);\n      }\n      if (oi.aliases.length > 0) {\n        for (String alias : oi.aliases) {\n          if (name_map.containsKey(alias)) {\n            throw new Error(\"alias \" + oi + \" appears twice\");\n          }\n          name_map.put(alias, oi);\n        }\n      }\n    }\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prepare for option processing.  Creates an object that will set fields\nin all the given arguments.  An argument to this method may be a\nClass, in which case it must be fully initalized and its static fields are set.\nThe names of all the\noptions (that is, the fields annotated with &#064;'}, JavadocInlineTag{tagName='link', type=LINK, content=' Option'}, JavadocSnippet{text=') must be\nunique across all the arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a synopsis of how to call your program'}]}', name=Optional[usage_synopsis]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the classes whose options to process'}]}', name=Optional[args]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 240,col 3)-(line 479,col 3)","classOrInterfaceTokenRange":"class OptionInfo {\n\n    \/** What variable the option sets. *\/\n    Field field;\n\n    \/\/    \/** Option annotation on the field. *\/\n    \/\/    Option option;\n\n    \/** Object containing the field.  Null if the field is static. *\/\n    \/*@UnknownInitialization*\/ \/*@Raw*\/ \/*@Nullable*\/ Object obj;\n\n    \/** Short (one-character) argument name. *\/\n    \/*@Nullable*\/ String short_name;\n\n    \/** Long argument name. *\/\n    String long_name;\n\n    \/** Aliases for this option. *\/\n    String[] aliases;\n\n    \/** Argument description: the first line. *\/\n    String description;\n\n    \/** Full Javadoc description. *\/\n    \/*@Nullable*\/ String jdoc;\n\n    \/**\n     * Maps names of enum constants to their corresponding Javadoc.  This is\n     * used by OptionsDoclet to generate documentation for enum-type options.\n     * Null if the base_type is not an Enum.\n     *\/\n    \/*@MonotonicNonNull*\/ Map<String, String> enum_jdoc;\n\n    \/**\n     * Name of the argument type.  Defaults to the type of the field, but\n     * user can override this in the option string.\n     *\/\n    String type_name;\n\n    \/**\n     * Class type of this field.  If the field is a list, the basetype\n     * of the list.\n     *\/\n    Class<?> base_type;\n\n    \/** Default value of the option as a string. *\/\n    \/*@Nullable*\/ String default_str = null;\n\n    \/**\n     * If true, the default value string for this option will be excluded from\n     * OptionsDoclet documentation.\n     *\/\n    boolean no_doc_default = false;\n\n    \/** If the option is a list, this references that list. *\/\n    \/*@MonotonicNonNull*\/ List<Object> list = null;\n\n    \/** Constructor that takes one String for the type. *\/\n    \/*@Nullable*\/ Constructor<?> constructor = null;\n\n    \/** Factory that takes a string (some classes don't have a string constructor) and always returns non-null. *\/\n    \/*@Nullable*\/ Method factory = null;\n\n    \/**\n     * If true, this OptionInfo is not output when printing documentation.\n     * @see #usage()\n     *\/\n    boolean unpublicized;\n\n    \/**\n     * Create a new OptionInfo.\n     * The short name, type name, and description are taken\n     * from the option parameter.  The long name is the name of the\n     * field.  The default value is the current value of the field.\n     * @param field the field to set\n     * @param option the option\n     * @param obj the object whose field will be set;\n     *   if obj is null, the field must be static\n     * @param unpublicized whether the option is unpublicized\n     *\/\n    OptionInfo(\n        Field field,\n        Option option,\n        \/*@UnknownInitialization*\/ \/*@Raw*\/ \/*@Nullable*\/ Object obj,\n        boolean unpublicized) {\n      this.field = field;\n      \/\/      this.option = option;\n      this.obj = obj;\n      this.base_type = field.getType();\n      this.unpublicized = unpublicized;\n      this.aliases = option.aliases();\n      this.no_doc_default = option.noDocDefault();\n\n      \/\/ The long name is the name of the field\n      long_name = field.getName();\n      if (use_dashes) {\n        long_name = long_name.replace('_', '-');\n      }\n\n      \/\/ Get the default value (if any)\n      Object default_obj = null;\n      if (!Modifier.isPublic(field.getModifiers())) {\n        throw new Error(\"option field is not public: \" + field);\n      }\n      try {\n        default_obj = field.get(obj);\n        if (default_obj != null) {\n          default_str = default_obj.toString();\n        }\n      } catch (Exception e) {\n        throw new Error(\"Unexpected error getting default for \" + field, e);\n      }\n\n      if (field.getType().isArray()) {\n        throw new Error(\"@Option may not annotate a variable of array type: \" + field);\n      }\n\n      \/\/ Handle lists.  When a list argument is specified multiple times,\n      \/\/ each argument value is appended to the list.\n      Type gen_type = field.getGenericType();\n      if (gen_type instanceof ParameterizedType) {\n        ParameterizedType pt = (ParameterizedType) gen_type;\n        Type raw_type = pt.getRawType();\n        if (!raw_type.equals(List.class)) {\n          throw new Error(\n              \"@Option supports List<...> but no other parameterized type; it does not support type \"\n                  + pt\n                  + \" for field \"\n                  + field);\n        }\n        if (default_obj == null) {\n          List<Object> new_list = new ArrayList<Object>();\n          try {\n            field.set(obj, new_list);\n          } catch (Exception e) {\n            throw new Error(\"Unexpected error setting default for \" + field, e);\n          }\n          default_obj = new_list;\n        }\n        if (((List<?>) default_obj).isEmpty()) {\n          default_str = null;\n        }\n        @SuppressWarnings(\"unchecked\")\n        List<Object> default_obj_as_list = (List<Object>) default_obj;\n        this.list = default_obj_as_list;\n        \/\/ System.out.printf (\"list default = %s%n\", list);\n        Type[] listTypeArgs = pt.getActualTypeArguments();\n        this.base_type = (Class<?>) (listTypeArgs.length == 0 ? Object.class : listTypeArgs[0]);\n\n        \/\/ System.out.printf (\"Param type for %s = %s%n\", field, pt);\n        \/\/ System.out.printf (\"raw type = %s, type = %s%n\", pt.getRawType(),\n        \/\/                   pt.getActualTypeArguments()[0]);\n      }\n\n      \/\/ Get the short name, type name, and description from the annotation\n      ParseResult pr;\n      try {\n        pr = parse_option(option.value());\n      } catch (Throwable e) {\n        throw new Error(\n            \"Error while processing @Option(\\\"\" + option.value() + \"\\\") on '\" + field + \"'\", e);\n      }\n      short_name = pr.short_name;\n      if (pr.type_name != null) {\n        type_name = pr.type_name;\n      } else {\n        type_name = type_short_name(base_type);\n      }\n      description = pr.description;\n\n      \/\/ Get a constructor for non-primitive base types\n      if (!base_type.isPrimitive() && !base_type.isEnum()) {\n        try {\n          if (base_type == Pattern.class) {\n            factory = Pattern.class.getMethod(\"compile\", String.class);\n          } else { \/\/ look for a string constructor\n            constructor = base_type.getConstructor(String.class);\n          }\n        } catch (Exception e) {\n          throw new Error(\n              \"@Option does not support type \"\n                  + base_type\n                  + \" for field \"\n                  + field\n                  + \" because it does not have a string constructor\",\n              e);\n        }\n      }\n    }\n\n    \/**\n     * Return whether or not this option has a required argument.\n     * @return whether or not this option has a required argument\n     *\/\n    public boolean argument_required() {\n      Class<?> type = field.getType();\n      return ((type != Boolean.TYPE) && (type != Boolean.class));\n    }\n\n    \/**\n     * Returns a short synopsis of the option in the form\n     * <code>-s --long=&lt;type&gt;<\/code>\n     * <strong>or<\/strong> (if use_single_dash is true)\n     * <code>-s -long=&lt;type&gt;<\/code> .\n     *\/\n    public String synopsis() {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String name = prefix + long_name;\n      if (short_name != null) {\n        name = String.format(\"-%s %s\", short_name, name);\n      }\n      name += String.format(\"=<%s>\", type_name);\n      if (list != null) {\n        name += \" [+]\";\n      }\n      return (name);\n    }\n\n    \/**\n     * Return a one-line description of the option.\n     * @return a one-line description of the option\n     *\/\n    @Override\n    \/*@SideEffectFree*\/\n    public String toString(\/*>>>@GuardSatisfied OptionInfo this*\/) {\n      String prefix = use_single_dash ? \"-\" : \"--\";\n      String short_name_str = \"\";\n      if (short_name != null) {\n        short_name_str = \"-\" + short_name + \" \";\n      }\n      return String.format(\"%s%s%s field %s\", short_name_str, prefix, long_name, field);\n    }\n\n    \/** Returns the class that declares this option.\n     * @return the class that declares this option\n     *\/\n    public Class<?> get_declaring_class() {\n      return field.getDeclaringClass();\n    }\n  }","classOrInterfaceJavadocComment":" Information about an option. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Information about an option.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 482,col 3)-(line 522,col 3)","classOrInterfaceTokenRange":"static class OptionGroupInfo {\n\n    \/** The name of this option group. *\/\n    String name;\n\n    \/**\n     * If true, this group of options will not be printed in usage output by\n     * default. However, the usage information for this option group can be\n     * printed by specifying the group explicitly in the call to {@link\n     * #usage}.\n     *\/\n    boolean unpublicized;\n\n    \/** List of options that belong to this group. *\/\n    List<OptionInfo> optionList;\n\n    OptionGroupInfo(String name, boolean unpublicized) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = name;\n      this.unpublicized = unpublicized;\n    }\n\n    OptionGroupInfo(OptionGroup optionGroup) {\n      optionList = new ArrayList<OptionInfo>();\n      this.name = optionGroup.value();\n      this.unpublicized = optionGroup.unpublicized();\n    }\n\n    \/**\n     * If false, this group of options does not contain any publicized options,\n     * so it will not be included in the default usage message.\n     *\/\n    boolean any_publicized() {\n      for (OptionInfo oi : optionList) {\n        if (!oi.unpublicized) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }","classOrInterfaceJavadocComment":" Information about an option group. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Information about an option group.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1528,col 3)-(line 1539,col 3)","classOrInterfaceTokenRange":"public static class ArgException extends Exception {\n    static final long serialVersionUID = 20051223L;\n\n    public ArgException(String s) {\n      super(s);\n    }\n\n    @SuppressWarnings(\"formatter\") \/\/ acts as format method wrapper\n    public ArgException(String format, \/*@Nullable*\/ Object... args) {\n      super(String.format(format, args));\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Exceptions encountered during argument processing.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Exceptions encountered during argument processing.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 1541,col 3)-(line 1552,col 3)","classOrInterfaceTokenRange":"private static class ParseResult {\n    \/*@Nullable*\/ String short_name;\n    \/*@Nullable*\/ String type_name;\n    String description;\n\n    ParseResult(\n        \/*@Nullable*\/ String short_name, \/*@Nullable*\/ String type_name, String description) {\n      this.short_name = short_name;\n      this.type_name = type_name;\n      this.description = description;\n    }\n  }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to enable or disable logging","javadocBlockTagName":"enabled","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to enable or disable logging'}]}', name=Optional[enabled]}"}],"methodDeclaration":"public void enableDebugLogging(boolean enabled)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    debug_options.enabled = enabled;\n}","methodRange":"(line 604,col 3)-(line 606,col 3)","methodTokenRange":"public void enableDebugLogging(boolean enabled) {\n    debug_options.enabled = enabled;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Enable or disable debug logging.\n   * @param enabled whether to enable or disable logging\n   ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean enabled","parameterName":"enabled"}],"methodName":"enableDebugLogging","methodQualifiedSignature":"plume.Options.enableDebugLogging","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Enable or disable debug logging.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to enable or disable logging'}]}', name=Optional[enabled]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.enableDebugLogging(boolean)"},{"javadocBlockTags":[],"methodDeclaration":"private static T safeGetAnnotation(Field f, Class<T> annotationClass)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    T annotation;\n    try {\n        @SuppressWarnings(\"cast\")\n        T cast = f.getAnnotation((Class<T>) annotationClass);\n        annotation = cast;\n    } catch (Exception e) {\n        System.out.printf(\"Exception in call to f.getAnnotation(%s)%n  for f=%s%n  %s%nClasspath =%n\", annotationClass, f, e.getMessage());\n        JWhich.printClasspath();\n        annotation = null;\n    }\n    return annotation;\n}","methodRange":"(line 786,col 3)-(line 810,col 3)","methodTokenRange":"@SuppressWarnings(\n      \"initialization\") \/\/ bug; see test case checkers\/tests\/nullness\/generics\/OptionsTest.java\n  private static <T extends Annotation> \/*@Nullable*\/ T safeGetAnnotation(\n      Field f, Class<T> annotationClass) {\n    \/*@Nullable*\/ T annotation;\n    try {\n      @SuppressWarnings(\"cast\") \/\/ cast is redundant (except for type annotations)\n      \/*@Nullable*\/ T cast = f.getAnnotation((Class<\/*@NonNull*\/ T>) annotationClass);\n      annotation = cast;\n    } catch (Exception e) {\n      \/\/ Can get\n      \/\/   java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy\n      \/\/ when an annotation is not present at run time (example: @NonNull)\n      System.out.printf(\n          \"Exception in call to f.getAnnotation(%s)%n  for f=%s%n  %s%nClasspath =%n\",\n          annotationClass,\n          f,\n          e.getMessage());\n      \/\/e.printStackTrace();\n      JWhich.printClasspath();\n      annotation = null;\n    }\n\n    return annotation;\n  }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[Annotation])}","methodJavadocComment":"\n   * Like getAnnotation, but returns null (and prints a warning) rather\n   * than throwing an exception.\n   ","methodParameters":[{"parameterType":"Field","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.reflect.Field, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.reflect.Field","parameter":"Field f","parameterName":"f"},{"parameterType":"Class<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=TypeVariable {JPTypeParameter(T, bounds=[Annotation])}}}}","parameterTypeResolvedDescribed":"java.lang.Class<T>","parameter":"Class<T> annotationClass","parameterName":"annotationClass"}],"methodName":"safeGetAnnotation","methodQualifiedSignature":"plume.Options.safeGetAnnotation","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Like getAnnotation, but returns null (and prints a warning) rather\nthan throwing an exception.'}]}, blockTags=[]}","methodReturnTypeDescribed":"T","methodType":"T","literalExprs":[{"literalExprRange":"(line 787,col 7)-(line 787,col 22)","literalExprId":1,"literalExpr":"\"initialization\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 792,col 25)-(line 792,col 30)","literalExprId":2,"literalExpr":"\"cast\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 800,col 11)-(line 800,col 85)","literalExprId":3,"literalExpr":"\"Exception in call to f.getAnnotation(%s)%n  for f=%s%n  %s%nClasspath =%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 806,col 20)-(line 806,col 23)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Options.safeGetAnnotation(java.lang.reflect.Field, java.lang.Class<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to parse arguments after a non-option command-line argument","javadocBlockTagName":"val","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to parse arguments after a non-option command-line argument'}]}', name=Optional[val]}"}],"methodDeclaration":"public void parse_options_after_arg(boolean val)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    parse_options_after_arg = val;\n}","methodRange":"(line 820,col 3)-(line 822,col 3)","methodTokenRange":"public void parse_options_after_arg(boolean val) {\n    parse_options_after_arg = val;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * If true, Options will parse arguments even after a non-option\n   * command-line argument.  Setting this to true is useful to permit users\n   * to write options at the end of a command line.  Setting this to false\n   * is useful to avoid processing arguments that are actually\n   * options\/arguments for another program that this one will invoke.\n   * @param val whether to parse arguments after a non-option command-line argument\n   ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean val","parameterName":"val"}],"methodName":"parse_options_after_arg","methodQualifiedSignature":"plume.Options.parse_options_after_arg","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='If true, Options will parse arguments even after a non-option\ncommand-line argument.  Setting this to true is useful to permit users\nto write options at the end of a command line.  Setting this to false\nis useful to avoid processing arguments that are actually\noptions\/arguments for another program that this one will invoke.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to parse arguments after a non-option command-line argument'}]}', name=Optional[val]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.parse_options_after_arg(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to parse long options with a single dash, as in -longOption","javadocBlockTagName":"val","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to parse long options with a single dash, as in -longOption'}]}', name=Optional[val]}"}],"methodDeclaration":"public void use_single_dash(boolean val)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    use_single_dash = val;\n}","methodRange":"(line 830,col 3)-(line 832,col 3)","methodTokenRange":"public void use_single_dash(boolean val) {\n    use_single_dash = val;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * If true, long options (those derived from field names) will be parsed with\n   * a single dash prefix as in -longOption.  The default is false and long\n   * options will be parsed with a double dash prefix as in --longOption.\n   * @param val whether to parse long options with a single dash, as in -longOption\n   ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean val","parameterName":"val"}],"methodName":"use_single_dash","methodQualifiedSignature":"plume.Options.use_single_dash","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='If true, long options (those derived from field names) will be parsed with\na single dash prefix as in -longOption.  The default is false and long\noptions will be parsed with a double dash prefix as in --longOption.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to parse long options with a single dash, as in -longOption'}]}', name=Optional[val]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.use_single_dash(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the commandline to be parsed","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the commandline to be parsed'}]}', name=Optional[args]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all non-option arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the command line contains unknown option or\nmisused options.","javadocBlockTagName":"ArgException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the command line contains unknown option or\nmisused options.'}]}', name=Optional[ArgException]}"}],"methodDeclaration":"public String[] parse(String[] args) throws ArgException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<String> non_options = new ArrayList<String>();\n    boolean ignore_options = false;\n    String tail = \"\";\n    String arg;\n    for (int ii = 0; ii < args.length; ) {\n        if (tail.length() > 0) {\n            arg = tail;\n            tail = \"\";\n        } else {\n            arg = args[ii];\n        }\n        if (arg.equals(\"--\")) {\n            ignore_options = true;\n        } else if ((arg.startsWith(\"--\") || arg.startsWith(\"-\")) && !ignore_options) {\n            String arg_name;\n            String arg_value;\n            int split_pos = arg.indexOf(\",-\");\n            if (split_pos == 0) {\n                arg = arg.substring(1);\n                split_pos = arg.indexOf(\",-\");\n            }\n            if (split_pos > 0) {\n                tail = arg.substring(split_pos + 1);\n                arg = arg.substring(0, split_pos);\n            }\n            int eq_pos = arg.indexOf('=');\n            if (eq_pos == -1) {\n                arg_name = arg;\n                arg_value = null;\n            } else {\n                arg_name = arg.substring(0, eq_pos);\n                arg_value = arg.substring(eq_pos + 1);\n            }\n            OptionInfo oi = name_map.get(arg_name);\n            if (oi == null) {\n                StringBuilder msg = new StringBuilder();\n                msg.append(String.format(\"unknown option name '%s' in arg '%s'\", arg_name, arg));\n                if (false) {\n                    msg.append(\"; known options:\");\n                    for (String option_name : UtilMDE.sortedKeySet(name_map)) {\n                        msg.append(\" \");\n                        msg.append(option_name);\n                    }\n                }\n                throw new ArgException(msg.toString());\n            }\n            if (oi.argument_required() && (arg_value == null)) {\n                ii++;\n                if (ii >= args.length) {\n                    throw new ArgException(\"option %s requires an argument\", arg);\n                }\n                arg_value = args[ii];\n            }\n            set_arg(oi, arg_name, arg_value);\n        } else {\n            if (!parse_options_after_arg) {\n                ignore_options = true;\n            }\n            non_options.add(arg);\n        }\n        if (tail.length() == 0) {\n            ii++;\n        }\n    }\n    String[] result = non_options.toArray(new String[non_options.size()]);\n    return result;\n}","methodRange":"(line 841,col 3)-(line 925,col 3)","methodTokenRange":"public String[] parse(String[] args) throws ArgException {\n\n    List<String> non_options = new ArrayList<String>();\n    \/\/ If true, then \"--\" has been seen and any argument starting with \"-\"\n    \/\/ is processed as an ordinary argument, not as an option.\n    boolean ignore_options = false;\n\n    \/\/ Loop through each argument\n    String tail = \"\";\n    String arg;\n    for (int ii = 0; ii < args.length; ) {\n      \/\/ If there was a ',' separator in previous arg, use the tail as\n      \/\/ current arg; otherwise, fetch the next arg from args list.\n      if (tail.length() > 0) {\n        arg = tail;\n        tail = \"\";\n      } else {\n        arg = args[ii];\n      }\n\n      if (arg.equals(\"--\")) {\n        ignore_options = true;\n      } else if ((arg.startsWith(\"--\") || arg.startsWith(\"-\")) && !ignore_options) {\n        String arg_name;\n        String arg_value;\n\n        \/\/ Allow ',' as an argument separator to get around\n        \/\/ some command line quoting problems.  (markro)\n        int split_pos = arg.indexOf(\",-\");\n        if (split_pos == 0) {\n          \/\/ Just discard the ',' if \",-\" occurs at begining of string\n          arg = arg.substring(1);\n          split_pos = arg.indexOf(\",-\");\n        }\n        if (split_pos > 0) {\n          tail = arg.substring(split_pos + 1);\n          arg = arg.substring(0, split_pos);\n        }\n\n        int eq_pos = arg.indexOf('=');\n        if (eq_pos == -1) {\n          arg_name = arg;\n          arg_value = null;\n        } else {\n          arg_name = arg.substring(0, eq_pos);\n          arg_value = arg.substring(eq_pos + 1);\n        }\n        OptionInfo oi = name_map.get(arg_name);\n        if (oi == null) {\n          StringBuilder msg = new StringBuilder();\n          msg.append(String.format(\"unknown option name '%s' in arg '%s'\", arg_name, arg));\n          if (false) { \/\/ for debugging\n            msg.append(\"; known options:\");\n            for (String option_name : UtilMDE.sortedKeySet(name_map)) {\n              msg.append(\" \");\n              msg.append(option_name);\n            }\n          }\n          throw new ArgException(msg.toString());\n        }\n        if (oi.argument_required() && (arg_value == null)) {\n          ii++;\n          if (ii >= args.length) {\n            throw new ArgException(\"option %s requires an argument\", arg);\n          }\n          arg_value = args[ii];\n        }\n        \/\/ System.out.printf (\"arg_name = '%s', arg_value='%s'%n\", arg_name,\n        \/\/                    arg_value);\n        set_arg(oi, arg_name, arg_value);\n      } else { \/\/ not an option\n        if (!parse_options_after_arg) {\n          ignore_options = true;\n        }\n        non_options.add(arg);\n      }\n\n      \/\/ If no ',' tail, advance to next args option\n      if (tail.length() == 0) {\n        ii++;\n      }\n    }\n    String[] result = non_options.toArray(new String[non_options.size()]);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Parses a command line and sets the options accordingly.\n   * @param args the commandline to be parsed\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains unknown option or\n   * misused options.\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"parse","methodQualifiedSignature":"plume.Options.parse","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Parses a command line and sets the options accordingly.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the commandline to be parsed'}]}', name=Optional[args]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the command line contains unknown option or\nmisused options.'}]}', name=Optional[ArgException]}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 846,col 30)-(line 846,col 34)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 849,col 19)-(line 849,col 20)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 851,col 19)-(line 851,col 19)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 854,col 27)-(line 854,col 27)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 856,col 16)-(line 856,col 17)","literalExprId":5,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 861,col 22)-(line 861,col 25)","literalExprId":6,"literalExpr":"\"--\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 862,col 26)-(line 862,col 29)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 863,col 34)-(line 863,col 37)","literalExprId":8,"literalExpr":"\"--\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 863,col 58)-(line 863,col 60)","literalExprId":9,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 869,col 37)-(line 869,col 40)","literalExprId":10,"literalExpr":"\",-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 870,col 26)-(line 870,col 26)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 872,col 31)-(line 872,col 31)","literalExprId":12,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 873,col 35)-(line 873,col 38)","literalExprId":13,"literalExpr":"\",-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 875,col 25)-(line 875,col 25)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 876,col 44)-(line 876,col 44)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 877,col 31)-(line 877,col 31)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 880,col 34)-(line 880,col 36)","literalExprId":17,"literalExpr":"'='","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 881,col 24)-(line 881,col 24)","literalExprId":18,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 883,col 23)-(line 883,col 26)","literalExprId":19,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 885,col 36)-(line 885,col 36)","literalExprId":20,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 886,col 46)-(line 886,col 46)","literalExprId":21,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 889,col 19)-(line 889,col 22)","literalExprId":22,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 891,col 36)-(line 891,col 73)","literalExprId":23,"literalExpr":"\"unknown option name '%s' in arg '%s'\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 892,col 15)-(line 892,col 19)","literalExprId":24,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 893,col 24)-(line 893,col 41)","literalExprId":25,"literalExpr":"\"; known options:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 895,col 26)-(line 895,col 28)","literalExprId":26,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 901,col 53)-(line 901,col 56)","literalExprId":27,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 904,col 36)-(line 904,col 67)","literalExprId":28,"literalExpr":"\"option %s requires an argument\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 913,col 28)-(line 913,col 31)","literalExprId":29,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 919,col 28)-(line 919,col 28)","literalExprId":30,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Options.parse(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the command line to parse","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command line to parse'}]}', name=Optional[args]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all non-option arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the command line contains misused options or an unknown option.","javadocBlockTagName":"ArgException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the command line contains misused options or an unknown option.'}]}', name=Optional[ArgException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#parse(String[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#parse(String[])'}]}', name=Optional.empty}"}],"methodDeclaration":"public String[] parse(String args) throws ArgException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    args = args.trim();\n    List<String> arg_list = new ArrayList<String>();\n    String arg = \"\";\n    char active_quote = 0;\n    for (int ii = 0; ii < args.length(); ii++) {\n        char ch = args.charAt(ii);\n        if ((ch == '\\'') || (ch == '\"')) {\n            arg += ch;\n            ii++;\n            while ((ii < args.length()) && (args.charAt(ii) != ch)) {\n                arg += args.charAt(ii++);\n            }\n            arg += ch;\n        } else if (Character.isWhitespace(ch)) {\n            arg_list.add(arg);\n            arg = \"\";\n            while ((ii < args.length()) && Character.isWhitespace(args.charAt(ii))) {\n                ii++;\n            }\n            if (ii < args.length()) {\n                ii--;\n            }\n        } else {\n            arg += ch;\n        }\n    }\n    if (!arg.equals(\"\")) {\n        arg_list.add(arg);\n    }\n    String[] argsArray = arg_list.toArray(new String[arg_list.size()]);\n    return parse(argsArray);\n}","methodRange":"(line 942,col 3)-(line 981,col 3)","methodTokenRange":"public String[] parse(String args) throws ArgException {\n\n    \/\/ Split the args string on whitespace boundaries accounting for quoted\n    \/\/ strings.\n    args = args.trim();\n    List<String> arg_list = new ArrayList<String>();\n    String arg = \"\";\n    char active_quote = 0;\n    for (int ii = 0; ii < args.length(); ii++) {\n      char ch = args.charAt(ii);\n      if ((ch == '\\'') || (ch == '\"')) {\n        arg += ch;\n        ii++;\n        while ((ii < args.length()) && (args.charAt(ii) != ch)) {\n          arg += args.charAt(ii++);\n        }\n        arg += ch;\n      } else if (Character.isWhitespace(ch)) {\n        \/\/ System.out.printf (\"adding argument '%s'%n\", arg);\n        arg_list.add(arg);\n        arg = \"\";\n        while ((ii < args.length()) && Character.isWhitespace(args.charAt(ii))) {\n          ii++;\n        }\n        if (ii < args.length()) {\n          \/\/ Encountered a non-whitespace character.\n          \/\/ Back up to process it on the next loop iteration.\n          ii--;\n        }\n      } else { \/\/ must be part of current argument\n        arg += ch;\n      }\n    }\n    if (!arg.equals(\"\")) {\n      arg_list.add(arg);\n    }\n\n    String[] argsArray = arg_list.toArray(new String[arg_list.size()]);\n    return parse(argsArray);\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Parses a command line and sets the options accordingly.  This method\n   * splits the argument string into command-line arguments, respecting\n   * single and double quotes, then calls {@link #parse(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]<\/code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain<\/code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @throws ArgException if the command line contains misused options or an unknown option.\n   * @see #parse(String[])\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String args","parameterName":"args"}],"methodName":"parse","methodQualifiedSignature":"plume.Options.parse","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Parses a command line and sets the options accordingly.  This method\nsplits the argument string into command-line arguments, respecting\nsingle and double quotes, then calls '}, JavadocInlineTag{tagName='link', type=LINK, content=' #parse(String[])'}, JavadocSnippet{text='.\n<p>\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #parse(String[])'}, JavadocSnippet{text=' is usually a better method to call.  This one\nis appropriate when the <code>String[]<\/code> version of the arguments is\nnot available &mdash; for example, for the <code>premain<\/code> method of\na Java agent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command line to parse'}]}', name=Optional[args]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the command line contains misused options or an unknown option.'}]}', name=Optional[ArgException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#parse(String[])'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 948,col 18)-(line 948,col 19)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 949,col 25)-(line 949,col 25)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 950,col 19)-(line 950,col 19)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 952,col 18)-(line 952,col 21)","literalExprId":4,"literalExpr":"'\\''","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 952,col 34)-(line 952,col 36)","literalExprId":5,"literalExpr":"'\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 962,col 15)-(line 962,col 16)","literalExprId":6,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 975,col 21)-(line 975,col 22)","literalExprId":7,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.parse(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the command line to parse","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command line to parse'}]}', name=Optional[args]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all non-option arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#parse(String[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#parse(String[])'}]}', name=Optional.empty}"}],"methodDeclaration":"public String[] parse_or_usage(String[] args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String[] non_options = null;\n    try {\n        non_options = parse(args);\n    } catch (ArgException ae) {\n        String message = ae.getMessage();\n        if (message != null) {\n            print_usage(message);\n        } else {\n            print_usage();\n        }\n        System.exit(-1);\n    }\n    return (non_options);\n}","methodRange":"(line 991,col 3)-(line 1008,col 3)","methodTokenRange":"public String[] parse_or_usage(String[] args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      \/\/ throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse(String[])\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"parse_or_usage","methodQualifiedSignature":"plume.Options.parse_or_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Parses a command line and sets the options accordingly.  If an error\noccurs, prints the usage message and terminates the program.  The program is\nterminated rather than throwing an error to create cleaner output.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command line to parse'}]}', name=Optional[args]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#parse(String[])'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 993,col 28)-(line 993,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 999,col 22)-(line 999,col 25)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1004,col 20)-(line 1004,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Options.parse_or_usage(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the command line to parse","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command line to parse'}]}', name=Optional[args]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"all non-option arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#parse_or_usage(String[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#parse_or_usage(String[])'}]}', name=Optional.empty}"}],"methodDeclaration":"public String[] parse_or_usage(String args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String[] non_options = null;\n    try {\n        non_options = parse(args);\n    } catch (ArgException ae) {\n        String message = ae.getMessage();\n        if (message != null) {\n            print_usage(message);\n        } else {\n            print_usage();\n        }\n        System.exit(-1);\n    }\n    return (non_options);\n}","methodRange":"(line 1028,col 3)-(line 1045,col 3)","methodTokenRange":"public String[] parse_or_usage(String args) {\n\n    String[] non_options = null;\n\n    try {\n      non_options = parse(args);\n    } catch (ArgException ae) {\n      String message = ae.getMessage();\n      if (message != null) {\n        print_usage(message);\n      } else {\n        print_usage();\n      }\n      System.exit(-1);\n      \/\/ throw new Error (\"usage error: \", ae);\n    }\n    return (non_options);\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Parses a command line and sets the options accordingly.  If an error\n   * occurs, prints the usage message and terminates the program.  The program is\n   * terminated rather than throwing an error to create cleaner output.\n   * <p>\n   * This method splits the argument string into command-line arguments,\n   * respecting single and double quotes, then calls\n   * {@link #parse_or_usage(String[])}.\n   * <p>\n   * {@link #parse(String[])} is usually a better method to call.  This one\n   * is appropriate when the <code>String[]<\/code> version of the arguments is\n   * not available &mdash; for example, for the <code>premain<\/code> method of\n   * a Java agent.\n   *\n   * @param args the command line to parse\n   * @return all non-option arguments\n   * @see #parse_or_usage(String[])\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String args","parameterName":"args"}],"methodName":"parse_or_usage","methodQualifiedSignature":"plume.Options.parse_or_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Parses a command line and sets the options accordingly.  If an error\noccurs, prints the usage message and terminates the program.  The program is\nterminated rather than throwing an error to create cleaner output.\n<p>\nThis method splits the argument string into command-line arguments,\nrespecting single and double quotes, then calls\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #parse_or_usage(String[])'}, JavadocSnippet{text='.\n<p>\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #parse(String[])'}, JavadocSnippet{text=' is usually a better method to call.  This one\nis appropriate when the <code>String[]<\/code> version of the arguments is\nnot available &mdash; for example, for the <code>premain<\/code> method of\na Java agent.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the command line to parse'}]}', name=Optional[args]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='all non-option arguments'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#parse_or_usage(String[])'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 1030,col 28)-(line 1030,col 31)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1036,col 22)-(line 1036,col 25)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1041,col 20)-(line 1041,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Options.parse_or_usage(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"where to print usage information","javadocBlockTagName":"ps","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to print usage information'}]}', name=Optional[ps]}"}],"methodDeclaration":"public void print_usage(PrintStream ps)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (usage_synopsis != null) {\n        ps.printf(\"Usage: %s%n\", usage_synopsis);\n    }\n    ps.println(usage());\n    if (print_list_help) {\n        ps.println();\n        ps.println(LIST_HELP);\n    }\n}","methodRange":"(line 1055,col 3)-(line 1064,col 3)","methodTokenRange":"public void print_usage(PrintStream ps) {\n    if (usage_synopsis != null) {\n      ps.printf(\"Usage: %s%n\", usage_synopsis);\n    }\n    ps.println(usage());\n    if (print_list_help) {\n      ps.println();\n      ps.println(LIST_HELP);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Prints usage information.  Uses the usage synopsis passed into the\n   * constructor, if any.\n   * @param ps where to print usage information\n   ","methodParameters":[{"parameterType":"PrintStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.PrintStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.PrintStream","parameter":"PrintStream ps","parameterName":"ps"}],"methodName":"print_usage","methodQualifiedSignature":"plume.Options.print_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prints usage information.  Uses the usage synopsis passed into the\nconstructor, if any.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to print usage information'}]}', name=Optional[ps]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1056,col 27)-(line 1056,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1057,col 17)-(line 1057,col 29)","literalExprId":2,"literalExpr":"\"Usage: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.print_usage(java.io.PrintStream)"},{"javadocBlockTags":[],"methodDeclaration":"public void print_usage()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    print_usage(System.out);\n}","methodRange":"(line 1069,col 3)-(line 1071,col 3)","methodTokenRange":"public void print_usage() {\n    print_usage(System.out);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Prints, to standard output, usage information.\n   ","methodParameters":[],"methodName":"print_usage","methodQualifiedSignature":"plume.Options.print_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prints, to standard output, usage information.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.print_usage()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"where to print usage information","javadocBlockTagName":"ps","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to print usage information'}]}', name=Optional[ps]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"message to print before usage information","javadocBlockTagName":"msg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='message to print before usage information'}]}', name=Optional[msg]}"}],"methodDeclaration":"public void print_usage(PrintStream ps, String msg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ps.println(msg);\n    print_usage(ps);\n}","methodRange":"(line 1082,col 3)-(line 1085,col 3)","methodTokenRange":"public void print_usage(PrintStream ps, String msg) {\n    ps.println(msg);\n    print_usage(ps);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Prints a message followed by indented usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param msg message to print before usage information\n   ","methodParameters":[{"parameterType":"PrintStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.PrintStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.PrintStream","parameter":"PrintStream ps","parameterName":"ps"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String msg","parameterName":"msg"}],"methodName":"print_usage","methodQualifiedSignature":"plume.Options.print_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prints a message followed by indented usage information.\nThe message is printed in addition to (not replacing) the usage synopsis.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to print usage information'}]}', name=Optional[ps]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='message to print before usage information'}]}', name=Optional[msg]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.print_usage(java.io.PrintStream, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"messag. to print before usage information","javadocBlockTagName":"msg","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='messag. to print before usage information'}]}', name=Optional[msg]}"}],"methodDeclaration":"public void print_usage(String msg)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    print_usage(System.out, msg);\n}","methodRange":"(line 1092,col 3)-(line 1094,col 3)","methodTokenRange":"public void print_usage(String msg) {\n    print_usage(System.out, msg);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Prints, to standard output, a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param msg messag. to print before usage information\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String msg","parameterName":"msg"}],"methodName":"print_usage","methodQualifiedSignature":"plume.Options.print_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prints, to standard output, a message followed by usage information.\nThe message is printed in addition to (not replacing) the usage synopsis.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='messag. to print before usage information'}]}', name=Optional[msg]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.print_usage(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"where to print usage information","javadocBlockTagName":"ps","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to print usage information'}]}', name=Optional[ps]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"message to print before usage information","javadocBlockTagName":"format","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='message to print before usage information'}]}', name=Optional[format]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"objects to put in formatted message","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='objects to put in formatted message'}]}', name=Optional[args]}"}],"methodDeclaration":"public void print_usage(PrintStream ps, String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    ps.printf(format, args);\n    if (!format.endsWith(\"%n\")) {\n        ps.println();\n    }\n    print_usage(ps);\n}","methodRange":"(line 1103,col 3)-(line 1110,col 3)","methodTokenRange":"@SuppressWarnings(\"formatter\") \/\/ acts as format method wrapper\n  public void print_usage(PrintStream ps, String format, \/*@Nullable*\/ Object... args) {\n    ps.printf(format, args);\n    if (!format.endsWith(\"%n\")) {\n      ps.println();\n    }\n    print_usage(ps);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Prints a message followed by usage information.\n   * The message is printed in addition to (not replacing) the usage synopsis.\n   * @param ps where to print usage information\n   * @param format message to print before usage information\n   * @param args objects to put in formatted message\n   ","methodParameters":[{"parameterType":"PrintStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.PrintStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.PrintStream","parameter":"PrintStream ps","parameterName":"ps"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":3,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"print_usage","methodQualifiedSignature":"plume.Options.print_usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Prints a message followed by usage information.\nThe message is printed in addition to (not replacing) the usage synopsis.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='where to print usage information'}]}', name=Optional[ps]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='message to print before usage information'}]}', name=Optional[format]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='objects to put in formatted message'}]}', name=Optional[args]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1103,col 21)-(line 1103,col 31)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1106,col 26)-(line 1106,col 29)","literalExprId":2,"literalExpr":"\"%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.print_usage(java.io.PrintStream, java.lang.String, java.lang.Object...)"},{"methodDeclaration":"public void print_usage(String format, Object... args)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    print_usage(System.out, format, args);\n}","methodRange":"(line 1119,col 3)-(line 1121,col 3)","methodTokenRange":"public void print_usage(String format, \/*@Nullable*\/ Object... args) {\n    print_usage(System.out, format, args);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@FormatMethod","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String format","parameterName":"format"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object...","parameter":"Object... args","parameterName":"args"}],"methodName":"print_usage","methodQualifiedSignature":"plume.Options.print_usage","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.Options.print_usage(java.lang.String, java.lang.Object...)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the command-line usage message","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line usage message'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.","javadocBlockTagName":"group_names","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.'}]}', name=Optional[group_names]}"}],"methodDeclaration":"public String usage(String... group_names)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return usage(false, group_names);\n}","methodRange":"(line 1133,col 3)-(line 1135,col 3)","methodTokenRange":"public String usage(String... group_names) {\n    return usage(false, group_names);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String...","parameter":"String... group_names","parameterName":"group_names"}],"methodName":"usage","methodQualifiedSignature":"plume.Options.usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the String containing the usage message for command-line options.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line usage message'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.'}]}', name=Optional[group_names]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1134,col 18)-(line 1134,col 22)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.Options.usage(java.lang.String...)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the command-line usage message","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line usage message'}]}', name=Optional.empty}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, treat all unpublicized options\nand option groups as publicized","javadocBlockTagName":"include_unpublicized","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, treat all unpublicized options\nand option groups as publicized'}]}', name=Optional[include_unpublicized]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.","javadocBlockTagName":"group_names","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.'}]}', name=Optional[group_names]}"}],"methodDeclaration":"public String usage(boolean include_unpublicized, String... group_names)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (!use_groups) {\n        if (group_names.length > 0) {\n            throw new IllegalArgumentException(\"This instance of Options does not have any option groups defined\");\n        }\n        return format_options(options, max_opt_len(options, include_unpublicized), include_unpublicized);\n    }\n    List<OptionGroupInfo> groups = new ArrayList<OptionGroupInfo>();\n    if (group_names.length > 0) {\n        for (String group_name : group_names) {\n            if (!group_map.containsKey(group_name)) {\n                throw new IllegalArgumentException(\"invalid option group: \" + group_name);\n            }\n            OptionGroupInfo gi = group_map.get(group_name);\n            if (!include_unpublicized && !gi.any_publicized()) {\n                throw new IllegalArgumentException(\"group does not contain any publicized options: \" + group_name);\n            } else {\n                groups.add(group_map.get(group_name));\n            }\n        }\n    } else {\n        for (OptionGroupInfo gi : group_map.values()) {\n            if ((gi.unpublicized || !gi.any_publicized()) && !include_unpublicized) {\n                continue;\n            }\n            groups.add(gi);\n        }\n    }\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (OptionGroupInfo gi : groups) {\n        lengths.add(max_opt_len(gi.optionList, include_unpublicized));\n    }\n    int max_len = Collections.max(lengths);\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionGroupInfo gi : groups) {\n        buf.append(String.format(\"%n%s:\", gi.name));\n        buf.append(format_options(gi.optionList, max_len, include_unpublicized));\n    }\n    return buf.toString();\n}","methodRange":"(line 1149,col 3)-(line 1195,col 3)","methodTokenRange":"public String usage(boolean include_unpublicized, String... group_names) {\n    if (!use_groups) {\n      if (group_names.length > 0) {\n        throw new IllegalArgumentException(\n            \"This instance of Options does not have any option groups defined\");\n      }\n      return format_options(\n          options, max_opt_len(options, include_unpublicized), include_unpublicized);\n    }\n\n    List<OptionGroupInfo> groups = new ArrayList<OptionGroupInfo>();\n    if (group_names.length > 0) {\n      for (String group_name : group_names) {\n        if (!group_map.containsKey(group_name)) {\n          throw new IllegalArgumentException(\"invalid option group: \" + group_name);\n        }\n        OptionGroupInfo gi = group_map.get(group_name);\n        if (!include_unpublicized && !gi.any_publicized()) {\n          throw new IllegalArgumentException(\n              \"group does not contain any publicized options: \" + group_name);\n        } else {\n          groups.add(group_map.get(group_name));\n        }\n      }\n    } else { \/\/ return usage for all groups that are not unpublicized\n      for (OptionGroupInfo gi : group_map.values()) {\n        if ((gi.unpublicized || !gi.any_publicized()) && !include_unpublicized) {\n          continue;\n        }\n        groups.add(gi);\n      }\n    }\n\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (OptionGroupInfo gi : groups) {\n      lengths.add(max_opt_len(gi.optionList, include_unpublicized));\n    }\n    int max_len = Collections.max(lengths);\n\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionGroupInfo gi : groups) {\n      buf.append(String.format(\"%n%s:\", gi.name));\n      buf.append(format_options(gi.optionList, max_len, include_unpublicized));\n    }\n\n    return buf.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the String containing the usage message for command-line options.\n   *\n   * @return the command-line usage message\n   * @param include_unpublicized if true, treat all unpublicized options\n   * and option groups as publicized\n   * @param group_names the list of option groups to include in the usage\n   * message.  If empty and option groups are being used, will return usage\n   * for all option groups that are not unpublicized.  If empty and option\n   * groups are not being used, will return usage for all options that are\n   * not unpublicized.\n   ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean include_unpublicized","parameterName":"include_unpublicized"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String...","parameter":"String... group_names","parameterName":"group_names"}],"methodName":"usage","methodQualifiedSignature":"plume.Options.usage","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the String containing the usage message for command-line options.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the command-line usage message'}]}', name=Optional.empty}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, treat all unpublicized options\nand option groups as publicized'}]}', name=Optional[include_unpublicized]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list of option groups to include in the usage\nmessage.  If empty and option groups are being used, will return usage\nfor all option groups that are not unpublicized.  If empty and option\ngroups are not being used, will return usage for all options that are\nnot unpublicized.'}]}', name=Optional[group_names]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1151,col 32)-(line 1151,col 32)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1153,col 13)-(line 1153,col 78)","literalExprId":2,"literalExpr":"\"This instance of Options does not have any option groups defined\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1160,col 30)-(line 1160,col 30)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1163,col 46)-(line 1163,col 69)","literalExprId":4,"literalExpr":"\"invalid option group: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1168,col 15)-(line 1168,col 63)","literalExprId":5,"literalExpr":"\"group does not contain any publicized options: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1190,col 32)-(line 1190,col 38)","literalExprId":6,"literalExpr":"\"%n%s:\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.usage(boolean, java.lang.String...)"},{"javadocBlockTags":[],"methodDeclaration":"private String format_options(List<OptionInfo> opt_list, int max_len, boolean include_unpublicized)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionInfo oi : opt_list) {\n        if (oi.unpublicized && !include_unpublicized) {\n            continue;\n        }\n        String default_str = \"\";\n        if (oi.default_str != null) {\n            default_str = String.format(\" [default %s]\", oi.default_str);\n        }\n        @SuppressWarnings(\"formatter\")\n        String use = String.format(\"  %-\" + max_len + \"s - %s%s\", oi.synopsis(), oi.description, default_str);\n        buf.append(use);\n    }\n    return buf.toString();\n}","methodRange":"(line 1200,col 3)-(line 1218,col 3)","methodTokenRange":"private String format_options(\n      List<OptionInfo> opt_list, int max_len, boolean include_unpublicized) {\n    StringBuilderDelimited buf = new StringBuilderDelimited(eol);\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      String default_str = \"\";\n      if (oi.default_str != null) {\n        default_str = String.format(\" [default %s]\", oi.default_str);\n      }\n\n      @SuppressWarnings(\"formatter\") \/\/ format string computed from max_len argument\n      String use =\n          String.format(\"  %-\" + max_len + \"s - %s%s\", oi.synopsis(), oi.description, default_str);\n      buf.append(use);\n    }\n    return buf.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Format a list of options for use in generating usage messages.\n   ","methodParameters":[{"parameterType":"List<OptionInfo>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<plume.Options.OptionInfo>","parameter":"List<OptionInfo> opt_list","parameterName":"opt_list"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int max_len","parameterName":"max_len"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean include_unpublicized","parameterName":"include_unpublicized"}],"methodName":"format_options","methodQualifiedSignature":"plume.Options.format_options","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Format a list of options for use in generating usage messages.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1207,col 28)-(line 1207,col 29)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1208,col 29)-(line 1208,col 32)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1209,col 37)-(line 1209,col 51)","literalExprId":3,"literalExpr":"\" [default %s]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1212,col 25)-(line 1212,col 35)","literalExprId":4,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1214,col 25)-(line 1214,col 30)","literalExprId":5,"literalExpr":"\"  %-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1214,col 44)-(line 1214,col 53)","literalExprId":6,"literalExpr":"\"s - %s%s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.format_options(java.util.List<plume.Options.OptionInfo>, int, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the length of the longest synopsis message in a list of options","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the length of the longest synopsis message in a list of options'}]}', name=Optional.empty}"}],"methodDeclaration":"private int max_opt_len(List<OptionInfo> opt_list, boolean include_unpublicized)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    int max_len = 0;\n    for (OptionInfo oi : opt_list) {\n        if (oi.unpublicized && !include_unpublicized) {\n            continue;\n        }\n        int len = oi.synopsis().length();\n        if (len > max_len) {\n            max_len = len;\n        }\n    }\n    return max_len;\n}","methodRange":"(line 1225,col 3)-(line 1237,col 3)","methodTokenRange":"private int max_opt_len(List<OptionInfo> opt_list, boolean include_unpublicized) {\n    int max_len = 0;\n    for (OptionInfo oi : opt_list) {\n      if (oi.unpublicized && !include_unpublicized) {\n        continue;\n      }\n      int len = oi.synopsis().length();\n      if (len > max_len) {\n        max_len = len;\n      }\n    }\n    return max_len;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the length of the longest synopsis message in a list of options.\n   * Useful for aligning options in usage strings.\n   * @return the length of the longest synopsis message in a list of options\n   ","methodParameters":[{"parameterType":"List<OptionInfo>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.List<plume.Options.OptionInfo>","parameter":"List<OptionInfo> opt_list","parameterName":"opt_list"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean include_unpublicized","parameterName":"include_unpublicized"}],"methodName":"max_opt_len","methodQualifiedSignature":"plume.Options.max_opt_len","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the length of the longest synopsis message in a list of options.\nUseful for aligning options in usage strings.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the length of the longest synopsis message in a list of options'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 1226,col 19)-(line 1226,col 19)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.Options.max_opt_len(java.util.List<plume.Options.OptionInfo>, boolean)"},{"methodDeclaration":" boolean isUsingGroups()","methodAccessSpecifier":"NONE","methodBody":"{\n    return use_groups;\n}","methodRange":"(line 1244,col 3)-(line 1246,col 3)","methodTokenRange":"boolean isUsingGroups() {\n    return use_groups;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"isUsingGroups","methodQualifiedSignature":"plume.Options.isUsingGroups","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.Options.isUsingGroups()"},{"methodDeclaration":" boolean isUsingSingleDash()","methodAccessSpecifier":"NONE","methodBody":"{\n    return use_single_dash;\n}","methodRange":"(line 1249,col 3)-(line 1251,col 3)","methodTokenRange":"boolean isUsingSingleDash() {\n    return use_single_dash;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"isUsingSingleDash","methodQualifiedSignature":"plume.Options.isUsingSingleDash","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.Options.isUsingSingleDash()"},{"methodDeclaration":" List<OptionInfo> getOptions()","methodAccessSpecifier":"NONE","methodBody":"{\n    return options;\n}","methodRange":"(line 1253,col 3)-(line 1255,col 3)","methodTokenRange":"List<OptionInfo> getOptions() {\n    return options;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getOptions","methodQualifiedSignature":"plume.Options.getOptions","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<plume.Options.OptionInfo>","methodType":"List<OptionInfo>","literalExprs":[],"methodQualifiedName":"plume.Options.getOptions()"},{"methodDeclaration":" Collection<OptionGroupInfo> getOptionGroups()","methodAccessSpecifier":"NONE","methodBody":"{\n    return group_map.values();\n}","methodRange":"(line 1257,col 3)-(line 1259,col 3)","methodTokenRange":"Collection<OptionGroupInfo> getOptionGroups() {\n    return group_map.values();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=ReferenceType{plume.Options.OptionGroupInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"getOptionGroups","methodQualifiedSignature":"plume.Options.getOptionGroups","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Collection<plume.Options.OptionGroupInfo>","methodType":"Collection<OptionGroupInfo>","literalExprs":[],"methodQualifiedName":"plume.Options.getOptionGroups()"},{"javadocBlockTags":[],"methodDeclaration":"private void set_arg(OptionInfo oi, String arg_name, String arg_value) throws ArgException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Field f = oi.field;\n    Class<?> type = oi.base_type;\n    if (options_str.length() > 0) {\n        options_str += \" \";\n    }\n    options_str += arg_name;\n    if (arg_value != null) {\n        if (!arg_value.contains(\" \")) {\n            options_str += \"=\" + arg_value;\n        } else if (!arg_value.contains(\"'\")) {\n            options_str += \"='\" + arg_value + \"'\";\n        } else if (!arg_value.contains(\"\\\"\")) {\n            options_str += \"=\\\"\" + arg_value + \"\\\"\";\n        } else {\n            throw new ArgException(\"Can't quote for internal debugging: \" + arg_value);\n        }\n    }\n    if (arg_value == null) {\n        if ((type != Boolean.TYPE) || (type != Boolean.class)) {\n            arg_value = \"true\";\n        } else {\n            throw new ArgException(\"Value required for option \" + arg_name);\n        }\n    }\n    try {\n        if (type.isPrimitive()) {\n            if (type == Boolean.TYPE) {\n                boolean val;\n                String arg_value_lowercase = arg_value.toLowerCase();\n                if (arg_value_lowercase.equals(\"true\") || (arg_value_lowercase.equals(\"t\"))) {\n                    val = true;\n                } else if (arg_value_lowercase.equals(\"false\") || arg_value_lowercase.equals(\"f\")) {\n                    val = false;\n                } else {\n                    throw new ArgException(\"Value \\\"%s\\\" for argument %s is not a boolean\", arg_value, arg_name);\n                }\n                arg_value = (val) ? \"true\" : \"false\";\n                f.setBoolean(oi.obj, val);\n            } else if (type == Integer.TYPE) {\n                int val;\n                try {\n                    val = Integer.decode(arg_value);\n                } catch (Exception e) {\n                    throw new ArgException(\"Value \\\"%s\\\" for argument %s is not an integer\", arg_value, arg_name);\n                }\n                f.setInt(oi.obj, val);\n            } else if (type == Long.TYPE) {\n                long val;\n                try {\n                    val = Long.decode(arg_value);\n                } catch (Exception e) {\n                    throw new ArgException(\"Value \\\"%s\\\" for argument %s is not a long integer\", arg_value, arg_name);\n                }\n                f.setLong(oi.obj, val);\n            } else if (type == Float.TYPE) {\n                Float val;\n                try {\n                    val = Float.valueOf(arg_value);\n                } catch (Exception e) {\n                    throw new ArgException(\"Value \\\"%s\\\" for argument %s is not a float\", arg_value, arg_name);\n                }\n                f.setFloat(oi.obj, val);\n            } else if (type == Double.TYPE) {\n                Double val;\n                try {\n                    val = Double.valueOf(arg_value);\n                } catch (Exception e) {\n                    throw new ArgException(\"Value \\\"%s\\\" for argument %s is not a double\", arg_value, arg_name);\n                }\n                f.setDouble(oi.obj, val);\n            } else {\n                throw new Error(\"Unexpected type \" + type);\n            }\n        } else {\n            if (oi.list != null) {\n                if (split_lists) {\n                    String[] aarr = arg_value.split(\"  *\");\n                    for (String aval : aarr) {\n                        Object val = get_ref_arg(oi, arg_name, aval);\n                        oi.list.add(val);\n                    }\n                } else {\n                    Object val = get_ref_arg(oi, arg_name, arg_value);\n                    oi.list.add(val);\n                }\n            } else {\n                Object val = get_ref_arg(oi, arg_name, arg_value);\n                f.set(oi.obj, val);\n            }\n        }\n    } catch (ArgException ae) {\n        throw ae;\n    } catch (Exception e) {\n        throw new Error(\"Unexpected error \", e);\n    }\n}","methodRange":"(line 1265,col 3)-(line 1377,col 3)","methodTokenRange":"private void set_arg(OptionInfo oi, String arg_name, \/*@Nullable*\/ String arg_value)\n      throws ArgException {\n\n    Field f = oi.field;\n    Class<?> type = oi.base_type;\n\n    \/\/ Keep track of all of the options specified\n    if (options_str.length() > 0) {\n      options_str += \" \";\n    }\n    options_str += arg_name;\n    if (arg_value != null) {\n      if (!arg_value.contains(\" \")) {\n        options_str += \"=\" + arg_value;\n      } else if (!arg_value.contains(\"'\")) {\n        options_str += \"='\" + arg_value + \"'\";\n      } else if (!arg_value.contains(\"\\\"\")) {\n        options_str += \"=\\\"\" + arg_value + \"\\\"\";\n      } else {\n        throw new ArgException(\"Can't quote for internal debugging: \" + arg_value);\n      }\n    }\n    \/\/ Argument values are required for everything but booleans\n    if (arg_value == null) {\n      if ((type != Boolean.TYPE) || (type != Boolean.class)) {\n        arg_value = \"true\";\n      } else {\n        throw new ArgException(\"Value required for option \" + arg_name);\n      }\n    }\n\n    try {\n      if (type.isPrimitive()) {\n        if (type == Boolean.TYPE) {\n          boolean val;\n          String arg_value_lowercase = arg_value.toLowerCase();\n          if (arg_value_lowercase.equals(\"true\") || (arg_value_lowercase.equals(\"t\"))) {\n            val = true;\n          } else if (arg_value_lowercase.equals(\"false\") || arg_value_lowercase.equals(\"f\")) {\n            val = false;\n          } else {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a boolean\", arg_value, arg_name);\n          }\n          arg_value = (val) ? \"true\" : \"false\";\n          \/\/ System.out.printf (\"Setting %s to %s%n\", arg_name, val);\n          f.setBoolean(oi.obj, val);\n        } else if (type == Integer.TYPE) {\n          int val;\n          try {\n            val = Integer.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not an integer\", arg_value, arg_name);\n          }\n          f.setInt(oi.obj, val);\n        } else if (type == Long.TYPE) {\n          long val;\n          try {\n            val = Long.decode(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a long integer\", arg_value, arg_name);\n          }\n          f.setLong(oi.obj, val);\n        } else if (type == Float.TYPE) {\n          Float val;\n          try {\n            val = Float.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a float\", arg_value, arg_name);\n          }\n          f.setFloat(oi.obj, val);\n        } else if (type == Double.TYPE) {\n          Double val;\n          try {\n            val = Double.valueOf(arg_value);\n          } catch (Exception e) {\n            throw new ArgException(\n                \"Value \\\"%s\\\" for argument %s is not a double\", arg_value, arg_name);\n          }\n          f.setDouble(oi.obj, val);\n        } else { \/\/ unexpected type\n          throw new Error(\"Unexpected type \" + type);\n        }\n      } else { \/\/ reference type\n\n        \/\/ If the argument is a list, add repeated arguments or multiple\n        \/\/ blank separated arguments to the list, otherwise just set the\n        \/\/ argument value.\n        if (oi.list != null) {\n          if (split_lists) {\n            String[] aarr = arg_value.split(\"  *\");\n            for (String aval : aarr) {\n              Object val = get_ref_arg(oi, arg_name, aval);\n              oi.list.add(val); \/\/ uncheck cast\n            }\n          } else {\n            Object val = get_ref_arg(oi, arg_name, arg_value);\n            oi.list.add(val);\n          }\n        } else {\n          Object val = get_ref_arg(oi, arg_name, arg_value);\n          f.set(oi.obj, val);\n        }\n      }\n    } catch (ArgException ae) {\n      throw ae;\n    } catch (Exception e) {\n      throw new Error(\"Unexpected error \", e);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Set the specified option to the value specified in arg_value.  Throws\n   * an ArgException if there are any errors.\n   ","methodParameters":[{"parameterType":"OptionInfo","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.Options.OptionInfo","parameter":"OptionInfo oi","parameterName":"oi"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg_name","parameterName":"arg_name"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg_value","parameterName":"arg_value"}],"methodName":"set_arg","methodQualifiedSignature":"plume.Options.set_arg","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the specified option to the value specified in arg_value.  Throws\nan ArgException if there are any errors.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1272,col 32)-(line 1272,col 32)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1273,col 22)-(line 1273,col 24)","literalExprId":2,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1276,col 22)-(line 1276,col 25)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1277,col 31)-(line 1277,col 33)","literalExprId":4,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1278,col 24)-(line 1278,col 26)","literalExprId":5,"literalExpr":"\"=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1279,col 38)-(line 1279,col 40)","literalExprId":6,"literalExpr":"\"'\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1280,col 24)-(line 1280,col 27)","literalExprId":7,"literalExpr":"\"='\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1280,col 43)-(line 1280,col 45)","literalExprId":8,"literalExpr":"\"'\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1281,col 38)-(line 1281,col 41)","literalExprId":9,"literalExpr":"\"\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1282,col 24)-(line 1282,col 28)","literalExprId":10,"literalExpr":"\"=\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1282,col 44)-(line 1282,col 47)","literalExprId":11,"literalExpr":"\"\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1284,col 32)-(line 1284,col 69)","literalExprId":12,"literalExpr":"\"Can't quote for internal debugging: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1288,col 22)-(line 1288,col 25)","literalExprId":13,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1290,col 21)-(line 1290,col 26)","literalExprId":14,"literalExpr":"\"true\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1292,col 32)-(line 1292,col 59)","literalExprId":15,"literalExpr":"\"Value required for option \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1301,col 42)-(line 1301,col 47)","literalExprId":16,"literalExpr":"\"true\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1301,col 81)-(line 1301,col 83)","literalExprId":17,"literalExpr":"\"t\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1302,col 19)-(line 1302,col 22)","literalExprId":18,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1303,col 49)-(line 1303,col 55)","literalExprId":19,"literalExpr":"\"false\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1303,col 88)-(line 1303,col 90)","literalExprId":20,"literalExpr":"\"f\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1304,col 19)-(line 1304,col 23)","literalExprId":21,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1307,col 17)-(line 1307,col 63)","literalExprId":22,"literalExpr":"\"Value \\\"%s\\\" for argument %s is not a boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1309,col 31)-(line 1309,col 36)","literalExprId":23,"literalExpr":"\"true\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1309,col 40)-(line 1309,col 46)","literalExprId":24,"literalExpr":"\"false\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1318,col 17)-(line 1318,col 64)","literalExprId":25,"literalExpr":"\"Value \\\"%s\\\" for argument %s is not an integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1327,col 17)-(line 1327,col 68)","literalExprId":26,"literalExpr":"\"Value \\\"%s\\\" for argument %s is not a long integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1336,col 17)-(line 1336,col 61)","literalExprId":27,"literalExpr":"\"Value \\\"%s\\\" for argument %s is not a float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1345,col 17)-(line 1345,col 62)","literalExprId":28,"literalExpr":"\"Value \\\"%s\\\" for argument %s is not a double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1349,col 27)-(line 1349,col 44)","literalExprId":29,"literalExpr":"\"Unexpected type \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1356,col 24)-(line 1356,col 27)","literalExprId":30,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1358,col 45)-(line 1358,col 49)","literalExprId":31,"literalExpr":"\"  *\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1375,col 23)-(line 1375,col 41)","literalExprId":32,"literalExpr":"\"Unexpected error \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.set_arg(plume.Options.OptionInfo, java.lang.String, java.lang.String)"},{"javadocBlockTags":[],"methodDeclaration":"private Object get_ref_arg(OptionInfo oi, String arg_name, String arg_value) throws ArgException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Object val = null;\n    try {\n        if (oi.constructor != null) {\n            val = oi.constructor.newInstance(new Object[] { arg_value });\n        } else if (oi.base_type.isEnum()) {\n            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n            Object tmpVal = getEnumValue((Class<Enum>) oi.base_type, arg_value);\n            val = tmpVal;\n        } else {\n            if (oi.factory == null) {\n                throw new Error(\"No constructor or factory for argument \" + arg_name);\n            }\n            @SuppressWarnings(\"nullness\")\n            Object tmpVal = oi.factory.invoke(null, arg_value);\n            val = tmpVal;\n        }\n    } catch (Exception e) {\n        throw new ArgException(\"Invalid argument (%s) for argument %s\", arg_value, arg_name);\n    }\n    assert val != null : \"@AssumeAssertion(nullness)\";\n    return val;\n}","methodRange":"(line 1384,col 3)-(line 1409,col 3)","methodTokenRange":"private \/*@NonNull*\/ Object get_ref_arg(OptionInfo oi, String arg_name, String arg_value)\n      throws ArgException {\n\n    Object val = null;\n    try {\n      if (oi.constructor != null) {\n        val = oi.constructor.newInstance(new Object[] {arg_value});\n      } else if (oi.base_type.isEnum()) {\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        Object tmpVal = getEnumValue((Class<Enum>) oi.base_type, arg_value);\n        val = tmpVal;\n      } else {\n        if (oi.factory == null) {\n          throw new Error(\"No constructor or factory for argument \" + arg_name);\n        }\n        @SuppressWarnings(\"nullness\") \/\/ oi.factory is a static method, so null first argument is OK\n        Object tmpVal = oi.factory.invoke(null, arg_value);\n        val = tmpVal;\n      }\n    } catch (Exception e) {\n      throw new ArgException(\"Invalid argument (%s) for argument %s\", arg_value, arg_name);\n    }\n\n    assert val != null : \"@AssumeAssertion(nullness)\";\n    return val;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Create an instance of the correct type by passing the argument value\n   * string to the constructor.  The only expected error is some sort\n   * of parse error from the constructor.\n   ","methodParameters":[{"parameterType":"OptionInfo","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.Options.OptionInfo","parameter":"OptionInfo oi","parameterName":"oi"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg_name","parameterName":"arg_name"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String arg_value","parameterName":"arg_value"}],"methodName":"get_ref_arg","methodQualifiedSignature":"plume.Options.get_ref_arg","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create an instance of the correct type by passing the argument value\nstring to the constructor.  The only expected error is some sort\nof parse error from the constructor.'}]}, blockTags=[]}","methodReturnTypeDescribed":"java.lang.Object","methodType":"Object","literalExprs":[{"literalExprRange":"(line 1387,col 18)-(line 1387,col 21)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1389,col 29)-(line 1389,col 32)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1392,col 28)-(line 1392,col 38)","literalExprId":3,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1392,col 41)-(line 1392,col 50)","literalExprId":4,"literalExpr":"\"rawtypes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1396,col 27)-(line 1396,col 30)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1397,col 27)-(line 1397,col 67)","literalExprId":6,"literalExpr":"\"No constructor or factory for argument \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1399,col 27)-(line 1399,col 36)","literalExprId":7,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1400,col 43)-(line 1400,col 46)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1404,col 30)-(line 1404,col 68)","literalExprId":9,"literalExpr":"\"Invalid argument (%s) for argument %s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1407,col 19)-(line 1407,col 22)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1407,col 26)-(line 1407,col 53)","literalExprId":11,"literalExpr":"\"@AssumeAssertion(nullness)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.get_ref_arg(plume.Options.OptionInfo, java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the enum type","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the enum type'}]}', name=Optional[<T>]}"}],"methodDeclaration":"private T getEnumValue(Class<T> enumType, String name)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    T[] constants = enumType.getEnumConstants();\n    if (constants == null) {\n        throw new IllegalArgumentException(enumType.getName() + \" is not an enum type\");\n    }\n    for (T constant : constants) {\n        if (constant.name().equalsIgnoreCase(name.replace('-', '_'))) {\n            return constant;\n        }\n    }\n    throw new IllegalArgumentException(\"No enum constant \" + enumType.getCanonicalName() + \".\" + name);\n}","methodRange":"(line 1418,col 3)-(line 1431,col 3)","methodTokenRange":"private <T extends Enum<T>> T getEnumValue(Class<T> enumType, String name) {\n    T[] constants = enumType.getEnumConstants();\n    if (constants == null) {\n      throw new IllegalArgumentException(enumType.getName() + \" is not an enum type\");\n    }\n    for (T constant : constants) {\n      if (constant.name().equalsIgnoreCase(name.replace('-', '_'))) {\n        return constant;\n      }\n    }\n    \/\/ same error that's thrown by Enum.valueOf()\n    throw new IllegalArgumentException(\n        \"No enum constant \" + enumType.getCanonicalName() + \".\" + name);\n  }","methodReturnTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[Enum<T>])}","methodJavadocComment":"\n   * Behaves like {@link java.lang.Enum#valueOf}, except that <code>name<\/code>\n   * is case-insensitive and hyphen-insensitive (hyphens can be used in place of\n   * underscores).  This allows for greater flexibility when specifying enum\n   * types as command-line arguments.\n   * @param <T> the enum type\n   ","methodParameters":[{"parameterType":"Class<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=TypeVariable {JPTypeParameter(T, bounds=[Enum<T>])}}}}","parameterTypeResolvedDescribed":"java.lang.Class<T>","parameter":"Class<T> enumType","parameterName":"enumType"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String name","parameterName":"name"}],"methodName":"getEnumValue","methodQualifiedSignature":"plume.Options.getEnumValue","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Behaves like '}, JavadocInlineTag{tagName='link', type=LINK, content=' java.lang.Enum#valueOf'}, JavadocSnippet{text=', except that <code>name<\/code>\nis case-insensitive and hyphen-insensitive (hyphens can be used in place of\nunderscores).  This allows for greater flexibility when specifying enum\ntypes as command-line arguments.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the enum type'}]}', name=Optional[<T>]}]}","methodReturnTypeDescribed":"T","methodType":"T","literalExprs":[{"literalExprRange":"(line 1420,col 22)-(line 1420,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1421,col 63)-(line 1421,col 84)","literalExprId":2,"literalExpr":"\" is not an enum type\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1424,col 57)-(line 1424,col 59)","literalExprId":3,"literalExpr":"'-'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1424,col 62)-(line 1424,col 64)","literalExprId":4,"literalExpr":"'_'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1430,col 9)-(line 1430,col 27)","literalExprId":5,"literalExpr":"\"No enum constant \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1430,col 61)-(line 1430,col 63)","literalExprId":6,"literalExpr":"\".\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.getEnumValue(java.lang.Class<T>, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a short name for the specified type for use in messages","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a short name for the specified type for use in messages'}]}', name=Optional.empty}"}],"methodDeclaration":"private static String type_short_name(Class<?> type)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (type.isPrimitive()) {\n        return type.getName();\n    } else if (type == File.class) {\n        return \"filename\";\n    } else if (type == Pattern.class) {\n        return \"regex\";\n    } else if (type.isEnum()) {\n        return (\"enum\");\n    } else {\n        return type.getSimpleName().toLowerCase();\n    }\n}","methodRange":"(line 1437,col 3)-(line 1450,col 3)","methodTokenRange":"private static String type_short_name(Class<?> type) {\n\n    if (type.isPrimitive()) {\n      return type.getName();\n    } else if (type == File.class) {\n      return \"filename\";\n    } else if (type == Pattern.class) {\n      return \"regex\";\n    } else if (type.isEnum()) {\n      return (\"enum\");\n    } else {\n      return type.getSimpleName().toLowerCase();\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a short name for the specified type for use in messages.\n   * @return a short name for the specified type for use in messages\n   ","methodParameters":[{"parameterType":"Class<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.lang.Class<?>","parameter":"Class<?> type","parameterName":"type"}],"methodName":"type_short_name","methodQualifiedSignature":"plume.Options.type_short_name","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a short name for the specified type for use in messages.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a short name for the specified type for use in messages'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1442,col 14)-(line 1442,col 23)","literalExprId":1,"literalExpr":"\"filename\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1444,col 14)-(line 1444,col 20)","literalExprId":2,"literalExpr":"\"regex\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1446,col 15)-(line 1446,col 20)","literalExprId":3,"literalExpr":"\"enum\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.type_short_name(java.lang.Class<?>)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"options, similarly to supplied on the command line","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='options, similarly to supplied on the command line'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#settings()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#settings()'}]}', name=Optional.empty}"}],"methodDeclaration":"public String get_options_str()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (options_str);\n}","methodRange":"(line 1459,col 3)-(line 1461,col 3)","methodTokenRange":"public String get_options_str() {\n    return (options_str);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a string containing all of the options that were set and their\n   * arguments.  This is essentially the contents of args[] with all\n   * non-options removed.\n   * @return options, similarly to supplied on the command line\n   * @see #settings()\n   ","methodParameters":[],"methodName":"get_options_str","methodQualifiedSignature":"plume.Options.get_options_str","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string containing all of the options that were set and their\narguments.  This is essentially the contents of args[] with all\nnon-options removed.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='options, similarly to supplied on the command line'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#settings()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[],"methodQualifiedName":"plume.Options.get_options_str()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"options, similarly to supplied on the command line","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='options, similarly to supplied on the command line'}]}', name=Optional.empty}"}],"methodDeclaration":"public String settings()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return settings(false);\n}","methodRange":"(line 1471,col 3)-(line 1473,col 3)","methodTokenRange":"public String settings() {\n    return settings(false);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   * @return options, similarly to supplied on the command line\n   ","methodParameters":[],"methodName":"settings","methodQualifiedSignature":"plume.Options.settings","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string containing the current setting for each option, in a\nformat that can be parsed by Options.  This differs from\nget_options_str() in that it contains each known option exactly once:\nit never contains duplicates, and it contains every known option even\nif the option was not specified on the command line.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='options, similarly to supplied on the command line'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1472,col 21)-(line 1472,col 25)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.Options.settings()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"if true, treat all unpublicized options\nand option groups as publicized","javadocBlockTagName":"include_unpublicized","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, treat all unpublicized options\nand option groups as publicized'}]}', name=Optional[include_unpublicized]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"options, similarly to supplied on the command line","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='options, similarly to supplied on the command line'}]}', name=Optional.empty}"}],"methodDeclaration":"public String settings(boolean include_unpublicized)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n    int max_len = max_opt_len(options, include_unpublicized);\n    for (OptionInfo oi : options) {\n        @SuppressWarnings(\"formatter\")\n        String use = String.format(\"%-\" + max_len + \"s = \", oi.long_name);\n        try {\n            use += oi.field.get(oi.obj);\n        } catch (Exception e) {\n            throw new Error(\"unexpected exception reading field \" + oi.field, e);\n        }\n        out.append(use);\n    }\n    return out.toString();\n}","methodRange":"(line 1486,col 3)-(line 1505,col 3)","methodTokenRange":"public String settings(boolean include_unpublicized) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    \/\/ Determine the length of the longest name\n    int max_len = max_opt_len(options, include_unpublicized);\n\n    \/\/ Create the settings string\n    for (OptionInfo oi : options) {\n      @SuppressWarnings(\"formatter\") \/\/ format string computed from max_len\n      String use = String.format(\"%-\" + max_len + \"s = \", oi.long_name);\n      try {\n        use += oi.field.get(oi.obj);\n      } catch (Exception e) {\n        throw new Error(\"unexpected exception reading field \" + oi.field, e);\n      }\n      out.append(use);\n    }\n\n    return out.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns a string containing the current setting for each option, in a\n   * format that can be parsed by Options.  This differs from\n   * get_options_str() in that it contains each known option exactly once:\n   * it never contains duplicates, and it contains every known option even\n   * if the option was not specified on the command line.\n   *\n   * @param include_unpublicized  if true, treat all unpublicized options\n   * and option groups as publicized\n   * @return options, similarly to supplied on the command line\n   ","methodParameters":[{"parameterType":"boolean","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean include_unpublicized","parameterName":"include_unpublicized"}],"methodName":"settings","methodQualifiedSignature":"plume.Options.settings","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns a string containing the current setting for each option, in a\nformat that can be parsed by Options.  This differs from\nget_options_str() in that it contains each known option exactly once:\nit never contains duplicates, and it contains every known option even\nif the option was not specified on the command line.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='if true, treat all unpublicized options\nand option groups as publicized'}]}', name=Optional[include_unpublicized]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='options, similarly to supplied on the command line'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1494,col 25)-(line 1494,col 35)","literalExprId":1,"literalExpr":"\"formatter\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1495,col 34)-(line 1495,col 37)","literalExprId":2,"literalExpr":"\"%-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1495,col 51)-(line 1495,col 56)","literalExprId":3,"literalExpr":"\"s = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1499,col 25)-(line 1499,col 61)","literalExprId":4,"literalExpr":"\"unexpected exception reading field \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.settings(boolean)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a description of all of the known options","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a description of all of the known options'}]}', name=Optional.empty}"}],"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n    for (OptionInfo oi : options) {\n        out.append(oi);\n    }\n    return out.toString();\n}","methodRange":"(line 1512,col 3)-(line 1523,col 3)","methodTokenRange":"@Override\n  @SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public String toString(\/*>>>@GuardSatisfied Options this*\/) {\n    StringBuilderDelimited out = new StringBuilderDelimited(eol);\n\n    for (OptionInfo oi : options) {\n      out.append(oi);\n    }\n\n    return out.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a description of all of the known options.\n   * Each option is described on its own line in the output.\n   * @return a description of all of the known options\n   ","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.Options.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a description of all of the known options.\nEach option is described on its own line in the output.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a description of all of the known options'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1513,col 21)-(line 1513,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.Options.toString()"},{"javadocBlockTags":[],"methodDeclaration":"private static ParseResult parse_option(String val)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    String short_name;\n    String type_name;\n    String description;\n    if (val.startsWith(\"-\")) {\n        if (val.length() < 4 || !val.substring(2, 3).equals(\" \")) {\n            throw new Error(\"Malformed @Option argument \\\"\" + val + \"\\\".  An argument that starts with '-' should contain a short name, a space, and a description.\");\n        }\n        short_name = val.substring(1, 2);\n        description = val.substring(3);\n    } else {\n        short_name = null;\n        description = val;\n    }\n    if (description.startsWith(\"<\")) {\n        type_name = description.substring(1).replaceFirst(\">.*\", \"\");\n        description = description.replaceFirst(\"<.*> \", \"\");\n    } else {\n        type_name = null;\n    }\n    return new ParseResult(short_name, type_name, description);\n}","methodRange":"(line 1559,col 3)-(line 1591,col 3)","methodTokenRange":"private static ParseResult parse_option(String val) {\n\n    \/\/ Get the short name, long name, and description\n    String short_name;\n    String type_name;\n    \/*@NonNull*\/ String description;\n\n    \/\/ Get the short name (if any)\n    if (val.startsWith(\"-\")) {\n      if (val.length() < 4 || !val.substring(2, 3).equals(\" \")) {\n        throw new Error(\n            \"Malformed @Option argument \\\"\"\n                + val\n                + \"\\\".  An argument that starts with '-' should contain a short name, a space, and a description.\");\n      }\n      short_name = val.substring(1, 2);\n      description = val.substring(3);\n    } else {\n      short_name = null;\n      description = val;\n    }\n\n    \/\/ Get the type name (if any)\n    if (description.startsWith(\"<\")) {\n      type_name = description.substring(1).replaceFirst(\">.*\", \"\");\n      description = description.replaceFirst(\"<.*> \", \"\");\n    } else {\n      type_name = null;\n    }\n\n    \/\/ Return the result\n    return new ParseResult(short_name, type_name, description);\n  }","methodReturnTypeResolved":"ReferenceType{plume.Options.ParseResult, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Parse an option value and return its three components (short_name,\n   * type_name, and description).  The short_name and type_name are null\n   * if they are not specified in the string.\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String val","parameterName":"val"}],"methodName":"parse_option","methodQualifiedSignature":"plume.Options.parse_option","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Parse an option value and return its three components (short_name,\ntype_name, and description).  The short_name and type_name are null\nif they are not specified in the string.'}]}, blockTags=[]}","methodReturnTypeDescribed":"plume.Options.ParseResult","methodType":"ParseResult","literalExprs":[{"literalExprRange":"(line 1567,col 24)-(line 1567,col 26)","literalExprId":1,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1568,col 26)-(line 1568,col 26)","literalExprId":2,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1568,col 46)-(line 1568,col 46)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1568,col 49)-(line 1568,col 49)","literalExprId":4,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1568,col 59)-(line 1568,col 61)","literalExprId":5,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1570,col 13)-(line 1570,col 43)","literalExprId":6,"literalExpr":"\"Malformed @Option argument \\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1572,col 19)-(line 1572,col 114)","literalExprId":7,"literalExpr":"\"\\\".  An argument that starts with '-' should contain a short name, a space, and a description.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1574,col 34)-(line 1574,col 34)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1574,col 37)-(line 1574,col 37)","literalExprId":9,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1575,col 35)-(line 1575,col 35)","literalExprId":10,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1577,col 20)-(line 1577,col 23)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1582,col 32)-(line 1582,col 34)","literalExprId":12,"literalExpr":"\"<\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1583,col 41)-(line 1583,col 41)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1583,col 57)-(line 1583,col 61)","literalExprId":14,"literalExpr":"\">.*\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1583,col 64)-(line 1583,col 65)","literalExprId":15,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1584,col 46)-(line 1584,col 52)","literalExprId":16,"literalExpr":"\"<.*> \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1584,col 55)-(line 1584,col 56)","literalExprId":17,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1586,col 19)-(line 1586,col 22)","literalExprId":18,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.Options.parse_option(java.lang.String)"}],"classJavadoc":"\/**\n * The Options class:\n * <ul>\n *   <li>parses command-line options and sets fields in your program accordingly,<\/li>\n *   <li>creates usage messages (such as printed by a <code>--help<\/code> option), and<\/li>\n *   <li>creates documentation suitable for a manual or manpage.<\/li>\n * <\/ul>\n * Thus, the programmer is freed from writing duplicative, boilerplate code\n * and documentation that could get out of sync with the rest of the program.\n * <p>\n *\n * The programmer does not have to write any code, only declare and\n * document variables.  For each field that you want to set from a\n * command-line argument, you write Javadoc and an @{@link plume.Option}\n * annotation.  Then, the field is automatically set from a command-line\n * option of the same name, and usage messages and printed documentation\n * are generated automatically.\n * <p>\n *\n * The main entry point is {@link #parse_or_usage(String[])}.\n * Typical use is:\n *\n * <!-- Example needs some more words of explanation and example command lines. -->\n * <pre>\n *  import plume.*;\n *\n *  public class MyProgram {\n *\n *    &#64;Option(\"-o &lt;filename&gt; the output file \")\n *    public static File outfile = new File(\"\/tmp\/foobar\");\n *\n *    &#64;Option(\"-i ignore case\")\n *    public static boolean ignore_case;\n *\n *    &#64;Option(\"set the initial temperature\")\n *    public static double temperature = 75.0;\n *\n *    public static void main(String[] args) {\n *      MyProgram myInstance = new MyProgram();\n *      Options options = new Options(\"MyProgram [options] infile outfile\",\n *                                    myInstance, MyUtilityClass.class);\n *      String[] remaining_args = options.parse_or_usage(args);\n *      ...\n *    }\n *  }<\/pre>\n * A user may invoke the program using the command-line arguments\n * <code>-o<\/code>, <code>--outfile<\/code>, <code>-i<\/code>, <code>--ignore-case<\/code>,\n * and <code>--temperature<\/code>. <p>\n *\n * The call to {@link #parse_or_usage} sets fields in object myInstance,\n * and sets static fields in class MyUtilityClass.  It returns the original\n * command line, with all options removed. <p>\n *\n * <b>@Option indicates a command-line option<\/b> <p>\n * The @{@link Option} annotation on a field specifies brief user documentation\n * and, optionally, a one-character short name that users may supply on the\n * command line.  The long name is taken from the name of the variable;\n * when the name contains an underscore, the user may substitute a hyphen\n * on the command line instead; for example, the --multi-word-variable\n * command-line option would set the variable multi_word_variable. <p>\n *\n * On the command line, the values for options are specified in the form\n * '--longname=value', '-shortname=value', '--longname value', or '-shortname\n * value'.  If {@link #use_single_dash(boolean)} is true, then the long names\n * take the form '-longname=value' or '-longname value'.  The value is\n * mandatory for all options except booleans.  Booleans are set to true if no\n * value is specified. <p>\n *\n * All arguments that start with '-' are processed as options.  To\n * terminate option processing at the first non-option argument, see {@link\n * #parse_options_after_arg(boolean)}.  Also, the special option '--'\n * terminates option processing; method <code>parse_or_usage<\/code> returns\n * all subsequent arguments (along with any preceding non-option arguments)\n * without scanning them for options. <p>\n *\n * A user may provide an option multiple times on the command line.  If the\n * field is a list, each entry is added to the list.  If the field is\n * not a list, then only the last occurrence is used (subsequent\n * occurrences overwrite the previous value). <p>\n *\n * <b>Unpublicized options<\/b> <p>\n * The @{@link Unpublicized} annotation causes an option not to be displayed\n * in the usage message.  This can be useful for options that are\n * preliminary, experimental, or for internal purposes only.  The @{@link\n * Unpublicized} annotation must be specified in addition to the @{@link\n * Option} annotation. <p>\n *\n * There are forms of the usage-message methods that can include even\n * unpublicized options; for example, see {@link #usage(boolean,String...)}.\n * <p>\n *\n * <b>Option groups<\/b> <p>\n * The @{@link OptionGroup} annotation can be used to assign a name to a set of\n * related options.  This is useful for organizing a list of\n * options.  Options in the same group are displayed under the same heading\n * in usage texts. <p>\n *\n * The @{@link OptionGroup} annotation must be specified on a field in addition\n * to an @{@link Option} annotation.  Note that, due to a deficiency in\n * Javadoc, an <code>@OptionGroup<\/code> annotation must appear underneath any\n * Javadoc comment for the field it applies to. <p>\n *\n * The <code>@OptionGroup<\/code> annotation acts like a delimiter &mdash; all\n * <code>@Option<\/code>-annotated fields up to the next\n * <code>@OptionGroup<\/code> annotation belong to the same group.  When using\n * option groups, the first <code>@Option<\/code>-annotated field of every class\n * and object passed to the {@link #Options(String, Object...)} constructor\n * must have an <code>@OptionGroup<\/code> annotation.  Furthermore, the first\n * parameter of an <code>@OptionGroup<\/code> annotation (the group name) must\n * be unique among all classes and objects passed to the {@link\n * #Options(String, Object...)} constructor. <p>\n *\n * If an option group itself is unpublicized:\n * <ul>\n *   <li>The default usage message omits the group and all options belonging\n *       to it.\n *   <li>An unpublicized option group (that has any publicized options) is\n *       included in documentation for a manual.\n *   <li>A field with an @{@link Unpublicized} annotation is excluded\n *       even when passing the group's name\n *       explicitly as a parameter to {@link #usage(String...)}.\n * <\/ul>\n *\n * If an option group is not unpublicized but contains only unpublicized\n * options, it will not be included in the default usage message. <p>\n *\n * <b>Option aliases<\/b> <p>\n * The @{@link Option} annotation has an optional parameter <code>aliases<\/code>,\n * which accepts an array of strings.  Each string in the array is an alias for\n * the option being defined and can be used in place of an option's long name\n * or short name.<\/p>\n *\n * For example:\n * <pre>\n *     \/\/ The user may supply --help, -h, or -help, all of which mean the same thing and set this variable\n *     &#64;Option(value=\"-h Print a help message\", aliases={\"-help\"})\n *     public static boolean help;<\/pre>\n *\n * Aliases should start with a single dash or double dash.\n * If there is only a single, one-character alias, it can be put at the\n * beginning of the value field without the need for an aliases field.\n * It is the user's responsibility to ensure that no alias is the same as other\n * options or aliases and that they can be parsed unambiguously. <p>\n *\n * <b>Generating documentation for a manual or manpage<\/b> <p>\n * The class Javadoc for a class that has a main method should generally\n * contain a summary of all command-line options.  Such a summary can also\n * be useful in other circumstances.\n * See the {@link plume.OptionsDoclet} class for instructions about generating\n * HTML documentation. <p>\n *\n * <b>Supported field types<\/b> <p>\n * A field with an @{@link Option} annotation may be of the following types:\n * <ul>\n *   <li>Primitive types:  boolean, int, long, float, double.\n *       (Primitives can also be represented as wrappers:  Boolean,\n *       Integer, Long, Float, Double.  Use of a wrapper type allows the\n *       argument to have no default value.)\n *   <li>Reference types that have a constructor with a single string\n *       parameter.\n *   <li>java.util.regex.Pattern.\n *   <li>enums.\n *   <li>Lists of any of the above reference types.\n * <\/ul> <p>\n *\n * <b>More examples<\/b> <p>\n *\n * Example clients of the Options library include {@link plume.Lookup},\n * <a href=\"https:\/\/randoop.github.io\/randoop\/manual\/#command-line-options\">Randoop<\/a>, and\n * <a href=\"http:\/\/types.cs.washington.edu\/javari\/javarifier\/#command-line-opts\">Javarifier<\/a>, among many others.  <p>\n *\n * <b>Limitations<\/b> <ul>\n *\n *  <li> Short options are only supported as separate entries\n *  (e.g., \"-a -b\") and not as a single group (e.g., \"-ab\").\n *\n *  <li> Not all primitive types are supported.\n *\n *  <li> Types without a constructor that takes a single <code>String<\/code>\n *  argument are not supported.\n *\n *  <li> The \"--no-long\" option to turn off a boolean option named \"long\"\n *  is not supported; use \"--long=false\" instead.\n *\n * <\/ul> <p>\n *\n * <b>Possible enhancements<\/b> <ul>\n *  <li> Positional arguments (non-options that must be provided in a given\n *  order) could be supported.\n * <\/ul>\n *\n * @see plume.Option\n * @see plume.OptionGroup\n * @see plume.Unpublicized\n * @see plume.OptionsDoclet\n *\/\n","className":"Options","fields":[{"fieldRange":"(line 237,col 3)-(line 237,col 67)","fieldName":"eol","fieldJavadocComment":" The system-dependent line separator. ","fieldTokenRange":"private static String eol = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 237,col 50)-(line 237,col 65)","literalExprId":1,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"The system-dependent line separator.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 528,col 3)-(line 528,col 49)","fieldName":"parse_options_after_arg","fieldJavadocComment":"\n   * Whether to parse options after a non-option command-line argument.\n   * @see #parse_options_after_arg(boolean)\n   ","fieldTokenRange":"private boolean parse_options_after_arg = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 528,col 45)-(line 528,col 48)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"Whether to parse options after a non-option command-line argument.\n\n@see #parse_options_after_arg(boolean)\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 531,col 3)-(line 531,col 34)","fieldName":"options_str","fieldJavadocComment":" All of the argument options as a single string. ","fieldTokenRange":"private String options_str = \"\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 531,col 32)-(line 531,col 33)","literalExprId":1,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"\"]","fieldType":"String","fieldJavadoc":"All of the argument options as a single string.\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 534,col 3)-(line 534,col 42)","fieldName":"main_class","fieldJavadocComment":" First specified class.  Void stands for \"not yet initialized\". ","fieldTokenRange":"private Class<?> main_class = Void.TYPE;","fieldTypeResolved":"ReferenceType{java.lang.Class, typeParametersMap=TypeParametersMap{nameToValue={java.lang.Class.T=WildcardUsage{type=null, boundedType=null}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[Void.TYPE]","fieldType":"Class<?>","fieldJavadoc":"First specified class.  Void stands for \"not yet initialized\".\n","fieldTypeResolvedDescribed":"java.lang.Class<?>"},{"fieldRange":"(line 537,col 3)-(line 537,col 71)","fieldName":"options","fieldJavadocComment":" List of all of the defined options. ","fieldTokenRange":"private final List<OptionInfo> options = new ArrayList<OptionInfo>();","fieldTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new ArrayList<OptionInfo>()]","fieldType":"List<OptionInfo>","fieldJavadoc":"List of all of the defined options.\n","fieldTypeResolvedDescribed":"java.util.List<plume.Options.OptionInfo>"},{"fieldRange":"(line 540,col 3)-(line 540,col 91)","fieldName":"name_map","fieldJavadocComment":" Map from short or long option names (with leading dashes) to option information. ","fieldTokenRange":"private final Map<String, OptionInfo> name_map = new LinkedHashMap<String, OptionInfo>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{plume.Options.OptionInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new LinkedHashMap<String, OptionInfo>()]","fieldType":"Map<String, OptionInfo>","fieldJavadoc":"Map from short or long option names (with leading dashes) to option information.\n","fieldTypeResolvedDescribed":"java.util.Map<java.lang.String, plume.Options.OptionInfo>"},{"fieldRange":"(line 543,col 3)-(line 544,col 51)","fieldName":"group_map","fieldJavadocComment":" Map from option group name to option group information. ","fieldTokenRange":"private final Map<String, OptionGroupInfo> group_map =\n      new LinkedHashMap<String, OptionGroupInfo>();","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{plume.Options.OptionGroupInfo, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new LinkedHashMap<String, OptionGroupInfo>()]","fieldType":"Map<String, OptionGroupInfo>","fieldJavadoc":"Map from option group name to option group information.\n","fieldTypeResolvedDescribed":"java.util.Map<java.lang.String, plume.Options.OptionGroupInfo>"},{"fieldRange":"(line 553,col 3)-(line 553,col 29)","fieldName":"use_groups","fieldJavadocComment":"\n   * If, after the Options constructor is called, use_groups is true, then the\n   * user is using @OptionGroup annotations correctly (as per the requirement\n   * specified above).  If false, then @OptionGroup annotations have not been\n   * specified on any @Option-annotated fields.  When @OptionGroup annotations\n   * are used incorrectly, an Error is thrown by the Options constructor.\n   ","fieldTokenRange":"private boolean use_groups;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"boolean","fieldJavadoc":"If, after the Options constructor is called, use_groups is true, then the\nuser is using @OptionGroup annotations correctly (as per the requirement\nspecified above).  If false, then @OptionGroup annotations have not been\nspecified on any @Option-annotated fields.  When @OptionGroup annotations\nare used incorrectly, an Error is thrown by the Options constructor.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 559,col 3)-(line 559,col 42)","fieldName":"use_dashes","fieldJavadocComment":"\n   * Convert underscores to dashes in long options in usage messages.  Users\n   * may specify either the underscore or dashed name on the command line.\n   ","fieldTokenRange":"private final boolean use_dashes = true;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 559,col 38)-(line 559,col 41)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[true]","fieldType":"boolean","fieldJavadoc":"Convert underscores to dashes in long options in usage messages.  Users\nmay specify either the underscore or dashed name on the command line.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 565,col 3)-(line 565,col 42)","fieldName":"use_single_dash","fieldJavadocComment":"\n   * When true, long options take the form -longOption with a single dash,\n   * rather than the default --longOption with two dashes.\n   ","fieldTokenRange":"private boolean use_single_dash = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 565,col 37)-(line 565,col 41)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"When true, long options take the form -longOption with a single dash,\nrather than the default --longOption with two dashes.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 570,col 3)-(line 570,col 94)","fieldName":"LIST_HELP","fieldJavadocComment":"\n   * String describing \"[+]\" (copied from Mercurial).\n   ","fieldTokenRange":"private static final String LIST_HELP = \"[+] marked option can be specified multiple times\";","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 570,col 43)-(line 570,col 93)","literalExprId":1,"literalExpr":"\"[+] marked option can be specified multiple times\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[\"[+] marked option can be specified multiple times\"]","fieldType":"String","fieldJavadoc":"String describing \"[+]\" (copied from Mercurial).\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 577,col 3)-(line 577,col 42)","fieldName":"print_list_help","fieldJavadocComment":"\n   * Whether printing the usage message should print LIST_HELP.  The default is\n   * to print LIST_HELP if the usage message contains an option that accepts a\n   * list as a parameter.\n   ","fieldTokenRange":"private boolean print_list_help = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 577,col 37)-(line 577,col 41)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"Whether printing the usage message should print LIST_HELP.  The default is\nto print LIST_HELP if the usage message contains an option that accepts a\nlist as a parameter.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 585,col 3)-(line 586,col 44)","fieldName":"split_lists","fieldJavadocComment":"\n   * When true, an argument to a option of list type is split, on\n   * whitespace, into multiple arguments each of which is added to the\n   * list.  When false, each argument to an option of list type is treated\n   * as a single element, no matter what characters it contains.\n   ","fieldTokenRange":"@Option(\"Treat arguments to lists as space-separated.\")\n  public static boolean split_lists = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 585,col 11)-(line 585,col 56)","literalExprId":1,"literalExpr":"\"Treat arguments to lists as space-separated.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 586,col 39)-(line 586,col 43)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"When true, an argument to a option of list type is split, on\nwhitespace, into multiple arguments each of which is added to the\nlist.  When false, each argument to an option of list type is treated\nas a single element, no matter what characters it contains.\n","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 594,col 3)-(line 594,col 52)","fieldName":"usage_synopsis","fieldJavadocComment":"\n   * Synopsis of usage.  Example:  \"prog [options] arg1 arg2 ...\"\n   * <p>\n   * This variable is public so that clients can reset it (useful for\n   * masquerading as another program, based on parsed options).\n   ","fieldTokenRange":"public \/*@Nullable*\/ String usage_synopsis = null;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 594,col 48)-(line 594,col 51)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"String","fieldJavadoc":"Synopsis of usage.  Example:  \"prog [options] arg1 arg2 ...\"\n<p>\nThis variable is public so that clients can reset it (useful for\nmasquerading as another program, based on parsed options).\n","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 598,col 3)-(line 598,col 63)","fieldName":"debug_options","fieldJavadocComment":" Does nothing if not enabled.","fieldTokenRange":"private final SimpleLog debug_options = new SimpleLog(false);","fieldTypeResolved":"ReferenceType{plume.SimpleLog, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 598,col 57)-(line 598,col 61)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[new SimpleLog(false)]","fieldType":"SimpleLog","fieldJavadoc":"","fieldTypeResolvedDescribed":"plume.SimpleLog"}]}],"sourceFileId":41,"packageName":"plume"},{"sourceFileName":"plume.ArraysMDE","imports":[{"importId":1,"import":"import java.io.Serializable;\n"},{"importId":2,"import":"import java.util.Arrays;\n"},{"importId":3,"import":"import java.util.Collection;\n"},{"importId":4,"import":"import java.util.Comparator;\n"},{"importId":5,"import":"import java.util.HashSet;\n"},{"importId":6,"import":"import java.util.Iterator;\n"},{"importId":7,"import":"import java.util.List;\n"},{"importId":8,"import":"import java.util.Objects;\n"},{"importId":9,"import":"import java.util.Set;\n"},{"importId":10,"import":"import java.util.Vector;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.ArraysMDE.ArraysMDE()","variableDeclarationExprs":[],"constructorRange":"(line 30,col 3)-(line 32,col 3)","constructorJavadocComment":" This class is a collecton of methods; it does not represent anything. ","constructorDeclaration":"private ArraysMDE()","constructorBody":"{\n    throw new Error(\"do not instantiate\");\n}","constructorName":"ArraysMDE","constructorQualifiedName":"plume.ArraysMDE.ArraysMDE","constructorParameters":[],"literalExprs":[{"literalExprRange":"(line 31,col 21)-(line 31,col 40)","literalExprId":1,"literalExpr":"\"do not instantiate\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"constructorTokenRange":"private ArraysMDE() {\n    throw new Error(\"do not instantiate\");\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='This class is a collecton of methods; it does not represent anything.'}]}, blockTags=[]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 2721,col 3)-(line 2745,col 3)","classOrInterfaceTokenRange":"public static final class IntArrayComparatorLexical implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer,\n     * depending on whether the first argument is less than,\n     * equal to, or greater than the second argument\n     *\/\n    \/*@Pure*\/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * numbers).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays lexically (element-by-element).\nIf all shared elements are the same, but the lengths differ,\nthen the shorter array is considered less.\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nnumbers).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2757,col 3)-(line 2781,col 3)","classOrInterfaceTokenRange":"public static final class LongArrayComparatorLexical implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * numbers).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays lexically (element-by-element).\nIf all shared elements are the same, but the lengths differ,\nthen the shorter array is considered less.\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nnumbers).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2793,col 3)-(line 2819,col 3)","classOrInterfaceTokenRange":"public static final class DoubleArrayComparatorLexical\n      implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int result = Double.compare(a1[i], a2[i]);\n        if (result != 0) {\n          return (result);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * numbers).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays lexically (element-by-element).\nIf all shared elements are the same, but the lengths differ,\nthen the shorter array is considered less.\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nnumbers).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2831,col 3)-(line 2872,col 3)","classOrInterfaceTokenRange":"public static final class StringArrayComparatorLexical\n      implements Comparator<String[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    @SuppressWarnings(\n        \"override.param.invalid\") \/\/ CF bug: does not permit expanding annotations on array elements with @Poly\n    \/\/ The signature on this method is unnecessarily strict because it\n    \/\/ requires that the component types be identical.  The signature should\n    \/\/ be compare(@PolyAll(1) String[], @PolyAll(2) String[]), but the\n    \/\/ @PolyAll qualifier does not yet take an argument.\n    public int compare(\/*@PolyAll*\/ String[] a1, \/*@PolyAll*\/ String[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        int tmp = 0;\n        if ((a1[i] == null) && (a2[i] == null)) {\n          tmp = 0;\n        } else if (a1[i] == null) {\n          tmp = -1;\n        } else if (a2[i] == null) {\n          tmp = 1;\n        } else {\n          tmp = a1[i].compareTo(a2[i]);\n        }\n        if (tmp != 0) {\n          return (tmp);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * Strings).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays lexically (element-by-element).\nIf all shared elements are the same, but the lengths differ,\nthen the shorter array is considered less.\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nStrings).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2884,col 3)-(line 2930,col 3)","classOrInterfaceTokenRange":"public static final class ComparableArrayComparatorLexical<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    @SuppressWarnings(\n        \"override.param.invalid\") \/\/ CF bug: does not permit expanding annotations on array elements with @Poly\n    \/\/ The signature on this method is unnecessarily strict because it\n    \/\/ requires that the component types be identical.  The signature should\n    \/\/ be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    \/\/ @PolyAll qualifier does not yet take an argument.\n    public int compare(\/*@PolyAll*\/ T[] a1, \/*@PolyAll*\/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        \/\/ Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        \/\/ Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * objects).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays lexically (element-by-element).\nIf all shared elements are the same, but the lengths differ,\nthen the shorter array is considered less.\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nobjects).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2942,col 3)-(line 2989,col 3)","classOrInterfaceTokenRange":"public static final class ObjectArrayComparatorLexical\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    @SuppressWarnings(\n        \"override.param.invalid\") \/\/ CF bug: does not permit expanding annotations on array elements with @Poly\n    \/\/ The signature on this method is unnecessarily strict because it\n    \/\/ requires that the component types be identical.  The signature should\n    \/\/ be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    \/\/ @PolyAll qualifier does not yet take an argument.\n    public int compare(\/*@PolyAll*\/ Object[] a1, \/*@PolyAll*\/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        \/\/ Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        int tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        \/\/ I'm counting on the fact that hashCode returns a different\n        \/\/ number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays lexically (element-by-element).\n   * If all shared elements are the same, but the lengths differ,\n   * then the shorter array is considered less.\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * objects).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays lexically (element-by-element).\nIf all shared elements are the same, but the lengths differ,\nthen the shorter array is considered less.\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nobjects).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3000,col 3)-(line 3029,col 3)","classOrInterfaceTokenRange":"public static final class IntArrayComparatorLengthFirst\n      implements Comparator<int[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    public int compare(int[] a1, int[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * numbers).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays first by length (a shorter array is considered\nless), and if of equal length compare lexically (element-by-element).\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nnumbers).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3040,col 3)-(line 3069,col 3)","classOrInterfaceTokenRange":"public static final class LongArrayComparatorLengthFirst\n      implements Comparator<long[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    public int compare(long[] a1, long[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int lendiff = a1.length - a2.length;\n      if (lendiff != 0) {\n        return lendiff;\n      }\n      long tmp;\n      for (int i = 0; i < a1.length; i++) {\n        if (a1[i] != a2[i]) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return 0;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * numbers).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays first by length (a shorter array is considered\nless), and if of equal length compare lexically (element-by-element).\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nnumbers).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3080,col 3)-(line 3130,col 3)","classOrInterfaceTokenRange":"public static final class ComparableArrayComparatorLengthFirst<T extends Comparable<T>>\n      implements Comparator<T[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    @SuppressWarnings(\n        \"override.param.invalid\") \/\/ CF bug: does not permit expanding annotations on array elements with @Poly\n    \/\/ The signature on this method is unnecessarily strict because it\n    \/\/ requires that the component types be identical.  The signature should\n    \/\/ be compare(@PolyAll(1) T[], @PolyAll(2) T[]), but the\n    \/\/ @PolyAll qualifier does not yet take an argument.\n    public int compare(\/*@PolyAll*\/ T[] a1, \/*@PolyAll*\/ T[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        T elt1 = a1[i];\n        T elt2 = a2[i];\n        \/\/ Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.compareTo(elt2);\n        if (tmp != 0) {\n          return tmp;\n        }\n        \/\/ Check the assumption that the two elements are equal.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * objects).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays first by length (a shorter array is considered\nless), and if of equal length compare lexically (element-by-element).\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nobjects).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3141,col 3)-(line 3192,col 3)","classOrInterfaceTokenRange":"public static final class ObjectArrayComparatorLengthFirst\n      implements Comparator<Object[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Compare two arrays by length, then lexically (element-by-element).\n     * @param a1 first array to compare\n     * @param a2 first array to compare\n     * @return a negative integer, zero, or a positive integer, depending\n     * on whether the first argument is less than, equal to, or greater\n     * than the second argument\n     *\/\n    \/*@Pure*\/\n    @SuppressWarnings(\n        \"override.param.invalid\") \/\/ CF bug: does not permit expanding annotations on array elements with @Poly\n    \/\/ The signature on this method is unnecessarily strict because it\n    \/\/ requires that the component types be identical.  The signature should\n    \/\/ be compare(@PolyAll(1) Object[], @PolyAll(2) Object[]), but the\n    \/\/ @PolyAll qualifier does not yet take an argument.\n    public int compare(\/*@PolyAll*\/ Object[] a1, \/*@PolyAll*\/ Object[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int tmp;\n      tmp = a1.length - a2.length;\n      if (tmp != 0) {\n        return tmp;\n      }\n      for (int i = 0; i < a1.length; i++) {\n        Object elt1 = a1[i];\n        Object elt2 = a2[i];\n        \/\/ Make null compare smaller than anything else\n        if ((elt1 == null) && (elt2 == null)) {\n          continue;\n        }\n        if (elt1 == null) {\n          return -1;\n        }\n        if (elt2 == null) {\n          return 1;\n        }\n        tmp = elt1.hashCode() - elt2.hashCode();\n        if (tmp != 0) {\n          return tmp;\n        }\n        \/\/ I'm counting on the fact that hashCode returns a different\n        \/\/ number for each Object in the system.  This checks that assumption.\n        assert elt1.equals(elt2);\n      }\n      return 0;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Compare two arrays first by length (a shorter array is considered\n   * less), and if of equal length compare lexically (element-by-element).\n   * <p>\n   * Note: this comparator imposes orderings that are inconsistent with\n   * <code>equals()<\/code>.  That is, it may return 0 if the arrays are not\n   * equal according to <code>equals()<\/code> (but do contain identical\n   * objects).\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Compare two arrays first by length (a shorter array is considered\nless), and if of equal length compare lexically (element-by-element).\n<p>\nNote: this comparator imposes orderings that are inconsistent with\n<code>equals()<\/code>.  That is, it may return 0 if the arrays are not\nequal according to <code>equals()<\/code> (but do contain identical\nobjects).'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the smallest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static int min(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}","methodRange":"(line 46,col 3)-(line 55,col 3)","methodTokenRange":"public static int min(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"min","methodQualifiedSignature":"plume.ArraysMDE.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the smallest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 47,col 21)-(line 47,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 48,col 48)-(line 48,col 81)","literalExprId":2,"literalExpr":"\"Empty array passed to min(int[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 50,col 20)-(line 50,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 51,col 18)-(line 51,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the smallest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static long min(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}","methodRange":"(line 63,col 3)-(line 72,col 3)","methodTokenRange":"public static long min(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"min","methodQualifiedSignature":"plume.ArraysMDE.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the smallest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 64,col 21)-(line 64,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 65,col 48)-(line 65,col 82)","literalExprId":2,"literalExpr":"\"Empty array passed to min(long[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 67,col 21)-(line 67,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 68,col 18)-(line 68,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the smallest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static double min(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.min(result, a[i]);\n    }\n    return result;\n}","methodRange":"(line 80,col 3)-(line 89,col 3)","methodTokenRange":"public static double min(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.min(result, a[i]);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"min","methodQualifiedSignature":"plume.ArraysMDE.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the smallest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 81,col 21)-(line 81,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 82,col 48)-(line 82,col 84)","literalExprId":2,"literalExpr":"\"Empty array passed to min(double[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 84,col 23)-(line 84,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 85,col 18)-(line 85,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the smallest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static Integer min(Integer[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0];\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}","methodRange":"(line 97,col 3)-(line 110,col 3)","methodTokenRange":"public static Integer min(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Integer[])\");\n    }\n    Integer result = a[0]; \/\/ to return a value actually in the array\n    int result_int = result.intValue(); \/\/ for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"Integer[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Integer[]","parameter":"Integer[] a","parameterName":"a"}],"methodName":"min","methodQualifiedSignature":"plume.ArraysMDE.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the smallest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 98,col 21)-(line 98,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 99,col 48)-(line 99,col 85)","literalExprId":2,"literalExpr":"\"Empty array passed to min(Integer[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 101,col 24)-(line 101,col 24)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 103,col 18)-(line 103,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min(java.lang.Integer[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the smallest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static Long min(Long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0];\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() < result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}","methodRange":"(line 118,col 3)-(line 131,col 3)","methodTokenRange":"public static Long min(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Long[])\");\n    }\n    Long result = a[0]; \/\/ to return a value actually in the array\n    long result_long = result.longValue(); \/\/ for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() < result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"Long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Long[]","parameter":"Long[] a","parameterName":"a"}],"methodName":"min","methodQualifiedSignature":"plume.ArraysMDE.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the smallest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"java.lang.Long","methodType":"Long","literalExprs":[{"literalExprRange":"(line 119,col 21)-(line 119,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 120,col 48)-(line 120,col 82)","literalExprId":2,"literalExpr":"\"Empty array passed to min(Long[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 122,col 21)-(line 122,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 124,col 18)-(line 124,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min(java.lang.Long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the smallest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static Double min(Double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0];\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() < result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}","methodRange":"(line 139,col 3)-(line 152,col 3)","methodTokenRange":"public static Double min(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min(Double[])\");\n    }\n    Double result = a[0]; \/\/ to return a value actually in the array\n    int result_int = result.intValue(); \/\/ for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() < result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the smallest value in the array.\n   * @param a an array\n   * @return the smallest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"Double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Double[]","parameter":"Double[] a","parameterName":"a"}],"methodName":"min","methodQualifiedSignature":"plume.ArraysMDE.min","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the smallest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the smallest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"java.lang.Double","methodType":"Double","literalExprs":[{"literalExprRange":"(line 140,col 21)-(line 140,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 141,col 48)-(line 141,col 84)","literalExprId":2,"literalExpr":"\"Empty array passed to min(Double[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 143,col 23)-(line 143,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 145,col 18)-(line 145,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min(java.lang.Double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the largest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static int max(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}","methodRange":"(line 160,col 3)-(line 169,col 3)","methodTokenRange":"public static int max(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(int[])\");\n    }\n    int result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"max","methodQualifiedSignature":"plume.ArraysMDE.max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the largest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 161,col 21)-(line 161,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 162,col 48)-(line 162,col 81)","literalExprId":2,"literalExpr":"\"Empty array passed to max(int[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 164,col 20)-(line 164,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 165,col 18)-(line 165,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.max(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the largest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static long max(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}","methodRange":"(line 177,col 3)-(line 186,col 3)","methodTokenRange":"public static long max(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(long[])\");\n    }\n    long result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"max","methodQualifiedSignature":"plume.ArraysMDE.max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the largest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 178,col 21)-(line 178,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 48)-(line 179,col 82)","literalExprId":2,"literalExpr":"\"Empty array passed to max(long[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 181,col 21)-(line 181,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 182,col 18)-(line 182,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.max(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the largest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static double max(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result = Math.max(result, a[i]);\n    }\n    return result;\n}","methodRange":"(line 194,col 3)-(line 203,col 3)","methodTokenRange":"public static double max(double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(double[])\");\n    }\n    double result = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result = Math.max(result, a[i]);\n    }\n    return result;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"max","methodQualifiedSignature":"plume.ArraysMDE.max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the largest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 195,col 21)-(line 195,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 196,col 48)-(line 196,col 84)","literalExprId":2,"literalExpr":"\"Empty array passed to max(double[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 198,col 23)-(line 198,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 199,col 18)-(line 199,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.max(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the largest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static Integer max(Integer[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0];\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}","methodRange":"(line 211,col 3)-(line 224,col 3)","methodTokenRange":"public static Integer max(Integer[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Integer[])\");\n    }\n    Integer result = a[0]; \/\/ to return a value actually in the array\n    int result_int = result.intValue(); \/\/ for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"Integer[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Integer[]","parameter":"Integer[] a","parameterName":"a"}],"methodName":"max","methodQualifiedSignature":"plume.ArraysMDE.max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the largest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"java.lang.Integer","methodType":"Integer","literalExprs":[{"literalExprRange":"(line 212,col 21)-(line 212,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 213,col 48)-(line 213,col 85)","literalExprId":2,"literalExpr":"\"Empty array passed to max(Integer[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 215,col 24)-(line 215,col 24)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 217,col 18)-(line 217,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.max(java.lang.Integer[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the largest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static Long max(Long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0];\n    long result_long = result.longValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].longValue() > result_long) {\n            result = a[i];\n            result_long = result.longValue();\n        }\n    }\n    return result;\n}","methodRange":"(line 232,col 3)-(line 245,col 3)","methodTokenRange":"public static Long max(Long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Long[])\");\n    }\n    Long result = a[0]; \/\/ to return a value actually in the array\n    long result_long = result.longValue(); \/\/ for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].longValue() > result_long) {\n        result = a[i];\n        result_long = result.longValue();\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"Long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Long, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Long[]","parameter":"Long[] a","parameterName":"a"}],"methodName":"max","methodQualifiedSignature":"plume.ArraysMDE.max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the largest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"java.lang.Long","methodType":"Long","literalExprs":[{"literalExprRange":"(line 233,col 21)-(line 233,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 234,col 48)-(line 234,col 82)","literalExprId":2,"literalExpr":"\"Empty array passed to max(Long[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 236,col 21)-(line 236,col 21)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 238,col 18)-(line 238,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.max(java.lang.Long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the largest value in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static Double max(Double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0];\n    int result_int = result.intValue();\n    for (int i = 1; i < a.length; i++) {\n        if (a[i].intValue() > result_int) {\n            result = a[i];\n            result_int = result.intValue();\n        }\n    }\n    return result;\n}","methodRange":"(line 253,col 3)-(line 266,col 3)","methodTokenRange":"public static Double max(Double[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to max(Double[])\");\n    }\n    Double result = a[0]; \/\/ to return a value actually in the array\n    int result_int = result.intValue(); \/\/ for faster comparison\n    for (int i = 1; i < a.length; i++) {\n      if (a[i].intValue() > result_int) {\n        result = a[i];\n        result_int = result.intValue();\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the largest value in the array.\n   * @param a an array\n   * @return the largest value in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"Double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Double, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Double[]","parameter":"Double[] a","parameterName":"a"}],"methodName":"max","methodQualifiedSignature":"plume.ArraysMDE.max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the largest value in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the largest value in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"java.lang.Double","methodType":"Double","literalExprs":[{"literalExprRange":"(line 254,col 21)-(line 254,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 255,col 48)-(line 255,col 84)","literalExprId":2,"literalExpr":"\"Empty array passed to max(Double[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 257,col 23)-(line 257,col 23)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 259,col 18)-(line 259,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.max(java.lang.Double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a two-element array containing the smallest and largest values in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a two-element array containing the smallest and largest values in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static int[] min_max(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] { result_min, result_max };\n}","methodRange":"(line 274,col 3)-(line 286,col 3)","methodTokenRange":"public static int[] min_max(int[] a) {\n    if (a.length == 0) {\n      \/\/ return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(int[])\");\n    }\n    int result_min = a[0];\n    int result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new int[] {result_min, result_max};\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"min_max","methodQualifiedSignature":"plume.ArraysMDE.min_max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a two-element array containing the smallest and largest values in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a two-element array containing the smallest and largest values in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 275,col 21)-(line 275,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 277,col 48)-(line 277,col 85)","literalExprId":2,"literalExpr":"\"Empty array passed to min_max(int[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 279,col 24)-(line 279,col 24)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 280,col 24)-(line 280,col 24)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 281,col 18)-(line 281,col 18)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min_max(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a two-element array containing the smallest and largest values in the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a two-element array containing the smallest and largest values in the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static long[] min_max(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n        result_min = Math.min(result_min, a[i]);\n        result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] { result_min, result_max };\n}","methodRange":"(line 294,col 3)-(line 306,col 3)","methodTokenRange":"public static long[] min_max(long[] a) {\n    if (a.length == 0) {\n      \/\/ return null;\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to min_max(long[])\");\n    }\n    long result_min = a[0];\n    long result_max = a[0];\n    for (int i = 1; i < a.length; i++) {\n      result_min = Math.min(result_min, a[i]);\n      result_max = Math.max(result_max, a[i]);\n    }\n    return new long[] {result_min, result_max};\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return a two-element array containing the smallest and largest values in the array.\n   * @param a an array\n   * @return a two-element array containing the smallest and largest values in the array\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"min_max","methodQualifiedSignature":"plume.ArraysMDE.min_max","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a two-element array containing the smallest and largest values in the array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a two-element array containing the smallest and largest values in the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 295,col 21)-(line 295,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 297,col 48)-(line 297,col 86)","literalExprId":2,"literalExpr":"\"Empty array passed to min_max(long[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 299,col 25)-(line 299,col 25)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 300,col 25)-(line 300,col 25)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 301,col 18)-(line 301,col 18)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.min_max(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the difference between the smallest and largest array elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the difference between the smallest and largest array elements'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static int element_range(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}","methodRange":"(line 314,col 3)-(line 320,col 3)","methodTokenRange":"public static int element_range(int[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(int[])\");\n    }\n    int[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"element_range","methodQualifiedSignature":"plume.ArraysMDE.element_range","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the difference between the smallest and largest array elements.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the difference between the smallest and largest array elements'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 315,col 21)-(line 315,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 316,col 48)-(line 316,col 91)","literalExprId":2,"literalExpr":"\"Empty array passed to element_range(int[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 319,col 20)-(line 319,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 319,col 33)-(line 319,col 33)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.element_range(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the difference between the smallest and largest array elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the difference between the smallest and largest array elements'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the array has length 0","javadocBlockTagName":"ArrayIndexOutOfBoundsException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}"}],"methodDeclaration":"public static long element_range(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n}","methodRange":"(line 328,col 3)-(line 334,col 3)","methodTokenRange":"public static long element_range(long[] a) {\n    if (a.length == 0) {\n      throw new ArrayIndexOutOfBoundsException(\"Empty array passed to element_range(long[])\");\n    }\n    long[] min_max = min_max(a);\n    return min_max[1] - min_max[0];\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":"\n   * Return the difference between the smallest and largest array elements.\n   * @param a an array\n   * @return the difference between the smallest and largest array elements\n   * @throws ArrayIndexOutOfBoundsException if the array has length 0\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"element_range","methodQualifiedSignature":"plume.ArraysMDE.element_range","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the difference between the smallest and largest array elements.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the difference between the smallest and largest array elements'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the array has length 0'}]}', name=Optional[ArrayIndexOutOfBoundsException]}]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 329,col 21)-(line 329,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 330,col 48)-(line 330,col 92)","literalExprId":2,"literalExpr":"\"Empty array passed to element_range(long[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 333,col 20)-(line 333,col 20)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 333,col 33)-(line 333,col 33)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.element_range(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the sum of an array of integers","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of an array of integers'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int sum(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}","methodRange":"(line 341,col 3)-(line 347,col 3)","methodTokenRange":"public static int sum(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the sum of an array of integers.\n   * @param a an array\n   * @return the sum of an array of integers\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"sum","methodQualifiedSignature":"plume.ArraysMDE.sum","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the sum of an array of integers.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of an array of integers'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 342,col 15)-(line 342,col 15)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 343,col 18)-(line 343,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sum(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a 2d array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a 2d array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the sum of all the elements of a 2d array of integers","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of all the elements of a 2d array of integers'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int sum(int[][] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}","methodRange":"(line 354,col 3)-(line 362,col 3)","methodTokenRange":"public static int sum(int[][] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Returns the sum of all the elements of a 2d array of integers.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of integers\n   ","methodParameters":[{"parameterType":"int[][]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}","parameterTypeResolvedDescribed":"int[][]","parameter":"int[][] a","parameterName":"a"}],"methodName":"sum","methodQualifiedSignature":"plume.ArraysMDE.sum","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the sum of all the elements of a 2d array of integers.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a 2d array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of all the elements of a 2d array of integers'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 355,col 15)-(line 355,col 15)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 18)-(line 356,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 357,col 20)-(line 357,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sum(int[][])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the sum of an array of doubles","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of an array of doubles'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double sum(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n    return sum;\n}","methodRange":"(line 369,col 3)-(line 375,col 3)","methodTokenRange":"public static double sum(double[] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      sum += a[i];\n    }\n    return sum;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n   * Returns the sum of an array of doubles.\n   * @param a an array\n   * @return the sum of an array of doubles\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"sum","methodQualifiedSignature":"plume.ArraysMDE.sum","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the sum of an array of doubles.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of an array of doubles'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 370,col 18)-(line 370,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 371,col 18)-(line 371,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sum(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a 2d array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a 2d array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the sum of all the elements of a 2d array of doubles","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of all the elements of a 2d array of doubles'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double sum(double[][] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        for (int j = 0; j < a[i].length; j++) {\n            sum += a[i][j];\n        }\n    }\n    return sum;\n}","methodRange":"(line 382,col 3)-(line 390,col 3)","methodTokenRange":"public static double sum(double[][] a) {\n    double sum = 0;\n    for (int i = 0; i < a.length; i++) {\n      for (int j = 0; j < a[i].length; j++) {\n        sum += a[i][j];\n      }\n    }\n    return sum;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='double'}","methodJavadocComment":"\n   * Returns the sum of all the elements of a 2d array of doubles.\n   * @param a a 2d array\n   * @return the sum of all the elements of a 2d array of doubles\n   ","methodParameters":[{"parameterType":"double[][]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='double'}}}","parameterTypeResolvedDescribed":"double[][]","parameter":"double[][] a","parameterName":"a"}],"methodName":"sum","methodQualifiedSignature":"plume.ArraysMDE.sum","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the sum of all the elements of a 2d array of doubles.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a 2d array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the sum of all the elements of a 2d array of doubles'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double","methodType":"double","literalExprs":[{"literalExprRange":"(line 383,col 18)-(line 383,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 384,col 18)-(line 384,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 385,col 20)-(line 385,col 20)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sum(double[][])"},{"methodDeclaration":"public static int indexOf(T[] a, Object elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (elt == null) {\n        return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 407,col 3)-(line 417,col 3)","methodTokenRange":"public static <T> int indexOf(T[] a, \/*@Nullable*\/ Object elt) {\n    if (elt == null) {\n      return indexOfEq(a, elt);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"T[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","parameterTypeResolvedDescribed":"T[]","parameter":"T[] a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 408,col 16)-(line 408,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 411,col 18)-(line 411,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 13)-(line 416,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(T[], java.lang.Object)"},{"methodDeclaration":"public static int indexOf(T[] a, Object elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 433,col 3)-(line 443,col 3)","methodTokenRange":"public static <T> int indexOf(T[] a, \/*@Nullable*\/ Object elt, int minindex, int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"T[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","parameterTypeResolvedDescribed":"T[]","parameter":"T[] a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 434,col 16)-(line 434,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 442,col 13)-(line 442,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(T[], java.lang.Object, int, int)"},{"methodDeclaration":"public static int indexOf(List<? extends Object> a, Object elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return a.indexOf(elt);\n}","methodRange":"(line 456,col 3)-(line 458,col 3)","methodTokenRange":"public static int indexOf(List<? extends \/*@PolyNull*\/ Object> a, \/*@Nullable*\/ Object elt) {\n    return a.indexOf(elt);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<? extends Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends java.lang.Object>","parameter":"List<? extends Object> a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.ArraysMDE.indexOf(java.util.List<? extends java.lang.Object>, java.lang.Object)"},{"methodDeclaration":"public static int indexOf(List<? extends Object> a, Object elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (elt == null) {\n        return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt.equals(a.get(i))) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 473,col 3)-(line 487,col 3)","methodTokenRange":"public static int indexOf(\n      List<? extends \/*@PolyNull*\/ Object> a,\n      \/*@Nullable*\/ Object elt,\n      int minindex,\n      int indexlimit) {\n    if (elt == null) {\n      return indexOfEq(a, elt, minindex, indexlimit);\n    }\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt.equals(a.get(i))) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<? extends Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends java.lang.Object>","parameter":"List<? extends Object> a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 478,col 16)-(line 478,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 486,col 13)-(line 486,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(java.util.List<? extends java.lang.Object>, java.lang.Object, int, int)"},{"methodDeclaration":"public static int indexOfEq(Object[] a, Object elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 499,col 3)-(line 506,col 3)","methodTokenRange":"public static int indexOfEq(\/*@PolyAll*\/ Object[] a, \/*@Nullable*\/ Object elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 500,col 18)-(line 500,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 13)-(line 505,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.lang.Object[], java.lang.Object)"},{"methodDeclaration":"public static int indexOfEq(Object[] a, Object elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 521,col 3)-(line 529,col 3)","methodTokenRange":"public static int indexOfEq(\n      \/*@PolyNull*\/ Object[] a, \/*@Nullable*\/ Object elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 528,col 13)-(line 528,col 13)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.lang.Object[], java.lang.Object, int, int)"},{"methodDeclaration":"public static int indexOfEq(List<? extends Object> a, Object elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.size(); i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 541,col 3)-(line 548,col 3)","methodTokenRange":"public static int indexOfEq(List<? extends \/*@PolyNull*\/ Object> a, \/*@Nullable*\/ Object elt) {\n    for (int i = 0; i < a.size(); i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<? extends Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends java.lang.Object>","parameter":"List<? extends Object> a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 542,col 18)-(line 542,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 547,col 13)-(line 547,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.util.List<? extends java.lang.Object>, java.lang.Object)"},{"methodDeclaration":"public static int indexOfEq(List<? extends Object> a, Object elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a.get(i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 563,col 3)-(line 574,col 3)","methodTokenRange":"public static int indexOfEq(\n      List<? extends \/*@PolyNull*\/ Object> a,\n      \/*@Nullable*\/ Object elt,\n      int minindex,\n      int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a.get(i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<? extends Object>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=EXTENDS, boundedType=ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}","parameterTypeResolvedDescribed":"java.util.List<? extends java.lang.Object>","parameter":"List<? extends Object> a","parameterName":"a"},{"parameterType":"Object","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 573,col 13)-(line 573,col 13)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.util.List<? extends java.lang.Object>, java.lang.Object, int, int)"},{"methodDeclaration":"public static int indexOf(int[] a, int elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 585,col 3)-(line 592,col 3)","methodTokenRange":"public static int indexOf(int[] a, int elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 586,col 18)-(line 586,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 591,col 13)-(line 591,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(int[], int)"},{"methodDeclaration":"public static int indexOf(long[] a, long elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 603,col 3)-(line 610,col 3)","methodTokenRange":"public static int indexOf(long[] a, long elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 604,col 18)-(line 604,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 609,col 13)-(line 609,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(long[], long)"},{"methodDeclaration":"public static int indexOf(int[] a, int elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 624,col 3)-(line 631,col 3)","methodTokenRange":"public static int indexOf(int[] a, int elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 630,col 13)-(line 630,col 13)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(int[], int, int, int)"},{"methodDeclaration":"public static int indexOf(long[] a, long elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 645,col 3)-(line 652,col 3)","methodTokenRange":"public static int indexOf(long[] a, long elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"long","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 651,col 13)-(line 651,col 13)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(long[], long, int, int)"},{"methodDeclaration":"public static int indexOf(boolean[] a, boolean elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 663,col 3)-(line 670,col 3)","methodTokenRange":"public static int indexOf(boolean[] a, boolean elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 664,col 18)-(line 664,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 669,col 13)-(line 669,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(boolean[], boolean)"},{"methodDeclaration":"public static int indexOf(double[] a, double elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 681,col 3)-(line 688,col 3)","methodTokenRange":"public static int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 682,col 18)-(line 682,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 687,col 13)-(line 687,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(double[], double)"},{"methodDeclaration":"public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = minindex; i < indexlimit; i++) {\n        if (elt == a[i]) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 702,col 3)-(line 709,col 3)","methodTokenRange":"public static int indexOf(boolean[] a, boolean elt, int minindex, int indexlimit) {\n    for (int i = minindex; i < indexlimit; i++) {\n      if (elt == a[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean elt","parameterName":"elt"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int minindex","parameterName":"minindex"},{"parameterType":"int","parameterId":4,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int indexlimit","parameterName":"indexlimit"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 708,col 13)-(line 708,col 13)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(boolean[], boolean, int, int)"},{"methodDeclaration":"public static int indexOf(Object[] a, Object[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 731,col 3)-(line 739,col 3)","methodTokenRange":"public static int indexOf(\/*@PolyAll*\/ Object[] a, Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 732,col 47)-(line 732,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 733,col 18)-(line 733,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 738,col 13)-(line 738,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(java.lang.Object[], java.lang.Object[])"},{"methodDeclaration":"public static int indexOfEq(Object[] a, Object[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 756,col 3)-(line 764,col 3)","methodTokenRange":"public static int indexOfEq(\/*@PolyAll*\/ Object[] a, \/*@PolyAll*\/ Object[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 757,col 47)-(line 757,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 758,col 18)-(line 758,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 763,col 13)-(line 763,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.lang.Object[], java.lang.Object[])"},{"methodDeclaration":"public static int indexOf(List<?> a, Object[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 777,col 3)-(line 785,col 3)","methodTokenRange":"public static int indexOf(List<?> a, \/*@PolyAll*\/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 778,col 47)-(line 778,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 779,col 18)-(line 779,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 784,col 13)-(line 784,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(java.util.List<?>, java.lang.Object[])"},{"methodDeclaration":"public static int indexOfEq(List<?> a, Object[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 798,col 3)-(line 806,col 3)","methodTokenRange":"public static int indexOfEq(List<?> a, \/*@PolyAll*\/ Object[] sub) {\n    int a_index_max = a.size() - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 799,col 47)-(line 799,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 800,col 18)-(line 800,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 805,col 13)-(line 805,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.util.List<?>, java.lang.Object[])"},{"methodDeclaration":"public static int indexOf(Object[] a, List<?> sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 819,col 3)-(line 827,col 3)","methodTokenRange":"public static int indexOf(\/*@PolyAll*\/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 820,col 47)-(line 820,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 821,col 18)-(line 821,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 826,col 13)-(line 826,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(java.lang.Object[], java.util.List<?>)"},{"methodDeclaration":"public static int indexOfEq(Object[] a, List<?> sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 840,col 3)-(line 848,col 3)","methodTokenRange":"public static int indexOfEq(\/*@PolyAll*\/ Object[] a, List<?> sub) {\n    int a_index_max = a.length - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 841,col 47)-(line 841,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 842,col 18)-(line 842,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 847,col 13)-(line 847,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.lang.Object[], java.util.List<?>)"},{"methodDeclaration":"public static int indexOf(List<?> a, List<?> sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 861,col 3)-(line 869,col 3)","methodTokenRange":"public static int indexOf(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 862,col 47)-(line 862,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 863,col 18)-(line 863,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 868,col 13)-(line 868,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(java.util.List<?>, java.util.List<?>)"},{"methodDeclaration":"public static int indexOfEq(List<?> a, List<?> sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarrayEq(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 882,col 3)-(line 890,col 3)","methodTokenRange":"public static int indexOfEq(List<?> a, List<?> sub) {\n    int a_index_max = a.size() - sub.size() + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarrayEq(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"}],"methodName":"indexOfEq","methodQualifiedSignature":"plume.ArraysMDE.indexOfEq","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 883,col 47)-(line 883,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 884,col 18)-(line 884,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 889,col 13)-(line 889,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOfEq(java.util.List<?>, java.util.List<?>)"},{"methodDeclaration":"public static int indexOf(int[] a, int[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 902,col 3)-(line 910,col 3)","methodTokenRange":"public static int indexOf(int[] a, int[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 903,col 47)-(line 903,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 904,col 18)-(line 904,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 909,col 13)-(line 909,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(int[], int[])"},{"methodDeclaration":"public static int indexOf(double[] a, double[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 922,col 3)-(line 930,col 3)","methodTokenRange":"public static int indexOf(double[] a, double[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 923,col 47)-(line 923,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 924,col 18)-(line 924,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 929,col 13)-(line 929,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(double[], double[])"},{"methodDeclaration":"public static int indexOf(long[] a, long[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 942,col 3)-(line 950,col 3)","methodTokenRange":"public static int indexOf(long[] a, long[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"long[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 943,col 47)-(line 943,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 944,col 18)-(line 944,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 949,col 13)-(line 949,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(long[], long[])"},{"methodDeclaration":"public static int indexOf(boolean[] a, boolean[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n        if (isSubarray(a, sub, i)) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 962,col 3)-(line 970,col 3)","methodTokenRange":"public static int indexOf(boolean[] a, boolean[] sub) {\n    int a_index_max = a.length - sub.length + 1;\n    for (int i = 0; i <= a_index_max; i++) {\n      if (isSubarray(a, sub, i)) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"},{"parameterType":"boolean[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.ArraysMDE.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 963,col 47)-(line 963,col 47)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 964,col 18)-(line 964,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 969,col 13)-(line 969,col 13)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.indexOf(boolean[], boolean[])"},{"methodDeclaration":"public static Object[] subarray(Object[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object[] result = new Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 999,col 3)-(line 1004,col 3)","methodTokenRange":"public static \/*@PolyAll*\/ Object[] subarray(\n      \/*@PolyAll*\/ Object[] a, int startindex, int length) {\n    \/*@PolyAll*\/ Object[] result = new \/*@PolyAll*\/ Object[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.Object[]","methodType":"Object[]","literalExprs":[{"literalExprRange":"(line 1002,col 45)-(line 1002,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(java.lang.Object[], int, int)"},{"methodDeclaration":"public static List<T> subarray(List<T> a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return a.subList(startindex, startindex + length);\n}","methodRange":"(line 1017,col 3)-(line 1019,col 3)","methodTokenRange":"public static <T> List<T> subarray(List<T> a, int startindex, int length) {\n    return a.subList(startindex, startindex + length);\n  }","methodReturnTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"java.util.List<T>","methodType":"List<T>","literalExprs":[],"methodQualifiedName":"plume.ArraysMDE.subarray(java.util.List<T>, int, int)"},{"methodDeclaration":"public static String[] subarray(String[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String[] result = new String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1031,col 3)-(line 1036,col 3)","methodTokenRange":"public static \/*@PolyAll*\/ String[] subarray(\n      \/*@PolyAll*\/ String[] a, int startindex, int length) {\n    \/*@PolyAll*\/ String[] result = new \/*@PolyAll*\/ String[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 1034,col 45)-(line 1034,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(java.lang.String[], int, int)"},{"methodDeclaration":"public static byte[] subarray(byte[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1048,col 3)-(line 1052,col 3)","methodTokenRange":"public static byte[] subarray(byte[] a, int startindex, int length) {\n    byte[] result = new byte[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"byte[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","parameterTypeResolvedDescribed":"byte[]","parameter":"byte[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"byte[]","methodType":"byte[]","literalExprs":[{"literalExprRange":"(line 1050,col 45)-(line 1050,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(byte[], int, int)"},{"methodDeclaration":"public static boolean[] subarray(boolean[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1064,col 3)-(line 1068,col 3)","methodTokenRange":"public static boolean[] subarray(boolean[] a, int startindex, int length) {\n    boolean[] result = new boolean[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean[]","methodType":"boolean[]","literalExprs":[{"literalExprRange":"(line 1066,col 45)-(line 1066,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(boolean[], int, int)"},{"methodDeclaration":"public static char[] subarray(char[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1080,col 3)-(line 1084,col 3)","methodTokenRange":"public static char[] subarray(char[] a, int startindex, int length) {\n    char[] result = new char[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"char[]","methodType":"char[]","literalExprs":[{"literalExprRange":"(line 1082,col 45)-(line 1082,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(char[], int, int)"},{"methodDeclaration":"public static double[] subarray(double[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1096,col 3)-(line 1100,col 3)","methodTokenRange":"public static double[] subarray(double[] a, int startindex, int length) {\n    double[] result = new double[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"double[]","methodType":"double[]","literalExprs":[{"literalExprRange":"(line 1098,col 45)-(line 1098,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(double[], int, int)"},{"methodDeclaration":"public static float[] subarray(float[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1112,col 3)-(line 1116,col 3)","methodTokenRange":"public static float[] subarray(float[] a, int startindex, int length) {\n    float[] result = new float[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"float[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","parameterTypeResolvedDescribed":"float[]","parameter":"float[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"float[]","methodType":"float[]","literalExprs":[{"literalExprRange":"(line 1114,col 45)-(line 1114,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(float[], int, int)"},{"methodDeclaration":"public static int[] subarray(int[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1128,col 3)-(line 1132,col 3)","methodTokenRange":"public static int[] subarray(int[] a, int startindex, int length) {\n    int[] result = new int[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1130,col 45)-(line 1130,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(int[], int, int)"},{"methodDeclaration":"public static long[] subarray(long[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1144,col 3)-(line 1148,col 3)","methodTokenRange":"public static long[] subarray(long[] a, int startindex, int length) {\n    long[] result = new long[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1146,col 45)-(line 1146,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(long[], int, int)"},{"methodDeclaration":"public static short[] subarray(short[] a, int startindex, int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n}","methodRange":"(line 1160,col 3)-(line 1164,col 3)","methodTokenRange":"public static short[] subarray(short[] a, int startindex, int length) {\n    short[] result = new short[length];\n    System.arraycopy(a, startindex, result, 0, length);\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='short'}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"short[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='short'}}","parameterTypeResolvedDescribed":"short[]","parameter":"short[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int startindex","parameterName":"startindex"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"subarray","methodQualifiedSignature":"plume.ArraysMDE.subarray","methodJavadoc":"","methodReturnTypeDescribed":"short[]","methodType":"short[]","literalExprs":[{"literalExprRange":"(line 1162,col 45)-(line 1162,col 45)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.subarray(short[], int, int)"},{"methodDeclaration":"public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1180,col 3)-(line 1193,col 3)","methodTokenRange":"public static boolean isSubarray(\n      \/*@PolyAll*\/ Object[] a, \/*@PolyNull*\/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1185,col 14)-(line 1185,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1187,col 18)-(line 1187,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1189,col 16)-(line 1189,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1192,col 12)-(line 1192,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(java.lang.Object[], java.lang.Object[], int)"},{"methodDeclaration":"public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1205,col 3)-(line 1218,col 3)","methodTokenRange":"public static boolean isSubarrayEq(\n      \/*@PolyAll*\/ Object[] a, \/*@PolyAll*\/ Object[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarrayEq","methodQualifiedSignature":"plume.ArraysMDE.isSubarrayEq","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1210,col 14)-(line 1210,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1212,col 18)-(line 1212,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1214,col 16)-(line 1214,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1217,col 12)-(line 1217,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarrayEq(java.lang.Object[], java.lang.Object[], int)"},{"methodDeclaration":"public static boolean isSubarray(Object[] a, List<?> sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1231,col 3)-(line 1243,col 3)","methodTokenRange":"public static boolean isSubarray(\/*@PolyAll*\/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a[a_offset + i])) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1235,col 14)-(line 1235,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1237,col 18)-(line 1237,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 16)-(line 1239,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1242,col 12)-(line 1242,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(java.lang.Object[], java.util.List<?>, int)"},{"methodDeclaration":"public static boolean isSubarrayEq(Object[] a, List<?> sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1255,col 3)-(line 1267,col 3)","methodTokenRange":"public static boolean isSubarrayEq(\/*@PolyAll*\/ Object[] a, List<?> sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarrayEq","methodQualifiedSignature":"plume.ArraysMDE.isSubarrayEq","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1259,col 14)-(line 1259,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1261,col 18)-(line 1261,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1263,col 16)-(line 1263,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1266,col 12)-(line 1266,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarrayEq(java.lang.Object[], java.util.List<?>, int)"},{"methodDeclaration":"public static boolean isSubarray(List<?> a, Object[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1280,col 3)-(line 1292,col 3)","methodTokenRange":"public static boolean isSubarray(List<?> a, \/*@PolyAll*\/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub[i], a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1284,col 14)-(line 1284,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1286,col 18)-(line 1286,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1288,col 16)-(line 1288,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1291,col 12)-(line 1291,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(java.util.List<?>, java.lang.Object[], int)"},{"methodDeclaration":"public static boolean isSubarrayEq(List<?> a, Object[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1304,col 3)-(line 1316,col 3)","methodTokenRange":"public static boolean isSubarrayEq(List<?> a, \/*@PolyAll*\/ Object[] sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"Object[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarrayEq","methodQualifiedSignature":"plume.ArraysMDE.isSubarrayEq","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1308,col 14)-(line 1308,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1310,col 18)-(line 1310,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1312,col 16)-(line 1312,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1315,col 12)-(line 1315,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarrayEq(java.util.List<?>, java.lang.Object[], int)"},{"methodDeclaration":"public static boolean isSubarray(List<?> a, List<?> sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1329,col 3)-(line 1341,col 3)","methodTokenRange":"public static boolean isSubarray(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (!Objects.equals(sub.get(i), a.get(a_offset + i))) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1333,col 14)-(line 1333,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1335,col 18)-(line 1335,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1337,col 16)-(line 1337,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1340,col 12)-(line 1340,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(java.util.List<?>, java.util.List<?>, int)"},{"methodDeclaration":"public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub.get(i) != a.get(a_offset + i)) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1353,col 3)-(line 1365,col 3)","methodTokenRange":"public static boolean isSubarrayEq(List<?> a, List<?> sub, int a_offset) {\n    int a_len = a.size() - a_offset;\n    int sub_len = sub.size();\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub.get(i) != a.get(a_offset + i)) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"},{"parameterType":"List<?>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarrayEq","methodQualifiedSignature":"plume.ArraysMDE.isSubarrayEq","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1357,col 14)-(line 1357,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1359,col 18)-(line 1359,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1361,col 16)-(line 1361,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1364,col 12)-(line 1364,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarrayEq(java.util.List<?>, java.util.List<?>, int)"},{"methodDeclaration":"public static boolean isSubarray(int[] a, int[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1376,col 3)-(line 1388,col 3)","methodTokenRange":"public static boolean isSubarray(int[] a, int[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1380,col 14)-(line 1380,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1382,col 18)-(line 1382,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1384,col 16)-(line 1384,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1387,col 12)-(line 1387,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(int[], int[], int)"},{"methodDeclaration":"public static boolean isSubarray(long[] a, long[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1399,col 3)-(line 1411,col 3)","methodTokenRange":"public static boolean isSubarray(long[] a, long[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"long[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1403,col 14)-(line 1403,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1405,col 18)-(line 1405,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 16)-(line 1407,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1410,col 12)-(line 1410,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(long[], long[], int)"},{"methodDeclaration":"public static boolean isSubarray(double[] a, double[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1422,col 3)-(line 1434,col 3)","methodTokenRange":"public static boolean isSubarray(double[] a, double[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1426,col 14)-(line 1426,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1428,col 18)-(line 1428,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1430,col 16)-(line 1430,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1433,col 12)-(line 1433,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(double[], double[], int)"},{"methodDeclaration":"public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n        return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n        if (sub[i] != a[a_offset + i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 1445,col 3)-(line 1457,col 3)","methodTokenRange":"public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset) {\n    int a_len = a.length - a_offset;\n    int sub_len = sub.length;\n    if (a_len < sub_len) {\n      return false;\n    }\n    for (int i = 0; i < sub_len; i++) {\n      if (sub[i] != a[a_offset + i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"},{"parameterType":"boolean[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] sub","parameterName":"sub"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int a_offset","parameterName":"a_offset"}],"methodName":"isSubarray","methodQualifiedSignature":"plume.ArraysMDE.isSubarray","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 1449,col 14)-(line 1449,col 18)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1451,col 18)-(line 1451,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1453,col 16)-(line 1453,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1456,col 12)-(line 1456,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubarray(boolean[], boolean[], int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the base type of the result","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base type of the result'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the list to convert to an array","javadocBlockTagName":"lst","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list to convert to an array'}]}', name=Optional[lst]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"the result of lst.toArray, casted to a more precise type than Object[]","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the result of lst.toArray, casted to a more precise type than Object[]'}]}', name=Optional.empty}"}],"methodDeclaration":"private static T[] toTArray(List<T> lst)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n}","methodRange":"(line 1472,col 3)-(line 1476,col 3)","methodTokenRange":"private static <T> T[] toTArray(List<T> lst) {\n    @SuppressWarnings(\"unchecked\")\n    T[] asArray = (T[]) lst.toArray();\n    return asArray;\n  }","methodReturnTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","methodJavadocComment":"\n   * Call this method in order to suppress compiler warnings.\n   * @param <T> the base type of the result\n   * @param lst the list to convert to an array\n   * @return the result of lst.toArray, casted to a more precise type than Object[]\n   ","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> lst","parameterName":"lst"}],"methodName":"toTArray","methodQualifiedSignature":"plume.ArraysMDE.toTArray","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Call this method in order to suppress compiler warnings.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the base type of the result'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the list to convert to an array'}]}', name=Optional[lst]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the result of lst.toArray, casted to a more precise type than Object[]'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T[]","methodType":"T[]","literalExprs":[{"literalExprRange":"(line 1473,col 23)-(line 1473,col 33)","literalExprId":1,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toTArray(java.util.List<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of the sequence elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static T[] concat(T[] a, T[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1488,col 3)-(line 1509,col 3)","methodTokenRange":"public static <T> T[] concat(T \/*@Nullable*\/ [] a, T \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new \/*@MonotonicNonNull*\/ Object[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"T[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","parameterTypeResolvedDescribed":"T[]","parameter":"T[] a","parameterName":"a"},{"parameterType":"T[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","parameterTypeResolvedDescribed":"T[]","parameter":"T[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T[]","methodType":"T[]","literalExprs":[{"literalExprRange":"(line 1489,col 14)-(line 1489,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1490,col 16)-(line 1490,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1493,col 27)-(line 1493,col 37)","literalExprId":3,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1494,col 39)-(line 1494,col 39)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1498,col 16)-(line 1498,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1501,col 27)-(line 1501,col 37)","literalExprId":6,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1504,col 29)-(line 1504,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1504,col 40)-(line 1504,col 40)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1505,col 29)-(line 1505,col 29)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(T[], T[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of the sequence elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static T[] concat(T[] a, List<T> b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[a.length + b.size()];\n            System.arraycopy(a, 0, result, 0, a.length);\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.length] = b.get(i);\n            }\n            return result;\n        }\n    }\n}","methodRange":"(line 1521,col 3)-(line 1545,col 3)","methodTokenRange":"public static <T> T[] concat(T \/*@Nullable*\/ [] a, \/*@Nullable*\/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new \/*@MonotonicNonNull*\/ Object[a.length + b.size()];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        \/\/ System.arraycopy(b, 0, result, a.length, b.size());\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.length] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"T[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","parameterTypeResolvedDescribed":"T[]","parameter":"T[] a","parameterName":"a"},{"parameterType":"List<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T[]","methodType":"T[]","literalExprs":[{"literalExprRange":"(line 1522,col 14)-(line 1522,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1523,col 16)-(line 1523,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1526,col 27)-(line 1526,col 37)","literalExprId":3,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1527,col 39)-(line 1527,col 39)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1531,col 16)-(line 1531,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1534,col 27)-(line 1534,col 37)","literalExprId":6,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1537,col 29)-(line 1537,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1537,col 40)-(line 1537,col 40)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1539,col 22)-(line 1539,col 22)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(T[], java.util.List<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of the sequence elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static T[] concat(List<T> a, T[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b != null) {\n            return b;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[a.size() + b.length];\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            System.arraycopy(b, 0, result, a.size(), b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1557,col 3)-(line 1581,col 3)","methodTokenRange":"public static <T> T[] concat(\/*@Nullable*\/ List<T> a, T \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b != null) {\n        return b;\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new \/*@MonotonicNonNull*\/ Object[a.size() + b.length];\n\n        \/\/ System.arraycopy(a, 0, result, 0, a.size());\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        System.arraycopy(b, 0, result, a.size(), b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> a","parameterName":"a"},{"parameterType":"T[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","parameterTypeResolvedDescribed":"T[]","parameter":"T[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T[]","methodType":"T[]","literalExprs":[{"literalExprRange":"(line 1558,col 14)-(line 1558,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1559,col 16)-(line 1559,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1562,col 27)-(line 1562,col 37)","literalExprId":3,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1563,col 39)-(line 1563,col 39)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1567,col 16)-(line 1567,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1570,col 27)-(line 1570,col 37)","literalExprId":6,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1574,col 22)-(line 1574,col 22)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1577,col 29)-(line 1577,col 29)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(java.util.List<T>, T[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of the sequence elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static T[] concat(List<T> a, List<T> b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b != null) {\n            return toTArray(b);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[0];\n            return result;\n        }\n    } else {\n        if (b == null) {\n            return toTArray(a);\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] result = (T[]) new Object[a.size() + b.size()];\n            for (int i = 0; i < a.size(); i++) {\n                result[i] = a.get(i);\n            }\n            for (int i = 0; i < b.size(); i++) {\n                result[i + a.size()] = b.get(i);\n            }\n            return result;\n        }\n    }\n}","methodRange":"(line 1593,col 3)-(line 1620,col 3)","methodTokenRange":"public static <T> T[] concat(\/*@Nullable*\/ List<T> a, \/*@Nullable*\/ List<T> b) {\n    if (a == null) {\n      if (b != null) {\n        return toTArray(b);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new Object[0];\n        return result;\n      }\n    } else {\n      if (b == null) {\n        return toTArray(a);\n      } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] result = (T[]) new \/*@MonotonicNonNull*\/ Object[a.size() + b.size()];\n\n        \/\/ System.arraycopy(a, 0, result, 0, a.length);\n        for (int i = 0; i < a.size(); i++) {\n          result[i] = a.get(i);\n        }\n        \/\/ System.arraycopy(b, 0, result, a.length, b.length);\n        for (int i = 0; i < b.size(); i++) {\n          result[i + a.size()] = b.get(i);\n        }\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param <T> the type of the sequence elements\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> a","parameterName":"a"},{"parameterType":"List<T>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the sequence elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"T[]","methodType":"T[]","literalExprs":[{"literalExprRange":"(line 1594,col 14)-(line 1594,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1595,col 16)-(line 1595,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1598,col 27)-(line 1598,col 37)","literalExprId":3,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1599,col 39)-(line 1599,col 39)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1603,col 16)-(line 1603,col 19)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1606,col 27)-(line 1606,col 37)","literalExprId":6,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1610,col 22)-(line 1610,col 22)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1614,col 22)-(line 1614,col 22)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(java.util.List<T>, java.util.List<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first array to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first array to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second array to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second array to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String[] concat(String[] a, String[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new String[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            String[] result = new String[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1632,col 3)-(line 1651,col 3)","methodTokenRange":"public static \/*@PolyAll*\/ String[] concat(\n      \/*@PolyAll*\/ String \/*@Nullable*\/ [] a, \/*@PolyAll*\/ String \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new String[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        \/*@PolyAll*\/ String[] result = new String[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first array to concatenate\n   * @param b the second array to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] a","parameterName":"a"},{"parameterType":"String[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first array to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second array to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String[]","methodType":"String[]","literalExprs":[{"literalExprRange":"(line 1634,col 14)-(line 1634,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1635,col 16)-(line 1635,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1636,col 27)-(line 1636,col 27)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1641,col 16)-(line 1641,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1646,col 29)-(line 1646,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1646,col 40)-(line 1646,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1647,col 29)-(line 1647,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(java.lang.String[], java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static byte[] concat(byte[] a, byte[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new byte[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            byte[] result = new byte[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1662,col 3)-(line 1680,col 3)","methodTokenRange":"public static byte[] concat(byte \/*@Nullable*\/ [] a, byte \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new byte[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        byte[] result = new byte[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"byte[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","parameterTypeResolvedDescribed":"byte[]","parameter":"byte[] a","parameterName":"a"},{"parameterType":"byte[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","parameterTypeResolvedDescribed":"byte[]","parameter":"byte[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"byte[]","methodType":"byte[]","literalExprs":[{"literalExprRange":"(line 1663,col 14)-(line 1663,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1664,col 16)-(line 1664,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1665,col 25)-(line 1665,col 25)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1670,col 16)-(line 1670,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1675,col 29)-(line 1675,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1675,col 40)-(line 1675,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1676,col 29)-(line 1676,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(byte[], byte[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean[] concat(boolean[] a, boolean[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new boolean[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            boolean[] result = new boolean[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1691,col 3)-(line 1709,col 3)","methodTokenRange":"public static boolean[] concat(boolean \/*@Nullable*\/ [] a, boolean \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new boolean[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        boolean[] result = new boolean[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"},{"parameterType":"boolean[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean[]","methodType":"boolean[]","literalExprs":[{"literalExprRange":"(line 1692,col 14)-(line 1692,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1693,col 16)-(line 1693,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1694,col 28)-(line 1694,col 28)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1699,col 16)-(line 1699,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1704,col 29)-(line 1704,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1704,col 40)-(line 1704,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1705,col 29)-(line 1705,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(boolean[], boolean[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static char[] concat(char[] a, char[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new char[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            char[] result = new char[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1720,col 3)-(line 1738,col 3)","methodTokenRange":"public static char[] concat(char \/*@Nullable*\/ [] a, char \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new char[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        char[] result = new char[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] a","parameterName":"a"},{"parameterType":"char[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"char[]","methodType":"char[]","literalExprs":[{"literalExprRange":"(line 1721,col 14)-(line 1721,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1722,col 16)-(line 1722,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1723,col 25)-(line 1723,col 25)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1728,col 16)-(line 1728,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1733,col 29)-(line 1733,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1733,col 40)-(line 1733,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1734,col 29)-(line 1734,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(char[], char[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static double[] concat(double[] a, double[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new double[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            double[] result = new double[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1749,col 3)-(line 1767,col 3)","methodTokenRange":"public static double[] concat(double \/*@Nullable*\/ [] a, double \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new double[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        double[] result = new double[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"double[]","methodType":"double[]","literalExprs":[{"literalExprRange":"(line 1750,col 14)-(line 1750,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1751,col 16)-(line 1751,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1752,col 27)-(line 1752,col 27)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1757,col 16)-(line 1757,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1762,col 29)-(line 1762,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1762,col 40)-(line 1762,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1763,col 29)-(line 1763,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(double[], double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static float[] concat(float[] a, float[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new float[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            float[] result = new float[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1778,col 3)-(line 1796,col 3)","methodTokenRange":"public static float[] concat(float \/*@Nullable*\/ [] a, float \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new float[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        float[] result = new float[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"float[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","parameterTypeResolvedDescribed":"float[]","parameter":"float[] a","parameterName":"a"},{"parameterType":"float[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","parameterTypeResolvedDescribed":"float[]","parameter":"float[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"float[]","methodType":"float[]","literalExprs":[{"literalExprRange":"(line 1779,col 14)-(line 1779,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1780,col 16)-(line 1780,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1781,col 26)-(line 1781,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1786,col 16)-(line 1786,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1791,col 29)-(line 1791,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1791,col 40)-(line 1791,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1792,col 29)-(line 1792,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(float[], float[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] concat(int[] a, int[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new int[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            int[] result = new int[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1807,col 3)-(line 1825,col 3)","methodTokenRange":"public static int[] concat(int \/*@Nullable*\/ [] a, int \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new int[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        int[] result = new int[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 1808,col 14)-(line 1808,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1809,col 16)-(line 1809,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1810,col 24)-(line 1810,col 24)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1815,col 16)-(line 1815,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1820,col 29)-(line 1820,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1820,col 40)-(line 1820,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1821,col 29)-(line 1821,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(int[], int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static long[] concat(long[] a, long[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new long[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            long[] result = new long[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1836,col 3)-(line 1854,col 3)","methodTokenRange":"public static long[] concat(long \/*@Nullable*\/ [] a, long \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new long[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        long[] result = new long[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"},{"parameterType":"long[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"long[]","methodType":"long[]","literalExprs":[{"literalExprRange":"(line 1837,col 14)-(line 1837,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1838,col 16)-(line 1838,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1839,col 25)-(line 1839,col 25)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1844,col 16)-(line 1844,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1849,col 29)-(line 1849,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1849,col 40)-(line 1849,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1850,col 29)-(line 1850,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(long[], long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first sequence to concatenate","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the second sequence to concatenate","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"an array that concatenates the arguments","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}"}],"methodDeclaration":"public static short[] concat(short[] a, short[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        if (b == null) {\n            return new short[0];\n        } else {\n            return b;\n        }\n    } else {\n        if (b == null) {\n            return a;\n        } else {\n            short[] result = new short[a.length + b.length];\n            System.arraycopy(a, 0, result, 0, a.length);\n            System.arraycopy(b, 0, result, a.length, b.length);\n            return result;\n        }\n    }\n}","methodRange":"(line 1865,col 3)-(line 1883,col 3)","methodTokenRange":"public static short[] concat(short \/*@Nullable*\/ [] a, short \/*@Nullable*\/ [] b) {\n    if (a == null) {\n      if (b == null) {\n        return new short[0];\n      } else {\n        return b;\n      }\n    } else {\n      if (b == null) {\n        return a;\n      } else {\n        short[] result = new short[a.length + b.length];\n\n        System.arraycopy(a, 0, result, 0, a.length);\n        System.arraycopy(b, 0, result, a.length, b.length);\n        return result;\n      }\n    }\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='short'}}","methodJavadocComment":"\n   * Return an array that contains all the elements of both argument\n   * arrays, in order.\n   * Returns a new array unless one argument is null, in which case\n   * it returns the other array.\n   * @param a the first sequence to concatenate\n   * @param b the second sequence to concatenate\n   * @return an array that concatenates the arguments\n   ","methodParameters":[{"parameterType":"short[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='short'}}","parameterTypeResolvedDescribed":"short[]","parameter":"short[] a","parameterName":"a"},{"parameterType":"short[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='short'}}","parameterTypeResolvedDescribed":"short[]","parameter":"short[] b","parameterName":"b"}],"methodName":"concat","methodQualifiedSignature":"plume.ArraysMDE.concat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array that contains all the elements of both argument\narrays, in order.\nReturns a new array unless one argument is null, in which case\nit returns the other array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first sequence to concatenate'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the second sequence to concatenate'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='an array that concatenates the arguments'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"short[]","methodType":"short[]","literalExprs":[{"literalExprRange":"(line 1866,col 14)-(line 1866,col 17)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1867,col 16)-(line 1867,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1868,col 26)-(line 1868,col 26)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1873,col 16)-(line 1873,col 19)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1878,col 29)-(line 1878,col 29)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1878,col 40)-(line 1878,col 40)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1879,col 29)-(line 1879,col 29)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.concat(short[], short[])"},{"methodDeclaration":"public static String toString(Object[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return toString(a, false);\n}","methodRange":"(line 1901,col 3)-(line 1903,col 3)","methodTokenRange":"public static String toString(\/*@PolyAll*\/ Object \/*@Nullable*\/ [] a) {\n    return toString(a, false);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1902,col 24)-(line 1902,col 28)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(java.lang.Object[])"},{"methodDeclaration":"public static String toStringQuoted(Object[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return toString(a, true);\n}","methodRange":"(line 1914,col 3)-(line 1916,col 3)","methodTokenRange":"public static String toStringQuoted(\/*@PolyAll*\/ Object \/*@Nullable*\/ [] a) {\n    return toString(a, true);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"}],"methodName":"toStringQuoted","methodQualifiedSignature":"plume.ArraysMDE.toStringQuoted","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1915,col 24)-(line 1915,col 27)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toStringQuoted(java.lang.Object[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to quote the array elements","javadocBlockTagName":"quoted","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to quote the array elements'}]}', name=Optional[quoted]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(Object[] a, boolean quoted)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            if (quoted && a[i] instanceof String) {\n                String elt = (String) a[i];\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava(elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(a[i]);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 1927,col 3)-(line 1951,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(\/*@PolyAll*\/ Object \/*@Nullable*\/ [] a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        if (quoted && a[i] instanceof String) {\n          String elt = (String) a[i];\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava(elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(a[i]);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * Furthermore, if quoted is true, then each element is quoted like a Java String.\n   * @param a an array\n   * @param quoted whether to quote the array elements\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean quoted","parameterName":"quoted"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the array.\nThe representation is patterned after that of java.util.Vector.\nFurthermore, if quoted is true, then each element is quoted like a Java String.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to quote the array elements'}]}', name=Optional[quoted]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1927,col 21)-(line 1927,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1930,col 14)-(line 1930,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1931,col 14)-(line 1931,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1934,col 15)-(line 1934,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1935,col 20)-(line 1935,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1936,col 19)-(line 1936,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1937,col 20)-(line 1937,col 20)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1938,col 19)-(line 1938,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1941,col 21)-(line 1941,col 24)","literalExprId":9,"literalExpr":"'\\\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1943,col 21)-(line 1943,col 24)","literalExprId":10,"literalExpr":"'\\\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 1949,col 15)-(line 1949,col 17)","literalExprId":11,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(java.lang.Object[], boolean)"},{"methodDeclaration":"public static String toString(Collection<?> a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return toString(a, false);\n}","methodRange":"(line 1961,col 3)-(line 1963,col 3)","methodTokenRange":"public static String toString(\/*@Nullable*\/ Collection<?> a) {\n    return toString(a, false);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"Collection<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.Collection<?>","parameter":"Collection<?> a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1962,col 24)-(line 1962,col 28)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(java.util.Collection<?>)"},{"methodDeclaration":"public static String toStringQuoted(Collection<?> a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return toString(a, true);\n}","methodRange":"(line 1973,col 3)-(line 1975,col 3)","methodTokenRange":"public static String toStringQuoted(\/*@Nullable*\/ Collection<?> a) {\n    return toString(a, true);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"@SideEffectFree","methodParameters":[{"parameterType":"Collection<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.Collection<?>","parameter":"Collection<?> a","parameterName":"a"}],"methodName":"toStringQuoted","methodQualifiedSignature":"plume.ArraysMDE.toStringQuoted","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1974,col 24)-(line 1974,col 27)","literalExprId":1,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toStringQuoted(java.util.Collection<?>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a collection","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a collection'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"whether to quote the collection elements that are Java strings","javadocBlockTagName":"quoted","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to quote the collection elements that are Java strings'}]}', name=Optional[quoted]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the list","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the list'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(Collection<?> a, boolean quoted)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n        Iterator<?> itor = a.iterator();\n        sb.append(itor.next());\n        while (itor.hasNext()) {\n            sb.append(\", \");\n            Object elt = itor.next();\n            if (quoted && elt instanceof String) {\n                sb.append('\\\"');\n                sb.append(UtilMDE.escapeNonJava((String) elt));\n                sb.append('\\\"');\n            } else {\n                sb.append(elt);\n            }\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 1985,col 3)-(line 2010,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(\/*@Nullable*\/ Collection<?> a, boolean quoted) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.size() > 0) {\n      Iterator<?> itor = a.iterator();\n      sb.append(itor.next());\n      while (itor.hasNext()) {\n        sb.append(\", \");\n        Object elt = itor.next();\n        if (quoted && elt instanceof String) {\n          sb.append('\\\"');\n          sb.append(UtilMDE.escapeNonJava((String) elt));\n          sb.append('\\\"');\n        } else {\n          sb.append(elt);\n        }\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the collection.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a a collection\n   * @param quoted whether to quote the collection elements that are Java strings\n   * @return a string representation of the list\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"Collection<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Collection, typeParametersMap=TypeParametersMap{nameToValue={java.util.Collection.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.Collection<?>","parameter":"Collection<?> a","parameterName":"a"},{"parameterType":"boolean","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean quoted","parameterName":"quoted"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the collection.\nThe representation is patterned after that of java.util.Vector.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a collection'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='whether to quote the collection elements that are Java strings'}]}', name=Optional[quoted]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the list'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 1985,col 21)-(line 1985,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1988,col 14)-(line 1988,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1989,col 14)-(line 1989,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1992,col 15)-(line 1992,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1993,col 20)-(line 1993,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1997,col 19)-(line 1997,col 22)","literalExprId":6,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2000,col 21)-(line 2000,col 24)","literalExprId":7,"literalExpr":"'\\\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2002,col 21)-(line 2002,col 24)","literalExprId":8,"literalExpr":"'\\\"'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2008,col 15)-(line 2008,col 17)","literalExprId":9,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(java.util.Collection<?>, boolean)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 2019,col 3)-(line 2036,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(int \/*@Nullable*\/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the array.\nThe representation is patterned after that of java.util.Vector.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2019,col 21)-(line 2019,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2022,col 14)-(line 2022,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2023,col 14)-(line 2023,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2026,col 15)-(line 2026,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2027,col 20)-(line 2027,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2028,col 19)-(line 2028,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2029,col 20)-(line 2029,col 20)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2030,col 19)-(line 2030,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2034,col 15)-(line 2034,col 17)","literalExprId":9,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 2045,col 3)-(line 2062,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(long \/*@Nullable*\/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the array.\nThe representation is patterned after that of java.util.Vector.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2045,col 21)-(line 2045,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2048,col 14)-(line 2048,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2049,col 14)-(line 2049,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2052,col 15)-(line 2052,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2053,col 20)-(line 2053,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2054,col 19)-(line 2054,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2055,col 20)-(line 2055,col 20)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2056,col 19)-(line 2056,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2060,col 15)-(line 2060,col 17)","literalExprId":9,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 2071,col 3)-(line 2088,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(double \/*@Nullable*\/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the array.\nThe representation is patterned after that of java.util.Vector.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2071,col 21)-(line 2071,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2074,col 14)-(line 2074,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2075,col 14)-(line 2075,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2078,col 15)-(line 2078,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2079,col 20)-(line 2079,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2080,col 19)-(line 2080,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2081,col 20)-(line 2081,col 20)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2082,col 19)-(line 2082,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2086,col 15)-(line 2086,col 17)","literalExprId":9,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(float[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 2097,col 3)-(line 2114,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(float \/*@Nullable*\/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"float[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","parameterTypeResolvedDescribed":"float[]","parameter":"float[] a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the array.\nThe representation is patterned after that of java.util.Vector.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2097,col 21)-(line 2097,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2100,col 14)-(line 2100,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2101,col 14)-(line 2101,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2104,col 15)-(line 2104,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2105,col 20)-(line 2105,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2106,col 19)-(line 2106,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2107,col 20)-(line 2107,col 20)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2108,col 19)-(line 2108,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2112,col 15)-(line 2112,col 17)","literalExprId":9,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(float[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"java.util.Vector#toString","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}"}],"methodDeclaration":"public static String toString(boolean[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a == null) {\n        return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n        sb.append(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            sb.append(\", \");\n            sb.append(a[i]);\n        }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n}","methodRange":"(line 2123,col 3)-(line 2140,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (string creation)\n  \/*@SideEffectFree*\/\n  public static String toString(boolean \/*@Nullable*\/ [] a) {\n    if (a == null) {\n      return \"null\";\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"[\");\n    if (a.length > 0) {\n      sb.append(a[0]);\n      for (int i = 1; i < a.length; i++) {\n        sb.append(\", \");\n        sb.append(a[i]);\n      }\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return a string representation of the array.\n   * The representation is patterned after that of java.util.Vector.\n   * @param a an array\n   * @return a string representation of the array\n   * @see java.util.Vector#toString\n   ","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a string representation of the array.\nThe representation is patterned after that of java.util.Vector.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='java.util.Vector#toString'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2123,col 21)-(line 2123,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2126,col 14)-(line 2126,col 17)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2127,col 14)-(line 2127,col 19)","literalExprId":3,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2130,col 15)-(line 2130,col 17)","literalExprId":4,"literalExpr":"\"[\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2131,col 20)-(line 2131,col 20)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2132,col 19)-(line 2132,col 19)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2133,col 20)-(line 2133,col 20)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2134,col 19)-(line 2134,col 22)","literalExprId":8,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2138,col 15)-(line 2138,col 17)","literalExprId":9,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(boolean[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"obj","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[obj]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if obj is null or is not one of the types mentioned above.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if obj is null or is not one of the types mentioned above.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":"public static String toString(Object obj) throws IllegalArgumentException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (obj instanceof boolean[]) {\n        return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n        return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n        return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n        return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n        return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n        return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n        return toString((List<?>) obj);\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}","methodRange":"(line 2150,col 3)-(line 2171,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ defensive coding: throw exception when argument is invalid\n  \/*@SideEffectFree*\/\n  public static String toString(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return toString((boolean[]) obj);\n    } else if (obj instanceof double[]) {\n      return toString((double[]) obj);\n    } else if (obj instanceof float[]) {\n      return toString((float[]) obj);\n    } else if (obj instanceof int[]) {\n      return toString((int[]) obj);\n    } else if (obj instanceof long[]) {\n      return toString((long[]) obj);\n    } else if (obj instanceof Object[]) {\n      return toString((Object[]) obj);\n    } else if (obj instanceof List<?>) {\n      return toString((List<?>) obj);\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Casts obj down to the proper array type then calls the appropriate\n   * toString() method.  Only call this method if obj is a boolean, double,\n   * int, long, or Object array.\n   * @param obj an array\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"toString","methodQualifiedSignature":"plume.ArraysMDE.toString","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Casts obj down to the proper array type then calls the appropriate\ntoString() method.  Only call this method if obj is a boolean, double,\nint, long, or Object array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[obj]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if obj is null or is not one of the types mentioned above.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 2150,col 21)-(line 2150,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2169,col 11)-(line 2169,col 24)","literalExprId":2,"literalExpr":"\"Argument is \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2169,col 37)-(line 2169,col 40)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2169,col 45)-(line 2169,col 50)","literalExprId":4,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2169,col 54)-(line 2169,col 64)","literalExprId":5,"literalExpr":"\"of class \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.toString(java.lang.Object)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list","javadocBlockTagName":"obj","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list'}]}', name=Optional[obj]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a string representation of the array","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if obj is null or is not one of the types mentioned above.","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if obj is null or is not one of the types mentioned above.'}]}', name=Optional[IllegalArgumentException]}"}],"methodDeclaration":"public static int length(Object obj) throws IllegalArgumentException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (obj instanceof boolean[]) {\n        return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n        return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n        return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n        return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n        return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n        return ((List<?>) obj).size();\n    } else {\n        throw new IllegalArgumentException(\"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n}","methodRange":"(line 2180,col 3)-(line 2199,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ defensive coding: throw exception when argument is invalid\n  \/*@Pure*\/\n  public static int length(Object obj) throws IllegalArgumentException {\n    if (obj instanceof boolean[]) {\n      return ((boolean[]) obj).length;\n    } else if (obj instanceof double[]) {\n      return ((double[]) obj).length;\n    } else if (obj instanceof int[]) {\n      return ((int[]) obj).length;\n    } else if (obj instanceof long[]) {\n      return ((long[]) obj).length;\n    } else if (obj instanceof Object[]) {\n      return ((Object[]) obj).length;\n    } else if (obj instanceof List<?>) {\n      return ((List<?>) obj).size();\n    } else {\n      throw new IllegalArgumentException(\n          \"Argument is \" + ((obj == null) ? \"null\" : \"of class \" + obj.getClass().getName()));\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Casts obj down to the proper array type then calls .length.\n   * Only call this method if obj is a boolean, double, int, long, or Object array.\n   * @param obj a list\n   * @return a string representation of the array\n   * @throws IllegalArgumentException if obj is null or is not one of the types mentioned above.\n   ","methodParameters":[{"parameterType":"Object","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.Object","parameter":"Object obj","parameterName":"obj"}],"methodName":"length","methodQualifiedSignature":"plume.ArraysMDE.length","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Casts obj down to the proper array type then calls .length.\nOnly call this method if obj is a boolean, double, int, long, or Object array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list'}]}', name=Optional[obj]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a string representation of the array'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if obj is null or is not one of the types mentioned above.'}]}', name=Optional[IllegalArgumentException]}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 2180,col 21)-(line 2180,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2197,col 11)-(line 2197,col 24)","literalExprId":2,"literalExpr":"\"Argument is \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2197,col 37)-(line 2197,col 40)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2197,col 45)-(line 2197,col 50)","literalExprId":4,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2197,col 54)-(line 2197,col 64)","literalExprId":5,"literalExpr":"\"of class \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.length(java.lang.Object)"},{"methodDeclaration":"public static boolean sorted(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2211,col 3)-(line 2218,col 3)","methodTokenRange":"public static boolean sorted(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"sorted","methodQualifiedSignature":"plume.ArraysMDE.sorted","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2212,col 18)-(line 2212,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2212,col 36)-(line 2212,col 36)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2213,col 17)-(line 2213,col 17)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2214,col 16)-(line 2214,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2217,col 12)-(line 2217,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sorted(int[])"},{"methodDeclaration":"public static boolean sorted(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] < a[i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2226,col 3)-(line 2233,col 3)","methodTokenRange":"public static boolean sorted(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] < a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"sorted","methodQualifiedSignature":"plume.ArraysMDE.sorted","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2227,col 18)-(line 2227,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2227,col 36)-(line 2227,col 36)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2228,col 17)-(line 2228,col 17)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2229,col 16)-(line 2229,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2232,col 12)-(line 2232,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sorted(long[])"},{"methodDeclaration":"public static boolean sorted_descending(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2241,col 3)-(line 2248,col 3)","methodTokenRange":"public static boolean sorted_descending(int[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"sorted_descending","methodQualifiedSignature":"plume.ArraysMDE.sorted_descending","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2242,col 18)-(line 2242,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2242,col 36)-(line 2242,col 36)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2243,col 17)-(line 2243,col 17)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2244,col 16)-(line 2244,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2247,col 12)-(line 2247,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sorted_descending(int[])"},{"methodDeclaration":"public static boolean sorted_descending(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length - 1; i++) {\n        if (a[i + 1] > a[i]) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2256,col 3)-(line 2263,col 3)","methodTokenRange":"public static boolean sorted_descending(long[] a) {\n    for (int i = 0; i < a.length - 1; i++) {\n      if (a[i + 1] > a[i]) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"sorted_descending","methodQualifiedSignature":"plume.ArraysMDE.sorted_descending","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2257,col 18)-(line 2257,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2257,col 36)-(line 2257,col 36)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2258,col 17)-(line 2258,col 17)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2259,col 16)-(line 2259,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2262,col 12)-(line 2262,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.sorted_descending(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(boolean[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n        Boolean n = Boolean.valueOf(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2271,col 3)-(line 2285,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(boolean[] a) {\n    HashSet<Boolean> hs = new HashSet<Boolean>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      Boolean n = Boolean.valueOf(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"boolean[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='boolean'}}","parameterTypeResolvedDescribed":"boolean[]","parameter":"boolean[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2271,col 21)-(line 2271,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2275,col 18)-(line 2275,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2280,col 16)-(line 2280,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2284,col 12)-(line 2284,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(boolean[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(byte[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n        Byte n = new Byte(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2293,col 3)-(line 2307,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(byte[] a) {\n    HashSet<Byte> hs = new HashSet<Byte>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      Byte n = new Byte(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"byte[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='byte'}}","parameterTypeResolvedDescribed":"byte[]","parameter":"byte[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2293,col 21)-(line 2293,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2297,col 18)-(line 2297,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2302,col 16)-(line 2302,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2306,col 12)-(line 2306,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(byte[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(char[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n        Character n = new Character(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2315,col 3)-(line 2329,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(char[] a) {\n    HashSet<Character> hs = new HashSet<Character>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      Character n = new Character(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2315,col 21)-(line 2315,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2319,col 18)-(line 2319,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2324,col 16)-(line 2324,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2328,col 12)-(line 2328,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(char[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(float[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n        Float n = new Float(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2337,col 3)-(line 2351,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(float[] a) {\n    HashSet<Float> hs = new HashSet<Float>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      Float n = new Float(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"float[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='float'}}","parameterTypeResolvedDescribed":"float[]","parameter":"float[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2337,col 21)-(line 2337,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2341,col 18)-(line 2341,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2346,col 16)-(line 2346,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2350,col 12)-(line 2350,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(float[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(short[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n        Short n = new Short(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2359,col 3)-(line 2373,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(short[] a) {\n    HashSet<Short> hs = new HashSet<Short>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      Short n = new Short(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"short[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='short'}}","parameterTypeResolvedDescribed":"short[]","parameter":"short[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2359,col 21)-(line 2359,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2363,col 18)-(line 2363,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2368,col 16)-(line 2368,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2372,col 12)-(line 2372,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(short[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n        Integer n = new Integer(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2381,col 3)-(line 2395,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(int[] a) {\n    HashSet<Integer> hs = new HashSet<Integer>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      Integer n = new Integer(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2381,col 21)-(line 2381,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2385,col 18)-(line 2385,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2390,col 16)-(line 2390,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2394,col 12)-(line 2394,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(double[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n        Double n = new Double(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2404,col 3)-(line 2418,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(double[] a) {\n    HashSet<Double> hs = new HashSet<Double>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to create the last element,\n      \/\/ but that would make the code much less readable.\n      Double n = new Double(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space. Equality checking\n   * uses the .equals() method for java.lang.Double.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space. Equality checking\nuses the .equals() method for java.lang.Double.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2404,col 21)-(line 2404,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2408,col 18)-(line 2408,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2413,col 16)-(line 2413,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2417,col 12)-(line 2417,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(long[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n        Long n = new Long(a[i]);\n        if (hs.contains(n)) {\n            return false;\n        }\n        hs.add(n);\n    }\n    return true;\n}","methodRange":"(line 2426,col 3)-(line 2440,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(long[] a) {\n    HashSet<Long> hs = new HashSet<Long>();\n    for (int i = 0; i < a.length; i++) {\n      \/\/ Could be optimized not to create the last element,\n      \/\/ but that would make the code much less readable.\n      Long n = new Long(a[i]);\n      if (hs.contains(n)) {\n        return false;\n      }\n      hs.add(n);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2426,col 21)-(line 2426,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2430,col 18)-(line 2430,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2435,col 16)-(line 2435,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2439,col 12)-(line 2439,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(String[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        hs.add(a[i]);\n    }\n    return true;\n}","methodRange":"(line 2448,col 3)-(line 2461,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(String[] a) {\n    HashSet<String> hs = new HashSet<String>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2448,col 21)-(line 2448,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2452,col 18)-(line 2452,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2454,col 16)-(line 2454,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2460,col 12)-(line 2460,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(java.lang.String[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(Object[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n        if (hs.contains(a[i])) {\n            return false;\n        }\n        hs.add(a[i]);\n    }\n    return true;\n}","methodRange":"(line 2469,col 3)-(line 2482,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean noDuplicates(Object[] a) {\n    HashSet<Object> hs = new HashSet<Object>();\n    for (int i = 0; i < a.length; i++) {\n      if (hs.contains(a[i])) {\n        return false;\n      }\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      hs.add(a[i]);\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param a an array\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2469,col 21)-(line 2469,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2473,col 18)-(line 2473,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2475,col 16)-(line 2475,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2481,col 12)-(line 2481,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(java.lang.Object[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the type of the elements","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the elements'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff a does not contain duplicate elements","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean noDuplicates(List<T> a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n        if (hs.contains(a.get(i))) {\n            return false;\n        }\n        hs.add(a.get(i));\n    }\n    return true;\n}","methodRange":"(line 2491,col 3)-(line 2504,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static <T> boolean noDuplicates(List<T> a) {\n    HashSet<T> hs = new HashSet<T>();\n    for (int i = 0; i < a.size(); i++) {\n      if (hs.contains(a.get(i))) {\n        return false;\n      }\n      \/\/ Could be optimized not to add the last element,\n      \/\/ but that would make the code much less readable.\n      hs.add(a.get(i));\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return true iff a does not contain duplicate elements,\n   * using O(n) time and O(n) space.\n   * @param <T> the type of the elements\n   * @param a a list\n   * @return true iff a does not contain duplicate elements\n   ","methodParameters":[{"parameterType":"List<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.List<T>","parameter":"List<T> a","parameterName":"a"}],"methodName":"noDuplicates","methodQualifiedSignature":"plume.ArraysMDE.noDuplicates","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return true iff a does not contain duplicate elements,\nusing O(n) time and O(n) space.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the elements'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff a does not contain duplicate elements'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2491,col 21)-(line 2491,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2495,col 18)-(line 2495,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2497,col 16)-(line 2497,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2503,col 12)-(line 2503,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.noDuplicates(java.util.List<T>)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array, representing a function","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array, representing a function'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff all elements of a are in [0..a.length) and a\ncontains no duplicates.","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff all elements of a are in [0..a.length) and a\ncontains no duplicates.'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean fn_is_permutation(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int n = a[i];\n        if (n < 0 || n >= a.length || see[n]) {\n            return false;\n        }\n        see[n] = true;\n    }\n    return true;\n}","methodRange":"(line 2516,col 3)-(line 2529,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (array)\n  \/*@Pure*\/\n  public static boolean fn_is_permutation(int[] a) {\n    \/\/ In the common case we expect to succeed, so use as few loops as possible\n    boolean[] see = new boolean[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int n = a[i];\n      if (n < 0 || n >= a.length || see[n]) {\n        return false;\n      }\n      see[n] = true;\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns true if the array is a permutation of [0..a.length).\n   * @param a an array, representing a function\n   * @return true iff all elements of a are in [0..a.length) and a\n   * contains no duplicates.\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"fn_is_permutation","methodQualifiedSignature":"plume.ArraysMDE.fn_is_permutation","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns true if the array is a permutation of [0..a.length).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array, representing a function'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff all elements of a are in [0..a.length) and a\ncontains no duplicates.'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2516,col 21)-(line 2516,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2521,col 18)-(line 2521,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2523,col 15)-(line 2523,col 15)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2524,col 16)-(line 2524,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2526,col 16)-(line 2526,col 19)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2528,col 12)-(line 2528,col 15)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.fn_is_permutation(int[])"},{"methodDeclaration":"public static boolean fn_is_total(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return indexOf(a, -1) == -1;\n}","methodRange":"(line 2537,col 3)-(line 2539,col 3)","methodTokenRange":"public static boolean fn_is_total(int[] a) {\n    return indexOf(a, -1) == -1; \/\/ not found\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"fn_is_total","methodQualifiedSignature":"plume.ArraysMDE.fn_is_total","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2538,col 24)-(line 2538,col 24)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2538,col 31)-(line 2538,col 31)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.fn_is_total(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the length of the result","javadocBlockTagName":"length","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the length of the result'}]}', name=Optional[length]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"fresh array that is the identity function of the given length","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='fresh array that is the identity function of the given length'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] fn_identity(int length)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n        result[i] = i;\n    }\n    return result;\n}","methodRange":"(line 2546,col 3)-(line 2552,col 3)","methodTokenRange":"public static int[] fn_identity(int length) {\n    int[] result = new int[length];\n    for (int i = 0; i < length; i++) {\n      result[i] = i;\n    }\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return an array [0..lenth).\n   * @param length the length of the result\n   * @return fresh array that is the identity function of the given length\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"}],"methodName":"fn_identity","methodQualifiedSignature":"plume.ArraysMDE.fn_identity","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return an array [0..lenth).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the length of the result'}]}', name=Optional[length]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='fresh array that is the identity function of the given length'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 2548,col 18)-(line 2548,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.fn_identity(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the input permutation","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the input permutation'}]}', name=Optional[a]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"fresh array which is the inverse of the given permutation","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='fresh array which is the inverse of the given permutation'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#fn_is_permutation(int[])","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#fn_is_permutation(int[])'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] fn_inverse_permutation(int[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return fn_inverse(a, a.length);\n}","methodRange":"(line 2560,col 3)-(line 2562,col 3)","methodTokenRange":"public static int[] fn_inverse_permutation(int[] a) {\n    return fn_inverse(a, a.length);\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Requires that fn_is_permutation(a) holds.\n   * @param a the input permutation\n   * @return fresh array which is the inverse of the given permutation\n   * @see #fn_is_permutation(int[])\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"}],"methodName":"fn_inverse_permutation","methodQualifiedSignature":"plume.ArraysMDE.fn_inverse_permutation","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Requires that fn_is_permutation(a) holds.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the input permutation'}]}', name=Optional[a]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='fresh array which is the inverse of the given permutation'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#fn_is_permutation(int[])'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[],"methodQualifiedName":"plume.ArraysMDE.fn_inverse_permutation(int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"an array representing a function from [0..a.length) to [0..arange);\n each element of a is between 0 and arange inclusive","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array representing a function from [0..a.length) to [0..arange);\n each element of a is between 0 and arange inclusive'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"length of the argument's range and the result's domain","javadocBlockTagName":"arange","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='length of the argument's range and the result's domain'}]}', name=Optional[arange]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"function from [0..arange) to [0..a.length) that is the inverse of a","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..arange) to [0..a.length) that is the inverse of a'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if a value of a is outside of arange","javadocBlockTagName":"IllegalArgumentException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a value of a is outside of arange'}]}', name=Optional[IllegalArgumentException]}"},{"javadocBlockType":"EXCEPTION","javadocBlockTagContent":"when the function is not invertible","javadocBlockTagName":"UnsupportedOperationException","javadocBlockTag":"JavadocBlockTag{type=EXCEPTION, content='JavadocDescription{elements=[JavadocSnippet{text='when the function is not invertible'}]}', name=Optional[UnsupportedOperationException]}"}],"methodDeclaration":"public static int[] fn_inverse(int[] a, int arange)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n        int ai = a[i];\n        if (ai < -1 || ai >= arange) {\n            throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n        }\n        if (ai >= 0) {\n            if (result[ai] != -1) {\n                throw new UnsupportedOperationException(String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n            }\n            result[ai] = i;\n        }\n    }\n    return result;\n}","methodRange":"(line 2573,col 3)-(line 2591,col 3)","methodTokenRange":"public static int[] fn_inverse(int[] a, int arange) {\n    int[] result = new int[arange];\n    Arrays.fill(result, -1);\n    for (int i = 0; i < a.length; i++) {\n      int ai = a[i];\n      if (ai < -1 || ai >= arange) {\n        throw new IllegalArgumentException(String.format(\"Bad range value: a[%d]=%d\", i, ai));\n      }\n      \/\/ ai is either -1 or a valid index\n      if (ai >= 0) {\n        if (result[ai] != -1) {\n          throw new UnsupportedOperationException(\n              String.format(\"Not invertible; a[%d]=%d and a[%d]=%d\", result[ai], ai, i, ai));\n        }\n        result[ai] = i;\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return the inverse of the given function, which is represented as an array.\n   * @param a an array representing a function from [0..a.length) to [0..arange);\n   *  each element of a is between 0 and arange inclusive\n   * @param arange length of the argument's range and the result's domain\n   * @return function from [0..arange) to [0..a.length) that is the inverse of a\n   * @throws IllegalArgumentException if a value of a is outside of arange\n   * @exception UnsupportedOperationException when the function is not invertible\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int arange","parameterName":"arange"}],"methodName":"fn_inverse","methodQualifiedSignature":"plume.ArraysMDE.fn_inverse","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the inverse of the given function, which is represented as an array.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='an array representing a function from [0..a.length) to [0..arange);\n each element of a is between 0 and arange inclusive'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='length of the argument's range and the result's domain'}]}', name=Optional[arange]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..arange) to [0..a.length) that is the inverse of a'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if a value of a is outside of arange'}]}', name=Optional[IllegalArgumentException]}, JavadocBlockTag{type=EXCEPTION, content='JavadocDescription{elements=[JavadocSnippet{text='when the function is not invertible'}]}', name=Optional[UnsupportedOperationException]}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 2575,col 26)-(line 2575,col 26)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2576,col 18)-(line 2576,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2578,col 17)-(line 2578,col 17)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2579,col 58)-(line 2579,col 84)","literalExprId":4,"literalExpr":"\"Bad range value: a[%d]=%d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2582,col 17)-(line 2582,col 17)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2583,col 28)-(line 2583,col 28)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2585,col 29)-(line 2585,col 67)","literalExprId":7,"literalExpr":"\"Not invertible; a[%d]=%d and a[%d]=%d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.fn_inverse(int[], int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"function from [0..a.length) to [0..b.length)","javadocBlockTagName":"a","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..a.length) to [0..b.length)'}]}', name=Optional[a]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"function from [0..b.length) to range R","javadocBlockTagName":"b","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..b.length) to range R'}]}', name=Optional[b]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"function from [0..a.length) to range R that is the\ncomposition of a and b","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..a.length) to range R that is the\ncomposition of a and b'}]}', name=Optional.empty}"}],"methodDeclaration":"public static int[] fn_compose(int[] a, int[] b)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        int inner = a[i];\n        if (inner == -1) {\n            result[i] = -1;\n        } else {\n            result[i] = b[inner];\n        }\n    }\n    return result;\n}","methodRange":"(line 2601,col 3)-(line 2612,col 3)","methodTokenRange":"public static int[] fn_compose(int[] a, int[] b) {\n    int[] result = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n      int inner = a[i];\n      if (inner == -1) {\n        result[i] = -1;\n      } else {\n        result[i] = b[inner];\n      }\n    }\n    return result;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"\n   * Return the composition of the given two functions, all of which are\n   * represented as arrays.\n   * @param a function from [0..a.length) to [0..b.length)\n   * @param b function from [0..b.length) to range R\n   * @return function from [0..a.length) to range R that is the\n   * composition of a and b\n   ","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a","parameterName":"a"},{"parameterType":"int[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] b","parameterName":"b"}],"methodName":"fn_compose","methodQualifiedSignature":"plume.ArraysMDE.fn_compose","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the composition of the given two functions, all of which are\nrepresented as arrays.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..a.length) to [0..b.length)'}]}', name=Optional[a]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..b.length) to range R'}]}', name=Optional[b]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='function from [0..a.length) to range R that is the\ncomposition of a and b'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 2603,col 18)-(line 2603,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2605,col 21)-(line 2605,col 21)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2606,col 22)-(line 2606,col 22)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.fn_compose(int[], int[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first set to test","javadocBlockTagName":"smaller","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first set to test'}]}', name=Optional[smaller]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second set to test","javadocBlockTagName":"bigger","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second set to test'}]}', name=Optional[bigger]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff smaller is a subset of bigger","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff smaller is a subset of bigger'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isSubset(long[] smaller, long[] bigger)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<Long> setBigger = new HashSet<Long>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Long(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Long elt = new Long(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2629,col 3)-(line 2646,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean isSubset(long[] smaller, long[] bigger) {\n    Set<Long> setBigger = new HashSet<Long>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Long(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Long elt = new Long(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   ","methodParameters":[{"parameterType":"long[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] smaller","parameterName":"smaller"},{"parameterType":"long[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='long'}}","parameterTypeResolvedDescribed":"long[]","parameter":"long[] bigger","parameterName":"bigger"}],"methodName":"isSubset","methodQualifiedSignature":"plume.ArraysMDE.isSubset","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return whether smaller is a subset of bigger.  The implementation is to\nuse collections because we want to take advantage of HashSet's\nconstant time membership tests.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first set to test'}]}', name=Optional[smaller]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second set to test'}]}', name=Optional[bigger]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff smaller is a subset of bigger'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2629,col 21)-(line 2629,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2634,col 18)-(line 2634,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2638,col 18)-(line 2638,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2641,col 16)-(line 2641,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2645,col 12)-(line 2645,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubset(long[], long[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first set to test","javadocBlockTagName":"smaller","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first set to test'}]}', name=Optional[smaller]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second set to test","javadocBlockTagName":"bigger","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second set to test'}]}', name=Optional[bigger]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff smaller is a subset of bigger","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff smaller is a subset of bigger'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isSubset(double[] smaller, double[] bigger)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<Double> setBigger = new HashSet<Double>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(new Double(bigger[i]));\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        Double elt = new Double(smaller[i]);\n        if (!setBigger.contains(elt)) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2659,col 3)-(line 2676,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean isSubset(double[] smaller, double[] bigger) {\n    Set<Double> setBigger = new HashSet<Double>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(new Double(bigger[i]));\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      Double elt = new Double(smaller[i]);\n      if (!setBigger.contains(elt)) {\n        return false;\n      }\n    }\n\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] smaller","parameterName":"smaller"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] bigger","parameterName":"bigger"}],"methodName":"isSubset","methodQualifiedSignature":"plume.ArraysMDE.isSubset","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return whether smaller is a subset of bigger.  The implementation is to\nuse collections because we want to take advantage of HashSet's\nconstant time membership tests.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first set to test'}]}', name=Optional[smaller]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second set to test'}]}', name=Optional[bigger]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff smaller is a subset of bigger'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2659,col 21)-(line 2659,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2664,col 18)-(line 2664,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2668,col 18)-(line 2668,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2671,col 16)-(line 2671,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2675,col 12)-(line 2675,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubset(double[], double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"first set to test","javadocBlockTagName":"smaller","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first set to test'}]}', name=Optional[smaller]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"second set to test","javadocBlockTagName":"bigger","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second set to test'}]}', name=Optional[bigger]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true iff smaller is a subset of bigger","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff smaller is a subset of bigger'}]}', name=Optional.empty}"}],"methodDeclaration":"public static boolean isSubset(String[] smaller, String[] bigger)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Set<String> setBigger = new HashSet<String>();\n    for (int i = 0; i < bigger.length; i++) {\n        setBigger.add(bigger[i]);\n    }\n    for (int i = 0; i < smaller.length; i++) {\n        if (!setBigger.contains(smaller[i])) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 2689,col 3)-(line 2705,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (HashSet)\n  \/*@Pure*\/\n  public static boolean isSubset(String[] smaller, String[] bigger) {\n    Set<String> setBigger = new HashSet<String>();\n\n    for (int i = 0; i < bigger.length; i++) {\n      setBigger.add(bigger[i]);\n    }\n\n    for (int i = 0; i < smaller.length; i++) {\n      if (!setBigger.contains(smaller[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Return whether smaller is a subset of bigger.  The implementation is to\n   * use collections because we want to take advantage of HashSet's\n   * constant time membership tests.\n   * @param smaller first set to test\n   * @param bigger second set to test\n   * @return true iff smaller is a subset of bigger\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] smaller","parameterName":"smaller"},{"parameterType":"String[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] bigger","parameterName":"bigger"}],"methodName":"isSubset","methodQualifiedSignature":"plume.ArraysMDE.isSubset","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return whether smaller is a subset of bigger.  The implementation is to\nuse collections because we want to take advantage of HashSet's\nconstant time membership tests.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='first set to test'}]}', name=Optional[smaller]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='second set to test'}]}', name=Optional[bigger]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true iff smaller is a subset of bigger'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 2689,col 21)-(line 2689,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2694,col 18)-(line 2694,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2698,col 18)-(line 2698,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2700,col 16)-(line 2700,col 20)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2704,col 12)-(line 2704,col 15)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.isSubset(java.lang.String[], java.lang.String[])"},{"methodDeclaration":"public static boolean any_null(Object[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.length == 0) {\n        return false;\n    }\n    return indexOfEq(a, (Object) null) >= 0;\n}","methodRange":"(line 3204,col 3)-(line 3210,col 3)","methodTokenRange":"public static boolean any_null(\/*@PolyAll*\/ Object[] a) {\n    if (a.length == 0) {\n      return false;\n    }\n    \/\/ The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (\/*@Nullable*\/ Object) null) >= 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"}],"methodName":"any_null","methodQualifiedSignature":"plume.ArraysMDE.any_null","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 3205,col 21)-(line 3205,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3206,col 14)-(line 3206,col 18)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3209,col 48)-(line 3209,col 51)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3209,col 57)-(line 3209,col 57)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.any_null(java.lang.Object[])"},{"methodDeclaration":"public static boolean all_null(Object[] a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (!(a[i] == null)) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 3218,col 3)-(line 3225,col 3)","methodTokenRange":"public static boolean all_null(\/*@PolyAll*\/ Object[] a) {\n    for (int i = 0; i < a.length; i++) {\n      if (!(a[i] == null)) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"Object[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.Object, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.Object[]","parameter":"Object[] a","parameterName":"a"}],"methodName":"all_null","methodQualifiedSignature":"plume.ArraysMDE.all_null","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 3219,col 18)-(line 3219,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3220,col 21)-(line 3220,col 24)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3221,col 16)-(line 3221,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3224,col 12)-(line 3224,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.all_null(java.lang.Object[])"},{"methodDeclaration":"public static boolean any_null(List<?> a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (a.size() == 0) {\n        return false;\n    }\n    return indexOfEq(a, (Object) null) >= 0;\n}","methodRange":"(line 3233,col 3)-(line 3239,col 3)","methodTokenRange":"public static boolean any_null(List<?> a) {\n    if (a.size() == 0) {\n      return false;\n    }\n    \/\/ The cast ensures that the right version of IndexOfEq gets called.\n    return indexOfEq(a, (\/*@Nullable*\/ Object) null) >= 0;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"}],"methodName":"any_null","methodQualifiedSignature":"plume.ArraysMDE.any_null","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 3234,col 21)-(line 3234,col 21)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3235,col 14)-(line 3235,col 18)","literalExprId":2,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3238,col 48)-(line 3238,col 51)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3238,col 57)-(line 3238,col 57)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.any_null(java.util.List<?>)"},{"methodDeclaration":"public static boolean all_null(List<?> a)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.size(); i++) {\n        if (!(a.get(i) == null)) {\n            return false;\n        }\n    }\n    return true;\n}","methodRange":"(line 3247,col 3)-(line 3254,col 3)","methodTokenRange":"public static boolean all_null(List<?> a) {\n    for (int i = 0; i < a.size(); i++) {\n      if (!(a.get(i) == null)) {\n        return false;\n      }\n    }\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"List<?>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=WildcardUsage{type=null, boundedType=null}}}}","parameterTypeResolvedDescribed":"java.util.List<?>","parameter":"List<?> a","parameterName":"a"}],"methodName":"all_null","methodQualifiedSignature":"plume.ArraysMDE.all_null","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 3248,col 18)-(line 3248,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3249,col 25)-(line 3249,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3250,col 16)-(line 3250,col 20)","literalExprId":3,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3253,col 12)-(line 3253,col 15)","literalExprId":4,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.ArraysMDE.all_null(java.util.List<?>)"}],"classJavadoc":"\/**\n * Utilities for manipulating arrays and collections.\n * This complements {@link java.util.Arrays} and {@link java.util.Collections}.\n *\/\n","className":"ArraysMDE","fields":[{"fieldRange":"(line 3265,col 3)-(line 3265,col 34)","fieldName":"javadocLossage","fieldJavadocComment":" Yuck!","fieldTokenRange":"public Vector<?> javadocLossage;","fieldTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=WildcardUsage{type=null, boundedType=null}}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"Vector<?>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Vector<?>"}]}],"sourceFileId":42,"packageName":"plume"},{"sourceFileName":"plume.StrTok","imports":[{"importId":1,"import":"\/*>>>\nimport org.checkerframework.checker.initialization.qual.*;\nimport org.checkerframework.checker.interning.qual.*;\nimport org.checkerframework.checker.nullness.qual.*;\nimport org.checkerframework.dataflow.qual.*;\n*\/\nimport java.io.Reader;\n"},{"importId":2,"import":"import java.io.StreamTokenizer;\n"},{"importId":3,"import":"import java.io.StringReader;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to tokenize","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to tokenize'}]}', name=Optional[s]}"}],"constructorQualifiedSignature":"plume.StrTok.StrTok(java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 48,col 3)-(line 50,col 3)","constructorJavadocComment":"\n   * Creates a tokenizer for the specified string.\n   * @param s string to tokenize\n   ","constructorDeclaration":"public StrTok(String s)","constructorBody":"{\n    this(s, new ErrorHandler());\n}","constructorName":"StrTok","constructorQualifiedName":"plume.StrTok.StrTok","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"}],"literalExprs":[],"constructorTokenRange":"public StrTok(String s) {\n    this(s, new ErrorHandler());\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a tokenizer for the specified string.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to tokenize'}]}', name=Optional[s]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to tokenize","javadocBlockTagName":"s","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to tokenize'}]}', name=Optional[s]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"error handler","javadocBlockTagName":"e","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='error handler'}]}', name=Optional[e]}"}],"constructorQualifiedSignature":"plume.StrTok.StrTok(java.lang.String, plume.StrTok.ErrorHandler)","variableDeclarationExprs":[],"constructorRange":"(line 58,col 3)-(line 63,col 3)","constructorJavadocComment":"\n   * Creates a tokenizer for the specified string with the specified\n   * error handler.\n   * @param s string to tokenize\n   * @param e error handler\n   ","constructorDeclaration":"public StrTok(String s, ErrorHandler e)","constructorBody":"{\n    reader = new StringReader(s);\n    stok = new StreamTokenizer(reader);\n    stok.wordChars('_', '_');\n    set_error_handler(e);\n}","constructorName":"StrTok","constructorQualifiedName":"plume.StrTok.StrTok","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String s","parameterName":"s"},{"parameterType":"ErrorHandler","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.StrTok.ErrorHandler, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.StrTok.ErrorHandler","parameter":"ErrorHandler e","parameterName":"e"}],"literalExprs":[{"literalExprRange":"(line 61,col 20)-(line 61,col 22)","literalExprId":1,"literalExpr":"'_'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 61,col 25)-(line 61,col 27)","literalExprId":2,"literalExpr":"'_'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"}],"constructorTokenRange":"public StrTok(String s, ErrorHandler e) {\n    reader = new StringReader(s);\n    stok = new StreamTokenizer(reader);\n    stok.wordChars('_', '_');\n    set_error_handler(e);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a tokenizer for the specified string with the specified\nerror handler.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to tokenize'}]}', name=Optional[s]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='error handler'}]}', name=Optional[e]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 71,col 3)-(line 80,col 3)","classOrInterfaceTokenRange":"public static class ErrorHandler {\n\n    \/**\n     * Called when an unexpected token is found (see {@link #need(String)}).\n     * @param s unexpected token that has been found\n     *\/\n    public void tok_error(String s) {\n      throw new RuntimeException(\"StrTok error: \" + s);\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Default class for error handling.  Throws a RuntimeException when an\n   * error occurs.\n   *\n   * @see #set_error_handler(ErrorHandler)\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Default class for error handling.  Throws a RuntimeException when an\nerror occurs.'}]}, blockTags=[JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#set_error_handler(ErrorHandler)'}]}', name=Optional.empty}]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the next token","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next token'}]}', name=Optional.empty}"}],"methodDeclaration":"public String nextToken()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        stok.nextToken();\n    } catch (Exception e) {\n        throw new RuntimeException(\"StreamTokenizer exception: \", e);\n    }\n    return (token());\n}","methodRange":"(line 88,col 3)-(line 99,col 3)","methodTokenRange":"public \/*@Nullable*\/ \/*@Interned*\/ String nextToken() {\n\n    \/\/ Get the next token.  Turn IO exceptions into runtime exceptions\n    \/\/ so that callers don't have to catch them.\n    try {\n      stok.nextToken();\n    } catch (Exception e) {\n      throw new RuntimeException(\"StreamTokenizer exception: \", e);\n    }\n\n    return (token());\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the next token as a string.  EOF returns a null, EOL\n   * returns an empty string.  Delimiters are returned as one character\n   * strings.  Quoted strings and words are returned as strings.\n   * @return the next token\n   ","methodParameters":[],"methodName":"nextToken","methodQualifiedSignature":"plume.StrTok.nextToken","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the next token as a string.  EOF returns a null, EOL\nreturns an empty string.  Delimiters are returned as one character\nstrings.  Quoted strings and words are returned as strings.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next token'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 95,col 34)-(line 95,col 62)","literalExprId":1,"literalExpr":"\"StreamTokenizer exception: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.StrTok.nextToken()"},{"javadocBlockTags":[],"methodDeclaration":"public void pushBack()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    stok.pushBack();\n}","methodRange":"(line 102,col 3)-(line 104,col 3)","methodTokenRange":"public void pushBack() {\n    stok.pushBack();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Causes the next call to nextToken() to return the current token. ","methodParameters":[],"methodName":"pushBack","methodQualifiedSignature":"plume.StrTok.pushBack","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Causes the next call to nextToken() to return the current token.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.StrTok.pushBack()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the current token","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the current token'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#nextToken()","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#nextToken()'}]}', name=Optional.empty}"}],"methodDeclaration":"public String token()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int ttype = stok.ttype;\n    if (ttype == StreamTokenizer.TT_EOF) {\n        return (null);\n    }\n    if (ttype == StreamTokenizer.TT_EOL) {\n        return (\"\");\n    }\n    if (stok.sval != null) {\n        if (ttype > 0) {\n            String s = ((char) ttype) + stok.sval + ((char) ttype);\n            return (s.intern());\n        }\n        return (stok.sval.intern());\n    }\n    if (ttype > 0) {\n        String s = \"\" + (char) ttype;\n        return (s.intern());\n    }\n    throw new RuntimeException(\"Unexpected return \" + ttype + \" from StreamTokenizer\");\n}","methodRange":"(line 111,col 3)-(line 142,col 3)","methodTokenRange":"public \/*@Nullable*\/ \/*@Interned*\/ String token() {\n\n    int ttype = stok.ttype;\n\n    \/\/ Null indicates eof\n    if (ttype == StreamTokenizer.TT_EOF) {\n      return (null);\n    }\n\n    \/\/ Return end of line as an empty string\n    if (ttype == StreamTokenizer.TT_EOL) {\n      return (\"\");\n    }\n\n    \/\/ Return identifiers (words) and quoted strings.  Quoted strings\n    \/\/ include their quote characters (for recognition)\n    if (stok.sval != null) {\n      if (ttype > 0) {\n        String s = ((char) ttype) + stok.sval + ((char) ttype);\n        return (s.intern());\n      }\n      return (stok.sval.intern());\n    }\n\n    \/\/ Other tokens are delimiters\n    if (ttype > 0) {\n      String s = \"\" + (char) ttype;\n      return (s.intern());\n    }\n\n    throw new RuntimeException(\"Unexpected return \" + ttype + \" from StreamTokenizer\");\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the current token.\n   * @return the current token\n   * @see #nextToken()\n   ","methodParameters":[],"methodName":"token","methodQualifiedSignature":"plume.StrTok.token","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the current token.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the current token'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#nextToken()'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 117,col 15)-(line 117,col 18)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 122,col 15)-(line 122,col 16)","literalExprId":2,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 127,col 22)-(line 127,col 25)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 128,col 19)-(line 128,col 19)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 136,col 17)-(line 136,col 17)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 137,col 18)-(line 137,col 19)","literalExprId":6,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 141,col 32)-(line 141,col 51)","literalExprId":7,"literalExpr":"\"Unexpected return \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 141,col 63)-(line 141,col 85)","literalExprId":8,"literalExpr":"\" from StreamTokenizer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.StrTok.token()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the comment character","javadocBlockTagName":"ch","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the comment character'}]}', name=Optional[ch]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"StreamTokenizer#commentChar(int)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='StreamTokenizer#commentChar(int)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void commentChar(int ch)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    stok.commentChar(ch);\n}","methodRange":"(line 149,col 3)-(line 151,col 3)","methodTokenRange":"public void commentChar(int ch) {\n    stok.commentChar(ch);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Specifies the single line comment character.\n   * @param ch the comment character\n   * @see StreamTokenizer#commentChar(int)\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int ch","parameterName":"ch"}],"methodName":"commentChar","methodQualifiedSignature":"plume.StrTok.commentChar","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Specifies the single line comment character.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the comment character'}]}', name=Optional[ch]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='StreamTokenizer#commentChar(int)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.StrTok.commentChar(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the quoting character","javadocBlockTagName":"ch","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the quoting character'}]}', name=Optional[ch]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"StreamTokenizer#quoteChar(int)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='StreamTokenizer#quoteChar(int)'}]}', name=Optional.empty}"}],"methodDeclaration":"public void quoteChar(int ch)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    stok.quoteChar(ch);\n}","methodRange":"(line 158,col 3)-(line 160,col 3)","methodTokenRange":"public void quoteChar(int ch) {\n    stok.quoteChar(ch);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Specifies that matching pairs of this character delimit string constants.\n   * @param ch the quoting character\n   * @see StreamTokenizer#quoteChar(int)\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int ch","parameterName":"ch"}],"methodName":"quoteChar","methodQualifiedSignature":"plume.StrTok.quoteChar","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Specifies that matching pairs of this character delimit string constants.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the quoting character'}]}', name=Optional[ch]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='StreamTokenizer#quoteChar(int)'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.StrTok.quoteChar(int)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the type of the current token","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the current token'}]}', name=Optional.empty}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"StreamTokenizer#ttype","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='StreamTokenizer#ttype'}]}', name=Optional.empty}"}],"methodDeclaration":"public int ttype()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return stok.ttype;\n}","methodRange":"(line 167,col 3)-(line 169,col 3)","methodTokenRange":"public int ttype() {\n    return stok.ttype;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the type of the current token.\n   * @return the type of the current token\n   * @see StreamTokenizer#ttype\n   ","methodParameters":[],"methodName":"ttype","methodQualifiedSignature":"plume.StrTok.ttype","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the type of the current token.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the type of the current token'}]}', name=Optional.empty}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='StreamTokenizer#ttype'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.StrTok.ttype()"},{"methodDeclaration":"public boolean isWord()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (stok.ttype == StreamTokenizer.TT_WORD);\n}","methodRange":"(line 175,col 3)-(line 177,col 3)","methodTokenRange":"public boolean isWord() {\n    return (stok.ttype == StreamTokenizer.TT_WORD);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"isWord","methodQualifiedSignature":"plume.StrTok.isWord","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.StrTok.isWord()"},{"methodDeclaration":"public boolean isQString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((stok.sval != null) && (stok.ttype > 0));\n}","methodRange":"(line 183,col 3)-(line 185,col 3)","methodTokenRange":"public boolean isQString() {\n    return ((stok.sval != null) && (stok.ttype > 0));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"isQString","methodQualifiedSignature":"plume.StrTok.isQString","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 184,col 27)-(line 184,col 30)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 184,col 50)-(line 184,col 50)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.StrTok.isQString()"},{"methodDeclaration":"public void set_error_handler(ErrorHandler errorHandler)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.errorHandler = errorHandler;\n}","methodRange":"(line 194,col 3)-(line 197,col 3)","methodTokenRange":"public void set_error_handler(\n      \/*>>>@UnknownInitialization @Raw StrTok this,*\/ ErrorHandler errorHandler) {\n    this.errorHandler = errorHandler;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"@EnsuresNonNull(\"this.errorHandler\")","methodParameters":[{"parameterType":"ErrorHandler","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.StrTok.ErrorHandler, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"plume.StrTok.ErrorHandler","parameter":"ErrorHandler errorHandler","parameterName":"errorHandler"}],"methodName":"set_error_handler","methodQualifiedSignature":"plume.StrTok.set_error_handler","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.StrTok.set_error_handler(plume.StrTok.ErrorHandler)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"string to check next token against","javadocBlockTagName":"tok","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check next token against'}]}', name=Optional[tok]}"}],"methodDeclaration":"public void need(String tok)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String t = nextToken();\n    if (tok.equals(t)) {\n        return;\n    }\n    errorHandler.tok_error(String.format(\"Token %s found where %s expected\", t, tok));\n}","methodRange":"(line 206,col 3)-(line 214,col 3)","methodTokenRange":"public void need(String tok) {\n\n    String t = nextToken();\n    if (tok.equals(t)) {\n      return;\n    }\n\n    errorHandler.tok_error(String.format(\"Token %s found where %s expected\", t, tok));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Reads the next token and checks that it matches tok.  If it does\n   * not match, calls the current error handling routine (see\n   * {@link #set_error_handler(StrTok.ErrorHandler) set_error_handler()}).\n   * If it does match, just returns.\n   * @param tok string to check next token against\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String tok","parameterName":"tok"}],"methodName":"need","methodQualifiedSignature":"plume.StrTok.need","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the next token and checks that it matches tok.  If it does\nnot match, calls the current error handling routine (see\n'}, JavadocInlineTag{tagName='link', type=LINK, content=' #set_error_handler(StrTok.ErrorHandler) set_error_handler()'}, JavadocSnippet{text=').\nIf it does match, just returns.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='string to check next token against'}]}', name=Optional[tok]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 213,col 42)-(line 213,col 75)","literalExprId":1,"literalExpr":"\"Token %s found where %s expected\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.StrTok.need(java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"next token, if if it a word; otherwise calls the error handling routine","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='next token, if if it a word; otherwise calls the error handling routine'}]}', name=Optional.empty}"}],"methodDeclaration":"public String need_word()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String t = nextToken();\n    if (!isWord()) {\n        errorHandler.tok_error(String.format(\"'%s' found where identifier expected\", t));\n    }\n    assert t != null : \"@AssumeAssertion(nullness): dependent: because of isWord check\";\n    return t;\n}","methodRange":"(line 222,col 3)-(line 229,col 3)","methodTokenRange":"public String need_word() {\n    String t = nextToken();\n    if (!isWord()) {\n      errorHandler.tok_error(String.format(\"'%s' found where identifier expected\", t));\n    }\n    assert t != null : \"@AssumeAssertion(nullness): dependent: because of isWord check\";\n    return t;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Reads the next token and checks to make sure that it is a word (id).\n   * If it is not a word, calls the error handling routine.  If it is,\n   * returns the string of the word.\n   * @return next token, if if it a word; otherwise calls the error handling routine\n   ","methodParameters":[],"methodName":"need_word","methodQualifiedSignature":"plume.StrTok.need_word","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the next token and checks to make sure that it is a word (id).\nIf it is not a word, calls the error handling routine.  If it is,\nreturns the string of the word.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='next token, if if it a word; otherwise calls the error handling routine'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 225,col 44)-(line 225,col 81)","literalExprId":1,"literalExpr":"\"'%s' found where identifier expected\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 227,col 17)-(line 227,col 20)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 227,col 24)-(line 227,col 87)","literalExprId":3,"literalExpr":"\"@AssumeAssertion(nullness): dependent: because of isWord check\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.StrTok.need_word()"}],"classJavadoc":"\/**\n * Provides a somewhat simpler interface for tokenizing strings than\n * does StreamTokenizer.  All tokenizing is done by StreamTokenizer. <p>\n *\n * The major difference from StreamTokenizer is that all tokens are\n * returned as strings.  EOF returns a null, EOL returns an empty string.\n * A delimiter is returned as a one-character string.  Words and numbers\n * are returned as strings.  Quoted strings are also returned as strings\n * including their quote characters (so they can easily be differentiated\n * from words and numbers).\n *\n * Other differences are: <ul>\n *  <li> Automatic setup for tokenizing strings.\n *  <li> Underscores are included in identifiers (words).\n *  <li> I\/O errors (which should be impossible when tokenizing strings) are\n *       converted to RuntimeExceptions so that every call doesn't have to\n *       be included in a try block.\n *  <li> Convenience functions isWord(), isQString(), and need().\n *  <li> Returned string tokens are interned for easier comparisons.\n * <\/ul>\n *\/\n","className":"StrTok","fields":[{"fieldRange":"(line 38,col 3)-(line 38,col 16)","fieldName":"reader","fieldJavadocComment":" Where to read tokens from. ","fieldTokenRange":"Reader reader;","fieldTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"Reader","fieldJavadoc":"Where to read tokens from.\n","fieldTypeResolvedDescribed":"java.io.Reader"},{"fieldRange":"(line 40,col 3)-(line 40,col 30)","fieldName":"stok","fieldJavadocComment":" The StreamTokenizer to which all work is delegated. ","fieldTokenRange":"public StreamTokenizer stok;","fieldTypeResolved":"ReferenceType{java.io.StreamTokenizer, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[],"fieldInitializer":"","fieldType":"StreamTokenizer","fieldJavadoc":"The StreamTokenizer to which all work is delegated.\n","fieldTypeResolvedDescribed":"java.io.StreamTokenizer"},{"fieldRange":"(line 42,col 3)-(line 42,col 28)","fieldName":"errorHandler","fieldJavadocComment":" How to handle errors. ","fieldTokenRange":"ErrorHandler errorHandler;","fieldTypeResolved":"ReferenceType{plume.StrTok.ErrorHandler, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"ErrorHandler","fieldJavadoc":"How to handle errors.\n","fieldTypeResolvedDescribed":"plume.StrTok.ErrorHandler"}]}],"sourceFileId":43,"packageName":"plume"},{"sourceFileName":"plume.Unpublicized","imports":[{"importId":1,"import":"import java.lang.annotation.ElementType;\n"},{"importId":2,"import":"import java.lang.annotation.Retention;\n"},{"importId":3,"import":"import java.lang.annotation.RetentionPolicy;\n"},{"importId":4,"import":"import java.lang.annotation.Target;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[],"classJavadoc":"\/**\n * Used in conjunction with the <code>@Option<\/code> annotation to signal\n * that the option should not be included in the usage message, unless an\n * optional include_unpublicized argument is supplied to the usage message\n * method and is true.\n * @see plume.Option\n * @see plume.Options\n * @see plume.OptionGroup\n * @see plume.OptionsDoclet\n *\/\n","className":"Unpublicized","fields":[]}],"sourceFileId":44,"packageName":"plume"},{"sourceFileName":"plume.TestPlume","imports":[{"importId":1,"import":"import static plume.Options.ArgException;\n"},{"importId":2,"import":"import java.io.ByteArrayInputStream;\n"},{"importId":3,"import":"import java.io.CharArrayWriter;\n"},{"importId":4,"import":"import java.io.File;\n"},{"importId":5,"import":"import java.io.IOException;\n"},{"importId":6,"import":"import java.text.DateFormat;\n"},{"importId":7,"import":"import java.text.SimpleDateFormat;\n"},{"importId":8,"import":"import java.util.ArrayList;\n"},{"importId":9,"import":"import java.util.Arrays;\n"},{"importId":10,"import":"import java.util.BitSet;\n"},{"importId":11,"import":"import java.util.Calendar;\n"},{"importId":12,"import":"import java.util.Collection;\n"},{"importId":13,"import":"import java.util.Comparator;\n"},{"importId":14,"import":"import java.util.Enumeration;\n"},{"importId":15,"import":"import java.util.Iterator;\n"},{"importId":16,"import":"import java.util.LinkedHashMap;\n"},{"importId":17,"import":"import java.util.List;\n"},{"importId":18,"import":"import java.util.Locale;\n"},{"importId":19,"import":"import java.util.Map;\n"},{"importId":20,"import":"import java.util.NoSuchElementException;\n"},{"importId":21,"import":"import java.util.Random;\n"},{"importId":22,"import":"import java.util.Vector;\n"},{"importId":23,"import":"import java.util.regex.Pattern;\n"},{"importId":24,"import":"import org.junit.Test;\n"}],"typeDeclarations":[{"constructors":[],"classOrInterface":[{"classOrInterfaceRange":"(line 1598,col 3)-(line 1618,col 3)","classOrInterfaceTokenRange":"public static class PrintOneIntPerTimePeriod {\n    \/**\n     * @param args  two-element array containing:  how many to print; how many milliseconds between each\n     *\/\n    public static void main(String[] args) {\n      if (args.length != 2) {\n        System.err.println(\"Needs 2 arguments, got \" + args.length);\n      }\n      int limit = Integer.parseInt(args[0]);\n      int period = Integer.parseInt(args[1]);\n      for (int i = 0; i < limit; i++) {\n        System.out.printf(\"out%d \", i);\n        System.err.printf(\"err%d \", i);\n        try {\n          Thread.sleep(period);\n        } catch (InterruptedException e) {\n          \/\/ We don't care if this is interrupted\n        }\n      }\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Print one integer periodically.\n   * <p>\n   * Example use from the command line, for one integer each half-second:\n   * <pre>  java plume.TestPlume\\$PrintOneIntPerSecond 500<\/pre>\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Print one integer periodically.\n<p>\nExample use from the command line, for one integer each half-second:\n<pre>  java plume.TestPlume\\$PrintOneIntPerSecond 500<\/pre>'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 2948,col 3)-(line 2978,col 3)","classOrInterfaceTokenRange":"public static class TestOptions {\n\n    \/\/ TODO: test the @Unpublicized annotation and the usage() message.\n\n    @Option(\"list of patterns\")\n    public List<Pattern> lp = new ArrayList<Pattern>();\n\n    @Option(\"-a <filename> argument 1\")\n    public String arg1 = \"\/tmp\/foobar\";\n\n    @Option(\"argument 2\")\n    public \/*@Nullable*\/ String arg2;\n\n    @Option(\"-d double value\")\n    public double temperature;\n\n    @Option(\"-f the input file\")\n    public \/*@Nullable*\/ File input_file;\n\n    @Option(\"-b boolean\")\n    public boolean bool;\n\n    @Option(\"-i Integer\")\n    public \/*@Nullable*\/ Integer integer_reference;\n\n    @Option(\"list of doubles\")\n    public List<Double> ld = new ArrayList<Double>();\n\n    @Option(\"list with no default\")\n    public \/*@Nullable*\/ List<String> ls;\n  }","classOrInterfaceJavadocComment":"\n   * Test class for Options testing.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test class for Options testing.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3049,col 3)-(line 3064,col 3)","classOrInterfaceTokenRange":"public static class TestOptionsAliases {\n    @Option(\"-d Set the day\")\n    public String day = \"Friday\";\n\n    @Option(\n      value = \"-t Set the temperature\",\n      aliases = {\"-temp\"}\n    )\n    public double temperature = 42.0;\n\n    @Option(\n      value = \"Print the program version\",\n      aliases = {\"-v\", \"-version\", \"--version\"}\n    )\n    public boolean printVersion = false;\n  }","classOrInterfaceJavadocComment":" Test class for option alias testing. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test class for option alias testing.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3109,col 3)-(line 3122,col 3)","classOrInterfaceTokenRange":"public static class TestOptionGroups1 {\n    @Option(\"-m Set the mass\")\n    public static int mass;\n\n    @OptionGroup(\"Coordinate options\")\n    @Option(\"-x Set the X coordinate\")\n    public static int x;\n\n    @Option(\"-y Set the Y coordinate\")\n    public static int y;\n\n    @Option(\"-z Set the Z coordinate\")\n    public static int z;\n  }","classOrInterfaceJavadocComment":" Test class for testing option groups. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test class for testing option groups.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3125,col 3)-(line 3147,col 3)","classOrInterfaceTokenRange":"public static class TestOptionGroups2 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(value = \"Internal options\", unpublicized = true)\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }","classOrInterfaceJavadocComment":" Test class for testing option groups. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test class for testing option groups.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3150,col 3)-(line 3173,col 3)","classOrInterfaceTokenRange":"public static class TestOptionGroups3 {\n    @OptionGroup(\"General options\")\n    @Option(\n      value = \"-h Display help message\",\n      aliases = {\"-help\"}\n    )\n    public static boolean help = false;\n\n    @OptionGroup(\"Internal options\")\n    @Unpublicized\n    @Option(\"Set mu\")\n    public static double mu = 4902.7;\n\n    @Unpublicized\n    @Option(\"Set pi\")\n    public static double pi = 3.14;\n\n    @OptionGroup(\"Display options\")\n    @Option(\n      value = \"Use colors\",\n      aliases = {\"--colour\"}\n    )\n    public static boolean color = false;\n  }","classOrInterfaceJavadocComment":" Test class for testing option groups. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test class for testing option groups.'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 3228,col 3)-(line 3240,col 3)","classOrInterfaceTokenRange":"public static class TestOptionsEnums {\n    enum Compressor {\n      RLE,\n      SMART_RLE,\n      HUFFMAN\n    }\n\n    @Option(\"Set the first compression pass\")\n    public static \/*@Nullable*\/ Compressor firstPass;\n\n    @Option(\"Set the second compression pass\")\n    public static \/*@Nullable*\/ Compressor secondPass;\n  }","classOrInterfaceJavadocComment":"","classOrInterfaceJavadoc":""}],"methods":[{"methodDeclaration":"public static void assert_arrays_equals(int[] a1, int[] a2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n        System.out.println(\"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n}","methodRange":"(line 77,col 3)-(line 86,col 3)","methodTokenRange":"public static void assert_arrays_equals(int \/*@Nullable*\/ [] a1, int \/*@Nullable*\/ [] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n    \/\/      assert(Arrays.equals(a1, a2),\n    \/\/         \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a1","parameterName":"a1"},{"parameterType":"int[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] a2","parameterName":"a2"}],"methodName":"assert_arrays_equals","methodQualifiedSignature":"plume.TestPlume.assert_arrays_equals","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 81,col 11)-(line 81,col 27)","literalExprId":1,"literalExpr":"\"Arrays differ: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 81,col 56)-(line 81,col 59)","literalExprId":2,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.assert_arrays_equals(int[], int[])"},{"methodDeclaration":"public static void assert_arrays_equals(double[] a1, double[] a2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n        System.out.println(\"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n}","methodRange":"(line 88,col 3)-(line 95,col 3)","methodTokenRange":"public static void assert_arrays_equals(double[] a1, double[] a2) {\n    boolean result = Arrays.equals(a1, a2);\n    if (!result) {\n      System.out.println(\n          \"Arrays differ: \" + ArraysMDE.toString(a1) + \", \" + ArraysMDE.toString(a2));\n    }\n    assert result;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a1","parameterName":"a1"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a2","parameterName":"a2"}],"methodName":"assert_arrays_equals","methodQualifiedSignature":"plume.TestPlume.assert_arrays_equals","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 92,col 11)-(line 92,col 27)","literalExprId":1,"literalExpr":"\"Arrays differ: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 92,col 56)-(line 92,col 59)","literalExprId":2,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.assert_arrays_equals(double[], double[])"},{"methodDeclaration":"public static Iterator<Integer> int_array_iterator(int[] nums)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n        asList.add(nums[i]);\n    }\n    return asList.iterator();\n}","methodRange":"(line 101,col 3)-(line 107,col 3)","methodTokenRange":"public static Iterator<Integer> int_array_iterator(int[] nums) {\n    List<Integer> asList = new ArrayList<Integer>(nums.length);\n    for (int i = 0; i < nums.length; i++) {\n      asList.add(nums[i]);\n    }\n    return asList.iterator();\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","parameterTypeResolvedDescribed":"int[]","parameter":"int[] nums","parameterName":"nums"}],"methodName":"int_array_iterator","methodQualifiedSignature":"plume.TestPlume.int_array_iterator","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Iterator<java.lang.Integer>","methodType":"Iterator<Integer>","literalExprs":[{"literalExprRange":"(line 103,col 18)-(line 103,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.int_array_iterator(int[])"},{"methodDeclaration":"public static int[] int_iterator_array(Iterator<Integer> itor)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n        a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n}","methodRange":"(line 109,col 3)-(line 119,col 3)","methodTokenRange":"public static int[] int_iterator_array(Iterator<Integer> itor) {\n    Vector<Integer> v = new Vector<Integer>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    int[] a = new int[v.size()];\n    for (int i = 0; i < a.length; i++) {\n      a[i] = v.elementAt(i).intValue();\n    }\n    return a;\n  }","methodReturnTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='int'}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Iterator<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<java.lang.Integer>","parameter":"Iterator<Integer> itor","parameterName":"itor"}],"methodName":"int_iterator_array","methodQualifiedSignature":"plume.TestPlume.int_iterator_array","methodJavadoc":"","methodReturnTypeDescribed":"int[]","methodType":"int[]","literalExprs":[{"literalExprRange":"(line 115,col 18)-(line 115,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.int_iterator_array(java.util.Iterator<java.lang.Integer>)"},{"methodDeclaration":"public static Vector<T> toVector(Iterator<T> itor)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n        v.add(itor.next());\n    }\n    return v;\n}","methodRange":"(line 121,col 3)-(line 127,col 3)","methodTokenRange":"public static <T> Vector<T> toVector(Iterator<T> itor) {\n    Vector<T> v = new Vector<T>();\n    while (itor.hasNext()) {\n      v.add(itor.next());\n    }\n    return v;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Iterator<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Iterator<T>","parameter":"Iterator<T> itor","parameterName":"itor"}],"methodName":"toVector","methodQualifiedSignature":"plume.TestPlume.toVector","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Vector<T>","methodType":"Vector<T>","literalExprs":[],"methodQualifiedName":"plume.TestPlume.toVector(java.util.Iterator<T>)"},{"methodDeclaration":"public static Vector<T> toVector(Enumeration<T> e)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n        v.add(e.nextElement());\n    }\n    return v;\n}","methodRange":"(line 129,col 3)-(line 135,col 3)","methodTokenRange":"public static <T> Vector<T> toVector(Enumeration<T> e) {\n    Vector<T> v = new Vector<T>();\n    while (e.hasMoreElements()) {\n      v.add(e.nextElement());\n    }\n    return v;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Vector, typeParametersMap=TypeParametersMap{nameToValue={java.util.Vector.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"Enumeration<T>","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.Enumeration, typeParametersMap=TypeParametersMap{nameToValue={java.util.Enumeration.E=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","parameterTypeResolvedDescribed":"java.util.Enumeration<T>","parameter":"Enumeration<T> e","parameterName":"e"}],"methodName":"toVector","methodQualifiedSignature":"plume.TestPlume.toVector","methodJavadoc":"","methodReturnTypeDescribed":"java.util.Vector<T>","methodType":"Vector<T>","literalExprs":[],"methodQualifiedName":"plume.TestPlume.toVector(java.util.Enumeration<T>)"},{"methodDeclaration":"public void testArraysMDE()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert ArraysMDE.min(new int[] { 1, 2, 3 }) == 1;\n    assert ArraysMDE.min(new int[] { 2, 33, 1 }) == 1;\n    assert ArraysMDE.min(new int[] { 3, -2, 1 }) == -2;\n    assert ArraysMDE.min(new int[] { 3 }) == 3;\n    assert ArraysMDE.max(new int[] { 1, 2, 3 }) == 3;\n    assert ArraysMDE.max(new int[] { 2, 33, 1 }) == 33;\n    assert ArraysMDE.max(new int[] { 3, -2, 1 }) == 3;\n    assert ArraysMDE.max(new int[] { 3 }) == 3;\n    assert_arrays_equals(ArraysMDE.min_max(new int[] { 1, 2, 3 }), new int[] { 1, 3 });\n    assert_arrays_equals(ArraysMDE.min_max(new int[] { 2, 33, 1 }), new int[] { 1, 33 });\n    assert_arrays_equals(ArraysMDE.min_max(new int[] { 3, -2, 1 }), new int[] { -2, 3 });\n    assert_arrays_equals(ArraysMDE.min_max(new int[] { 3 }), new int[] { 3, 3 });\n    try {\n        ArraysMDE.min_max(new int[] {});\n        throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n    try {\n        ArraysMDE.min_max(new long[] {});\n        throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n    assert 0 == ArraysMDE.sum(new int[0]);\n    assert 10 == ArraysMDE.sum(new int[] { 10 });\n    assert 10 == ArraysMDE.sum(new int[] { 1, 2, 3, 4 });\n    assert 0 == ArraysMDE.sum(new int[0][0]);\n    assert 78 == ArraysMDE.sum(new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } });\n    assert 68 == ArraysMDE.sum(new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 11, 12 } });\n    assert 0 == ArraysMDE.sum(new double[0]);\n    assert 3.14 == ArraysMDE.sum(new double[] { 3.14 });\n    assert 8.624 == ArraysMDE.sum(new double[] { 3.14, 2.718, -1.234, 4 });\n    assert 0 == ArraysMDE.sum(new double[0][0]);\n    assert 79.5 == ArraysMDE.sum(new double[][] { { 1.1, 2.2, 3.3, 4.4 }, { 5.5, 6, 7, 8 }, { 9, 10, 11, 12 } });\n    assert ArraysMDE.element_range(new int[] { 1, 2, 3 }) == 2;\n    assert ArraysMDE.element_range(new int[] { 2, 33, 1 }) == 32;\n    assert ArraysMDE.element_range(new int[] { 3, -2, 1 }) == 5;\n    assert ArraysMDE.element_range(new int[] { 3 }) == 0;\n    {\n        Integer[] a = new Integer[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = new Integer(i);\n        }\n        assert ArraysMDE.indexOf(a, new Integer(-1)) == -1;\n        assert ArraysMDE.indexOf(a, new Integer(0)) == 0;\n        assert ArraysMDE.indexOf(a, new Integer(7)) == 7;\n        assert ArraysMDE.indexOf(a, new Integer(9)) == 9;\n        assert ArraysMDE.indexOf(a, new Integer(10)) == -1;\n        assert ArraysMDE.indexOf(a, new Integer(20)) == -1;\n        assert ArraysMDE.indexOf(a, (Object) null) == -1;\n        assert ArraysMDE.indexOf(a, (Object) null, 1, 5) == -1;\n        assert ArraysMDE.indexOfEq(a, new Integer(-1)) == -1;\n        assert ArraysMDE.indexOfEq(a, new Integer(0)) == -1;\n        assert ArraysMDE.indexOfEq(a, new Integer(7)) == -1;\n        assert ArraysMDE.indexOfEq(a, new Integer(9)) == -1;\n        assert ArraysMDE.indexOfEq(a, new Integer(10)) == -1;\n        assert ArraysMDE.indexOfEq(a, new Integer(20)) == -1;\n        assert ArraysMDE.indexOfEq(a, (Object) null) == -1;\n        assert ArraysMDE.indexOfEq(a, (Object) null, 1, 5) == -1;\n        assert ArraysMDE.indexOfEq(a, a[0]) == 0;\n        assert ArraysMDE.indexOfEq(a, a[7]) == 7;\n        assert ArraysMDE.indexOfEq(a, a[9]) == 9;\n    }\n    {\n        assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n        assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n        assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n        assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n    }\n    {\n        int[] a = new int[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = i;\n        }\n        assert ArraysMDE.indexOf(a, -1) == -1;\n        assert ArraysMDE.indexOf(a, 0) == 0;\n        assert ArraysMDE.indexOf(a, 7) == 7;\n        assert ArraysMDE.indexOf(a, 9) == 9;\n        assert ArraysMDE.indexOf(a, 10) == -1;\n        assert ArraysMDE.indexOf(a, 20) == -1;\n    }\n    {\n        boolean[] a = new boolean[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = false;\n        }\n        assert ArraysMDE.indexOf(a, true) == -1;\n        assert ArraysMDE.indexOf(a, false) == 0;\n        a[9] = true;\n        assert ArraysMDE.indexOf(a, true) == 9;\n        assert ArraysMDE.indexOf(a, false) == 0;\n        a[7] = true;\n        assert ArraysMDE.indexOf(a, true) == 7;\n        assert ArraysMDE.indexOf(a, false) == 0;\n        a[0] = true;\n        assert ArraysMDE.indexOf(a, true) == 0;\n        assert ArraysMDE.indexOf(a, false) == 1;\n        for (int i = 0; i < a.length; i++) {\n            a[i] = true;\n        }\n        assert ArraysMDE.indexOf(a, true) == 0;\n        assert ArraysMDE.indexOf(a, false) == -1;\n    }\n    {\n        Integer[] a = new Integer[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = new Integer(i);\n        }\n        Integer[] b = new Integer[] {};\n        Integer[] c = new Integer[] { a[0], a[1], a[2] };\n        Integer[] d = new Integer[] { a[1], a[2] };\n        Integer[] e = new Integer[] { a[2], a[3], a[4], a[5] };\n        Integer[] f = new Integer[] { a[7], a[8], a[9] };\n        Integer[] g = new Integer[] { a[7], new Integer(8), a[9] };\n        Integer[] h = new Integer[] { a[7], a[8], a[9], new Integer(10) };\n        @SuppressWarnings(\"nullness\")\n        Integer[] i = new Integer[] { a[7], a[8], null, a[9], new Integer(10) };\n        @SuppressWarnings(\"nullness\")\n        Integer[] j = new Integer[] { a[8], null, a[9] };\n        Integer[] c2 = new Integer[] { new Integer(0), new Integer(1), new Integer(2) };\n        Integer[] d2 = new Integer[] { new Integer(1), new Integer(2) };\n        Integer[] e2 = new Integer[] { new Integer(2), new Integer(3), new Integer(4), new Integer(5) };\n        Integer[] f2 = new Integer[] { new Integer(7), new Integer(8), new Integer(9) };\n        assert ArraysMDE.indexOf(a, b) == 0;\n        assert ArraysMDE.indexOfEq(a, b) == 0;\n        assert ArraysMDE.indexOf(a, c) == 0;\n        assert ArraysMDE.indexOfEq(a, c) == 0;\n        assert ArraysMDE.indexOf(a, c2) == 0;\n        assert ArraysMDE.indexOfEq(a, c2) == -1;\n        assert ArraysMDE.indexOf(a, d) == 1;\n        assert ArraysMDE.indexOfEq(a, d) == 1;\n        assert ArraysMDE.indexOf(a, d2) == 1;\n        assert ArraysMDE.indexOfEq(a, d2) == -1;\n        assert ArraysMDE.indexOf(a, e) == 2;\n        assert ArraysMDE.indexOfEq(a, e) == 2;\n        assert ArraysMDE.indexOf(a, e2) == 2;\n        assert ArraysMDE.indexOfEq(a, e2) == -1;\n        assert ArraysMDE.indexOf(a, f) == 7;\n        assert ArraysMDE.indexOfEq(a, f) == 7;\n        assert ArraysMDE.indexOf(a, f2) == 7;\n        assert ArraysMDE.indexOfEq(a, f2) == -1;\n        assert ArraysMDE.indexOf(a, g) == 7;\n        assert ArraysMDE.indexOfEq(a, g) == -1;\n        assert ArraysMDE.indexOf(a, h) == -1;\n        assert ArraysMDE.indexOfEq(a, h) == -1;\n        assert ArraysMDE.indexOf(i, j) == 1;\n        assert ArraysMDE.indexOfEq(i, j) == 1;\n        assert ArraysMDE.indexOf(a, i) == -1;\n        assert ArraysMDE.indexOfEq(a, i) == -1;\n    }\n    {\n        int[] a = new int[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = i;\n        }\n        int[] b = new int[] {};\n        int[] c = new int[] { a[0], a[1], a[2] };\n        int[] d = new int[] { a[1], a[2] };\n        int[] e = new int[] { a[2], a[3], a[4], a[5] };\n        int[] f = new int[] { a[7], a[8], a[9] };\n        int[] g = new int[] { a[7], 22, a[9] };\n        int[] h = new int[] { a[7], a[8], a[9], 10 };\n        assert ArraysMDE.indexOf(a, b) == 0;\n        assert ArraysMDE.indexOf(a, c) == 0;\n        assert ArraysMDE.indexOf(a, d) == 1;\n        assert ArraysMDE.indexOf(a, e) == 2;\n        assert ArraysMDE.indexOf(a, f) == 7;\n        assert ArraysMDE.indexOf(a, g) == -1;\n        assert ArraysMDE.indexOf(a, h) == -1;\n        int[] origTheArray = new int[] { 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        int[] postTheArray = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        assert ArraysMDE.indexOf(postTheArray, origTheArray) == -1;\n        assert ArraysMDE.indexOf(origTheArray, postTheArray) == -1;\n    }\n    {\n        assert ArraysMDE.toString((Object[]) null).equals(\"null\");\n        assert ArraysMDE.toStringQuoted((Object[]) null).equals(\"null\");\n        assert ArraysMDE.toString((List<?>) null).equals(\"null\");\n        assert ArraysMDE.toStringQuoted((List<?>) null).equals(\"null\");\n        assert ArraysMDE.toStringQuoted(Arrays.asList(new Object[] { 3.14, null, \"hello\" })).equals(\"[3.14, null, \\\"hello\\\"]\");\n    }\n    assert ArraysMDE.toString(new int[] {}).equals(\"[]\");\n    assert ArraysMDE.toString(new int[] { 0 }).equals(\"[0]\");\n    assert ArraysMDE.toString(new int[] { 0, 1, 2 }).equals(\"[0, 1, 2]\");\n    assert ArraysMDE.sorted(new int[] { 0, 1, 2 });\n    assert ArraysMDE.sorted(new int[] { 0, 1, 2, 2, 3, 3 });\n    assert ArraysMDE.sorted(new int[] {});\n    assert ArraysMDE.sorted(new int[] { 0 });\n    assert ArraysMDE.sorted(new int[] { 0, 1 });\n    assert !ArraysMDE.sorted(new int[] { 1, 0 });\n    assert !ArraysMDE.sorted(new int[] { 0, 1, 2, 1, 2, 3 });\n    assert ArraysMDE.noDuplicates(new int[] { 1, 2, 3, 5, 4, 0 }) == true;\n    assert ArraysMDE.noDuplicates(new int[] { 1, 2, 3, 5, 4, 100 }) == true;\n    assert ArraysMDE.noDuplicates(new int[] { 2, 2, 3, 5, 4, 0 }) == false;\n    assert ArraysMDE.noDuplicates(new int[] { 1, 2, 3, 5, 4, 1 }) == false;\n    assert ArraysMDE.noDuplicates(new int[] { 1, 2, -3, -5, 4, 0 }) == true;\n    assert ArraysMDE.noDuplicates(new int[] { 1, 2, -2, -2, 4, 100 }) == false;\n    assert ArraysMDE.noDuplicates(new int[] {}) == true;\n    assert ArraysMDE.noDuplicates(new int[] { 42 }) == true;\n    assert ArraysMDE.noDuplicates(new long[] { 1, 2, 3, 5, 4, 0 }) == true;\n    assert ArraysMDE.noDuplicates(new long[] { 1, 2, 3, 5, 4, 100 }) == true;\n    assert ArraysMDE.noDuplicates(new long[] { 2, 2, 3, 5, 4, 0 }) == false;\n    assert ArraysMDE.noDuplicates(new long[] { 1, 2, 3, 5, 4, 1 }) == false;\n    assert ArraysMDE.noDuplicates(new long[] { 1, 2, -3, -5, 4, 0 }) == true;\n    assert ArraysMDE.noDuplicates(new long[] { 1, 2, -2, -2, 4, 100 }) == false;\n    assert ArraysMDE.noDuplicates(new long[] {}) == true;\n    assert ArraysMDE.noDuplicates(new long[] { 42 }) == true;\n    assert ArraysMDE.noDuplicates(new double[] { 1, 2, 3, 5, 4, 0 }) == true;\n    assert ArraysMDE.noDuplicates(new double[] { 1, 2, 3, 5, 4, 100 }) == true;\n    assert ArraysMDE.noDuplicates(new double[] { 2, 2, 3, 5, 4, 0 }) == false;\n    assert ArraysMDE.noDuplicates(new double[] { 1, 2, 3, 5, 4, 1 }) == false;\n    assert ArraysMDE.noDuplicates(new double[] { 1., 1.001, -3, -5, 4, 0 }) == true;\n    assert ArraysMDE.noDuplicates(new double[] { 1., 2, -2.00, -2, 4, 100 }) == false;\n    assert ArraysMDE.noDuplicates(new double[] {}) == true;\n    assert ArraysMDE.noDuplicates(new double[] { 42 }) == true;\n    assert ArraysMDE.noDuplicates(new String[] { \"1\", \"2\", \"3\", \"5\", \"4\", \"0\" }) == true;\n    assert ArraysMDE.noDuplicates(new String[] { \"A\", \"a\", \"foo\", \"Foo\", \"\" }) == true;\n    assert ArraysMDE.noDuplicates(new String[] { \" \", \" \" }) == false;\n    assert ArraysMDE.noDuplicates(new String[] { \"  \", \" \" }) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] { 0, 1, 2, 3 }) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] { 1, 2, 3, 0 }) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] { 3, 2, 1, 0 }) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] { 0, 1, 2, 2 }) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] { 0, -1, 2, 3 }) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] { 0, 1, 2, 4 }) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] { 0, 0, 0, 0 }) == false;\n    assert ArraysMDE.fn_is_total(new int[] { 0, 1, 2, 3 }) == true;\n    assert ArraysMDE.fn_is_total(new int[] { 1, 2, 3, 0 }) == true;\n    assert ArraysMDE.fn_is_total(new int[] { 3, 2, 1, 0 }) == true;\n    assert ArraysMDE.fn_is_total(new int[] { 0, 1, 2, 2 }) == true;\n    assert ArraysMDE.fn_is_total(new int[] { -1, 0, 2, 3 }) == false;\n    assert ArraysMDE.fn_is_total(new int[] { 0, -1, 2, 3 }) == false;\n    assert ArraysMDE.fn_is_total(new int[] { 0, -2, 1, 3 }) == true;\n    assert ArraysMDE.fn_is_total(new int[] { 0, 2, 3, -1 }) == false;\n    assert ArraysMDE.fn_is_total(new int[] { 0, 1, 2, 4 }) == true;\n    assert ArraysMDE.fn_is_total(new int[] { 0, 0, 0, 0 }) == true;\n    assert_arrays_equals(ArraysMDE.fn_identity(0), new int[] {});\n    assert_arrays_equals(ArraysMDE.fn_identity(1), new int[] { 0 });\n    assert_arrays_equals(ArraysMDE.fn_identity(2), new int[] { 0, 1 });\n    assert_arrays_equals(ArraysMDE.fn_identity(3), new int[] { 0, 1, 2 });\n    assert_arrays_equals(ArraysMDE.fn_inverse_permutation(new int[] { 0, 1, 2, 3 }), new int[] { 0, 1, 2, 3 });\n    assert_arrays_equals(ArraysMDE.fn_inverse_permutation(new int[] { 1, 2, 3, 0 }), new int[] { 3, 0, 1, 2 });\n    assert_arrays_equals(ArraysMDE.fn_inverse_permutation(new int[] { 3, 2, 1, 0 }), new int[] { 3, 2, 1, 0 });\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] { 0, 1, 2, 3 }, 4), new int[] { 0, 1, 2, 3 });\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] { 1, 2, 3, 0 }, 4), new int[] { 3, 0, 1, 2 });\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] { 3, 2, 1, 0 }, 4), new int[] { 3, 2, 1, 0 });\n    try {\n        ArraysMDE.fn_inverse(new int[] { 1, 0, 3, 0 }, 4);\n        throw new Error();\n    } catch (UnsupportedOperationException e) {\n        assert e.getMessage() != null && e.getMessage().equals(\"Not invertible; a[1]=0 and a[3]=0\");\n    }\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] { 5 }, 6), new int[] { -1, -1, -1, -1, -1, 0 });\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] { 1, 2, 3, 5 }, 6), new int[] { -1, 0, 1, 2, -1, 3 });\n    try {\n        assert_arrays_equals(ArraysMDE.fn_inverse(new int[] { 100, 101, 102, 103 }, 4), new int[] { 40, 41, 42, 43 });\n        throw new Error();\n    } catch (IllegalArgumentException e) {\n        assert e.getMessage() != null && e.getMessage().equals(\"Bad range value: a[0]=100\");\n    }\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] { 0, 1, 2, 3 }, new int[] { 0, 1, 2, 3 }), new int[] { 0, 1, 2, 3 });\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] { 1, 2, 3, 0 }, new int[] { 1, 2, 3, 0 }), new int[] { 2, 3, 0, 1 });\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] { 3, 2, 1, 0 }, new int[] { 3, 2, 1, 0 }), new int[] { 0, 1, 2, 3 });\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] { 0, 1, 0, 3 }, new int[] { 0, 5, 2, 1 }), new int[] { 0, 5, 0, 1 });\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] { 0 }, new int[] { 5 }), new int[] { 5 });\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] { 1, 2, 3, 5 }, new int[] { 1, 2, 3, 5, -1, -1 }), new int[] { 2, 3, 5, -1 });\n    {\n        double[] f1 = new double[10];\n        double[] f2 = new double[20];\n        for (int j = 0; j < f2.length; j++) {\n            f2[j] = j;\n        }\n        for (int i = 0; i < f2.length - f1.length; i++) {\n            for (int j = 0; j < f1.length; j++) {\n                f1[j] = f2[i + j];\n            }\n            f1[5] = f2[i];\n            double[] f1_copy = f1.clone();\n            double[] f2_copy = f2.clone();\n            assert ArraysMDE.isSubset(f1, f2);\n            assert_arrays_equals(f1, f1_copy);\n            assert_arrays_equals(f2, f2_copy);\n        }\n        double[] a1 = new double[] { 1, 5, 10 };\n        double[] a2 = new double[] {};\n        double[] a3 = new double[] { 1 };\n        double[] a4 = new double[] { 10 };\n        double[] a5 = new double[] { 1, 10, 15, 20 };\n        double[] a6 = new double[] { 10, 10, 10, 10, 10, 1 };\n        assert ArraysMDE.isSubset(a2, a1);\n        assert !ArraysMDE.isSubset(a1, a2);\n        assert !ArraysMDE.isSubset(a1, a5);\n        assert ArraysMDE.isSubset(a3, a1);\n        assert ArraysMDE.isSubset(a4, a1);\n        assert ArraysMDE.isSubset(a6, a1);\n        assert !ArraysMDE.isSubset(a1, a6);\n    }\n    {\n        Comparator<int[]> iacl = new ArraysMDE.IntArrayComparatorLexical();\n        Comparator<int[]> iaclf = new ArraysMDE.IntArrayComparatorLengthFirst();\n        int[] a0 = new int[] {};\n        int[] a1 = new int[] {};\n        int[] a2 = new int[] { 0, 1, 2, 3 };\n        int[] a3 = new int[] { 0, 1, 2, 3, 0 };\n        int[] a4 = new int[] { 0, 1, 2, 3, 4 };\n        int[] a5 = new int[] { 0, 1, 2, 3, 4 };\n        int[] a6 = new int[] { 0, 1, 5, 3, 4 };\n        int[] a7 = new int[] { 1, 2, 3, 4 };\n        int[] a8 = new int[] { -5 };\n        int[] a9 = new int[] { Integer.MAX_VALUE };\n        int[] a10 = new int[] { Integer.MIN_VALUE };\n        assert iacl.compare(a0, a1) == 0;\n        assert iaclf.compare(a0, a1) == 0;\n        assert iacl.compare(a1, a0) == 0;\n        assert iaclf.compare(a1, a0) == 0;\n        assert iacl.compare(a1, a2) < 0;\n        assert iaclf.compare(a1, a2) < 0;\n        assert iacl.compare(a2, a1) > 0;\n        assert iaclf.compare(a2, a1) > 0;\n        assert iacl.compare(a2, a3) < 0;\n        assert iaclf.compare(a2, a3) < 0;\n        assert iacl.compare(a3, a2) > 0;\n        assert iaclf.compare(a3, a2) > 0;\n        assert iacl.compare(a3, a4) < 0;\n        assert iaclf.compare(a3, a4) < 0;\n        assert iacl.compare(a4, a3) > 0;\n        assert iaclf.compare(a4, a3) > 0;\n        assert iacl.compare(a4, a5) == 0;\n        assert iaclf.compare(a4, a5) == 0;\n        assert iacl.compare(a5, a4) == 0;\n        assert iaclf.compare(a5, a4) == 0;\n        assert iacl.compare(a5, a6) < 0;\n        assert iaclf.compare(a5, a6) < 0;\n        assert iacl.compare(a6, a5) > 0;\n        assert iaclf.compare(a6, a5) > 0;\n        assert iacl.compare(a6, a7) < 0;\n        assert iaclf.compare(a6, a7) > 0;\n        assert iacl.compare(a7, a6) > 0;\n        assert iaclf.compare(a7, a6) < 0;\n        assert iacl.compare(a1, a4) < 0;\n        assert iaclf.compare(a1, a4) < 0;\n        assert iacl.compare(a4, a1) > 0;\n        assert iaclf.compare(a4, a1) > 0;\n        assert iacl.compare(a2, a4) < 0;\n        assert iaclf.compare(a2, a4) < 0;\n        assert iacl.compare(a4, a2) > 0;\n        assert iaclf.compare(a4, a2) > 0;\n        assert iacl.compare(a6, a4) > 0;\n        assert iaclf.compare(a6, a4) > 0;\n        assert iacl.compare(a4, a6) < 0;\n        assert iaclf.compare(a4, a6) < 0;\n        assert iacl.compare(a7, a4) > 0;\n        assert iaclf.compare(a7, a4) < 0;\n        assert iacl.compare(a4, a7) < 0;\n        assert iaclf.compare(a4, a7) > 0;\n        assert iacl.compare(a8, a9) < 0;\n        assert iaclf.compare(a8, a9) < 0;\n        assert iacl.compare(a10, a7) < 0;\n    }\n    {\n        Comparator<long[]> lacl = new ArraysMDE.LongArrayComparatorLexical();\n        Comparator<long[]> laclf = new ArraysMDE.LongArrayComparatorLengthFirst();\n        long[] a0 = new long[] {};\n        long[] a1 = new long[] {};\n        long[] a2 = new long[] { 0, 1, 2, 3 };\n        long[] a3 = new long[] { 0, 1, 2, 3, 0 };\n        long[] a4 = new long[] { 0, 1, 2, 3, 4 };\n        long[] a5 = new long[] { 0, 1, 2, 3, 4 };\n        long[] a6 = new long[] { 0, 1, 5, 3, 4 };\n        long[] a7 = new long[] { 1, 2, 3, 4 };\n        long[] a8 = new long[] { -5 };\n        long[] a9 = new long[] { Long.MAX_VALUE };\n        long[] a10 = new long[] { Long.MIN_VALUE };\n        assert lacl.compare(a0, a1) == 0;\n        assert laclf.compare(a0, a1) == 0;\n        assert lacl.compare(a1, a0) == 0;\n        assert laclf.compare(a1, a0) == 0;\n        assert lacl.compare(a1, a2) < 0;\n        assert laclf.compare(a1, a2) < 0;\n        assert lacl.compare(a2, a1) > 0;\n        assert laclf.compare(a2, a1) > 0;\n        assert lacl.compare(a2, a3) < 0;\n        assert laclf.compare(a2, a3) < 0;\n        assert lacl.compare(a3, a2) > 0;\n        assert laclf.compare(a3, a2) > 0;\n        assert lacl.compare(a3, a4) < 0;\n        assert laclf.compare(a3, a4) < 0;\n        assert lacl.compare(a4, a3) > 0;\n        assert laclf.compare(a4, a3) > 0;\n        assert lacl.compare(a4, a5) == 0;\n        assert laclf.compare(a4, a5) == 0;\n        assert lacl.compare(a5, a4) == 0;\n        assert laclf.compare(a5, a4) == 0;\n        assert lacl.compare(a5, a6) < 0;\n        assert laclf.compare(a5, a6) < 0;\n        assert lacl.compare(a6, a5) > 0;\n        assert laclf.compare(a6, a5) > 0;\n        assert lacl.compare(a6, a7) < 0;\n        assert laclf.compare(a6, a7) > 0;\n        assert lacl.compare(a7, a6) > 0;\n        assert laclf.compare(a7, a6) < 0;\n        assert lacl.compare(a1, a4) < 0;\n        assert laclf.compare(a1, a4) < 0;\n        assert lacl.compare(a4, a1) > 0;\n        assert laclf.compare(a4, a1) > 0;\n        assert lacl.compare(a2, a4) < 0;\n        assert laclf.compare(a2, a4) < 0;\n        assert lacl.compare(a4, a2) > 0;\n        assert laclf.compare(a4, a2) > 0;\n        assert lacl.compare(a6, a4) > 0;\n        assert laclf.compare(a6, a4) > 0;\n        assert lacl.compare(a4, a6) < 0;\n        assert laclf.compare(a4, a6) < 0;\n        assert lacl.compare(a7, a4) > 0;\n        assert laclf.compare(a7, a4) < 0;\n        assert lacl.compare(a4, a7) < 0;\n        assert laclf.compare(a4, a7) > 0;\n        assert lacl.compare(a8, a9) < 0;\n        assert laclf.compare(a8, a9) < 0;\n        assert lacl.compare(a10, a7) < 0;\n    }\n    {\n        Comparator<double[]> dacl = new ArraysMDE.DoubleArrayComparatorLexical();\n        double[] a0 = new double[] {};\n        double[] a1 = new double[] {};\n        double[] a2 = new double[] { 0, 1, 2, 3 };\n        double[] a3 = new double[] { 0, 1, 2, 3, 0 };\n        double[] a4 = new double[] { 0, 1, 2, 3, 4 };\n        double[] a5 = new double[] { 0, 1, 2, 3, 4 };\n        double[] a6 = new double[] { 0, 1, 5, 3, 4 };\n        double[] a7 = new double[] { 1, 2, 3, 4 };\n        double[] a8 = new double[] { 0.005 };\n        double[] a9 = new double[] { 0.004 };\n        double[] a10 = new double[] { -0.005 };\n        double[] a11 = new double[] { -0.004 };\n        double[] a12 = new double[] { 10.0 * Integer.MAX_VALUE };\n        double[] a13 = new double[] { 10.0 * Integer.MIN_VALUE };\n        assert dacl.compare(a0, a1) == 0;\n        assert dacl.compare(a1, a0) == 0;\n        assert dacl.compare(a1, a2) < 0;\n        assert dacl.compare(a2, a1) > 0;\n        assert dacl.compare(a2, a3) < 0;\n        assert dacl.compare(a3, a2) > 0;\n        assert dacl.compare(a3, a4) < 0;\n        assert dacl.compare(a4, a3) > 0;\n        assert dacl.compare(a4, a5) == 0;\n        assert dacl.compare(a5, a4) == 0;\n        assert dacl.compare(a5, a6) < 0;\n        assert dacl.compare(a6, a5) > 0;\n        assert dacl.compare(a6, a7) < 0;\n        assert dacl.compare(a7, a6) > 0;\n        assert dacl.compare(a1, a4) < 0;\n        assert dacl.compare(a4, a1) > 0;\n        assert dacl.compare(a2, a4) < 0;\n        assert dacl.compare(a4, a2) > 0;\n        assert dacl.compare(a6, a4) > 0;\n        assert dacl.compare(a4, a6) < 0;\n        assert dacl.compare(a7, a4) > 0;\n        assert dacl.compare(a4, a7) < 0;\n        assert dacl.compare(a8, a9) > 0;\n        assert dacl.compare(a10, a11) < 0;\n        assert dacl.compare(a11, a12) < 0;\n        assert dacl.compare(a12, a13) > 0;\n        assert dacl.compare(a13, a11) < 0;\n    }\n    {\n        Comparator<String[]> cacl = new ArraysMDE.ComparableArrayComparatorLexical<String>();\n        Comparator<String[]> caclf = new ArraysMDE.ComparableArrayComparatorLengthFirst<String>();\n        String[] a0 = new String[] {};\n        String[] a1 = new String[] {};\n        String[] a2 = new String[] { \"0\", \"1\", \"2\", \"3\" };\n        String[] a3 = new String[] { \"0\", \"1\", \"2\", \"3\", \"0\" };\n        String[] a4 = new String[] { \"0\", \"1\", \"2\", \"3\", \"4\" };\n        String[] a5 = new String[] { \"0\", \"1\", \"2\", \"3\", \"4\" };\n        String[] a6 = new String[] { \"0\", \"1\", \"5\", \"3\", \"4\" };\n        String[] a7 = new String[] { \"1\", \"2\", \"3\", \"4\" };\n        @SuppressWarnings(\"nullness\")\n        String[] a8 = new String[] { \"0\", \"1\", null, \"3\", \"4\" };\n        assert cacl.compare(a0, a1) == 0;\n        assert caclf.compare(a0, a1) == 0;\n        assert cacl.compare(a1, a0) == 0;\n        assert caclf.compare(a1, a0) == 0;\n        assert cacl.compare(a1, a2) < 0;\n        assert caclf.compare(a1, a2) < 0;\n        assert cacl.compare(a2, a1) > 0;\n        assert caclf.compare(a2, a1) > 0;\n        assert cacl.compare(a2, a3) < 0;\n        assert caclf.compare(a2, a3) < 0;\n        assert cacl.compare(a3, a2) > 0;\n        assert caclf.compare(a3, a2) > 0;\n        assert cacl.compare(a3, a4) < 0;\n        assert caclf.compare(a3, a4) < 0;\n        assert cacl.compare(a4, a3) > 0;\n        assert caclf.compare(a4, a3) > 0;\n        assert cacl.compare(a4, a5) == 0;\n        assert caclf.compare(a4, a5) == 0;\n        assert cacl.compare(a5, a4) == 0;\n        assert caclf.compare(a5, a4) == 0;\n        assert cacl.compare(a5, a6) < 0;\n        assert caclf.compare(a5, a6) < 0;\n        assert cacl.compare(a6, a5) > 0;\n        assert caclf.compare(a6, a5) > 0;\n        assert cacl.compare(a6, a7) < 0;\n        assert caclf.compare(a6, a7) > 0;\n        assert cacl.compare(a7, a6) > 0;\n        assert caclf.compare(a7, a6) < 0;\n        assert cacl.compare(a1, a4) < 0;\n        assert caclf.compare(a1, a4) < 0;\n        assert cacl.compare(a4, a1) > 0;\n        assert caclf.compare(a4, a1) > 0;\n        assert cacl.compare(a2, a4) < 0;\n        assert caclf.compare(a2, a4) < 0;\n        assert cacl.compare(a4, a2) > 0;\n        assert caclf.compare(a4, a2) > 0;\n        assert cacl.compare(a6, a4) > 0;\n        assert caclf.compare(a6, a4) > 0;\n        assert cacl.compare(a4, a6) < 0;\n        assert caclf.compare(a4, a6) < 0;\n        assert cacl.compare(a7, a4) > 0;\n        assert caclf.compare(a7, a4) < 0;\n        assert cacl.compare(a8, a1) > 0;\n        assert caclf.compare(a8, a1) > 0;\n        assert cacl.compare(a1, a8) < 0;\n        assert caclf.compare(a1, a8) < 0;\n        assert cacl.compare(a8, a2) < 0;\n        assert caclf.compare(a8, a2) > 0;\n        assert cacl.compare(a2, a8) > 0;\n        assert caclf.compare(a2, a8) < 0;\n        assert cacl.compare(a8, a3) < 0;\n        assert caclf.compare(a8, a3) < 0;\n        assert cacl.compare(a3, a8) > 0;\n        assert caclf.compare(a3, a8) > 0;\n    }\n    {\n        Object o = new Object();\n        assert ArraysMDE.any_null(new Object[] {}) == false;\n        assert ArraysMDE.any_null(new Object[] { null }) == true;\n        assert ArraysMDE.any_null(new Object[] { null, null }) == true;\n        assert ArraysMDE.any_null(new Object[] { o }) == false;\n        assert ArraysMDE.any_null(new Object[] { o, o }) == false;\n        assert ArraysMDE.any_null(new Object[] { o, null, null }) == true;\n        assert ArraysMDE.any_null(new Object[] { null, o, null }) == true;\n        assert ArraysMDE.any_null(new Object[] { o, null, o }) == true;\n        assert ArraysMDE.any_null(new Object[] { null, o, o }) == true;\n        assert ArraysMDE.any_null(new Object[][] {}) == false;\n        assert ArraysMDE.any_null(new Object[][] { null }) == true;\n        assert ArraysMDE.any_null(new Object[][] { new Object[] { null } }) == false;\n        assert ArraysMDE.any_null(new Object[][] { new Object[] { null }, null }) == true;\n        assert ArraysMDE.any_null(new Object[][] { new Object[] { null }, new Object[] { o } }) == false;\n    }\n    {\n        Object o = new Object();\n        assert ArraysMDE.all_null(new Object[] {}) == true;\n        assert ArraysMDE.all_null(new Object[] { null }) == true;\n        assert ArraysMDE.all_null(new Object[] { null, null }) == true;\n        assert ArraysMDE.all_null(new Object[] { o }) == false;\n        assert ArraysMDE.all_null(new Object[] { o, o }) == false;\n        assert ArraysMDE.all_null(new Object[] { o, null, null }) == false;\n        assert ArraysMDE.all_null(new Object[] { null, o, null }) == false;\n        assert ArraysMDE.all_null(new Object[] { o, null, o }) == false;\n        assert ArraysMDE.all_null(new Object[] { null, o, o }) == false;\n        assert ArraysMDE.all_null(new Object[][] {}) == true;\n        assert ArraysMDE.all_null(new Object[][] { null }) == true;\n        assert ArraysMDE.all_null(new Object[][] { null, null }) == true;\n        assert ArraysMDE.all_null(new Object[][] { new Object[] { null } }) == false;\n        assert ArraysMDE.all_null(new Object[][] { new Object[] { null }, null }) == false;\n        assert ArraysMDE.all_null(new Object[][] { new Object[] { null }, new Object[] { o } }) == false;\n    }\n}","methodRange":"(line 141,col 3)-(line 867,col 3)","methodTokenRange":"@Test\n  public void testArraysMDE() {\n\n    \/\/ public static int min(int[] a)\n    assert ArraysMDE.min(new int[] {1, 2, 3}) == 1;\n    assert ArraysMDE.min(new int[] {2, 33, 1}) == 1;\n    assert ArraysMDE.min(new int[] {3, -2, 1}) == -2;\n    assert ArraysMDE.min(new int[] {3}) == 3;\n\n    \/\/ public static int max(int[] a)\n    assert ArraysMDE.max(new int[] {1, 2, 3}) == 3;\n    assert ArraysMDE.max(new int[] {2, 33, 1}) == 33;\n    assert ArraysMDE.max(new int[] {3, -2, 1}) == 3;\n    assert ArraysMDE.max(new int[] {3}) == 3;\n\n    \/\/ public static int[] min_max(int[] a)\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {1, 2, 3}), new int[] {1, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {2, 33, 1}), new int[] {1, 33});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3, -2, 1}), new int[] {-2, 3});\n    assert_arrays_equals(ArraysMDE.min_max(new int[] {3}), new int[] {3, 3});\n    try {\n      ArraysMDE.min_max(new int[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n    try {\n      ArraysMDE.min_max(new long[] {});\n      throw new Error(\"Didn't throw ArrayIndexOutOfBoundsException\");\n    } catch (ArrayIndexOutOfBoundsException e) {\n    }\n\n    \/\/ public static int sum(int[] a)\n    assert 0 == ArraysMDE.sum(new int[0]);\n    assert 10 == ArraysMDE.sum(new int[] {10});\n    assert 10 == ArraysMDE.sum(new int[] {1, 2, 3, 4});\n\n    \/\/ public static int sum(int[][] a)\n    assert 0 == ArraysMDE.sum(new int[0][0]);\n    assert 78 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}});\n    assert 68 == ArraysMDE.sum(new int[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 11, 12}});\n\n    \/\/ public static double sum(double[] a)\n    assert 0 == ArraysMDE.sum(new double[0]);\n    assert 3.14 == ArraysMDE.sum(new double[] {3.14});\n    assert 8.624 == ArraysMDE.sum(new double[] {3.14, 2.718, -1.234, 4});\n\n    \/\/ public static double sum(double[][] a)\n    assert 0 == ArraysMDE.sum(new double[0][0]);\n    assert 79.5\n        == ArraysMDE.sum(new double[][] {{1.1, 2.2, 3.3, 4.4}, {5.5, 6, 7, 8}, {9, 10, 11, 12}});\n\n    \/\/ public static int element_range(int[] a)\n    assert ArraysMDE.element_range(new int[] {1, 2, 3}) == 2;\n    assert ArraysMDE.element_range(new int[] {2, 33, 1}) == 32;\n    assert ArraysMDE.element_range(new int[] {3, -2, 1}) == 5;\n    assert ArraysMDE.element_range(new int[] {3}) == 0;\n\n    \/\/ public static int indexOf(Object[] a, Object elt)\n    \/\/ public static int indexOfEq(Object[] a, Object elt)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      assert ArraysMDE.indexOf(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(0)) == 0;\n      assert ArraysMDE.indexOf(a, new Integer(7)) == 7;\n      assert ArraysMDE.indexOf(a, new Integer(9)) == 9;\n      assert ArraysMDE.indexOf(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOf(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null) == -1;\n      assert ArraysMDE.indexOf(a, (Object) null, 1, 5) == -1;\n\n      assert ArraysMDE.indexOfEq(a, new Integer(-1)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(0)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(7)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(9)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(10)) == -1;\n      assert ArraysMDE.indexOfEq(a, new Integer(20)) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null) == -1;\n      assert ArraysMDE.indexOfEq(a, (Object) null, 1, 5) == -1;\n      assert ArraysMDE.indexOfEq(a, a[0]) == 0;\n      assert ArraysMDE.indexOfEq(a, a[7]) == 7;\n      assert ArraysMDE.indexOfEq(a, a[9]) == 9;\n    }\n\n    \/\/ public static int indexOf(List<?> a, Object elt)\n    \/\/ public static int indexOf(List<?> a, Object elt, int minindex, int indexlimit)\n    \/\/ public static int indexOfEq(List<?> a, Object elt, int minindex, int indexlimit)\n    \/\/ public static int indexOfEq(List<?> a, Object elt)\n    {\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOf((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null) == -1;\n      assert ArraysMDE.indexOfEq((List<?>) new ArrayList<Object>(), (Object) null, 0, -1) == -1;\n    }\n\n    \/\/ public static int indexOf(int[] a, int elt)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      assert ArraysMDE.indexOf(a, -1) == -1;\n      assert ArraysMDE.indexOf(a, 0) == 0;\n      assert ArraysMDE.indexOf(a, 7) == 7;\n      assert ArraysMDE.indexOf(a, 9) == 9;\n      assert ArraysMDE.indexOf(a, 10) == -1;\n      assert ArraysMDE.indexOf(a, 20) == -1;\n    }\n\n    \/\/ public static int indexOf(boolean[] a, boolean elt)\n    {\n      boolean[] a = new boolean[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = false;\n      }\n      assert ArraysMDE.indexOf(a, true) == -1;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[9] = true;\n      assert ArraysMDE.indexOf(a, true) == 9;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[7] = true;\n      assert ArraysMDE.indexOf(a, true) == 7;\n      assert ArraysMDE.indexOf(a, false) == 0;\n      a[0] = true;\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == 1;\n      for (int i = 0; i < a.length; i++) {\n        a[i] = true;\n      }\n      assert ArraysMDE.indexOf(a, true) == 0;\n      assert ArraysMDE.indexOf(a, false) == -1;\n    }\n\n    \/\/ public static int indexOf(Object[] a, Object[] sub)\n    \/\/ public static int indexOfEq(Object[] a, Object[] sub)\n    {\n      Integer[] a = new Integer[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = new Integer(i);\n      }\n      Integer[] b = new Integer[] {};\n      Integer[] c = new Integer[] {a[0], a[1], a[2]};\n      Integer[] d = new Integer[] {a[1], a[2]};\n      Integer[] e = new Integer[] {a[2], a[3], a[4], a[5]};\n      Integer[] f = new Integer[] {a[7], a[8], a[9]};\n      Integer[] g = new Integer[] {a[7], new Integer(8), a[9]};\n      Integer[] h = new Integer[] {a[7], a[8], a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") \/\/ accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] i = new Integer[] {a[7], a[8], null, a[9], new Integer(10)};\n      @SuppressWarnings(\"nullness\") \/\/ accommodates poor annotation on indexOf(Object[], Object[])\n      Integer[] j = new Integer[] {a[8], null, a[9]};\n      Integer[] c2 = new Integer[] {new Integer(0), new Integer(1), new Integer(2)};\n      Integer[] d2 = new Integer[] {new Integer(1), new Integer(2)};\n      Integer[] e2 = new Integer[] {new Integer(2), new Integer(3), new Integer(4), new Integer(5)};\n      Integer[] f2 = new Integer[] {new Integer(7), new Integer(8), new Integer(9)};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOfEq(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOfEq(a, c) == 0;\n      assert ArraysMDE.indexOf(a, c2) == 0;\n      assert ArraysMDE.indexOfEq(a, c2) == -1;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOfEq(a, d) == 1;\n      assert ArraysMDE.indexOf(a, d2) == 1;\n      assert ArraysMDE.indexOfEq(a, d2) == -1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOfEq(a, e) == 2;\n      assert ArraysMDE.indexOf(a, e2) == 2;\n      assert ArraysMDE.indexOfEq(a, e2) == -1;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOfEq(a, f) == 7;\n      assert ArraysMDE.indexOf(a, f2) == 7;\n      assert ArraysMDE.indexOfEq(a, f2) == -1;\n      assert ArraysMDE.indexOf(a, g) == 7;\n      assert ArraysMDE.indexOfEq(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n      assert ArraysMDE.indexOfEq(a, h) == -1;\n      assert ArraysMDE.indexOf(i, j) == 1;\n      assert ArraysMDE.indexOfEq(i, j) == 1;\n      assert ArraysMDE.indexOf(a, i) == -1;\n      assert ArraysMDE.indexOfEq(a, i) == -1;\n    }\n\n    \/\/ public static int indexOf(int[] a, int[] sub)\n    {\n      int[] a = new int[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      int[] b = new int[] {};\n      int[] c = new int[] {a[0], a[1], a[2]};\n      int[] d = new int[] {a[1], a[2]};\n      int[] e = new int[] {a[2], a[3], a[4], a[5]};\n      int[] f = new int[] {a[7], a[8], a[9]};\n      int[] g = new int[] {a[7], 22, a[9]};\n      int[] h = new int[] {a[7], a[8], a[9], 10};\n\n      assert ArraysMDE.indexOf(a, b) == 0;\n      assert ArraysMDE.indexOf(a, c) == 0;\n      assert ArraysMDE.indexOf(a, d) == 1;\n      assert ArraysMDE.indexOf(a, e) == 2;\n      assert ArraysMDE.indexOf(a, f) == 7;\n      assert ArraysMDE.indexOf(a, g) == -1;\n      assert ArraysMDE.indexOf(a, h) == -1;\n\n      \/\/ Tests pulled from actual StackAr data\n      int[] origTheArray =\n          new int[] {\n            1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757, 1267757,\n            1267757, 1267757, 0, 0, 0, 0, 0, 0, 0, 0, 0\n          };\n\n      int[] postTheArray = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n      assert ArraysMDE.indexOf(postTheArray, origTheArray) == -1;\n      assert ArraysMDE.indexOf(origTheArray, postTheArray) == -1;\n    }\n\n    \/\/ public static int indexOf(boolean[] a, boolean[] sub)\n    \/\/ [I'm punting on this for now; deal with it later...]\n\n    \/\/ public static Object[] subarray(Object[] a, int startindex, int length)\n    \/\/ public static byte[] subarray(byte[] a, int startindex, int length)\n    \/\/ public static boolean[] subarray(boolean[] a, int startindex, int length)\n    \/\/ public static char[] subarray(char[] a, int startindex, int length)\n    \/\/ public static double[] subarray(double[] a, int startindex, int length)\n    \/\/ public static float[] subarray(float[] a, int startindex, int length)\n    \/\/ public static int[] subarray(int[] a, int startindex, int length)\n    \/\/ public static long[] subarray(long[] a, int startindex, int length)\n    \/\/ public static short[] subarray(short[] a, int startindex, int length)\n\n    \/\/ public static boolean isSubarray(Object[] a, Object[] sub, int a_offset)\n    \/\/ public static boolean isSubarrayEq(Object[] a, Object[] sub, int a_offset)\n    \/\/ public static boolean isSubarray(int[] a, int[] sub, int a_offset)\n    \/\/ public static boolean isSubarray(boolean[] a, boolean[] sub, int a_offset)\n    \/\/ (The subarray tests are missing; I hope that the indexOf(..., array)\n    \/\/ operations above test them sufficiently.)\n\n    \/\/ public static String toString(Object \/*@Nullable*\/ [] a)\n    \/\/ public static String toStringQuoted(Object \/*@Nullable*\/ [] a)\n    \/\/ public static String toString(Object \/*@Nullable*\/ [] a, boolean quoted)\n    \/\/ public static String toString(List<?> a)\n    \/\/ public static String toStringQuoted(List<?> a)\n    \/\/ public static String toString(List<?> a, boolean quoted)\n    {\n      assert ArraysMDE.toString((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((Object[]) null).equals(\"null\");\n      assert ArraysMDE.toString((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted((List<?>) null).equals(\"null\");\n      assert ArraysMDE.toStringQuoted(Arrays.asList(new Object[] {3.14, null, \"hello\"}))\n          .equals(\"[3.14, null, \\\"hello\\\"]\");\n    }\n\n    \/\/ static String toString(int[] a)\n    assert ArraysMDE.toString(new int[] {}).equals(\"[]\");\n    assert ArraysMDE.toString(new int[] {0}).equals(\"[0]\");\n    assert ArraysMDE.toString(new int[] {0, 1, 2}).equals(\"[0, 1, 2]\");\n\n    \/\/ public static boolean sorted(int[] a)\n    assert ArraysMDE.sorted(new int[] {0, 1, 2});\n    assert ArraysMDE.sorted(new int[] {0, 1, 2, 2, 3, 3});\n    assert ArraysMDE.sorted(new int[] {});\n    assert ArraysMDE.sorted(new int[] {0});\n    assert ArraysMDE.sorted(new int[] {0, 1});\n    assert !ArraysMDE.sorted(new int[] {1, 0});\n    assert !ArraysMDE.sorted(new int[] {0, 1, 2, 1, 2, 3});\n\n    \/\/ public static int noDuplicates(int[] a)\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new int[] {}) == true;\n    assert ArraysMDE.noDuplicates(new int[] {42}) == true;\n\n    \/\/ public static int noDuplicates(long[] a)\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {1, 2, -2, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new long[] {}) == true;\n    assert ArraysMDE.noDuplicates(new long[] {42}) == true;\n\n    \/\/ public static int noDuplicates(double[] a)\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 100}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {2, 2, 3, 5, 4, 0}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1, 2, 3, 5, 4, 1}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {1., 1.001, -3, -5, 4, 0}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {1., 2, -2.00, -2, 4, 100}) == false;\n    assert ArraysMDE.noDuplicates(new double[] {}) == true;\n    assert ArraysMDE.noDuplicates(new double[] {42}) == true;\n\n    \/\/ public static int noDuplicates(String[] a)\n    assert ArraysMDE.noDuplicates(new String[] {\"1\", \"2\", \"3\", \"5\", \"4\", \"0\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\"A\", \"a\", \"foo\", \"Foo\", \"\"}) == true;\n    assert ArraysMDE.noDuplicates(new String[] {\" \", \" \"}) == false;\n    assert ArraysMDE.noDuplicates(new String[] {\"  \", \" \"}) == true;\n\n    \/\/ public static boolean fn_is_permutation(int[] a)\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 2}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 1, 2, 4}) == false;\n    assert ArraysMDE.fn_is_permutation(new int[] {0, 0, 0, 0}) == false;\n\n    \/\/ public static boolean fn_is_total(int[] a)\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 3}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {1, 2, 3, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {3, 2, 1, 0}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 2}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {-1, 0, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -1, 2, 3}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, -2, 1, 3}) == true; \/\/ weird\n    assert ArraysMDE.fn_is_total(new int[] {0, 2, 3, -1}) == false;\n    assert ArraysMDE.fn_is_total(new int[] {0, 1, 2, 4}) == true;\n    assert ArraysMDE.fn_is_total(new int[] {0, 0, 0, 0}) == true;\n\n    \/\/ public static int[] fn_identity(int length)\n    assert_arrays_equals(ArraysMDE.fn_identity(0), new int[] {});\n    assert_arrays_equals(ArraysMDE.fn_identity(1), new int[] {0});\n    assert_arrays_equals(ArraysMDE.fn_identity(2), new int[] {0, 1});\n    assert_arrays_equals(ArraysMDE.fn_identity(3), new int[] {0, 1, 2});\n\n    \/\/ public static int[] fn_inverse_permutation(int[] a)\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {0, 1, 2, 3}), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {1, 2, 3, 0}), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse_permutation(new int[] {3, 2, 1, 0}), new int[] {3, 2, 1, 0});\n\n    \/\/ public static int[] fn_inverse(int[] a, int arange)\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {0, 1, 2, 3}, 4), new int[] {0, 1, 2, 3});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {1, 2, 3, 0}, 4), new int[] {3, 0, 1, 2});\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {3, 2, 1, 0}, 4), new int[] {3, 2, 1, 0});\n    try {\n      ArraysMDE.fn_inverse(new int[] {1, 0, 3, 0}, 4);\n      throw new Error();\n    } catch (UnsupportedOperationException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Not invertible; a[1]=0 and a[3]=0\");\n    }\n    assert_arrays_equals(ArraysMDE.fn_inverse(new int[] {5}, 6), new int[] {-1, -1, -1, -1, -1, 0});\n    assert_arrays_equals(\n        ArraysMDE.fn_inverse(new int[] {1, 2, 3, 5}, 6), new int[] {-1, 0, 1, 2, -1, 3});\n\n    try {\n      assert_arrays_equals(\n          ArraysMDE.fn_inverse(new int[] {100, 101, 102, 103}, 4), new int[] {40, 41, 42, 43});\n      throw new Error();\n    } catch (IllegalArgumentException e) {\n      assert e.getMessage() != null && e.getMessage().equals(\"Bad range value: a[0]=100\");\n    }\n\n    \/\/ public static int[] fn_compose(int[] a, int[] b)\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 2, 3}, new int[] {0, 1, 2, 3}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 0}, new int[] {1, 2, 3, 0}),\n        new int[] {2, 3, 0, 1});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {3, 2, 1, 0}, new int[] {3, 2, 1, 0}),\n        new int[] {0, 1, 2, 3});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {0, 1, 0, 3}, new int[] {0, 5, 2, 1}),\n        new int[] {0, 5, 0, 1});\n    assert_arrays_equals(ArraysMDE.fn_compose(new int[] {0}, new int[] {5}), new int[] {5});\n    assert_arrays_equals(\n        ArraysMDE.fn_compose(new int[] {1, 2, 3, 5}, new int[] {1, 2, 3, 5, -1, -1}),\n        new int[] {2, 3, 5, -1});\n\n    \/\/ public static boolean isSubset(long[] smaller, long[] bigger)\n    \/\/ public static boolean isSubset(double[] smaller, double[] bigger)\n    \/\/ public static boolean isSubset(String[] smaller, String[] bigger)\n\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        \/\/fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i];\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ArraysMDE.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ArraysMDE.isSubset(a2, a1);\n      assert !ArraysMDE.isSubset(a1, a2);\n      assert !ArraysMDE.isSubset(a1, a5);\n      assert ArraysMDE.isSubset(a3, a1);\n      assert ArraysMDE.isSubset(a4, a1);\n      assert ArraysMDE.isSubset(a6, a1);\n      assert !ArraysMDE.isSubset(a1, a6);\n    }\n\n    \/\/ public static class IntArrayComparatorLexical implements Comparator\n    \/\/ public static class IntArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<int[]> iacl = new ArraysMDE.IntArrayComparatorLexical();\n      Comparator<int[]> iaclf = new ArraysMDE.IntArrayComparatorLengthFirst();\n\n      int[] a0 = new int[] {};\n      int[] a1 = new int[] {};\n      int[] a2 = new int[] {0, 1, 2, 3};\n      int[] a3 = new int[] {0, 1, 2, 3, 0};\n      int[] a4 = new int[] {0, 1, 2, 3, 4};\n      int[] a5 = new int[] {0, 1, 2, 3, 4};\n      int[] a6 = new int[] {0, 1, 5, 3, 4};\n      int[] a7 = new int[] {1, 2, 3, 4};\n      int[] a8 = new int[] {-5};\n      int[] a9 = new int[] {Integer.MAX_VALUE};\n      int[] a10 = new int[] {Integer.MIN_VALUE};\n\n      assert iacl.compare(a0, a1) == 0;\n      assert iaclf.compare(a0, a1) == 0;\n      assert iacl.compare(a1, a0) == 0;\n      assert iaclf.compare(a1, a0) == 0;\n      assert iacl.compare(a1, a2) < 0;\n      assert iaclf.compare(a1, a2) < 0;\n      assert iacl.compare(a2, a1) > 0;\n      assert iaclf.compare(a2, a1) > 0;\n      assert iacl.compare(a2, a3) < 0;\n      assert iaclf.compare(a2, a3) < 0;\n      assert iacl.compare(a3, a2) > 0;\n      assert iaclf.compare(a3, a2) > 0;\n      assert iacl.compare(a3, a4) < 0;\n      assert iaclf.compare(a3, a4) < 0;\n      assert iacl.compare(a4, a3) > 0;\n      assert iaclf.compare(a4, a3) > 0;\n      assert iacl.compare(a4, a5) == 0;\n      assert iaclf.compare(a4, a5) == 0;\n      assert iacl.compare(a5, a4) == 0;\n      assert iaclf.compare(a5, a4) == 0;\n      assert iacl.compare(a5, a6) < 0;\n      assert iaclf.compare(a5, a6) < 0;\n      assert iacl.compare(a6, a5) > 0;\n      assert iaclf.compare(a6, a5) > 0;\n      assert iacl.compare(a6, a7) < 0;\n      assert iaclf.compare(a6, a7) > 0;\n      assert iacl.compare(a7, a6) > 0;\n      assert iaclf.compare(a7, a6) < 0;\n      assert iacl.compare(a1, a4) < 0;\n      assert iaclf.compare(a1, a4) < 0;\n      assert iacl.compare(a4, a1) > 0;\n      assert iaclf.compare(a4, a1) > 0;\n      assert iacl.compare(a2, a4) < 0;\n      assert iaclf.compare(a2, a4) < 0;\n      assert iacl.compare(a4, a2) > 0;\n      assert iaclf.compare(a4, a2) > 0;\n      assert iacl.compare(a6, a4) > 0;\n      assert iaclf.compare(a6, a4) > 0;\n      assert iacl.compare(a4, a6) < 0;\n      assert iaclf.compare(a4, a6) < 0;\n      assert iacl.compare(a7, a4) > 0;\n      assert iaclf.compare(a7, a4) < 0;\n      assert iacl.compare(a4, a7) < 0;\n      assert iaclf.compare(a4, a7) > 0;\n      assert iacl.compare(a8, a9) < 0;\n      assert iaclf.compare(a8, a9) < 0;\n      assert iacl.compare(a10, a7) < 0;\n    }\n\n    \/\/ public static class LongArrayComparatorLexical implements Comparator\n    \/\/ public static class LongArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<long[]> lacl = new ArraysMDE.LongArrayComparatorLexical();\n      Comparator<long[]> laclf = new ArraysMDE.LongArrayComparatorLengthFirst();\n      long[] a0 = new long[] {};\n      long[] a1 = new long[] {};\n      long[] a2 = new long[] {0, 1, 2, 3};\n      long[] a3 = new long[] {0, 1, 2, 3, 0};\n      long[] a4 = new long[] {0, 1, 2, 3, 4};\n      long[] a5 = new long[] {0, 1, 2, 3, 4};\n      long[] a6 = new long[] {0, 1, 5, 3, 4};\n      long[] a7 = new long[] {1, 2, 3, 4};\n      long[] a8 = new long[] {-5};\n      long[] a9 = new long[] {Long.MAX_VALUE};\n      long[] a10 = new long[] {Long.MIN_VALUE};\n\n      assert lacl.compare(a0, a1) == 0;\n      assert laclf.compare(a0, a1) == 0;\n      assert lacl.compare(a1, a0) == 0;\n      assert laclf.compare(a1, a0) == 0;\n      assert lacl.compare(a1, a2) < 0;\n      assert laclf.compare(a1, a2) < 0;\n      assert lacl.compare(a2, a1) > 0;\n      assert laclf.compare(a2, a1) > 0;\n      assert lacl.compare(a2, a3) < 0;\n      assert laclf.compare(a2, a3) < 0;\n      assert lacl.compare(a3, a2) > 0;\n      assert laclf.compare(a3, a2) > 0;\n      assert lacl.compare(a3, a4) < 0;\n      assert laclf.compare(a3, a4) < 0;\n      assert lacl.compare(a4, a3) > 0;\n      assert laclf.compare(a4, a3) > 0;\n      assert lacl.compare(a4, a5) == 0;\n      assert laclf.compare(a4, a5) == 0;\n      assert lacl.compare(a5, a4) == 0;\n      assert laclf.compare(a5, a4) == 0;\n      assert lacl.compare(a5, a6) < 0;\n      assert laclf.compare(a5, a6) < 0;\n      assert lacl.compare(a6, a5) > 0;\n      assert laclf.compare(a6, a5) > 0;\n      assert lacl.compare(a6, a7) < 0;\n      assert laclf.compare(a6, a7) > 0;\n      assert lacl.compare(a7, a6) > 0;\n      assert laclf.compare(a7, a6) < 0;\n      assert lacl.compare(a1, a4) < 0;\n      assert laclf.compare(a1, a4) < 0;\n      assert lacl.compare(a4, a1) > 0;\n      assert laclf.compare(a4, a1) > 0;\n      assert lacl.compare(a2, a4) < 0;\n      assert laclf.compare(a2, a4) < 0;\n      assert lacl.compare(a4, a2) > 0;\n      assert laclf.compare(a4, a2) > 0;\n      assert lacl.compare(a6, a4) > 0;\n      assert laclf.compare(a6, a4) > 0;\n      assert lacl.compare(a4, a6) < 0;\n      assert laclf.compare(a4, a6) < 0;\n      assert lacl.compare(a7, a4) > 0;\n      assert laclf.compare(a7, a4) < 0;\n      assert lacl.compare(a4, a7) < 0;\n      assert laclf.compare(a4, a7) > 0;\n      assert lacl.compare(a8, a9) < 0;\n      assert laclf.compare(a8, a9) < 0;\n      assert lacl.compare(a10, a7) < 0;\n    }\n\n    \/\/ public static class DoubleArrayComparatorLexical implements Comparator\n    {\n      Comparator<double[]> dacl = new ArraysMDE.DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a8 = new double[] {0.005};\n      double[] a9 = new double[] {0.004};\n      double[] a10 = new double[] {-0.005};\n      double[] a11 = new double[] {-0.004};\n      double[] a12 = new double[] {10.0 * Integer.MAX_VALUE};\n      double[] a13 = new double[] {10.0 * Integer.MIN_VALUE};\n\n      assert dacl.compare(a0, a1) == 0;\n      assert dacl.compare(a1, a0) == 0;\n      assert dacl.compare(a1, a2) < 0;\n      assert dacl.compare(a2, a1) > 0;\n      assert dacl.compare(a2, a3) < 0;\n      assert dacl.compare(a3, a2) > 0;\n      assert dacl.compare(a3, a4) < 0;\n      assert dacl.compare(a4, a3) > 0;\n      assert dacl.compare(a4, a5) == 0;\n      assert dacl.compare(a5, a4) == 0;\n      assert dacl.compare(a5, a6) < 0;\n      assert dacl.compare(a6, a5) > 0;\n      assert dacl.compare(a6, a7) < 0;\n      assert dacl.compare(a7, a6) > 0;\n      assert dacl.compare(a1, a4) < 0;\n      assert dacl.compare(a4, a1) > 0;\n      assert dacl.compare(a2, a4) < 0;\n      assert dacl.compare(a4, a2) > 0;\n      assert dacl.compare(a6, a4) > 0;\n      assert dacl.compare(a4, a6) < 0;\n      assert dacl.compare(a7, a4) > 0;\n      assert dacl.compare(a4, a7) < 0;\n\n      \/\/ Test the comparisons on small\/large numbers\n      assert dacl.compare(a8, a9) > 0;\n      assert dacl.compare(a10, a11) < 0;\n      assert dacl.compare(a11, a12) < 0;\n      assert dacl.compare(a12, a13) > 0;\n      assert dacl.compare(a13, a11) < 0;\n    }\n\n    \/\/ public static class ObjectArrayComparatorLexical implements Comparator\n    \/\/ public static class ObjectArrayComparatorLengthFirst implements Comparator\n\n    \/\/ public static final class ComparableArrayComparatorLexical implements Comparator\n    \/\/ public static final class ComparableArrayComparatorLengthFirst implements Comparator\n    {\n      Comparator<String[]> cacl = new ArraysMDE.ComparableArrayComparatorLexical<String>();\n      Comparator<String[]> caclf = new ArraysMDE.ComparableArrayComparatorLengthFirst<String>();\n      String[] a0 = new String[] {};\n      String[] a1 = new String[] {};\n      String[] a2 = new String[] {\"0\", \"1\", \"2\", \"3\"};\n      String[] a3 = new String[] {\"0\", \"1\", \"2\", \"3\", \"0\"};\n      String[] a4 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a5 = new String[] {\"0\", \"1\", \"2\", \"3\", \"4\"};\n      String[] a6 = new String[] {\"0\", \"1\", \"5\", \"3\", \"4\"};\n      String[] a7 = new String[] {\"1\", \"2\", \"3\", \"4\"};\n      @SuppressWarnings(\n          \"nullness\") \/\/ accommodates poor annotation on ComparableArrayComparatorLexical.compare() and ComparableArrayComparatorLengthFirst.compare()\n      String[] a8 = new String[] {\"0\", \"1\", null, \"3\", \"4\"};\n\n      assert cacl.compare(a0, a1) == 0;\n      assert caclf.compare(a0, a1) == 0;\n      assert cacl.compare(a1, a0) == 0;\n      assert caclf.compare(a1, a0) == 0;\n      assert cacl.compare(a1, a2) < 0;\n      assert caclf.compare(a1, a2) < 0;\n      assert cacl.compare(a2, a1) > 0;\n      assert caclf.compare(a2, a1) > 0;\n      assert cacl.compare(a2, a3) < 0;\n      assert caclf.compare(a2, a3) < 0;\n      assert cacl.compare(a3, a2) > 0;\n      assert caclf.compare(a3, a2) > 0;\n      assert cacl.compare(a3, a4) < 0;\n      assert caclf.compare(a3, a4) < 0;\n      assert cacl.compare(a4, a3) > 0;\n      assert caclf.compare(a4, a3) > 0;\n      assert cacl.compare(a4, a5) == 0;\n      assert caclf.compare(a4, a5) == 0;\n      assert cacl.compare(a5, a4) == 0;\n      assert caclf.compare(a5, a4) == 0;\n      assert cacl.compare(a5, a6) < 0;\n      assert caclf.compare(a5, a6) < 0;\n      assert cacl.compare(a6, a5) > 0;\n      assert caclf.compare(a6, a5) > 0;\n      assert cacl.compare(a6, a7) < 0;\n      assert caclf.compare(a6, a7) > 0;\n      assert cacl.compare(a7, a6) > 0;\n      assert caclf.compare(a7, a6) < 0;\n      assert cacl.compare(a1, a4) < 0;\n      assert caclf.compare(a1, a4) < 0;\n      assert cacl.compare(a4, a1) > 0;\n      assert caclf.compare(a4, a1) > 0;\n      assert cacl.compare(a2, a4) < 0;\n      assert caclf.compare(a2, a4) < 0;\n      assert cacl.compare(a4, a2) > 0;\n      assert caclf.compare(a4, a2) > 0;\n      assert cacl.compare(a6, a4) > 0;\n      assert caclf.compare(a6, a4) > 0;\n      assert cacl.compare(a4, a6) < 0;\n      assert caclf.compare(a4, a6) < 0;\n      assert cacl.compare(a7, a4) > 0;\n      assert caclf.compare(a7, a4) < 0;\n      assert cacl.compare(a8, a1) > 0;\n      assert caclf.compare(a8, a1) > 0;\n      assert cacl.compare(a1, a8) < 0;\n      assert caclf.compare(a1, a8) < 0;\n      assert cacl.compare(a8, a2) < 0;\n      assert caclf.compare(a8, a2) > 0;\n      assert cacl.compare(a2, a8) > 0;\n      assert caclf.compare(a2, a8) < 0;\n      assert cacl.compare(a8, a3) < 0;\n      assert caclf.compare(a8, a3) < 0;\n      assert cacl.compare(a3, a8) > 0;\n      assert caclf.compare(a3, a8) > 0;\n    }\n\n    \/\/ public static boolean any_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.any_null(new Object[] {}) == false;\n      assert ArraysMDE.any_null(new Object[] {null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.any_null(new Object[] {o, null, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, null}) == true;\n      assert ArraysMDE.any_null(new Object[] {o, null, o}) == true;\n      assert ArraysMDE.any_null(new Object[] {null, o, o}) == true;\n      assert ArraysMDE.any_null(new Object[][] {}) == false;\n      assert ArraysMDE.any_null(new Object[][] {null}) == true;\n      \/\/ Extraneous @Nullable on the following lines are due to CF issue #599:\n      \/\/ https:\/\/github.com\/typetools\/checker-framework\/issues\/599\n      assert ArraysMDE.any_null(new \/*@Nullable*\/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.any_null(new \/*@Nullable*\/ Object[][] {new Object[] {null}, null}) == true;\n      assert ArraysMDE.any_null(\n              new \/*@Nullable*\/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n\n    \/\/ public static boolean all_null(Object[] a)\n    {\n      Object o = new Object();\n      assert ArraysMDE.all_null(new Object[] {}) == true;\n      assert ArraysMDE.all_null(new Object[] {null}) == true;\n      assert ArraysMDE.all_null(new Object[] {null, null}) == true;\n      assert ArraysMDE.all_null(new Object[] {o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, null}) == false;\n      assert ArraysMDE.all_null(new Object[] {o, null, o}) == false;\n      assert ArraysMDE.all_null(new Object[] {null, o, o}) == false;\n      assert ArraysMDE.all_null(new Object[][] {}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null}) == true;\n      assert ArraysMDE.all_null(new Object[][] {null, null}) == true;\n      assert ArraysMDE.all_null(new \/*@Nullable*\/ Object[][] {new Object[] {null}}) == false;\n      assert ArraysMDE.all_null(new \/*@Nullable*\/ Object[][] {new Object[] {null}, null}) == false;\n      assert ArraysMDE.all_null(\n              new \/*@Nullable*\/ Object[][] {new Object[] {null}, new Object[] {o}})\n          == false;\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testArraysMDE","methodQualifiedSignature":"plume.TestPlume.testArraysMDE","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 145,col 37)-(line 145,col 37)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 145,col 40)-(line 145,col 40)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 145,col 43)-(line 145,col 43)","literalExprId":3,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 145,col 50)-(line 145,col 50)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 37)-(line 146,col 37)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 40)-(line 146,col 41)","literalExprId":6,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 44)-(line 146,col 44)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 146,col 51)-(line 146,col 51)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 37)-(line 147,col 37)","literalExprId":9,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 41)-(line 147,col 41)","literalExprId":10,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 44)-(line 147,col 44)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 147,col 52)-(line 147,col 52)","literalExprId":12,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 148,col 37)-(line 148,col 37)","literalExprId":13,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 148,col 44)-(line 148,col 44)","literalExprId":14,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 37)-(line 151,col 37)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 40)-(line 151,col 40)","literalExprId":16,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 43)-(line 151,col 43)","literalExprId":17,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 151,col 50)-(line 151,col 50)","literalExprId":18,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 37)-(line 152,col 37)","literalExprId":19,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 40)-(line 152,col 41)","literalExprId":20,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 44)-(line 152,col 44)","literalExprId":21,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 152,col 51)-(line 152,col 52)","literalExprId":22,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 37)-(line 153,col 37)","literalExprId":23,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 41)-(line 153,col 41)","literalExprId":24,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 44)-(line 153,col 44)","literalExprId":25,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 153,col 51)-(line 153,col 51)","literalExprId":26,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 154,col 37)-(line 154,col 37)","literalExprId":27,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 154,col 44)-(line 154,col 44)","literalExprId":28,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 157,col 55)-(line 157,col 55)","literalExprId":29,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 157,col 58)-(line 157,col 58)","literalExprId":30,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 157,col 61)-(line 157,col 61)","literalExprId":31,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 157,col 77)-(line 157,col 77)","literalExprId":32,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 157,col 80)-(line 157,col 80)","literalExprId":33,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 158,col 55)-(line 158,col 55)","literalExprId":34,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 158,col 58)-(line 158,col 59)","literalExprId":35,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 158,col 62)-(line 158,col 62)","literalExprId":36,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 158,col 78)-(line 158,col 78)","literalExprId":37,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 158,col 81)-(line 158,col 82)","literalExprId":38,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 55)-(line 159,col 55)","literalExprId":39,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 59)-(line 159,col 59)","literalExprId":40,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 62)-(line 159,col 62)","literalExprId":41,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 79)-(line 159,col 79)","literalExprId":42,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 159,col 82)-(line 159,col 82)","literalExprId":43,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 160,col 55)-(line 160,col 55)","literalExprId":44,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 160,col 71)-(line 160,col 71)","literalExprId":45,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 160,col 74)-(line 160,col 74)","literalExprId":46,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 163,col 23)-(line 163,col 67)","literalExprId":47,"literalExpr":"\"Didn't throw ArrayIndexOutOfBoundsException\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 168,col 23)-(line 168,col 67)","literalExprId":48,"literalExpr":"\"Didn't throw ArrayIndexOutOfBoundsException\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 173,col 12)-(line 173,col 12)","literalExprId":49,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 173,col 39)-(line 173,col 39)","literalExprId":50,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 174,col 12)-(line 174,col 13)","literalExprId":51,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 174,col 43)-(line 174,col 44)","literalExprId":52,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 175,col 12)-(line 175,col 13)","literalExprId":53,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 175,col 43)-(line 175,col 43)","literalExprId":54,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 175,col 46)-(line 175,col 46)","literalExprId":55,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 175,col 49)-(line 175,col 49)","literalExprId":56,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 175,col 52)-(line 175,col 52)","literalExprId":57,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 178,col 12)-(line 178,col 12)","literalExprId":58,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 178,col 39)-(line 178,col 39)","literalExprId":59,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 178,col 42)-(line 178,col 42)","literalExprId":60,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 12)-(line 179,col 13)","literalExprId":61,"literalExpr":"78","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 46)-(line 179,col 46)","literalExprId":62,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 49)-(line 179,col 49)","literalExprId":63,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 52)-(line 179,col 52)","literalExprId":64,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 55)-(line 179,col 55)","literalExprId":65,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 60)-(line 179,col 60)","literalExprId":66,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 63)-(line 179,col 63)","literalExprId":67,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 66)-(line 179,col 66)","literalExprId":68,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 69)-(line 179,col 69)","literalExprId":69,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 74)-(line 179,col 74)","literalExprId":70,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 77)-(line 179,col 78)","literalExprId":71,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 81)-(line 179,col 82)","literalExprId":72,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 179,col 85)-(line 179,col 86)","literalExprId":73,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 12)-(line 180,col 13)","literalExprId":74,"literalExpr":"68","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 46)-(line 180,col 46)","literalExprId":75,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 49)-(line 180,col 49)","literalExprId":76,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 52)-(line 180,col 52)","literalExprId":77,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 55)-(line 180,col 55)","literalExprId":78,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 60)-(line 180,col 60)","literalExprId":79,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 63)-(line 180,col 63)","literalExprId":80,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 66)-(line 180,col 66)","literalExprId":81,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 69)-(line 180,col 69)","literalExprId":82,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 74)-(line 180,col 74)","literalExprId":83,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 77)-(line 180,col 78)","literalExprId":84,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 180,col 81)-(line 180,col 82)","literalExprId":85,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 183,col 12)-(line 183,col 12)","literalExprId":86,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 183,col 42)-(line 183,col 42)","literalExprId":87,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 184,col 12)-(line 184,col 15)","literalExprId":88,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 184,col 48)-(line 184,col 51)","literalExprId":89,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 185,col 12)-(line 185,col 16)","literalExprId":90,"literalExpr":"8.624","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 185,col 49)-(line 185,col 52)","literalExprId":91,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 185,col 55)-(line 185,col 59)","literalExprId":92,"literalExpr":"2.718","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 185,col 63)-(line 185,col 67)","literalExprId":93,"literalExpr":"1.234","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 185,col 70)-(line 185,col 70)","literalExprId":94,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 188,col 12)-(line 188,col 12)","literalExprId":95,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 188,col 42)-(line 188,col 42)","literalExprId":96,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 188,col 45)-(line 188,col 45)","literalExprId":97,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 189,col 12)-(line 189,col 15)","literalExprId":98,"literalExpr":"79.5","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 190,col 43)-(line 190,col 45)","literalExprId":99,"literalExpr":"1.1","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 190,col 48)-(line 190,col 50)","literalExprId":100,"literalExpr":"2.2","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 190,col 53)-(line 190,col 55)","literalExprId":101,"literalExpr":"3.3","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 190,col 58)-(line 190,col 60)","literalExprId":102,"literalExpr":"4.4","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 190,col 65)-(line 190,col 67)","literalExprId":103,"literalExpr":"5.5","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 190,col 70)-(line 190,col 70)","literalExprId":104,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 73)-(line 190,col 73)","literalExprId":105,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 76)-(line 190,col 76)","literalExprId":106,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 81)-(line 190,col 81)","literalExprId":107,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 84)-(line 190,col 85)","literalExprId":108,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 88)-(line 190,col 89)","literalExprId":109,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 190,col 92)-(line 190,col 93)","literalExprId":110,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 47)-(line 193,col 47)","literalExprId":111,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 50)-(line 193,col 50)","literalExprId":112,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 53)-(line 193,col 53)","literalExprId":113,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 193,col 60)-(line 193,col 60)","literalExprId":114,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 47)-(line 194,col 47)","literalExprId":115,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 50)-(line 194,col 51)","literalExprId":116,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 54)-(line 194,col 54)","literalExprId":117,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 194,col 61)-(line 194,col 62)","literalExprId":118,"literalExpr":"32","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 195,col 47)-(line 195,col 47)","literalExprId":119,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 195,col 51)-(line 195,col 51)","literalExprId":120,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 195,col 54)-(line 195,col 54)","literalExprId":121,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 195,col 61)-(line 195,col 61)","literalExprId":122,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 196,col 47)-(line 196,col 47)","literalExprId":123,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 196,col 54)-(line 196,col 54)","literalExprId":124,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 201,col 33)-(line 201,col 34)","literalExprId":125,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 202,col 20)-(line 202,col 20)","literalExprId":126,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 205,col 48)-(line 205,col 48)","literalExprId":127,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 205,col 56)-(line 205,col 56)","literalExprId":128,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 206,col 47)-(line 206,col 47)","literalExprId":129,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 206,col 54)-(line 206,col 54)","literalExprId":130,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 207,col 47)-(line 207,col 47)","literalExprId":131,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 207,col 54)-(line 207,col 54)","literalExprId":132,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 208,col 47)-(line 208,col 47)","literalExprId":133,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 208,col 54)-(line 208,col 54)","literalExprId":134,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 209,col 47)-(line 209,col 48)","literalExprId":135,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 209,col 56)-(line 209,col 56)","literalExprId":136,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 210,col 47)-(line 210,col 48)","literalExprId":137,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 210,col 56)-(line 210,col 56)","literalExprId":138,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 211,col 44)-(line 211,col 47)","literalExprId":139,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 211,col 54)-(line 211,col 54)","literalExprId":140,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 212,col 44)-(line 212,col 47)","literalExprId":141,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 212,col 50)-(line 212,col 50)","literalExprId":142,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 212,col 53)-(line 212,col 53)","literalExprId":143,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 212,col 60)-(line 212,col 60)","literalExprId":144,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 214,col 50)-(line 214,col 50)","literalExprId":145,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 214,col 58)-(line 214,col 58)","literalExprId":146,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 215,col 49)-(line 215,col 49)","literalExprId":147,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 215,col 57)-(line 215,col 57)","literalExprId":148,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 216,col 49)-(line 216,col 49)","literalExprId":149,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 216,col 57)-(line 216,col 57)","literalExprId":150,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 217,col 49)-(line 217,col 49)","literalExprId":151,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 217,col 57)-(line 217,col 57)","literalExprId":152,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 218,col 49)-(line 218,col 50)","literalExprId":153,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 218,col 58)-(line 218,col 58)","literalExprId":154,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 49)-(line 219,col 50)","literalExprId":155,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 219,col 58)-(line 219,col 58)","literalExprId":156,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 220,col 46)-(line 220,col 49)","literalExprId":157,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 220,col 56)-(line 220,col 56)","literalExprId":158,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 221,col 46)-(line 221,col 49)","literalExprId":159,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 221,col 52)-(line 221,col 52)","literalExprId":160,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 221,col 55)-(line 221,col 55)","literalExprId":161,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 221,col 62)-(line 221,col 62)","literalExprId":162,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 222,col 39)-(line 222,col 39)","literalExprId":163,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 222,col 46)-(line 222,col 46)","literalExprId":164,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 223,col 39)-(line 223,col 39)","literalExprId":165,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 223,col 46)-(line 223,col 46)","literalExprId":166,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 39)-(line 224,col 39)","literalExprId":167,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 224,col 46)-(line 224,col 46)","literalExprId":168,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 232,col 76)-(line 232,col 79)","literalExprId":169,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 232,col 86)-(line 232,col 86)","literalExprId":170,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 233,col 76)-(line 233,col 79)","literalExprId":171,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 233,col 82)-(line 233,col 82)","literalExprId":172,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 233,col 86)-(line 233,col 86)","literalExprId":173,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 233,col 93)-(line 233,col 93)","literalExprId":174,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 234,col 78)-(line 234,col 81)","literalExprId":175,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 234,col 88)-(line 234,col 88)","literalExprId":176,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 235,col 78)-(line 235,col 81)","literalExprId":177,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 235,col 84)-(line 235,col 84)","literalExprId":178,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 235,col 88)-(line 235,col 88)","literalExprId":179,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 235,col 95)-(line 235,col 95)","literalExprId":180,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 240,col 25)-(line 240,col 26)","literalExprId":181,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 241,col 20)-(line 241,col 20)","literalExprId":182,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 244,col 36)-(line 244,col 36)","literalExprId":183,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 244,col 43)-(line 244,col 43)","literalExprId":184,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 245,col 35)-(line 245,col 35)","literalExprId":185,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 245,col 41)-(line 245,col 41)","literalExprId":186,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 246,col 35)-(line 246,col 35)","literalExprId":187,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 246,col 41)-(line 246,col 41)","literalExprId":188,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 247,col 35)-(line 247,col 35)","literalExprId":189,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 247,col 41)-(line 247,col 41)","literalExprId":190,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 248,col 35)-(line 248,col 36)","literalExprId":191,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 248,col 43)-(line 248,col 43)","literalExprId":192,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 249,col 35)-(line 249,col 36)","literalExprId":193,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 249,col 43)-(line 249,col 43)","literalExprId":194,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 254,col 33)-(line 254,col 34)","literalExprId":195,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 255,col 20)-(line 255,col 20)","literalExprId":196,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 256,col 16)-(line 256,col 20)","literalExprId":197,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 258,col 35)-(line 258,col 38)","literalExprId":198,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 258,col 45)-(line 258,col 45)","literalExprId":199,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 259,col 35)-(line 259,col 39)","literalExprId":200,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 259,col 45)-(line 259,col 45)","literalExprId":201,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 260,col 9)-(line 260,col 9)","literalExprId":202,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 260,col 14)-(line 260,col 17)","literalExprId":203,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 261,col 35)-(line 261,col 38)","literalExprId":204,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 261,col 44)-(line 261,col 44)","literalExprId":205,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 262,col 35)-(line 262,col 39)","literalExprId":206,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 262,col 45)-(line 262,col 45)","literalExprId":207,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 263,col 9)-(line 263,col 9)","literalExprId":208,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 263,col 14)-(line 263,col 17)","literalExprId":209,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 264,col 35)-(line 264,col 38)","literalExprId":210,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 264,col 44)-(line 264,col 44)","literalExprId":211,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 265,col 35)-(line 265,col 39)","literalExprId":212,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 265,col 45)-(line 265,col 45)","literalExprId":213,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 266,col 9)-(line 266,col 9)","literalExprId":214,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 266,col 14)-(line 266,col 17)","literalExprId":215,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 267,col 35)-(line 267,col 38)","literalExprId":216,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 267,col 44)-(line 267,col 44)","literalExprId":217,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 268,col 35)-(line 268,col 39)","literalExprId":218,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 268,col 45)-(line 268,col 45)","literalExprId":219,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 269,col 20)-(line 269,col 20)","literalExprId":220,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 270,col 16)-(line 270,col 19)","literalExprId":221,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 272,col 35)-(line 272,col 38)","literalExprId":222,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 272,col 44)-(line 272,col 44)","literalExprId":223,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 273,col 35)-(line 273,col 39)","literalExprId":224,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 273,col 46)-(line 273,col 46)","literalExprId":225,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 279,col 33)-(line 279,col 34)","literalExprId":226,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 280,col 20)-(line 280,col 20)","literalExprId":227,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 284,col 38)-(line 284,col 38)","literalExprId":228,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 284,col 44)-(line 284,col 44)","literalExprId":229,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 284,col 50)-(line 284,col 50)","literalExprId":230,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 285,col 38)-(line 285,col 38)","literalExprId":231,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 285,col 44)-(line 285,col 44)","literalExprId":232,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 286,col 38)-(line 286,col 38)","literalExprId":233,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 286,col 44)-(line 286,col 44)","literalExprId":234,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 286,col 50)-(line 286,col 50)","literalExprId":235,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 286,col 56)-(line 286,col 56)","literalExprId":236,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 38)-(line 287,col 38)","literalExprId":237,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 44)-(line 287,col 44)","literalExprId":238,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 287,col 50)-(line 287,col 50)","literalExprId":239,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 288,col 38)-(line 288,col 38)","literalExprId":240,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 288,col 54)-(line 288,col 54)","literalExprId":241,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 288,col 60)-(line 288,col 60)","literalExprId":242,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 289,col 38)-(line 289,col 38)","literalExprId":243,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 289,col 44)-(line 289,col 44)","literalExprId":244,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 289,col 50)-(line 289,col 50)","literalExprId":245,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 289,col 66)-(line 289,col 67)","literalExprId":246,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 290,col 25)-(line 290,col 34)","literalExprId":247,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 291,col 38)-(line 291,col 38)","literalExprId":248,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 291,col 44)-(line 291,col 44)","literalExprId":249,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 291,col 48)-(line 291,col 51)","literalExprId":250,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 291,col 56)-(line 291,col 56)","literalExprId":251,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 291,col 72)-(line 291,col 73)","literalExprId":252,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 292,col 25)-(line 292,col 34)","literalExprId":253,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 293,col 38)-(line 293,col 38)","literalExprId":254,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 293,col 42)-(line 293,col 45)","literalExprId":255,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 293,col 50)-(line 293,col 50)","literalExprId":256,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 294,col 49)-(line 294,col 49)","literalExprId":257,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 294,col 65)-(line 294,col 65)","literalExprId":258,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 294,col 81)-(line 294,col 81)","literalExprId":259,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 295,col 49)-(line 295,col 49)","literalExprId":260,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 295,col 65)-(line 295,col 65)","literalExprId":261,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 49)-(line 296,col 49)","literalExprId":262,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 65)-(line 296,col 65)","literalExprId":263,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 81)-(line 296,col 81)","literalExprId":264,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 296,col 97)-(line 296,col 97)","literalExprId":265,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 297,col 49)-(line 297,col 49)","literalExprId":266,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 297,col 65)-(line 297,col 65)","literalExprId":267,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 297,col 81)-(line 297,col 81)","literalExprId":268,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 299,col 41)-(line 299,col 41)","literalExprId":269,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 300,col 43)-(line 300,col 43)","literalExprId":270,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 301,col 41)-(line 301,col 41)","literalExprId":271,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 302,col 43)-(line 302,col 43)","literalExprId":272,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 303,col 42)-(line 303,col 42)","literalExprId":273,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 304,col 45)-(line 304,col 45)","literalExprId":274,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 305,col 41)-(line 305,col 41)","literalExprId":275,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 306,col 43)-(line 306,col 43)","literalExprId":276,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 307,col 42)-(line 307,col 42)","literalExprId":277,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 308,col 45)-(line 308,col 45)","literalExprId":278,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 309,col 41)-(line 309,col 41)","literalExprId":279,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 310,col 43)-(line 310,col 43)","literalExprId":280,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 311,col 42)-(line 311,col 42)","literalExprId":281,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 312,col 45)-(line 312,col 45)","literalExprId":282,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 313,col 41)-(line 313,col 41)","literalExprId":283,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 314,col 43)-(line 314,col 43)","literalExprId":284,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 315,col 42)-(line 315,col 42)","literalExprId":285,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 316,col 45)-(line 316,col 45)","literalExprId":286,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 317,col 41)-(line 317,col 41)","literalExprId":287,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 318,col 44)-(line 318,col 44)","literalExprId":288,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 319,col 42)-(line 319,col 42)","literalExprId":289,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 320,col 44)-(line 320,col 44)","literalExprId":290,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 321,col 41)-(line 321,col 41)","literalExprId":291,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 322,col 43)-(line 322,col 43)","literalExprId":292,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 323,col 42)-(line 323,col 42)","literalExprId":293,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 324,col 44)-(line 324,col 44)","literalExprId":294,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 329,col 25)-(line 329,col 26)","literalExprId":295,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 330,col 20)-(line 330,col 20)","literalExprId":296,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 334,col 30)-(line 334,col 30)","literalExprId":297,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 334,col 36)-(line 334,col 36)","literalExprId":298,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 334,col 42)-(line 334,col 42)","literalExprId":299,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 335,col 30)-(line 335,col 30)","literalExprId":300,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 335,col 36)-(line 335,col 36)","literalExprId":301,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 336,col 30)-(line 336,col 30)","literalExprId":302,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 336,col 36)-(line 336,col 36)","literalExprId":303,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 336,col 42)-(line 336,col 42)","literalExprId":304,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 336,col 48)-(line 336,col 48)","literalExprId":305,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 337,col 30)-(line 337,col 30)","literalExprId":306,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 337,col 36)-(line 337,col 36)","literalExprId":307,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 337,col 42)-(line 337,col 42)","literalExprId":308,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 338,col 30)-(line 338,col 30)","literalExprId":309,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 338,col 34)-(line 338,col 35)","literalExprId":310,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 338,col 40)-(line 338,col 40)","literalExprId":311,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 339,col 30)-(line 339,col 30)","literalExprId":312,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 339,col 36)-(line 339,col 36)","literalExprId":313,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 339,col 42)-(line 339,col 42)","literalExprId":314,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 339,col 46)-(line 339,col 47)","literalExprId":315,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 341,col 41)-(line 341,col 41)","literalExprId":316,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 342,col 41)-(line 342,col 41)","literalExprId":317,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 343,col 41)-(line 343,col 41)","literalExprId":318,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 344,col 41)-(line 344,col 41)","literalExprId":319,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 345,col 41)-(line 345,col 41)","literalExprId":320,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 346,col 42)-(line 346,col 42)","literalExprId":321,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 347,col 42)-(line 347,col 42)","literalExprId":322,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 13)-(line 352,col 19)","literalExprId":323,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 22)-(line 352,col 28)","literalExprId":324,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 31)-(line 352,col 37)","literalExprId":325,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 40)-(line 352,col 46)","literalExprId":326,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 49)-(line 352,col 55)","literalExprId":327,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 58)-(line 352,col 64)","literalExprId":328,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 67)-(line 352,col 73)","literalExprId":329,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 76)-(line 352,col 82)","literalExprId":330,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 352,col 85)-(line 352,col 91)","literalExprId":331,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 13)-(line 353,col 19)","literalExprId":332,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 22)-(line 353,col 28)","literalExprId":333,"literalExpr":"1267757","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 31)-(line 353,col 31)","literalExprId":334,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 34)-(line 353,col 34)","literalExprId":335,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 37)-(line 353,col 37)","literalExprId":336,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 40)-(line 353,col 40)","literalExprId":337,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 43)-(line 353,col 43)","literalExprId":338,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 46)-(line 353,col 46)","literalExprId":339,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 49)-(line 353,col 49)","literalExprId":340,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 52)-(line 353,col 52)","literalExprId":341,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 353,col 55)-(line 353,col 55)","literalExprId":342,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 39)-(line 356,col 39)","literalExprId":343,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 42)-(line 356,col 42)","literalExprId":344,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 45)-(line 356,col 45)","literalExprId":345,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 48)-(line 356,col 48)","literalExprId":346,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 51)-(line 356,col 51)","literalExprId":347,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 54)-(line 356,col 54)","literalExprId":348,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 57)-(line 356,col 57)","literalExprId":349,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 60)-(line 356,col 60)","literalExprId":350,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 63)-(line 356,col 63)","literalExprId":351,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 66)-(line 356,col 66)","literalExprId":352,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 69)-(line 356,col 69)","literalExprId":353,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 72)-(line 356,col 72)","literalExprId":354,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 75)-(line 356,col 75)","literalExprId":355,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 78)-(line 356,col 78)","literalExprId":356,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 81)-(line 356,col 81)","literalExprId":357,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 84)-(line 356,col 84)","literalExprId":358,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 87)-(line 356,col 87)","literalExprId":359,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 90)-(line 356,col 90)","literalExprId":360,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 93)-(line 356,col 93)","literalExprId":361,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 356,col 96)-(line 356,col 96)","literalExprId":362,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 357,col 64)-(line 357,col 64)","literalExprId":363,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 358,col 64)-(line 358,col 64)","literalExprId":364,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 388,col 44)-(line 388,col 47)","literalExprId":365,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 388,col 57)-(line 388,col 62)","literalExprId":366,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 389,col 50)-(line 389,col 53)","literalExprId":367,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 389,col 63)-(line 389,col 68)","literalExprId":368,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 390,col 43)-(line 390,col 46)","literalExprId":369,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 390,col 56)-(line 390,col 61)","literalExprId":370,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 391,col 49)-(line 391,col 52)","literalExprId":371,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 391,col 62)-(line 391,col 67)","literalExprId":372,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 392,col 67)-(line 392,col 70)","literalExprId":373,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 392,col 73)-(line 392,col 76)","literalExprId":374,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 392,col 79)-(line 392,col 85)","literalExprId":375,"literalExpr":"\"hello\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 393,col 19)-(line 393,col 43)","literalExprId":376,"literalExpr":"\"[3.14, null, \\\"hello\\\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 397,col 52)-(line 397,col 55)","literalExprId":377,"literalExpr":"\"[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 398,col 42)-(line 398,col 42)","literalExprId":378,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 398,col 53)-(line 398,col 57)","literalExprId":379,"literalExpr":"\"[0]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 399,col 42)-(line 399,col 42)","literalExprId":380,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 399,col 45)-(line 399,col 45)","literalExprId":381,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 399,col 48)-(line 399,col 48)","literalExprId":382,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 399,col 59)-(line 399,col 69)","literalExprId":383,"literalExpr":"\"[0, 1, 2]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 402,col 40)-(line 402,col 40)","literalExprId":384,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 402,col 43)-(line 402,col 43)","literalExprId":385,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 402,col 46)-(line 402,col 46)","literalExprId":386,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 403,col 40)-(line 403,col 40)","literalExprId":387,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 403,col 43)-(line 403,col 43)","literalExprId":388,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 403,col 46)-(line 403,col 46)","literalExprId":389,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 403,col 49)-(line 403,col 49)","literalExprId":390,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 403,col 52)-(line 403,col 52)","literalExprId":391,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 403,col 55)-(line 403,col 55)","literalExprId":392,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 405,col 40)-(line 405,col 40)","literalExprId":393,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 406,col 40)-(line 406,col 40)","literalExprId":394,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 406,col 43)-(line 406,col 43)","literalExprId":395,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 407,col 41)-(line 407,col 41)","literalExprId":396,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 407,col 44)-(line 407,col 44)","literalExprId":397,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 41)-(line 408,col 41)","literalExprId":398,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 44)-(line 408,col 44)","literalExprId":399,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 47)-(line 408,col 47)","literalExprId":400,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 50)-(line 408,col 50)","literalExprId":401,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 53)-(line 408,col 53)","literalExprId":402,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 408,col 56)-(line 408,col 56)","literalExprId":403,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 46)-(line 411,col 46)","literalExprId":404,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 49)-(line 411,col 49)","literalExprId":405,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 52)-(line 411,col 52)","literalExprId":406,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 55)-(line 411,col 55)","literalExprId":407,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 58)-(line 411,col 58)","literalExprId":408,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 61)-(line 411,col 61)","literalExprId":409,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 411,col 68)-(line 411,col 71)","literalExprId":410,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 412,col 46)-(line 412,col 46)","literalExprId":411,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 412,col 49)-(line 412,col 49)","literalExprId":412,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 412,col 52)-(line 412,col 52)","literalExprId":413,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 412,col 55)-(line 412,col 55)","literalExprId":414,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 412,col 58)-(line 412,col 58)","literalExprId":415,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 412,col 61)-(line 412,col 63)","literalExprId":416,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 412,col 70)-(line 412,col 73)","literalExprId":417,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 413,col 46)-(line 413,col 46)","literalExprId":418,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 49)-(line 413,col 49)","literalExprId":419,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 52)-(line 413,col 52)","literalExprId":420,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 55)-(line 413,col 55)","literalExprId":421,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 58)-(line 413,col 58)","literalExprId":422,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 61)-(line 413,col 61)","literalExprId":423,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 413,col 68)-(line 413,col 72)","literalExprId":424,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 414,col 46)-(line 414,col 46)","literalExprId":425,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 414,col 49)-(line 414,col 49)","literalExprId":426,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 414,col 52)-(line 414,col 52)","literalExprId":427,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 414,col 55)-(line 414,col 55)","literalExprId":428,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 414,col 58)-(line 414,col 58)","literalExprId":429,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 414,col 61)-(line 414,col 61)","literalExprId":430,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 414,col 68)-(line 414,col 72)","literalExprId":431,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 415,col 46)-(line 415,col 46)","literalExprId":432,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 415,col 49)-(line 415,col 49)","literalExprId":433,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 415,col 53)-(line 415,col 53)","literalExprId":434,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 415,col 57)-(line 415,col 57)","literalExprId":435,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 415,col 60)-(line 415,col 60)","literalExprId":436,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 415,col 63)-(line 415,col 63)","literalExprId":437,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 415,col 70)-(line 415,col 73)","literalExprId":438,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 416,col 46)-(line 416,col 46)","literalExprId":439,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 49)-(line 416,col 49)","literalExprId":440,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 53)-(line 416,col 53)","literalExprId":441,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 57)-(line 416,col 57)","literalExprId":442,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 60)-(line 416,col 60)","literalExprId":443,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 63)-(line 416,col 65)","literalExprId":444,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 416,col 72)-(line 416,col 76)","literalExprId":445,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 417,col 52)-(line 417,col 55)","literalExprId":446,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 418,col 46)-(line 418,col 47)","literalExprId":447,"literalExpr":"42","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 418,col 54)-(line 418,col 57)","literalExprId":448,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 421,col 47)-(line 421,col 47)","literalExprId":449,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 421,col 50)-(line 421,col 50)","literalExprId":450,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 421,col 53)-(line 421,col 53)","literalExprId":451,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 421,col 56)-(line 421,col 56)","literalExprId":452,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 421,col 59)-(line 421,col 59)","literalExprId":453,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 421,col 62)-(line 421,col 62)","literalExprId":454,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 421,col 69)-(line 421,col 72)","literalExprId":455,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 422,col 47)-(line 422,col 47)","literalExprId":456,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 422,col 50)-(line 422,col 50)","literalExprId":457,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 422,col 53)-(line 422,col 53)","literalExprId":458,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 422,col 56)-(line 422,col 56)","literalExprId":459,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 422,col 59)-(line 422,col 59)","literalExprId":460,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 422,col 62)-(line 422,col 64)","literalExprId":461,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 422,col 71)-(line 422,col 74)","literalExprId":462,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 423,col 47)-(line 423,col 47)","literalExprId":463,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 50)-(line 423,col 50)","literalExprId":464,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 53)-(line 423,col 53)","literalExprId":465,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 56)-(line 423,col 56)","literalExprId":466,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 59)-(line 423,col 59)","literalExprId":467,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 62)-(line 423,col 62)","literalExprId":468,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 423,col 69)-(line 423,col 73)","literalExprId":469,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 424,col 47)-(line 424,col 47)","literalExprId":470,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 424,col 50)-(line 424,col 50)","literalExprId":471,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 424,col 53)-(line 424,col 53)","literalExprId":472,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 424,col 56)-(line 424,col 56)","literalExprId":473,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 424,col 59)-(line 424,col 59)","literalExprId":474,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 424,col 62)-(line 424,col 62)","literalExprId":475,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 424,col 69)-(line 424,col 73)","literalExprId":476,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 425,col 47)-(line 425,col 47)","literalExprId":477,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 50)-(line 425,col 50)","literalExprId":478,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 54)-(line 425,col 54)","literalExprId":479,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 58)-(line 425,col 58)","literalExprId":480,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 61)-(line 425,col 61)","literalExprId":481,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 64)-(line 425,col 64)","literalExprId":482,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 425,col 71)-(line 425,col 74)","literalExprId":483,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 426,col 47)-(line 426,col 47)","literalExprId":484,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 50)-(line 426,col 50)","literalExprId":485,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 54)-(line 426,col 54)","literalExprId":486,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 58)-(line 426,col 58)","literalExprId":487,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 61)-(line 426,col 61)","literalExprId":488,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 64)-(line 426,col 66)","literalExprId":489,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 426,col 73)-(line 426,col 77)","literalExprId":490,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 427,col 53)-(line 427,col 56)","literalExprId":491,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 428,col 47)-(line 428,col 48)","literalExprId":492,"literalExpr":"42","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 428,col 55)-(line 428,col 58)","literalExprId":493,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 431,col 49)-(line 431,col 49)","literalExprId":494,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 431,col 52)-(line 431,col 52)","literalExprId":495,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 431,col 55)-(line 431,col 55)","literalExprId":496,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 431,col 58)-(line 431,col 58)","literalExprId":497,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 431,col 61)-(line 431,col 61)","literalExprId":498,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 431,col 64)-(line 431,col 64)","literalExprId":499,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 431,col 71)-(line 431,col 74)","literalExprId":500,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 432,col 49)-(line 432,col 49)","literalExprId":501,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 52)-(line 432,col 52)","literalExprId":502,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 55)-(line 432,col 55)","literalExprId":503,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 58)-(line 432,col 58)","literalExprId":504,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 61)-(line 432,col 61)","literalExprId":505,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 64)-(line 432,col 66)","literalExprId":506,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 432,col 73)-(line 432,col 76)","literalExprId":507,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 433,col 49)-(line 433,col 49)","literalExprId":508,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 52)-(line 433,col 52)","literalExprId":509,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 55)-(line 433,col 55)","literalExprId":510,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 58)-(line 433,col 58)","literalExprId":511,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 61)-(line 433,col 61)","literalExprId":512,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 64)-(line 433,col 64)","literalExprId":513,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 433,col 71)-(line 433,col 75)","literalExprId":514,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 434,col 49)-(line 434,col 49)","literalExprId":515,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 434,col 52)-(line 434,col 52)","literalExprId":516,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 434,col 55)-(line 434,col 55)","literalExprId":517,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 434,col 58)-(line 434,col 58)","literalExprId":518,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 434,col 61)-(line 434,col 61)","literalExprId":519,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 434,col 64)-(line 434,col 64)","literalExprId":520,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 434,col 71)-(line 434,col 75)","literalExprId":521,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 435,col 49)-(line 435,col 50)","literalExprId":522,"literalExpr":"1.","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 435,col 53)-(line 435,col 57)","literalExprId":523,"literalExpr":"1.001","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 435,col 61)-(line 435,col 61)","literalExprId":524,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 435,col 65)-(line 435,col 65)","literalExprId":525,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 435,col 68)-(line 435,col 68)","literalExprId":526,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 435,col 71)-(line 435,col 71)","literalExprId":527,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 435,col 78)-(line 435,col 81)","literalExprId":528,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 436,col 49)-(line 436,col 50)","literalExprId":529,"literalExpr":"1.","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 436,col 53)-(line 436,col 53)","literalExprId":530,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 436,col 57)-(line 436,col 60)","literalExprId":531,"literalExpr":"2.00","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 436,col 64)-(line 436,col 64)","literalExprId":532,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 436,col 67)-(line 436,col 67)","literalExprId":533,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 436,col 70)-(line 436,col 72)","literalExprId":534,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 436,col 79)-(line 436,col 83)","literalExprId":535,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 437,col 55)-(line 437,col 58)","literalExprId":536,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 438,col 49)-(line 438,col 50)","literalExprId":537,"literalExpr":"42","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 438,col 57)-(line 438,col 60)","literalExprId":538,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 441,col 49)-(line 441,col 51)","literalExprId":539,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 441,col 54)-(line 441,col 56)","literalExprId":540,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 441,col 59)-(line 441,col 61)","literalExprId":541,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 441,col 64)-(line 441,col 66)","literalExprId":542,"literalExpr":"\"5\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 441,col 69)-(line 441,col 71)","literalExprId":543,"literalExpr":"\"4\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 441,col 74)-(line 441,col 76)","literalExprId":544,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 441,col 83)-(line 441,col 86)","literalExprId":545,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 442,col 49)-(line 442,col 51)","literalExprId":546,"literalExpr":"\"A\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 442,col 54)-(line 442,col 56)","literalExprId":547,"literalExpr":"\"a\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 442,col 59)-(line 442,col 63)","literalExprId":548,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 442,col 66)-(line 442,col 70)","literalExprId":549,"literalExpr":"\"Foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 442,col 73)-(line 442,col 74)","literalExprId":550,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 442,col 81)-(line 442,col 84)","literalExprId":551,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 443,col 49)-(line 443,col 51)","literalExprId":552,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 443,col 54)-(line 443,col 56)","literalExprId":553,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 443,col 63)-(line 443,col 67)","literalExprId":554,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 444,col 49)-(line 444,col 52)","literalExprId":555,"literalExpr":"\"  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 444,col 55)-(line 444,col 57)","literalExprId":556,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 444,col 64)-(line 444,col 67)","literalExprId":557,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 447,col 51)-(line 447,col 51)","literalExprId":558,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 54)-(line 447,col 54)","literalExprId":559,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 57)-(line 447,col 57)","literalExprId":560,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 60)-(line 447,col 60)","literalExprId":561,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 447,col 67)-(line 447,col 70)","literalExprId":562,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 448,col 51)-(line 448,col 51)","literalExprId":563,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 448,col 54)-(line 448,col 54)","literalExprId":564,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 448,col 57)-(line 448,col 57)","literalExprId":565,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 448,col 60)-(line 448,col 60)","literalExprId":566,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 448,col 67)-(line 448,col 70)","literalExprId":567,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 449,col 51)-(line 449,col 51)","literalExprId":568,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 54)-(line 449,col 54)","literalExprId":569,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 57)-(line 449,col 57)","literalExprId":570,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 60)-(line 449,col 60)","literalExprId":571,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 449,col 67)-(line 449,col 70)","literalExprId":572,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 450,col 51)-(line 450,col 51)","literalExprId":573,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 450,col 54)-(line 450,col 54)","literalExprId":574,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 450,col 57)-(line 450,col 57)","literalExprId":575,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 450,col 60)-(line 450,col 60)","literalExprId":576,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 450,col 67)-(line 450,col 71)","literalExprId":577,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 451,col 51)-(line 451,col 51)","literalExprId":578,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 451,col 55)-(line 451,col 55)","literalExprId":579,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 451,col 58)-(line 451,col 58)","literalExprId":580,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 451,col 61)-(line 451,col 61)","literalExprId":581,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 451,col 68)-(line 451,col 72)","literalExprId":582,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 452,col 51)-(line 452,col 51)","literalExprId":583,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 452,col 54)-(line 452,col 54)","literalExprId":584,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 452,col 57)-(line 452,col 57)","literalExprId":585,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 452,col 60)-(line 452,col 60)","literalExprId":586,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 452,col 67)-(line 452,col 71)","literalExprId":587,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 453,col 51)-(line 453,col 51)","literalExprId":588,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 453,col 54)-(line 453,col 54)","literalExprId":589,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 453,col 57)-(line 453,col 57)","literalExprId":590,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 453,col 60)-(line 453,col 60)","literalExprId":591,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 453,col 67)-(line 453,col 71)","literalExprId":592,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 456,col 45)-(line 456,col 45)","literalExprId":593,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 456,col 48)-(line 456,col 48)","literalExprId":594,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 456,col 51)-(line 456,col 51)","literalExprId":595,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 456,col 54)-(line 456,col 54)","literalExprId":596,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 456,col 61)-(line 456,col 64)","literalExprId":597,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 457,col 45)-(line 457,col 45)","literalExprId":598,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 457,col 48)-(line 457,col 48)","literalExprId":599,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 457,col 51)-(line 457,col 51)","literalExprId":600,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 457,col 54)-(line 457,col 54)","literalExprId":601,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 457,col 61)-(line 457,col 64)","literalExprId":602,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 458,col 45)-(line 458,col 45)","literalExprId":603,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 458,col 48)-(line 458,col 48)","literalExprId":604,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 458,col 51)-(line 458,col 51)","literalExprId":605,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 458,col 54)-(line 458,col 54)","literalExprId":606,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 458,col 61)-(line 458,col 64)","literalExprId":607,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 459,col 45)-(line 459,col 45)","literalExprId":608,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 459,col 48)-(line 459,col 48)","literalExprId":609,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 459,col 51)-(line 459,col 51)","literalExprId":610,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 459,col 54)-(line 459,col 54)","literalExprId":611,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 459,col 61)-(line 459,col 64)","literalExprId":612,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 460,col 46)-(line 460,col 46)","literalExprId":613,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 460,col 49)-(line 460,col 49)","literalExprId":614,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 460,col 52)-(line 460,col 52)","literalExprId":615,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 460,col 55)-(line 460,col 55)","literalExprId":616,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 460,col 62)-(line 460,col 66)","literalExprId":617,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 461,col 45)-(line 461,col 45)","literalExprId":618,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 461,col 49)-(line 461,col 49)","literalExprId":619,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 461,col 52)-(line 461,col 52)","literalExprId":620,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 461,col 55)-(line 461,col 55)","literalExprId":621,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 461,col 62)-(line 461,col 66)","literalExprId":622,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 462,col 45)-(line 462,col 45)","literalExprId":623,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 462,col 49)-(line 462,col 49)","literalExprId":624,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 462,col 52)-(line 462,col 52)","literalExprId":625,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 462,col 55)-(line 462,col 55)","literalExprId":626,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 462,col 62)-(line 462,col 65)","literalExprId":627,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 463,col 45)-(line 463,col 45)","literalExprId":628,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 463,col 48)-(line 463,col 48)","literalExprId":629,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 463,col 51)-(line 463,col 51)","literalExprId":630,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 463,col 55)-(line 463,col 55)","literalExprId":631,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 463,col 62)-(line 463,col 66)","literalExprId":632,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 464,col 45)-(line 464,col 45)","literalExprId":633,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 464,col 48)-(line 464,col 48)","literalExprId":634,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 464,col 51)-(line 464,col 51)","literalExprId":635,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 464,col 54)-(line 464,col 54)","literalExprId":636,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 464,col 61)-(line 464,col 64)","literalExprId":637,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 465,col 45)-(line 465,col 45)","literalExprId":638,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 465,col 48)-(line 465,col 48)","literalExprId":639,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 465,col 51)-(line 465,col 51)","literalExprId":640,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 465,col 54)-(line 465,col 54)","literalExprId":641,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 465,col 61)-(line 465,col 64)","literalExprId":642,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 468,col 48)-(line 468,col 48)","literalExprId":643,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 469,col 48)-(line 469,col 48)","literalExprId":644,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 469,col 63)-(line 469,col 63)","literalExprId":645,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 470,col 48)-(line 470,col 48)","literalExprId":646,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 470,col 63)-(line 470,col 63)","literalExprId":647,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 470,col 66)-(line 470,col 66)","literalExprId":648,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 471,col 48)-(line 471,col 48)","literalExprId":649,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 471,col 63)-(line 471,col 63)","literalExprId":650,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 471,col 66)-(line 471,col 66)","literalExprId":651,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 471,col 69)-(line 471,col 69)","literalExprId":652,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 53)-(line 475,col 53)","literalExprId":653,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 56)-(line 475,col 56)","literalExprId":654,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 59)-(line 475,col 59)","literalExprId":655,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 62)-(line 475,col 62)","literalExprId":656,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 78)-(line 475,col 78)","literalExprId":657,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 81)-(line 475,col 81)","literalExprId":658,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 84)-(line 475,col 84)","literalExprId":659,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 475,col 87)-(line 475,col 87)","literalExprId":660,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 53)-(line 477,col 53)","literalExprId":661,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 56)-(line 477,col 56)","literalExprId":662,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 59)-(line 477,col 59)","literalExprId":663,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 62)-(line 477,col 62)","literalExprId":664,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 78)-(line 477,col 78)","literalExprId":665,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 81)-(line 477,col 81)","literalExprId":666,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 84)-(line 477,col 84)","literalExprId":667,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 477,col 87)-(line 477,col 87)","literalExprId":668,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 53)-(line 479,col 53)","literalExprId":669,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 56)-(line 479,col 56)","literalExprId":670,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 59)-(line 479,col 59)","literalExprId":671,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 62)-(line 479,col 62)","literalExprId":672,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 78)-(line 479,col 78)","literalExprId":673,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 81)-(line 479,col 81)","literalExprId":674,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 84)-(line 479,col 84)","literalExprId":675,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 479,col 87)-(line 479,col 87)","literalExprId":676,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 58)-(line 482,col 58)","literalExprId":677,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 61)-(line 482,col 61)","literalExprId":678,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 64)-(line 482,col 64)","literalExprId":679,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 67)-(line 482,col 67)","literalExprId":680,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 71)-(line 482,col 71)","literalExprId":681,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 86)-(line 482,col 86)","literalExprId":682,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 89)-(line 482,col 89)","literalExprId":683,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 92)-(line 482,col 92)","literalExprId":684,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 482,col 95)-(line 482,col 95)","literalExprId":685,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 58)-(line 483,col 58)","literalExprId":686,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 61)-(line 483,col 61)","literalExprId":687,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 64)-(line 483,col 64)","literalExprId":688,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 67)-(line 483,col 67)","literalExprId":689,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 71)-(line 483,col 71)","literalExprId":690,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 86)-(line 483,col 86)","literalExprId":691,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 89)-(line 483,col 89)","literalExprId":692,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 92)-(line 483,col 92)","literalExprId":693,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 483,col 95)-(line 483,col 95)","literalExprId":694,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 58)-(line 484,col 58)","literalExprId":695,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 61)-(line 484,col 61)","literalExprId":696,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 64)-(line 484,col 64)","literalExprId":697,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 67)-(line 484,col 67)","literalExprId":698,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 71)-(line 484,col 71)","literalExprId":699,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 86)-(line 484,col 86)","literalExprId":700,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 89)-(line 484,col 89)","literalExprId":701,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 92)-(line 484,col 92)","literalExprId":702,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 484,col 95)-(line 484,col 95)","literalExprId":703,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 486,col 39)-(line 486,col 39)","literalExprId":704,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 486,col 42)-(line 486,col 42)","literalExprId":705,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 486,col 45)-(line 486,col 45)","literalExprId":706,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 486,col 48)-(line 486,col 48)","literalExprId":707,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 486,col 52)-(line 486,col 52)","literalExprId":708,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 489,col 32)-(line 489,col 35)","literalExprId":709,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 489,col 62)-(line 489,col 96)","literalExprId":710,"literalExpr":"\"Not invertible; a[1]=0 and a[3]=0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 491,col 58)-(line 491,col 58)","literalExprId":711,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 62)-(line 491,col 62)","literalExprId":712,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 78)-(line 491,col 78)","literalExprId":713,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 82)-(line 491,col 82)","literalExprId":714,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 86)-(line 491,col 86)","literalExprId":715,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 90)-(line 491,col 90)","literalExprId":716,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 94)-(line 491,col 94)","literalExprId":717,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 97)-(line 491,col 97)","literalExprId":718,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 41)-(line 493,col 41)","literalExprId":719,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 44)-(line 493,col 44)","literalExprId":720,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 47)-(line 493,col 47)","literalExprId":721,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 50)-(line 493,col 50)","literalExprId":722,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 54)-(line 493,col 54)","literalExprId":723,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 70)-(line 493,col 70)","literalExprId":724,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 73)-(line 493,col 73)","literalExprId":725,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 76)-(line 493,col 76)","literalExprId":726,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 79)-(line 493,col 79)","literalExprId":727,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 83)-(line 493,col 83)","literalExprId":728,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 493,col 86)-(line 493,col 86)","literalExprId":729,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 43)-(line 497,col 45)","literalExprId":730,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 48)-(line 497,col 50)","literalExprId":731,"literalExpr":"101","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 53)-(line 497,col 55)","literalExprId":732,"literalExpr":"102","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 58)-(line 497,col 60)","literalExprId":733,"literalExpr":"103","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 64)-(line 497,col 64)","literalExprId":734,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 79)-(line 497,col 80)","literalExprId":735,"literalExpr":"40","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 83)-(line 497,col 84)","literalExprId":736,"literalExpr":"41","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 87)-(line 497,col 88)","literalExprId":737,"literalExpr":"42","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 497,col 91)-(line 497,col 92)","literalExprId":738,"literalExpr":"43","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 500,col 32)-(line 500,col 35)","literalExprId":739,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 500,col 62)-(line 500,col 88)","literalExprId":740,"literalExpr":"\"Bad range value: a[0]=100\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 505,col 41)-(line 505,col 41)","literalExprId":741,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 44)-(line 505,col 44)","literalExprId":742,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 47)-(line 505,col 47)","literalExprId":743,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 50)-(line 505,col 50)","literalExprId":744,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 65)-(line 505,col 65)","literalExprId":745,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 68)-(line 505,col 68)","literalExprId":746,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 71)-(line 505,col 71)","literalExprId":747,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 505,col 74)-(line 505,col 74)","literalExprId":748,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 506,col 20)-(line 506,col 20)","literalExprId":749,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 506,col 23)-(line 506,col 23)","literalExprId":750,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 506,col 26)-(line 506,col 26)","literalExprId":751,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 506,col 29)-(line 506,col 29)","literalExprId":752,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 41)-(line 508,col 41)","literalExprId":753,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 44)-(line 508,col 44)","literalExprId":754,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 47)-(line 508,col 47)","literalExprId":755,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 50)-(line 508,col 50)","literalExprId":756,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 65)-(line 508,col 65)","literalExprId":757,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 68)-(line 508,col 68)","literalExprId":758,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 71)-(line 508,col 71)","literalExprId":759,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 508,col 74)-(line 508,col 74)","literalExprId":760,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 509,col 20)-(line 509,col 20)","literalExprId":761,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 509,col 23)-(line 509,col 23)","literalExprId":762,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 509,col 26)-(line 509,col 26)","literalExprId":763,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 509,col 29)-(line 509,col 29)","literalExprId":764,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 41)-(line 511,col 41)","literalExprId":765,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 44)-(line 511,col 44)","literalExprId":766,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 47)-(line 511,col 47)","literalExprId":767,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 50)-(line 511,col 50)","literalExprId":768,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 65)-(line 511,col 65)","literalExprId":769,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 68)-(line 511,col 68)","literalExprId":770,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 71)-(line 511,col 71)","literalExprId":771,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 511,col 74)-(line 511,col 74)","literalExprId":772,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 512,col 20)-(line 512,col 20)","literalExprId":773,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 512,col 23)-(line 512,col 23)","literalExprId":774,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 512,col 26)-(line 512,col 26)","literalExprId":775,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 512,col 29)-(line 512,col 29)","literalExprId":776,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 41)-(line 514,col 41)","literalExprId":777,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 44)-(line 514,col 44)","literalExprId":778,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 47)-(line 514,col 47)","literalExprId":779,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 50)-(line 514,col 50)","literalExprId":780,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 65)-(line 514,col 65)","literalExprId":781,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 68)-(line 514,col 68)","literalExprId":782,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 71)-(line 514,col 71)","literalExprId":783,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 514,col 74)-(line 514,col 74)","literalExprId":784,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 515,col 20)-(line 515,col 20)","literalExprId":785,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 515,col 23)-(line 515,col 23)","literalExprId":786,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 515,col 26)-(line 515,col 26)","literalExprId":787,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 515,col 29)-(line 515,col 29)","literalExprId":788,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 516,col 58)-(line 516,col 58)","literalExprId":789,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 516,col 73)-(line 516,col 73)","literalExprId":790,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 516,col 89)-(line 516,col 89)","literalExprId":791,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 41)-(line 518,col 41)","literalExprId":792,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 44)-(line 518,col 44)","literalExprId":793,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 47)-(line 518,col 47)","literalExprId":794,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 50)-(line 518,col 50)","literalExprId":795,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 65)-(line 518,col 65)","literalExprId":796,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 68)-(line 518,col 68)","literalExprId":797,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 71)-(line 518,col 71)","literalExprId":798,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 74)-(line 518,col 74)","literalExprId":799,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 78)-(line 518,col 78)","literalExprId":800,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 518,col 82)-(line 518,col 82)","literalExprId":801,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 519,col 20)-(line 519,col 20)","literalExprId":802,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 519,col 23)-(line 519,col 23)","literalExprId":803,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 519,col 26)-(line 519,col 26)","literalExprId":804,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 519,col 30)-(line 519,col 30)","literalExprId":805,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 526,col 32)-(line 526,col 33)","literalExprId":806,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 527,col 32)-(line 527,col 33)","literalExprId":807,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 529,col 20)-(line 529,col 20)","literalExprId":808,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 532,col 20)-(line 532,col 20)","literalExprId":809,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 535,col 22)-(line 535,col 22)","literalExprId":810,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 539,col 12)-(line 539,col 12)","literalExprId":811,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 549,col 35)-(line 549,col 35)","literalExprId":812,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 549,col 38)-(line 549,col 38)","literalExprId":813,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 549,col 41)-(line 549,col 42)","literalExprId":814,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 551,col 35)-(line 551,col 35)","literalExprId":815,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 552,col 35)-(line 552,col 36)","literalExprId":816,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 553,col 35)-(line 553,col 35)","literalExprId":817,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 553,col 38)-(line 553,col 39)","literalExprId":818,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 553,col 42)-(line 553,col 43)","literalExprId":819,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 553,col 46)-(line 553,col 47)","literalExprId":820,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 554,col 35)-(line 554,col 36)","literalExprId":821,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 554,col 39)-(line 554,col 40)","literalExprId":822,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 554,col 43)-(line 554,col 44)","literalExprId":823,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 554,col 47)-(line 554,col 48)","literalExprId":824,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 554,col 51)-(line 554,col 52)","literalExprId":825,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 554,col 55)-(line 554,col 55)","literalExprId":826,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 573,col 29)-(line 573,col 29)","literalExprId":827,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 573,col 32)-(line 573,col 32)","literalExprId":828,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 573,col 35)-(line 573,col 35)","literalExprId":829,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 573,col 38)-(line 573,col 38)","literalExprId":830,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 574,col 29)-(line 574,col 29)","literalExprId":831,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 574,col 32)-(line 574,col 32)","literalExprId":832,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 574,col 35)-(line 574,col 35)","literalExprId":833,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 574,col 38)-(line 574,col 38)","literalExprId":834,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 574,col 41)-(line 574,col 41)","literalExprId":835,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 575,col 29)-(line 575,col 29)","literalExprId":836,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 575,col 32)-(line 575,col 32)","literalExprId":837,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 575,col 35)-(line 575,col 35)","literalExprId":838,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 575,col 38)-(line 575,col 38)","literalExprId":839,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 575,col 41)-(line 575,col 41)","literalExprId":840,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 576,col 29)-(line 576,col 29)","literalExprId":841,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 576,col 32)-(line 576,col 32)","literalExprId":842,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 576,col 35)-(line 576,col 35)","literalExprId":843,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 576,col 38)-(line 576,col 38)","literalExprId":844,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 576,col 41)-(line 576,col 41)","literalExprId":845,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 577,col 29)-(line 577,col 29)","literalExprId":846,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 577,col 32)-(line 577,col 32)","literalExprId":847,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 577,col 35)-(line 577,col 35)","literalExprId":848,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 577,col 38)-(line 577,col 38)","literalExprId":849,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 577,col 41)-(line 577,col 41)","literalExprId":850,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 578,col 29)-(line 578,col 29)","literalExprId":851,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 578,col 32)-(line 578,col 32)","literalExprId":852,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 578,col 35)-(line 578,col 35)","literalExprId":853,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 578,col 38)-(line 578,col 38)","literalExprId":854,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 579,col 30)-(line 579,col 30)","literalExprId":855,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 583,col 38)-(line 583,col 38)","literalExprId":856,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 584,col 39)-(line 584,col 39)","literalExprId":857,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 585,col 38)-(line 585,col 38)","literalExprId":858,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 586,col 39)-(line 586,col 39)","literalExprId":859,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 587,col 37)-(line 587,col 37)","literalExprId":860,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 588,col 38)-(line 588,col 38)","literalExprId":861,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 589,col 37)-(line 589,col 37)","literalExprId":862,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 590,col 38)-(line 590,col 38)","literalExprId":863,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 591,col 37)-(line 591,col 37)","literalExprId":864,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 592,col 38)-(line 592,col 38)","literalExprId":865,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 593,col 37)-(line 593,col 37)","literalExprId":866,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 594,col 38)-(line 594,col 38)","literalExprId":867,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 595,col 37)-(line 595,col 37)","literalExprId":868,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 596,col 38)-(line 596,col 38)","literalExprId":869,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 597,col 37)-(line 597,col 37)","literalExprId":870,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 598,col 38)-(line 598,col 38)","literalExprId":871,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 599,col 38)-(line 599,col 38)","literalExprId":872,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 600,col 39)-(line 600,col 39)","literalExprId":873,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 601,col 38)-(line 601,col 38)","literalExprId":874,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 602,col 39)-(line 602,col 39)","literalExprId":875,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 603,col 37)-(line 603,col 37)","literalExprId":876,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 604,col 38)-(line 604,col 38)","literalExprId":877,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 605,col 37)-(line 605,col 37)","literalExprId":878,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 606,col 38)-(line 606,col 38)","literalExprId":879,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 607,col 37)-(line 607,col 37)","literalExprId":880,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 608,col 38)-(line 608,col 38)","literalExprId":881,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 609,col 37)-(line 609,col 37)","literalExprId":882,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 610,col 38)-(line 610,col 38)","literalExprId":883,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 611,col 37)-(line 611,col 37)","literalExprId":884,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 612,col 38)-(line 612,col 38)","literalExprId":885,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 613,col 37)-(line 613,col 37)","literalExprId":886,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 614,col 38)-(line 614,col 38)","literalExprId":887,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 615,col 37)-(line 615,col 37)","literalExprId":888,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 616,col 38)-(line 616,col 38)","literalExprId":889,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 617,col 37)-(line 617,col 37)","literalExprId":890,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 618,col 38)-(line 618,col 38)","literalExprId":891,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 619,col 37)-(line 619,col 37)","literalExprId":892,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 620,col 38)-(line 620,col 38)","literalExprId":893,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 621,col 37)-(line 621,col 37)","literalExprId":894,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 622,col 38)-(line 622,col 38)","literalExprId":895,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 623,col 37)-(line 623,col 37)","literalExprId":896,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 624,col 38)-(line 624,col 38)","literalExprId":897,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 625,col 37)-(line 625,col 37)","literalExprId":898,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 626,col 38)-(line 626,col 38)","literalExprId":899,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 627,col 37)-(line 627,col 37)","literalExprId":900,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 628,col 38)-(line 628,col 38)","literalExprId":901,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 629,col 38)-(line 629,col 38)","literalExprId":902,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 639,col 31)-(line 639,col 31)","literalExprId":903,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 639,col 34)-(line 639,col 34)","literalExprId":904,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 639,col 37)-(line 639,col 37)","literalExprId":905,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 639,col 40)-(line 639,col 40)","literalExprId":906,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 640,col 31)-(line 640,col 31)","literalExprId":907,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 640,col 34)-(line 640,col 34)","literalExprId":908,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 640,col 37)-(line 640,col 37)","literalExprId":909,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 640,col 40)-(line 640,col 40)","literalExprId":910,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 640,col 43)-(line 640,col 43)","literalExprId":911,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 641,col 31)-(line 641,col 31)","literalExprId":912,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 641,col 34)-(line 641,col 34)","literalExprId":913,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 641,col 37)-(line 641,col 37)","literalExprId":914,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 641,col 40)-(line 641,col 40)","literalExprId":915,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 641,col 43)-(line 641,col 43)","literalExprId":916,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 642,col 31)-(line 642,col 31)","literalExprId":917,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 642,col 34)-(line 642,col 34)","literalExprId":918,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 642,col 37)-(line 642,col 37)","literalExprId":919,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 642,col 40)-(line 642,col 40)","literalExprId":920,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 642,col 43)-(line 642,col 43)","literalExprId":921,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 643,col 31)-(line 643,col 31)","literalExprId":922,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 643,col 34)-(line 643,col 34)","literalExprId":923,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 643,col 37)-(line 643,col 37)","literalExprId":924,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 643,col 40)-(line 643,col 40)","literalExprId":925,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 643,col 43)-(line 643,col 43)","literalExprId":926,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 644,col 31)-(line 644,col 31)","literalExprId":927,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 644,col 34)-(line 644,col 34)","literalExprId":928,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 644,col 37)-(line 644,col 37)","literalExprId":929,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 644,col 40)-(line 644,col 40)","literalExprId":930,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 645,col 32)-(line 645,col 32)","literalExprId":931,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 649,col 38)-(line 649,col 38)","literalExprId":932,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 650,col 39)-(line 650,col 39)","literalExprId":933,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 651,col 38)-(line 651,col 38)","literalExprId":934,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 652,col 39)-(line 652,col 39)","literalExprId":935,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 653,col 37)-(line 653,col 37)","literalExprId":936,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 654,col 38)-(line 654,col 38)","literalExprId":937,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 655,col 37)-(line 655,col 37)","literalExprId":938,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 656,col 38)-(line 656,col 38)","literalExprId":939,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 657,col 37)-(line 657,col 37)","literalExprId":940,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 658,col 38)-(line 658,col 38)","literalExprId":941,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 659,col 37)-(line 659,col 37)","literalExprId":942,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 660,col 38)-(line 660,col 38)","literalExprId":943,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 661,col 37)-(line 661,col 37)","literalExprId":944,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 662,col 38)-(line 662,col 38)","literalExprId":945,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 663,col 37)-(line 663,col 37)","literalExprId":946,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 664,col 38)-(line 664,col 38)","literalExprId":947,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 665,col 38)-(line 665,col 38)","literalExprId":948,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 666,col 39)-(line 666,col 39)","literalExprId":949,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 667,col 38)-(line 667,col 38)","literalExprId":950,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 668,col 39)-(line 668,col 39)","literalExprId":951,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 669,col 37)-(line 669,col 37)","literalExprId":952,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 670,col 38)-(line 670,col 38)","literalExprId":953,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 671,col 37)-(line 671,col 37)","literalExprId":954,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 672,col 38)-(line 672,col 38)","literalExprId":955,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 673,col 37)-(line 673,col 37)","literalExprId":956,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 674,col 38)-(line 674,col 38)","literalExprId":957,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 675,col 37)-(line 675,col 37)","literalExprId":958,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 676,col 38)-(line 676,col 38)","literalExprId":959,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 677,col 37)-(line 677,col 37)","literalExprId":960,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 678,col 38)-(line 678,col 38)","literalExprId":961,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 679,col 37)-(line 679,col 37)","literalExprId":962,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 680,col 38)-(line 680,col 38)","literalExprId":963,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 681,col 37)-(line 681,col 37)","literalExprId":964,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 682,col 38)-(line 682,col 38)","literalExprId":965,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 683,col 37)-(line 683,col 37)","literalExprId":966,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 684,col 38)-(line 684,col 38)","literalExprId":967,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 685,col 37)-(line 685,col 37)","literalExprId":968,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 686,col 38)-(line 686,col 38)","literalExprId":969,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 687,col 37)-(line 687,col 37)","literalExprId":970,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 688,col 38)-(line 688,col 38)","literalExprId":971,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 689,col 37)-(line 689,col 37)","literalExprId":972,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 690,col 38)-(line 690,col 38)","literalExprId":973,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 691,col 37)-(line 691,col 37)","literalExprId":974,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 692,col 38)-(line 692,col 38)","literalExprId":975,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 693,col 37)-(line 693,col 37)","literalExprId":976,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 694,col 38)-(line 694,col 38)","literalExprId":977,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 695,col 38)-(line 695,col 38)","literalExprId":978,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 703,col 35)-(line 703,col 35)","literalExprId":979,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 703,col 38)-(line 703,col 38)","literalExprId":980,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 703,col 41)-(line 703,col 41)","literalExprId":981,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 703,col 44)-(line 703,col 44)","literalExprId":982,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 35)-(line 704,col 35)","literalExprId":983,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 38)-(line 704,col 38)","literalExprId":984,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 41)-(line 704,col 41)","literalExprId":985,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 44)-(line 704,col 44)","literalExprId":986,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 704,col 47)-(line 704,col 47)","literalExprId":987,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 35)-(line 705,col 35)","literalExprId":988,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 38)-(line 705,col 38)","literalExprId":989,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 41)-(line 705,col 41)","literalExprId":990,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 44)-(line 705,col 44)","literalExprId":991,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 705,col 47)-(line 705,col 47)","literalExprId":992,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 706,col 35)-(line 706,col 35)","literalExprId":993,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 706,col 38)-(line 706,col 38)","literalExprId":994,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 706,col 41)-(line 706,col 41)","literalExprId":995,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 706,col 44)-(line 706,col 44)","literalExprId":996,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 706,col 47)-(line 706,col 47)","literalExprId":997,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 707,col 35)-(line 707,col 35)","literalExprId":998,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 707,col 38)-(line 707,col 38)","literalExprId":999,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 707,col 41)-(line 707,col 41)","literalExprId":1000,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 707,col 44)-(line 707,col 44)","literalExprId":1001,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 707,col 47)-(line 707,col 47)","literalExprId":1002,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 708,col 35)-(line 708,col 35)","literalExprId":1003,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 708,col 38)-(line 708,col 38)","literalExprId":1004,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 708,col 41)-(line 708,col 41)","literalExprId":1005,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 708,col 44)-(line 708,col 44)","literalExprId":1006,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 709,col 35)-(line 709,col 39)","literalExprId":1007,"literalExpr":"0.005","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 710,col 35)-(line 710,col 39)","literalExprId":1008,"literalExpr":"0.004","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 711,col 37)-(line 711,col 41)","literalExprId":1009,"literalExpr":"0.005","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 712,col 37)-(line 712,col 41)","literalExprId":1010,"literalExpr":"0.004","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 713,col 36)-(line 713,col 39)","literalExprId":1011,"literalExpr":"10.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 714,col 36)-(line 714,col 39)","literalExprId":1012,"literalExpr":"10.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 716,col 38)-(line 716,col 38)","literalExprId":1013,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 717,col 38)-(line 717,col 38)","literalExprId":1014,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 718,col 37)-(line 718,col 37)","literalExprId":1015,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 719,col 37)-(line 719,col 37)","literalExprId":1016,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 720,col 37)-(line 720,col 37)","literalExprId":1017,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 721,col 37)-(line 721,col 37)","literalExprId":1018,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 722,col 37)-(line 722,col 37)","literalExprId":1019,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 723,col 37)-(line 723,col 37)","literalExprId":1020,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 724,col 38)-(line 724,col 38)","literalExprId":1021,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 725,col 38)-(line 725,col 38)","literalExprId":1022,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 726,col 37)-(line 726,col 37)","literalExprId":1023,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 727,col 37)-(line 727,col 37)","literalExprId":1024,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 728,col 37)-(line 728,col 37)","literalExprId":1025,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 729,col 37)-(line 729,col 37)","literalExprId":1026,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 730,col 37)-(line 730,col 37)","literalExprId":1027,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 731,col 37)-(line 731,col 37)","literalExprId":1028,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 732,col 37)-(line 732,col 37)","literalExprId":1029,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 733,col 37)-(line 733,col 37)","literalExprId":1030,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 734,col 37)-(line 734,col 37)","literalExprId":1031,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 735,col 37)-(line 735,col 37)","literalExprId":1032,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 736,col 37)-(line 736,col 37)","literalExprId":1033,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 737,col 37)-(line 737,col 37)","literalExprId":1034,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 740,col 37)-(line 740,col 37)","literalExprId":1035,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 741,col 39)-(line 741,col 39)","literalExprId":1036,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 742,col 39)-(line 742,col 39)","literalExprId":1037,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 743,col 39)-(line 743,col 39)","literalExprId":1038,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 744,col 39)-(line 744,col 39)","literalExprId":1039,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 757,col 35)-(line 757,col 37)","literalExprId":1040,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 757,col 40)-(line 757,col 42)","literalExprId":1041,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 757,col 45)-(line 757,col 47)","literalExprId":1042,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 757,col 50)-(line 757,col 52)","literalExprId":1043,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 35)-(line 758,col 37)","literalExprId":1044,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 40)-(line 758,col 42)","literalExprId":1045,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 45)-(line 758,col 47)","literalExprId":1046,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 50)-(line 758,col 52)","literalExprId":1047,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 758,col 55)-(line 758,col 57)","literalExprId":1048,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 759,col 35)-(line 759,col 37)","literalExprId":1049,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 759,col 40)-(line 759,col 42)","literalExprId":1050,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 759,col 45)-(line 759,col 47)","literalExprId":1051,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 759,col 50)-(line 759,col 52)","literalExprId":1052,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 759,col 55)-(line 759,col 57)","literalExprId":1053,"literalExpr":"\"4\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 35)-(line 760,col 37)","literalExprId":1054,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 40)-(line 760,col 42)","literalExprId":1055,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 45)-(line 760,col 47)","literalExprId":1056,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 50)-(line 760,col 52)","literalExprId":1057,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 760,col 55)-(line 760,col 57)","literalExprId":1058,"literalExpr":"\"4\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 761,col 35)-(line 761,col 37)","literalExprId":1059,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 761,col 40)-(line 761,col 42)","literalExprId":1060,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 761,col 45)-(line 761,col 47)","literalExprId":1061,"literalExpr":"\"5\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 761,col 50)-(line 761,col 52)","literalExprId":1062,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 761,col 55)-(line 761,col 57)","literalExprId":1063,"literalExpr":"\"4\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 762,col 35)-(line 762,col 37)","literalExprId":1064,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 762,col 40)-(line 762,col 42)","literalExprId":1065,"literalExpr":"\"2\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 762,col 45)-(line 762,col 47)","literalExprId":1066,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 762,col 50)-(line 762,col 52)","literalExprId":1067,"literalExpr":"\"4\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 764,col 11)-(line 764,col 20)","literalExprId":1068,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 765,col 35)-(line 765,col 37)","literalExprId":1069,"literalExpr":"\"0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 765,col 40)-(line 765,col 42)","literalExprId":1070,"literalExpr":"\"1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 765,col 45)-(line 765,col 48)","literalExprId":1071,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 765,col 51)-(line 765,col 53)","literalExprId":1072,"literalExpr":"\"3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 765,col 56)-(line 765,col 58)","literalExprId":1073,"literalExpr":"\"4\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 767,col 38)-(line 767,col 38)","literalExprId":1074,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 768,col 39)-(line 768,col 39)","literalExprId":1075,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 769,col 38)-(line 769,col 38)","literalExprId":1076,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 770,col 39)-(line 770,col 39)","literalExprId":1077,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 771,col 37)-(line 771,col 37)","literalExprId":1078,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 772,col 38)-(line 772,col 38)","literalExprId":1079,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 773,col 37)-(line 773,col 37)","literalExprId":1080,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 774,col 38)-(line 774,col 38)","literalExprId":1081,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 775,col 37)-(line 775,col 37)","literalExprId":1082,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 776,col 38)-(line 776,col 38)","literalExprId":1083,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 777,col 37)-(line 777,col 37)","literalExprId":1084,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 778,col 38)-(line 778,col 38)","literalExprId":1085,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 779,col 37)-(line 779,col 37)","literalExprId":1086,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 780,col 38)-(line 780,col 38)","literalExprId":1087,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 781,col 37)-(line 781,col 37)","literalExprId":1088,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 782,col 38)-(line 782,col 38)","literalExprId":1089,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 783,col 38)-(line 783,col 38)","literalExprId":1090,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 784,col 39)-(line 784,col 39)","literalExprId":1091,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 785,col 38)-(line 785,col 38)","literalExprId":1092,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 786,col 39)-(line 786,col 39)","literalExprId":1093,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 787,col 37)-(line 787,col 37)","literalExprId":1094,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 788,col 38)-(line 788,col 38)","literalExprId":1095,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 789,col 37)-(line 789,col 37)","literalExprId":1096,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 790,col 38)-(line 790,col 38)","literalExprId":1097,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 791,col 37)-(line 791,col 37)","literalExprId":1098,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 792,col 38)-(line 792,col 38)","literalExprId":1099,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 793,col 37)-(line 793,col 37)","literalExprId":1100,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 794,col 38)-(line 794,col 38)","literalExprId":1101,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 795,col 37)-(line 795,col 37)","literalExprId":1102,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 796,col 38)-(line 796,col 38)","literalExprId":1103,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 797,col 37)-(line 797,col 37)","literalExprId":1104,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 798,col 38)-(line 798,col 38)","literalExprId":1105,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 799,col 37)-(line 799,col 37)","literalExprId":1106,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 800,col 38)-(line 800,col 38)","literalExprId":1107,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 801,col 37)-(line 801,col 37)","literalExprId":1108,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 802,col 38)-(line 802,col 38)","literalExprId":1109,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 803,col 37)-(line 803,col 37)","literalExprId":1110,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 804,col 38)-(line 804,col 38)","literalExprId":1111,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 805,col 37)-(line 805,col 37)","literalExprId":1112,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 806,col 38)-(line 806,col 38)","literalExprId":1113,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 807,col 37)-(line 807,col 37)","literalExprId":1114,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 808,col 38)-(line 808,col 38)","literalExprId":1115,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 809,col 37)-(line 809,col 37)","literalExprId":1116,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 810,col 38)-(line 810,col 38)","literalExprId":1117,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 811,col 37)-(line 811,col 37)","literalExprId":1118,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 812,col 38)-(line 812,col 38)","literalExprId":1119,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 813,col 37)-(line 813,col 37)","literalExprId":1120,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 814,col 38)-(line 814,col 38)","literalExprId":1121,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 815,col 37)-(line 815,col 37)","literalExprId":1122,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 816,col 38)-(line 816,col 38)","literalExprId":1123,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 817,col 37)-(line 817,col 37)","literalExprId":1124,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 818,col 38)-(line 818,col 38)","literalExprId":1125,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 819,col 37)-(line 819,col 37)","literalExprId":1126,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 820,col 38)-(line 820,col 38)","literalExprId":1127,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 826,col 53)-(line 826,col 57)","literalExprId":1128,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 827,col 47)-(line 827,col 50)","literalExprId":1129,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 827,col 57)-(line 827,col 60)","literalExprId":1130,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 828,col 47)-(line 828,col 50)","literalExprId":1131,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 828,col 53)-(line 828,col 56)","literalExprId":1132,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 828,col 63)-(line 828,col 66)","literalExprId":1133,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 829,col 54)-(line 829,col 58)","literalExprId":1134,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 830,col 57)-(line 830,col 61)","literalExprId":1135,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 831,col 50)-(line 831,col 53)","literalExprId":1136,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 831,col 56)-(line 831,col 59)","literalExprId":1137,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 831,col 66)-(line 831,col 69)","literalExprId":1138,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 832,col 47)-(line 832,col 50)","literalExprId":1139,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 832,col 56)-(line 832,col 59)","literalExprId":1140,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 832,col 66)-(line 832,col 69)","literalExprId":1141,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 833,col 50)-(line 833,col 53)","literalExprId":1142,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 833,col 63)-(line 833,col 66)","literalExprId":1143,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 834,col 47)-(line 834,col 50)","literalExprId":1144,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 834,col 63)-(line 834,col 66)","literalExprId":1145,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 835,col 55)-(line 835,col 59)","literalExprId":1146,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 836,col 49)-(line 836,col 52)","literalExprId":1147,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 836,col 59)-(line 836,col 62)","literalExprId":1148,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 839,col 77)-(line 839,col 80)","literalExprId":1149,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 839,col 88)-(line 839,col 92)","literalExprId":1150,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 840,col 77)-(line 840,col 80)","literalExprId":1151,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 840,col 84)-(line 840,col 87)","literalExprId":1152,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 840,col 94)-(line 840,col 97)","literalExprId":1153,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 842,col 59)-(line 842,col 62)","literalExprId":1154,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 843,col 14)-(line 843,col 18)","literalExprId":1155,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 849,col 53)-(line 849,col 56)","literalExprId":1156,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 850,col 47)-(line 850,col 50)","literalExprId":1157,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 850,col 57)-(line 850,col 60)","literalExprId":1158,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 851,col 47)-(line 851,col 50)","literalExprId":1159,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 851,col 53)-(line 851,col 56)","literalExprId":1160,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 851,col 63)-(line 851,col 66)","literalExprId":1161,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 852,col 54)-(line 852,col 58)","literalExprId":1162,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 853,col 57)-(line 853,col 61)","literalExprId":1163,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 854,col 50)-(line 854,col 53)","literalExprId":1164,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 854,col 56)-(line 854,col 59)","literalExprId":1165,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 854,col 66)-(line 854,col 70)","literalExprId":1166,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 855,col 47)-(line 855,col 50)","literalExprId":1167,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 855,col 56)-(line 855,col 59)","literalExprId":1168,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 855,col 66)-(line 855,col 70)","literalExprId":1169,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 856,col 50)-(line 856,col 53)","literalExprId":1170,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 856,col 63)-(line 856,col 67)","literalExprId":1171,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 857,col 47)-(line 857,col 50)","literalExprId":1172,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 857,col 63)-(line 857,col 67)","literalExprId":1173,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 858,col 55)-(line 858,col 58)","literalExprId":1174,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 859,col 49)-(line 859,col 52)","literalExprId":1175,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 859,col 59)-(line 859,col 62)","literalExprId":1176,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 860,col 49)-(line 860,col 52)","literalExprId":1177,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 860,col 55)-(line 860,col 58)","literalExprId":1178,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 860,col 65)-(line 860,col 68)","literalExprId":1179,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 861,col 77)-(line 861,col 80)","literalExprId":1180,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 861,col 88)-(line 861,col 92)","literalExprId":1181,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 862,col 77)-(line 862,col 80)","literalExprId":1182,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 862,col 84)-(line 862,col 87)","literalExprId":1183,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 862,col 94)-(line 862,col 98)","literalExprId":1184,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 864,col 59)-(line 864,col 62)","literalExprId":1185,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 865,col 14)-(line 865,col 18)","literalExprId":1186,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testArraysMDE()"},{"methodDeclaration":"public void testHasher()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    class InternTest {\n\n        void test(boolean random) {\n            int size1 = (random ? 100 : 1);\n            int size2 = (random ? 10 : 1);\n            Random random_gen = new Random();\n            int[][] arrays = new int[100][];\n            for (int i = 0; i < arrays.length; i++) {\n                int[] a = new int[10];\n                for (int j = 0; j < a.length; j++) {\n                    if (random) {\n                        a[j] = random_gen.nextInt(1000);\n                    } else {\n                        a[j] = j;\n                    }\n                }\n                arrays[i] = a;\n                a = null;\n            }\n            System.gc();\n            if (Intern.numIntArrays() != 0) {\n                throw new Error(\" expected 0 int arrays at start, found \" + Intern.numIntArrays());\n            }\n            for (int i = 0; i < arrays.length; i++) {\n                Intern.intern(arrays[i]);\n            }\n            if (Intern.numIntArrays() != size1) {\n                throw new Error(\"Expected \" + size1 + \", got \" + Intern.numIntArrays() + \" int arrays\");\n            }\n            System.gc();\n            if (Intern.numIntArrays() != size1) {\n                throw new Error();\n            }\n            for (int i = 10; i < arrays.length; i++) {\n                @SuppressWarnings(\"nullness\")\n                int[] reset_value = null;\n                arrays[i] = reset_value;\n            }\n            System.gc();\n            if (Intern.numIntArrays() != size2) {\n                if (Intern.numIntArrays() < size2 + 10) {\n                    System.out.println(\"Is JIT disabled?  Size should have been \" + size2 + \", actually was \" + Intern.numIntArrays());\n                } else {\n                    System.out.println(\"================\");\n                    for (int i = 0; i < arrays.length; i++) {\n                        System.out.println(ArraysMDE.toString(arrays[i]));\n                    }\n                    System.out.println(\"================\");\n                    for (Iterator<int[]> itor = Intern.intArrays(); itor.hasNext(); ) {\n                        System.out.println(ArraysMDE.toString(itor.next()));\n                    }\n                    String message = (\"Size should have been \" + size2 + \", actually was \" + Intern.numIntArrays());\n                    System.out.println(message);\n                    throw new Error(message);\n                }\n            }\n        }\n    }\n    InternTest intern = new InternTest();\n    intern.test(true);\n    intern.test(false);\n}","methodRange":"(line 870,col 3)-(line 975,col 3)","methodTokenRange":"@Test\n  public void testHasher() {\n\n    \/\/\/ To check (maybe some of these are done already).\n    \/\/\/ All of these methods are in Intern; should the tests appear in\n    \/\/\/ testIntern() or here?\n    \/\/ public static void internStrings(String[] a)\n    \/\/ public static boolean isInterned(Object value)\n    \/\/ public static int numIntegers()\n    \/\/ public static int numIntArrays()\n    \/\/ public static int numDoubles()\n    \/\/ public static int numDoubleArrays()\n    \/\/ public static int numObjectArrays()\n    \/\/ public static Iterator integers()\n    \/\/ public static Iterator intArrays()\n    \/\/ public static Iterator doubles()\n    \/\/ public static Iterator doubleArrays()\n    \/\/ public static Iterator objectArrays()\n    \/\/ public static Integer intern(Integer a)\n    \/\/ public static Integer internedInteger(int i)\n    \/\/ public static Integer internedInteger(String s)\n    \/\/ public static int[] intern(int[] a)\n    \/\/ public static Double intern(Double a)\n    \/\/ public static Double internedDouble(int i)\n    \/\/ public static Double internedDouble(String s)\n    \/\/ public static double[] intern(double[] a)\n    \/\/ public static Object[] intern(Object[] a)\n\n    \/\/ private static class IntArrayHasher implements Hasher\n    \/\/ private static class ObjectArrayHasher implements Hasher\n    \/\/ public static int[] intern(int[] a)\n    \/\/ public static Object[] intern(Object[] a)\n\n    class InternTest {\n      \/\/ javadoc won't let this be static.\n      void test(boolean random) {\n        int size1 = (random ? 100 : 1);\n        int size2 = (random ? 10 : 1);\n\n        Random random_gen = new Random();\n\n        int[][] arrays = new int[100][];\n        for (int i = 0; i < arrays.length; i++) {\n          int[] a = new int[10];\n          for (int j = 0; j < a.length; j++) {\n            if (random) {\n              a[j] = random_gen.nextInt(1000);\n            } else {\n              a[j] = j;\n            }\n          }\n          arrays[i] = a;\n          \/\/ System.out.println(ArraysMDE.toString(a));\n          \/\/ Sadly, this is required to get the last array to be\n          \/\/ garbage-collected with Jikes 1.03 and JDK 1.2.2.\n          a = null;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != 0) {\n          throw new Error(\" expected 0 int arrays at start, found \" + Intern.numIntArrays());\n        }\n        for (int i = 0; i < arrays.length; i++) {\n          Intern.intern(arrays[i]);\n        }\n        if (Intern.numIntArrays() != size1) {\n          throw new Error(\"Expected \" + size1 + \", got \" + Intern.numIntArrays() + \" int arrays\");\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size1) {\n          throw new Error();\n        }\n        for (int i = 10; i < arrays.length; i++) {\n          @SuppressWarnings(\"nullness\")\n          int \/*@NonNull*\/ [] reset_value = null;\n          arrays[i] = reset_value;\n        }\n        System.gc();\n        if (Intern.numIntArrays() != size2) {\n          if (Intern.numIntArrays() < size2 + 10) {\n            System.out.println(\n                \"Is JIT disabled?  Size should have been \"\n                    + size2\n                    + \", actually was \"\n                    + Intern.numIntArrays());\n          } else {\n            System.out.println(\"================\");\n            for (int i = 0; i < arrays.length; i++) {\n              System.out.println(ArraysMDE.toString(arrays[i]));\n            }\n            System.out.println(\"================\");\n            for (Iterator<int[]> itor = Intern.intArrays(); itor.hasNext(); ) {\n              System.out.println(ArraysMDE.toString(itor.next()));\n            }\n            String message =\n                (\"Size should have been \" + size2 + \", actually was \" + Intern.numIntArrays());\n            System.out.println(message);\n            throw new Error(message);\n          }\n        }\n      }\n    }\n\n    InternTest intern = new InternTest();\n    intern.test(true);\n    intern.test(false);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" This cannot be static because it instantiates an inner class.","methodParameters":[],"methodName":"testHasher","methodQualifiedSignature":"plume.TestPlume.testHasher","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 906,col 31)-(line 906,col 33)","literalExprId":1,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 906,col 37)-(line 906,col 37)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 907,col 31)-(line 907,col 32)","literalExprId":3,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 907,col 36)-(line 907,col 36)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 911,col 34)-(line 911,col 36)","literalExprId":5,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 912,col 22)-(line 912,col 22)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 913,col 29)-(line 913,col 30)","literalExprId":7,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 914,col 24)-(line 914,col 24)","literalExprId":8,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 916,col 41)-(line 916,col 44)","literalExprId":9,"literalExpr":"1000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 925,col 15)-(line 925,col 18)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 928,col 38)-(line 928,col 38)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 929,col 27)-(line 929,col 67)","literalExprId":12,"literalExpr":"\" expected 0 int arrays at start, found \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 931,col 22)-(line 931,col 22)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 935,col 27)-(line 935,col 37)","literalExprId":14,"literalExpr":"\"Expected \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 935,col 49)-(line 935,col 56)","literalExprId":15,"literalExpr":"\", got \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 935,col 84)-(line 935,col 96)","literalExprId":16,"literalExpr":"\" int arrays\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 941,col 22)-(line 941,col 23)","literalExprId":17,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 942,col 29)-(line 942,col 38)","literalExprId":18,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 943,col 45)-(line 943,col 48)","literalExprId":19,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 948,col 47)-(line 948,col 48)","literalExprId":20,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 950,col 17)-(line 950,col 58)","literalExprId":21,"literalExpr":"\"Is JIT disabled?  Size should have been \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 952,col 23)-(line 952,col 39)","literalExprId":22,"literalExpr":"\", actually was \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 955,col 32)-(line 955,col 49)","literalExprId":23,"literalExpr":"\"================\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 956,col 26)-(line 956,col 26)","literalExprId":24,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 959,col 32)-(line 959,col 49)","literalExprId":25,"literalExpr":"\"================\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 964,col 18)-(line 964,col 41)","literalExprId":26,"literalExpr":"\"Size should have been \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 964,col 53)-(line 964,col 69)","literalExprId":27,"literalExpr":"\", actually was \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 973,col 17)-(line 973,col 20)","literalExprId":28,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 974,col 17)-(line 974,col 21)","literalExprId":29,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testHasher()"},{"methodDeclaration":"public void testIntern()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Integer i = Intern.internedInteger(\"1234\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 1234;\n    i = Intern.internedInteger(\"0x12ab\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 0x12ab;\n    Long l = Intern.internedLong(\"12345678\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 12345678;\n    l = Intern.internedLong(\"0x1234abcd\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 0x1234abcd;\n}","methodRange":"(line 977,col 3)-(line 992,col 3)","methodTokenRange":"@Test\n  public void testIntern() {\n    Integer i = Intern.internedInteger(\"1234\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 1234;\n    i = Intern.internedInteger(\"0x12ab\");\n    assert Intern.isInterned(i);\n    assert i.intValue() == 0x12ab;\n\n    Long l = Intern.internedLong(\"12345678\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 12345678;\n    l = Intern.internedLong(\"0x1234abcd\");\n    assert Intern.isInterned(l);\n    assert l.intValue() == 0x1234abcd;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testIntern","methodQualifiedSignature":"plume.TestPlume.testIntern","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 979,col 40)-(line 979,col 45)","literalExprId":1,"literalExpr":"\"1234\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 981,col 28)-(line 981,col 31)","literalExprId":2,"literalExpr":"1234","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 982,col 32)-(line 982,col 39)","literalExprId":3,"literalExpr":"\"0x12ab\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 984,col 28)-(line 984,col 33)","literalExprId":4,"literalExpr":"0x12ab","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 986,col 34)-(line 986,col 43)","literalExprId":5,"literalExpr":"\"12345678\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 988,col 28)-(line 988,col 35)","literalExprId":6,"literalExpr":"12345678","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 989,col 29)-(line 989,col 40)","literalExprId":7,"literalExpr":"\"0x1234abcd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 991,col 28)-(line 991,col 37)","literalExprId":8,"literalExpr":"0x1234abcd","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testIntern()"},{"methodDeclaration":"public void testInternObject()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object nIntern = Intern.intern((Object) null);\n    assert nIntern == null;\n    String sOrig = new String(\"foo\");\n    String sIntern = Intern.intern(sOrig);\n    Object sObjIntern = Intern.intern((Object) sOrig);\n    assert sIntern == sObjIntern;\n    Object sOtherIntern = Intern.intern(new String(\"foo\"));\n    assert sIntern == sOtherIntern;\n    String[] saOrig = new String[] { \"foo\", \"bar\" };\n    String[] saIntern = Intern.intern(saOrig);\n    Object saObjIntern = Intern.intern((Object) saOrig);\n    assert saIntern == saObjIntern;\n    Object saOtherIntern = Intern.intern(new String[] { \"foo\", \"bar\" });\n    assert saIntern == saOtherIntern;\n    Integer iOrig = new Integer(1);\n    Integer iIntern = Intern.intern(iOrig);\n    Object iObjIntern = Intern.intern((Object) iOrig);\n    assert iIntern == iObjIntern;\n    Object iOtherIntern = Intern.intern((Object) new Integer(1));\n    assert iIntern == iOtherIntern;\n    Long lOrig = new Long(12345678901234L);\n    Long lIntern = Intern.intern(lOrig);\n    Object lObjIntern = Intern.intern((Object) lOrig);\n    assert lIntern == lObjIntern;\n    Object lOtherIntern = Intern.intern((Object) new Long(12345678901234L));\n    assert lIntern == lOtherIntern;\n    int[] iaOrig = new int[] { 1, 2, 3 };\n    int[] iaIntern = Intern.intern(iaOrig);\n    Object iaObjIntern = Intern.intern((Object) iaOrig);\n    assert iaIntern == iaObjIntern;\n    Object iaOtherIntern = Intern.intern((Object) new int[] { 1, 2, 3 });\n    assert iaIntern == iaOtherIntern;\n    long[] laOrig = new long[] { 12345678901234L, 98765432109876L };\n    long[] laIntern = Intern.intern(laOrig);\n    Object laObjIntern = Intern.intern((Object) laOrig);\n    assert laIntern == laObjIntern;\n    Object laOtherIntern = Intern.intern((Object) new long[] { 12345678901234L, 98765432109876L });\n    assert laIntern == laOtherIntern;\n    Double dOrig = new Double(3.14);\n    Double dIntern = Intern.intern(dOrig);\n    Object dObjIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dObjIntern;\n    Object dOtherIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dOtherIntern;\n    Double dnOrig = new Double(Double.NaN);\n    Double dnIntern = Intern.intern(dnOrig);\n    Object dnObjIntern = Intern.intern((Object) dnOrig);\n    assert dnIntern == dnObjIntern;\n    Object dnOtherIntern = Intern.intern((Object) new Double(Double.POSITIVE_INFINITY \/ Double.POSITIVE_INFINITY));\n    assert dnIntern == dnOtherIntern;\n    Double diOrig = new Double(Double.POSITIVE_INFINITY);\n    Double diIntern = Intern.intern(diOrig);\n    Object diObjIntern = Intern.intern((Object) diOrig);\n    assert diIntern == diObjIntern;\n    Object diOtherIntern = Intern.intern((Object) new Double(2 * Double.MAX_VALUE));\n    assert diIntern == diOtherIntern;\n    double positive_zero = +0.0;\n    double negative_zero = -0.0;\n    assert positive_zero == negative_zero;\n    assert 1 \/ positive_zero == Double.POSITIVE_INFINITY;\n    assert 1 \/ negative_zero == Double.NEGATIVE_INFINITY;\n    Double dzOrig = new Double(positive_zero);\n    Double dzIntern = Intern.intern(dzOrig);\n    Object dzObjIntern = Intern.intern((Object) dzOrig);\n    assert dzIntern == dzObjIntern;\n    Object dzOtherIntern = Intern.intern((Object) new Double(negative_zero));\n    assert dzIntern == dzOtherIntern;\n    double[] daOrig = new double[] { 3.14, 2.71 };\n    double[] daIntern = Intern.intern(daOrig);\n    Object daObjIntern = Intern.intern((Object) daOrig);\n    assert daIntern == daObjIntern;\n    Object daOtherIntern = Intern.intern((Object) new double[] { 3.14, 2.71 });\n    assert daIntern == daOtherIntern;\n    double[] da2Orig = new double[] { +0.0, Double.NaN };\n    double[] da2Intern = Intern.intern(da2Orig);\n    Object da2ObjIntern = Intern.intern((Object) da2Orig);\n    assert da2Intern == da2ObjIntern;\n    Object da2OtherIntern = Intern.intern((Object) new double[] { -0.0, Double.POSITIVE_INFINITY \/ Double.POSITIVE_INFINITY });\n    assert da2Intern == da2OtherIntern;\n    Object[] oaOrig = new Object[] { new String(\"foo\"), new Integer(1) };\n    Object[] oaIntern = Intern.intern(oaOrig);\n    Object oaObjIntern = Intern.intern((Object) oaOrig);\n    assert oaIntern == oaObjIntern;\n    Object oaOtherIntern = Intern.intern((Object) new Object[] { new String(\"foo\"), new Integer(1) });\n    assert oaIntern == oaOtherIntern;\n    java.awt.Point pOrig = new java.awt.Point(1, 2);\n    try {\n        Intern.intern((Object) pOrig);\n        throw new Error(\"Didn't throw IllegalArgumentException\");\n    } catch (IllegalArgumentException e) {\n    }\n}","methodRange":"(line 995,col 3)-(line 1108,col 3)","methodTokenRange":"@Test\n  public void testInternObject() {\n    Object nIntern = Intern.intern((\/*@Nullable*\/ Object) null);\n    assert nIntern == null;\n\n    String sOrig = new String(\"foo\");\n    String sIntern = Intern.intern(sOrig);\n    Object sObjIntern = Intern.intern((Object) sOrig);\n    assert sIntern == sObjIntern;\n    Object sOtherIntern = Intern.intern(new String(\"foo\"));\n    assert sIntern == sOtherIntern;\n\n    String[] saOrig = new String[] {\"foo\", \"bar\"};\n    String[] saIntern = Intern.intern(saOrig);\n    Object saObjIntern = Intern.intern((Object) saOrig);\n    assert saIntern == saObjIntern;\n    Object saOtherIntern = Intern.intern(new String[] {\"foo\", \"bar\"});\n    assert saIntern == saOtherIntern;\n\n    Integer iOrig = new Integer(1);\n    Integer iIntern = Intern.intern(iOrig);\n    Object iObjIntern = Intern.intern((Object) iOrig);\n    assert iIntern == iObjIntern;\n    Object iOtherIntern = Intern.intern((Object) new Integer(1));\n    assert iIntern == iOtherIntern;\n\n    Long lOrig = new Long(12345678901234L);\n    Long lIntern = Intern.intern(lOrig);\n    Object lObjIntern = Intern.intern((Object) lOrig);\n    assert lIntern == lObjIntern;\n    Object lOtherIntern = Intern.intern((Object) new Long(12345678901234L));\n    assert lIntern == lOtherIntern;\n\n    int[] iaOrig = new int[] {1, 2, 3};\n    int[] iaIntern = Intern.intern(iaOrig);\n    Object iaObjIntern = Intern.intern((Object) iaOrig);\n    assert iaIntern == iaObjIntern;\n    Object iaOtherIntern = Intern.intern((Object) new int[] {1, 2, 3});\n    assert iaIntern == iaOtherIntern;\n\n    long[] laOrig = new long[] {12345678901234L, 98765432109876L};\n    long[] laIntern = Intern.intern(laOrig);\n    Object laObjIntern = Intern.intern((Object) laOrig);\n    assert laIntern == laObjIntern;\n    Object laOtherIntern = Intern.intern((Object) new long[] {12345678901234L, 98765432109876L});\n    assert laIntern == laOtherIntern;\n\n    \/\/ Need to test positive and negative zeros, infinities.\n\n    Double dOrig = new Double(3.14);\n    Double dIntern = Intern.intern(dOrig);\n    Object dObjIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dObjIntern;\n    Object dOtherIntern = Intern.intern((Object) dOrig);\n    assert dIntern == dOtherIntern;\n\n    Double dnOrig = new Double(Double.NaN);\n    Double dnIntern = Intern.intern(dnOrig);\n    Object dnObjIntern = Intern.intern((Object) dnOrig);\n    assert dnIntern == dnObjIntern;\n    Object dnOtherIntern =\n        Intern.intern((Object) new Double(Double.POSITIVE_INFINITY \/ Double.POSITIVE_INFINITY));\n    assert dnIntern == dnOtherIntern;\n\n    Double diOrig = new Double(Double.POSITIVE_INFINITY);\n    Double diIntern = Intern.intern(diOrig);\n    Object diObjIntern = Intern.intern((Object) diOrig);\n    assert diIntern == diObjIntern;\n    Object diOtherIntern = Intern.intern((Object) new Double(2 * Double.MAX_VALUE));\n    assert diIntern == diOtherIntern;\n\n    double positive_zero = +0.0;\n    double negative_zero = -0.0;\n    assert positive_zero == negative_zero;\n    assert 1 \/ positive_zero == Double.POSITIVE_INFINITY;\n    assert 1 \/ negative_zero == Double.NEGATIVE_INFINITY;\n\n    Double dzOrig = new Double(positive_zero);\n    Double dzIntern = Intern.intern(dzOrig);\n    Object dzObjIntern = Intern.intern((Object) dzOrig);\n    assert dzIntern == dzObjIntern;\n    Object dzOtherIntern = Intern.intern((Object) new Double(negative_zero));\n    assert dzIntern == dzOtherIntern;\n\n    double[] daOrig = new double[] {3.14, 2.71};\n    double[] daIntern = Intern.intern(daOrig);\n    Object daObjIntern = Intern.intern((Object) daOrig);\n    assert daIntern == daObjIntern;\n    Object daOtherIntern = Intern.intern((Object) new double[] {3.14, 2.71});\n    assert daIntern == daOtherIntern;\n\n    double[] da2Orig = new double[] {+0.0, Double.NaN};\n    double[] da2Intern = Intern.intern(da2Orig);\n    Object da2ObjIntern = Intern.intern((Object) da2Orig);\n    assert da2Intern == da2ObjIntern;\n    Object da2OtherIntern =\n        Intern.intern(\n            (Object) new double[] {-0.0, Double.POSITIVE_INFINITY \/ Double.POSITIVE_INFINITY});\n    assert da2Intern == da2OtherIntern;\n\n    Object[] oaOrig = new Object[] {new String(\"foo\"), new Integer(1)};\n    Object[] oaIntern = Intern.intern(oaOrig);\n    Object oaObjIntern = Intern.intern((Object) oaOrig);\n    assert oaIntern == oaObjIntern;\n    Object oaOtherIntern = Intern.intern((Object) new Object[] {new String(\"foo\"), new Integer(1)});\n    assert oaIntern == oaOtherIntern;\n\n    java.awt.Point pOrig = new java.awt.Point(1, 2);\n    try {\n      Intern.intern((Object) pOrig); \/\/ performed for side effect\n      throw new Error(\"Didn't throw IllegalArgumentException\");\n    } catch (IllegalArgumentException e) {\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Tests the method \"Object intern(Object)\" in Intern.java","methodParameters":[],"methodName":"testInternObject","methodQualifiedSignature":"plume.TestPlume.testInternObject","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 997,col 59)-(line 997,col 62)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 998,col 23)-(line 998,col 26)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1000,col 31)-(line 1000,col 35)","literalExprId":3,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1004,col 52)-(line 1004,col 56)","literalExprId":4,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1007,col 37)-(line 1007,col 41)","literalExprId":5,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1007,col 44)-(line 1007,col 48)","literalExprId":6,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1011,col 56)-(line 1011,col 60)","literalExprId":7,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1011,col 63)-(line 1011,col 67)","literalExprId":8,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1014,col 33)-(line 1014,col 33)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1018,col 62)-(line 1018,col 62)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1021,col 27)-(line 1021,col 41)","literalExprId":11,"literalExpr":"12345678901234L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 1025,col 59)-(line 1025,col 73)","literalExprId":12,"literalExpr":"12345678901234L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 1028,col 31)-(line 1028,col 31)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1028,col 34)-(line 1028,col 34)","literalExprId":14,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1028,col 37)-(line 1028,col 37)","literalExprId":15,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1032,col 62)-(line 1032,col 62)","literalExprId":16,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1032,col 65)-(line 1032,col 65)","literalExprId":17,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1032,col 68)-(line 1032,col 68)","literalExprId":18,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1035,col 33)-(line 1035,col 47)","literalExprId":19,"literalExpr":"12345678901234L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 1035,col 50)-(line 1035,col 64)","literalExprId":20,"literalExpr":"98765432109876L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 1039,col 63)-(line 1039,col 77)","literalExprId":21,"literalExpr":"12345678901234L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 1039,col 80)-(line 1039,col 94)","literalExprId":22,"literalExpr":"98765432109876L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 1044,col 31)-(line 1044,col 34)","literalExprId":23,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1063,col 62)-(line 1063,col 62)","literalExprId":24,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1066,col 29)-(line 1066,col 31)","literalExprId":25,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1067,col 29)-(line 1067,col 31)","literalExprId":26,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1069,col 12)-(line 1069,col 12)","literalExprId":27,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1070,col 12)-(line 1070,col 12)","literalExprId":28,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1079,col 37)-(line 1079,col 40)","literalExprId":29,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1079,col 43)-(line 1079,col 46)","literalExprId":30,"literalExpr":"2.71","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1083,col 65)-(line 1083,col 68)","literalExprId":31,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1083,col 71)-(line 1083,col 74)","literalExprId":32,"literalExpr":"2.71","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1086,col 39)-(line 1086,col 41)","literalExprId":33,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1092,col 37)-(line 1092,col 39)","literalExprId":34,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 1095,col 48)-(line 1095,col 52)","literalExprId":35,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1095,col 68)-(line 1095,col 68)","literalExprId":36,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1099,col 76)-(line 1099,col 80)","literalExprId":37,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1099,col 96)-(line 1099,col 96)","literalExprId":38,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1102,col 47)-(line 1102,col 47)","literalExprId":39,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1102,col 50)-(line 1102,col 50)","literalExprId":40,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1105,col 23)-(line 1105,col 61)","literalExprId":41,"literalExpr":"\"Didn't throw IllegalArgumentException\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testInternObject()"},{"methodDeclaration":"private static void lsis_add_elts(int limit, LimitedSizeSet<Integer> s)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Random r = new Random(20140613);\n    for (int i = 0; i < 100; i++) {\n        s.add(r.nextInt(limit));\n    }\n}","methodRange":"(line 1111,col 3)-(line 1116,col 3)","methodTokenRange":"private static void lsis_add_elts(int limit, LimitedSizeSet<Integer> s) {\n    Random r = new Random(20140613);\n    for (int i = 0; i < 100; i++) {\n      s.add(r.nextInt(limit));\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Add 100 elements randomly selected from the range 0..limit-1 to the set.","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int limit","parameterName":"limit"},{"parameterType":"LimitedSizeSet<Integer>","parameterId":2,"parameterTypeResolved":"ReferenceType{plume.LimitedSizeSet, typeParametersMap=TypeParametersMap{nameToValue={plume.LimitedSizeSet.T=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"plume.LimitedSizeSet<java.lang.Integer>","parameter":"LimitedSizeSet<Integer> s","parameterName":"s"}],"methodName":"lsis_add_elts","methodQualifiedSignature":"plume.TestPlume.lsis_add_elts","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1112,col 27)-(line 1112,col 34)","literalExprId":1,"literalExpr":"20140613","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1113,col 18)-(line 1113,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1113,col 25)-(line 1113,col 27)","literalExprId":3,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.lsis_add_elts(int, plume.LimitedSizeSet<java.lang.Integer>)"},{"methodDeclaration":"private static void lsis_test(int max_size)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    LimitedSizeSet<Integer> s = new LimitedSizeSet<Integer>(max_size);\n    for (int i = 1; i < 2 * max_size; i++) {\n        lsis_add_elts(i, s);\n        int size = s.size();\n        assert ((i <= max_size) ? (size == i) : (size == max_size + 1)) : String.format(\"(%d<=%d) ? (%d==%d) : (%d==%d+1)   size=%d, i=%d, max_size=%d, s=%s\", i, max_size, size, i, size, max_size, size, i, max_size, s);\n    }\n}","methodRange":"(line 1119,col 3)-(line 1138,col 3)","methodTokenRange":"private static void lsis_test(int max_size) {\n    LimitedSizeSet<Integer> s = new LimitedSizeSet<Integer>(max_size);\n    for (int i = 1; i < 2 * max_size; i++) {\n      lsis_add_elts(i, s);\n      int size = s.size();\n      assert ((i <= max_size) ? (size == i) : (size == max_size + 1))\n          : String.format(\n              \"(%d<=%d) ? (%d==%d) : (%d==%d+1)   size=%d, i=%d, max_size=%d, s=%s\",\n              i,\n              max_size,\n              size,\n              i,\n              size,\n              max_size,\n              size,\n              i,\n              max_size,\n              s);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Create a LimitedSizeSet of the given size, and add elements to it.","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int max_size","parameterName":"max_size"}],"methodName":"lsis_test","methodQualifiedSignature":"plume.TestPlume.lsis_test","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1121,col 18)-(line 1121,col 18)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1121,col 25)-(line 1121,col 25)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1124,col 67)-(line 1124,col 67)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1126,col 15)-(line 1126,col 83)","literalExprId":4,"literalExpr":"\"(%d<=%d) ? (%d==%d) : (%d==%d+1)   size=%d, i=%d, max_size=%d, s=%s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.lsis_test(int)"},{"methodDeclaration":"private static void lss_with_null_test()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    LimitedSizeSet<Integer> s = new LimitedSizeSet<Integer>(10);\n    s.add(1);\n    s.add(2);\n    s.add(null);\n    assert s.size() == 3;\n    assert s.contains(1);\n    assert s.contains(null);\n    s.add(3);\n    assert s.size() == 4;\n    assert s.contains(1);\n    assert s.contains(null);\n    assert s.contains(3);\n}","methodRange":"(line 1140,col 3)-(line 1153,col 3)","methodTokenRange":"private static void lss_with_null_test() {\n    LimitedSizeSet<\/*@Nullable*\/ Integer> s = new LimitedSizeSet<\/*@Nullable*\/ Integer>(10);\n    s.add(1);\n    s.add(2);\n    s.add(null);\n    assert s.size() == 3;\n    assert s.contains(1);\n    assert s.contains(null);\n    s.add(3);\n    assert s.size() == 4;\n    assert s.contains(1);\n    assert s.contains(null);\n    assert s.contains(3);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"lss_with_null_test","methodQualifiedSignature":"plume.TestPlume.lss_with_null_test","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1141,col 89)-(line 1141,col 90)","literalExprId":1,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1142,col 11)-(line 1142,col 11)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1143,col 11)-(line 1143,col 11)","literalExprId":3,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1144,col 11)-(line 1144,col 14)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1145,col 24)-(line 1145,col 24)","literalExprId":5,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1146,col 23)-(line 1146,col 23)","literalExprId":6,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1147,col 23)-(line 1147,col 26)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1148,col 11)-(line 1148,col 11)","literalExprId":8,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1149,col 24)-(line 1149,col 24)","literalExprId":9,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1150,col 23)-(line 1150,col 23)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1151,col 23)-(line 1151,col 26)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1152,col 23)-(line 1152,col 23)","literalExprId":12,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.lss_with_null_test()"},{"methodDeclaration":"public void testLimitedSizeSet()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 1; i < 10; i++) {\n        lsis_test(i);\n    }\n    lss_with_null_test();\n}","methodRange":"(line 1155,col 3)-(line 1161,col 3)","methodTokenRange":"@Test\n  public void testLimitedSizeSet() {\n    for (int i = 1; i < 10; i++) {\n      lsis_test(i);\n    }\n    lss_with_null_test();\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testLimitedSizeSet","methodQualifiedSignature":"plume.TestPlume.testLimitedSizeSet","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1157,col 18)-(line 1157,col 18)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1157,col 25)-(line 1157,col 26)","literalExprId":2,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testLimitedSizeSet()"},{"methodDeclaration":"public void testMathMDE()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert MathMDE.negate(3) == -3;\n    assert MathMDE.negate(-22) == 22;\n    assert MathMDE.negate(0) == 0;\n    assert MathMDE.bitwiseComplement(3) == -4;\n    assert MathMDE.bitwiseComplement(-22) == 21;\n    assert MathMDE.bitwiseComplement(0) == -1;\n    assert MathMDE.sign(3) == 1;\n    assert MathMDE.sign(-22) == -1;\n    assert MathMDE.sign(0) == 0;\n    try {\n        assert MathMDE.pow(3, 3) == 27;\n        assert MathMDE.pow(-5, 5) == -3125;\n        assert MathMDE.pow(22, 0) == 1;\n        assert MathMDE.pow(4, 6) == 4096;\n        assert MathMDE.pow(1, 222222) == 1;\n        assert MathMDE.pow(-2, 25) == -33554432;\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new Error(e);\n    }\n    try {\n        MathMDE.pow(3, -3);\n        throw new Error(\"Didn't throw ArithmeticException\");\n    } catch (ArithmeticException e) {\n    }\n    assert MathMDE.gcd(2, 50) == 2;\n    assert MathMDE.gcd(50, 2) == 2;\n    assert MathMDE.gcd(12, 144) == 12;\n    assert MathMDE.gcd(144, 12) == 12;\n    assert MathMDE.gcd(96, 144) == 48;\n    assert MathMDE.gcd(144, 96) == 48;\n    assert MathMDE.gcd(10, 25) == 5;\n    assert MathMDE.gcd(25, 10) == 5;\n    assert MathMDE.gcd(17, 25) == 1;\n    assert MathMDE.gcd(25, 17) == 1;\n    assert MathMDE.gcd(0, 10) == 10;\n    assert MathMDE.gcd(10, 0) == 10;\n    assert MathMDE.gcd(25, -10) == 5;\n    assert MathMDE.gcd(-25, -10) == 5;\n    assert MathMDE.gcd(-25, 10) == 5;\n    assert MathMDE.gcd(new int[] { 2, 50 }) == 2;\n    assert MathMDE.gcd(new int[] { 12, 144 }) == 12;\n    assert MathMDE.gcd(new int[] { 96, 144 }) == 48;\n    assert MathMDE.gcd(new int[] { 10, 25 }) == 5;\n    assert MathMDE.gcd(new int[] { 100, 10, 25 }) == 5;\n    assert MathMDE.gcd(new int[] { 768, 324 }) == 12;\n    assert MathMDE.gcd(new int[] { 2400, 48, 36 }) == 12;\n    assert MathMDE.gcd(new int[] { 2400, 72, 36 }) == 12;\n    assert MathMDE.gcd_differences(new int[] { 0, 2, 52 }) == 2;\n    assert MathMDE.gcd_differences(new int[] { 0, 12, 156 }) == 12;\n    assert MathMDE.gcd_differences(new int[] { 0, 96, 240 }) == 48;\n    assert MathMDE.gcd_differences(new int[] { 0, 10, 35 }) == 5;\n    assert MathMDE.gcd_differences(new int[] { 0, 100, 110, 135 }) == 5;\n    assert MathMDE.gcd_differences(new int[] { 0, 768, 1092 }) == 12;\n    assert MathMDE.gcd_differences(new int[] { 0, 2400, 2448, 2484 }) == 12;\n    assert MathMDE.gcd_differences(new int[] { 0, 2400, 2472, 2508 }) == 12;\n    assert MathMDE.gcd_differences(new int[] { 5, 5, 5, 5 }) == 0;\n    assert MathMDE.mod_positive(33, 5) == 3;\n    assert MathMDE.mod_positive(-33, 5) == 2;\n    assert MathMDE.mod_positive(33, -5) == 3;\n    assert MathMDE.mod_positive(-33, -5) == 2;\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] { 3, 4, 5, 6, 7, 8 }), new int[] {});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] { 3, 4, 6, 7, 8 }), new int[] { 5 });\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] { 3, 4, 8 }), new int[] { 5, 6, 7 });\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] { 3, 5, 6, 8 }), new int[] { 4, 7 });\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] { 3, 6, 8 }), new int[] { 4, 5, 7 });\n    class TestMissingNumbersIteratorInt {\n\n        void test(int[] orig, boolean add_ends, int[] goal_missing) {\n            Iterator<Integer> orig_iterator = int_array_iterator(orig);\n            Iterator<Integer> missing_iterator = new MathMDE.MissingNumbersIteratorInt(orig_iterator, add_ends);\n            int[] missing = TestPlume.int_iterator_array(missing_iterator);\n            assert_arrays_equals(missing, goal_missing);\n        }\n    }\n    TestMissingNumbersIteratorInt tmni = new TestMissingNumbersIteratorInt();\n    tmni.test(new int[] { 3, 4, 5, 6, 7, 8 }, false, new int[] {});\n    tmni.test(new int[] { 3, 4, 6, 7, 8 }, false, new int[] { 5 });\n    tmni.test(new int[] { 3, 4, 8 }, false, new int[] { 5, 6, 7 });\n    tmni.test(new int[] { 3, 5, 6, 8 }, false, new int[] { 4, 7 });\n    tmni.test(new int[] { 3, 6, 8 }, false, new int[] { 4, 5, 7 });\n    tmni.test(new int[] { 3 }, false, new int[] {});\n    tmni.test(new int[] { 3, 4, 5 }, false, new int[] {});\n    tmni.test(new int[] { 3, 4, 5, 6, 7, 8 }, true, new int[] { 2, 9 });\n    tmni.test(new int[] { 3, 4, 6, 7, 8 }, true, new int[] { 2, 5, 9 });\n    tmni.test(new int[] { 3, 4, 8 }, true, new int[] { 2, 5, 6, 7, 9 });\n    tmni.test(new int[] { 3, 5, 6, 8 }, true, new int[] { 2, 4, 7, 9 });\n    tmni.test(new int[] { 3, 6, 8 }, true, new int[] { 2, 4, 5, 7, 9 });\n    tmni.test(new int[] { 3, 4, 5 }, true, new int[] { 2, 6 });\n    tmni.test(new int[] { -1, 1, 2, 3, 5, 6, 7, 9 }, true, new int[] { -2, 0, 4, 8, 10 });\n    class TestModulus {\n\n        void check(int[] nums, int[] goal_rm) {\n            int[] rm = MathMDE.modulus(nums);\n            if (!Arrays.equals(rm, goal_rm)) {\n                throw new Error(\"Expected (r,m)=\" + ArraysMDE.toString(goal_rm) + \", saw (r,m)=\" + ArraysMDE.toString(rm));\n            }\n            if (rm == null) {\n                return;\n            }\n            int goal_r = rm[0];\n            int m = rm[1];\n            for (int i = 0; i < nums.length; i++) {\n                int r = nums[i] % m;\n                if (r < 0) {\n                    r += m;\n                }\n                if (r != goal_r) {\n                    throw new Error(\"Expected \" + nums[i] + \" % \" + m + \" = \" + goal_r + \", got \" + r);\n                }\n            }\n        }\n\n        void check(Iterator<Integer> itor, int[] goal_rm) {\n            assert_arrays_equals(MathMDE.modulus_int(itor), goal_rm);\n        }\n\n        void check_iterator(int[] nums, int[] goal_rm) {\n            check(int_array_iterator(nums), goal_rm);\n        }\n    }\n    TestModulus testModulus = new TestModulus();\n    testModulus.check(new int[] { 3, 7, 47, 51 }, new int[] { 3, 4 });\n    testModulus.check(new int[] { 3, 11, 43, 51 }, new int[] { 3, 8 });\n    testModulus.check(new int[] { 3, 11, 47, 55 }, new int[] { 3, 4 });\n    testModulus.check(new int[] { 2383, 4015, -81, 463, -689 }, new int[] { 15, 32 });\n    testModulus.check(new int[] {}, null);\n    testModulus.check(new int[] { 1 }, null);\n    testModulus.check(new int[] { 3, 7 }, null);\n    testModulus.check(new int[] { 2, 3, 5, 7 }, null);\n    testModulus.check(new int[] { 2, 19, 101 }, null);\n    testModulus.check(new int[] { 5, 5, 5, 5, 5 }, null);\n    testModulus.check_iterator(new int[] {}, null);\n    testModulus.check_iterator(new int[] { 1 }, null);\n    testModulus.check_iterator(new int[] { 3, 7, 47, 51 }, new int[] { 3, 4 });\n    testModulus.check_iterator(new int[] { 3, 11, 43, 51 }, new int[] { 3, 8 });\n    testModulus.check_iterator(new int[] { 3, 11, 47, 55 }, new int[] { 3, 4 });\n    testModulus.check_iterator(new int[] { 2383, 4015, -81, 463, -689 }, new int[] { 15, 32 });\n    testModulus.check_iterator(new int[] { 5, 5, 5, 5, 5 }, null);\n    class TestNonModulus {\n\n        void check_strict(int[] nums, int[] goal_rm) {\n            check(nums, goal_rm, true);\n            Iterator<Integer> itor = int_array_iterator(nums);\n            assert_arrays_equals(MathMDE.nonmodulus_strict_int(itor), goal_rm);\n        }\n\n        void check_nonstrict(int[] nums, int[] goal_rm) {\n            check(nums, goal_rm, false);\n        }\n\n        void check(int[] nums, int[] goal_rm, boolean strict) {\n            int[] rm;\n            if (strict) {\n                rm = MathMDE.nonmodulus_strict(nums);\n            } else {\n                rm = MathMDE.nonmodulus_nonstrict(nums);\n            }\n            if (!Arrays.equals(rm, goal_rm)) {\n                throw new Error(\"Expected (r,m)=\" + ArraysMDE.toString(goal_rm) + \", saw (r,m)=\" + ArraysMDE.toString(rm));\n            }\n            if (rm == null) {\n                return;\n            }\n            int goal_r = rm[0];\n            int m = rm[1];\n            for (int i = 0; i < nums.length; i++) {\n                int r = nums[i] % m;\n                if (r < 0) {\n                    r += m;\n                }\n                if (r == goal_r) {\n                    throw new Error(\"Expected inequality, saw \" + nums[i] + \" % \" + m + \" = \" + r);\n                }\n            }\n        }\n    }\n    TestNonModulus testNonModulus = new TestNonModulus();\n    testNonModulus.check_strict(new int[] { 1, 2, 3, 5, 6, 7, 9 }, null);\n    testNonModulus.check_strict(new int[] { -1, 1, 2, 3, 5, 6, 7, 9 }, new int[] { 0, 4 });\n    testNonModulus.check_strict(new int[] { 1, 2, 3, 5, 6, 7, 9, 11 }, null);\n    testNonModulus.check_strict(new int[] { 1, 2, 3, 5, 6, 7, 11 }, null);\n    testNonModulus.check_strict(new int[] { 1, 2, 4, 6, 8, 10 }, null);\n    testNonModulus.check_nonstrict(new int[] { 1, 2, 3, 5, 6, 7, 9 }, null);\n    testNonModulus.check_nonstrict(new int[] { 1, 2, 3, 5, 6, 7, 9, 10 }, new int[] { 0, 4 });\n    testNonModulus.check_nonstrict(new int[] { 1, 2, 3, 5, 6, 7, 9, 11 }, new int[] { 0, 4 });\n    testNonModulus.check_nonstrict(new int[] { 1, 2, 3, 5, 6, 7, 9, 11, 12, 13 }, null);\n    testNonModulus.check_nonstrict(new int[] { 1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15 }, new int[] { 4, 6 });\n    testNonModulus.check_nonstrict(new int[] { 1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15, 22 }, null);\n}","methodRange":"(line 1164,col 3)-(line 1413,col 3)","methodTokenRange":"@Test\n  public void testMathMDE() {\n\n    \/\/ int negate(int a)\n    assert MathMDE.negate(3) == -3;\n    assert MathMDE.negate(-22) == 22;\n    assert MathMDE.negate(0) == 0;\n\n    \/\/ int bitwiseComplement(int a)\n    assert MathMDE.bitwiseComplement(3) == -4;\n    assert MathMDE.bitwiseComplement(-22) == 21;\n    assert MathMDE.bitwiseComplement(0) == -1;\n\n    \/\/ int sign(int a)\n    assert MathMDE.sign(3) == 1;\n    assert MathMDE.sign(-22) == -1;\n    assert MathMDE.sign(0) == 0;\n\n    \/\/ int pow(int base, int expt)\n    try {\n      assert MathMDE.pow(3, 3) == 27;\n      assert MathMDE.pow(-5, 5) == -3125;\n      assert MathMDE.pow(22, 0) == 1;\n      assert MathMDE.pow(4, 6) == 4096;\n      assert MathMDE.pow(1, 222222) == 1;\n      assert MathMDE.pow(-2, 25) == -33554432;\n      \/\/ This is beyond the precision.  Maybe return a long instead of an int?\n      \/\/ assert MathMDE.pow(-3, 25) == ...;\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      MathMDE.pow(3, -3);\n      throw new Error(\"Didn't throw ArithmeticException\");\n    } catch (ArithmeticException e) {\n    }\n\n    \/\/ int gcd(int a, int b)\n    assert MathMDE.gcd(2, 50) == 2;\n    assert MathMDE.gcd(50, 2) == 2;\n    assert MathMDE.gcd(12, 144) == 12;\n    assert MathMDE.gcd(144, 12) == 12;\n    assert MathMDE.gcd(96, 144) == 48;\n    assert MathMDE.gcd(144, 96) == 48;\n    assert MathMDE.gcd(10, 25) == 5;\n    assert MathMDE.gcd(25, 10) == 5;\n    assert MathMDE.gcd(17, 25) == 1;\n    assert MathMDE.gcd(25, 17) == 1;\n    assert MathMDE.gcd(0, 10) == 10;\n    assert MathMDE.gcd(10, 0) == 10;\n    assert MathMDE.gcd(25, -10) == 5;\n    assert MathMDE.gcd(-25, -10) == 5;\n    assert MathMDE.gcd(-25, 10) == 5;\n\n    \/\/ int gcd(int[] a)\n    assert MathMDE.gcd(new int[] {2, 50}) == 2;\n    assert MathMDE.gcd(new int[] {12, 144}) == 12;\n    assert MathMDE.gcd(new int[] {96, 144}) == 48;\n    assert MathMDE.gcd(new int[] {10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {100, 10, 25}) == 5;\n    assert MathMDE.gcd(new int[] {768, 324}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 48, 36}) == 12;\n    assert MathMDE.gcd(new int[] {2400, 72, 36}) == 12;\n\n    \/\/ int gcd_differences(int[] a)\n    \/\/ Weak set of tests, derived directly from those of \"int gcd(int[] a)\".\n    assert MathMDE.gcd_differences(new int[] {0, 2, 52}) == 2;\n    assert MathMDE.gcd_differences(new int[] {0, 12, 156}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 96, 240}) == 48;\n    assert MathMDE.gcd_differences(new int[] {0, 10, 35}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 100, 110, 135}) == 5;\n    assert MathMDE.gcd_differences(new int[] {0, 768, 1092}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2448, 2484}) == 12;\n    assert MathMDE.gcd_differences(new int[] {0, 2400, 2472, 2508}) == 12;\n    assert MathMDE.gcd_differences(new int[] {5, 5, 5, 5}) == 0;\n\n    \/\/ int mod_positive(int x, int y)\n    assert MathMDE.mod_positive(33, 5) == 3;\n    assert MathMDE.mod_positive(-33, 5) == 2;\n    assert MathMDE.mod_positive(33, -5) == 3;\n    assert MathMDE.mod_positive(-33, -5) == 2;\n\n    \/\/ int[] missing_numbers(int[] nums)\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 5, 6, 7, 8}), new int[] {});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 6, 7, 8}), new int[] {5});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 4, 8}), new int[] {5, 6, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 5, 6, 8}), new int[] {4, 7});\n    assert_arrays_equals(MathMDE.missing_numbers(new int[] {3, 6, 8}), new int[] {4, 5, 7});\n\n    \/\/ class MissingNumbersIteratorInt\n    class TestMissingNumbersIteratorInt {\n      \/\/ javadoc won't let this be static\n      void test(int[] orig, boolean add_ends, int[] goal_missing) {\n        Iterator<Integer> orig_iterator = int_array_iterator(orig);\n        Iterator<Integer> missing_iterator =\n            new MathMDE.MissingNumbersIteratorInt(orig_iterator, add_ends);\n        int[] missing = TestPlume.int_iterator_array(missing_iterator);\n        assert_arrays_equals(missing, goal_missing);\n      }\n    }\n\n    TestMissingNumbersIteratorInt tmni = new TestMissingNumbersIteratorInt();\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, false, new int[] {5});\n    tmni.test(new int[] {3, 4, 8}, false, new int[] {5, 6, 7});\n    tmni.test(new int[] {3, 5, 6, 8}, false, new int[] {4, 7});\n    tmni.test(new int[] {3, 6, 8}, false, new int[] {4, 5, 7});\n    tmni.test(new int[] {3}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5}, false, new int[] {});\n    tmni.test(new int[] {3, 4, 5, 6, 7, 8}, true, new int[] {2, 9});\n    tmni.test(new int[] {3, 4, 6, 7, 8}, true, new int[] {2, 5, 9});\n    tmni.test(new int[] {3, 4, 8}, true, new int[] {2, 5, 6, 7, 9});\n    tmni.test(new int[] {3, 5, 6, 8}, true, new int[] {2, 4, 7, 9});\n    tmni.test(new int[] {3, 6, 8}, true, new int[] {2, 4, 5, 7, 9});\n    tmni.test(new int[] {3, 4, 5}, true, new int[] {2, 6});\n\n    tmni.test(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, true, new int[] {-2, 0, 4, 8, 10});\n\n    \/\/ int[] modulus(int[] nums)\n    \/\/ int[] modulus(Iterator itor)\n\n    class TestModulus {\n      \/\/ javadoc won't let this be static\n      void check(int[] nums, int \/*@Nullable*\/ [] goal_rm) {\n        int[] rm = MathMDE.modulus(nums);\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r != goal_r) {\n            throw new Error(\"Expected \" + nums[i] + \" % \" + m + \" = \" + goal_r + \", got \" + r);\n          }\n        }\n      }\n\n      \/\/ javadoc won't let this be static\n      void check(Iterator<Integer> itor, int \/*@Nullable*\/ [] goal_rm) {\n        \/\/ There would be no point to this:  it's testing\n        \/\/ int_iterator_array, not the iterator version!\n        \/\/ return check(int_iterator_array(itor), goal_rm);\n        assert_arrays_equals(MathMDE.modulus_int(itor), goal_rm);\n      }\n\n      \/\/ javadoc won't let this be static\n      void check_iterator(int[] nums, int \/*@Nullable*\/ [] goal_rm) {\n        check(int_array_iterator(nums), goal_rm);\n      }\n    }\n\n    TestModulus testModulus = new TestModulus();\n\n    testModulus.check(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check(new int[] {}, null);\n    testModulus.check(new int[] {1}, null);\n    testModulus.check(new int[] {3, 7}, null);\n    testModulus.check(new int[] {2, 3, 5, 7}, null);\n    testModulus.check(new int[] {2, 19, 101}, null);\n    testModulus.check(new int[] {5, 5, 5, 5, 5}, null);\n\n    testModulus.check_iterator(new int[] {}, null);\n    testModulus.check_iterator(new int[] {1}, null);\n    testModulus.check_iterator(new int[] {3, 7, 47, 51}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {3, 11, 43, 51}, new int[] {3, 8});\n    testModulus.check_iterator(new int[] {3, 11, 47, 55}, new int[] {3, 4});\n    testModulus.check_iterator(new int[] {2383, 4015, -81, 463, -689}, new int[] {15, 32});\n    testModulus.check_iterator(new int[] {5, 5, 5, 5, 5}, null);\n\n    \/\/ int[] nonmodulus_strict(int[] nums)\n    \/\/ int[] nonmodulus_nonstrict(int[] nums)\n    \/\/ int[] nonmodulus_strict(Iterator nums)\n\n    class TestNonModulus {\n      \/\/ javadoc won't let this be static\n      void check_strict(int[] nums, int \/*@Nullable*\/ [] goal_rm) {\n        check(nums, goal_rm, true);\n        Iterator<Integer> itor = int_array_iterator(nums);\n        assert_arrays_equals(MathMDE.nonmodulus_strict_int(itor), goal_rm);\n      }\n\n      \/\/ javadoc won't let this be static\n      void check_nonstrict(int[] nums, int \/*@Nullable*\/ [] goal_rm) {\n        check(nums, goal_rm, false);\n      }\n\n      \/\/ javadoc won't let this be static\n      void check(int[] nums, int \/*@Nullable*\/ [] goal_rm, boolean strict) {\n        int[] rm;\n        if (strict) {\n          rm = MathMDE.nonmodulus_strict(nums);\n        } else {\n          rm = MathMDE.nonmodulus_nonstrict(nums);\n        }\n        if (!Arrays.equals(rm, goal_rm)) {\n          throw new Error(\n              \"Expected (r,m)=\"\n                  + ArraysMDE.toString(goal_rm)\n                  + \", saw (r,m)=\"\n                  + ArraysMDE.toString(rm));\n        }\n        if (rm == null) {\n          return;\n        }\n        int goal_r = rm[0];\n        int m = rm[1];\n        for (int i = 0; i < nums.length; i++) {\n          int r = nums[i] % m;\n          if (r < 0) {\n            r += m;\n          }\n          if (r == goal_r) {\n            throw new Error(\"Expected inequality, saw \" + nums[i] + \" % \" + m + \" = \" + r);\n          }\n        }\n      }\n    }\n\n    TestNonModulus testNonModulus = new TestNonModulus();\n\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_strict(new int[] {-1, 1, 2, 3, 5, 6, 7, 9}, new int[] {0, 4});\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 3, 5, 6, 7, 11}, null);\n    testNonModulus.check_strict(new int[] {1, 2, 4, 6, 8, 10}, null);\n\n    \/\/ null because only 7 elements, so don't try modulus = 4\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9}, null);\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 10}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11}, new int[] {0, 4});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13}, null);\n    testNonModulus.check_nonstrict(\n        new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15}, new int[] {4, 6});\n    testNonModulus.check_nonstrict(new int[] {1, 2, 3, 5, 6, 7, 9, 11, 12, 13, 14, 15, 22}, null);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" This cannot be static because it instantiates an inner class.","methodParameters":[],"methodName":"testMathMDE","methodQualifiedSignature":"plume.TestPlume.testMathMDE","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1168,col 27)-(line 1168,col 27)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1168,col 34)-(line 1168,col 34)","literalExprId":2,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1169,col 28)-(line 1169,col 29)","literalExprId":3,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1169,col 35)-(line 1169,col 36)","literalExprId":4,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1170,col 27)-(line 1170,col 27)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1170,col 33)-(line 1170,col 33)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1173,col 38)-(line 1173,col 38)","literalExprId":7,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1173,col 45)-(line 1173,col 45)","literalExprId":8,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1174,col 39)-(line 1174,col 40)","literalExprId":9,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1174,col 46)-(line 1174,col 47)","literalExprId":10,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1175,col 38)-(line 1175,col 38)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1175,col 45)-(line 1175,col 45)","literalExprId":12,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1178,col 25)-(line 1178,col 25)","literalExprId":13,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1178,col 31)-(line 1178,col 31)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1179,col 26)-(line 1179,col 27)","literalExprId":15,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1179,col 34)-(line 1179,col 34)","literalExprId":16,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1180,col 25)-(line 1180,col 25)","literalExprId":17,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1180,col 31)-(line 1180,col 31)","literalExprId":18,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1184,col 26)-(line 1184,col 26)","literalExprId":19,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1184,col 29)-(line 1184,col 29)","literalExprId":20,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1184,col 35)-(line 1184,col 36)","literalExprId":21,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1185,col 27)-(line 1185,col 27)","literalExprId":22,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1185,col 30)-(line 1185,col 30)","literalExprId":23,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1185,col 37)-(line 1185,col 40)","literalExprId":24,"literalExpr":"3125","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1186,col 26)-(line 1186,col 27)","literalExprId":25,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1186,col 30)-(line 1186,col 30)","literalExprId":26,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1186,col 36)-(line 1186,col 36)","literalExprId":27,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1187,col 26)-(line 1187,col 26)","literalExprId":28,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1187,col 29)-(line 1187,col 29)","literalExprId":29,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1187,col 35)-(line 1187,col 38)","literalExprId":30,"literalExpr":"4096","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1188,col 26)-(line 1188,col 26)","literalExprId":31,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1188,col 29)-(line 1188,col 34)","literalExprId":32,"literalExpr":"222222","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1188,col 40)-(line 1188,col 40)","literalExprId":33,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1189,col 27)-(line 1189,col 27)","literalExprId":34,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1189,col 30)-(line 1189,col 31)","literalExprId":35,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1189,col 38)-(line 1189,col 45)","literalExprId":36,"literalExpr":"33554432","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1197,col 19)-(line 1197,col 19)","literalExprId":37,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1197,col 23)-(line 1197,col 23)","literalExprId":38,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1198,col 23)-(line 1198,col 56)","literalExprId":39,"literalExpr":"\"Didn't throw ArithmeticException\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1203,col 24)-(line 1203,col 24)","literalExprId":40,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1203,col 27)-(line 1203,col 28)","literalExprId":41,"literalExpr":"50","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1203,col 34)-(line 1203,col 34)","literalExprId":42,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1204,col 24)-(line 1204,col 25)","literalExprId":43,"literalExpr":"50","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1204,col 28)-(line 1204,col 28)","literalExprId":44,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1204,col 34)-(line 1204,col 34)","literalExprId":45,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1205,col 24)-(line 1205,col 25)","literalExprId":46,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1205,col 28)-(line 1205,col 30)","literalExprId":47,"literalExpr":"144","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1205,col 36)-(line 1205,col 37)","literalExprId":48,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1206,col 24)-(line 1206,col 26)","literalExprId":49,"literalExpr":"144","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1206,col 29)-(line 1206,col 30)","literalExprId":50,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1206,col 36)-(line 1206,col 37)","literalExprId":51,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1207,col 24)-(line 1207,col 25)","literalExprId":52,"literalExpr":"96","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1207,col 28)-(line 1207,col 30)","literalExprId":53,"literalExpr":"144","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1207,col 36)-(line 1207,col 37)","literalExprId":54,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1208,col 24)-(line 1208,col 26)","literalExprId":55,"literalExpr":"144","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1208,col 29)-(line 1208,col 30)","literalExprId":56,"literalExpr":"96","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1208,col 36)-(line 1208,col 37)","literalExprId":57,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1209,col 24)-(line 1209,col 25)","literalExprId":58,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1209,col 28)-(line 1209,col 29)","literalExprId":59,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1209,col 35)-(line 1209,col 35)","literalExprId":60,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1210,col 24)-(line 1210,col 25)","literalExprId":61,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1210,col 28)-(line 1210,col 29)","literalExprId":62,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1210,col 35)-(line 1210,col 35)","literalExprId":63,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1211,col 24)-(line 1211,col 25)","literalExprId":64,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1211,col 28)-(line 1211,col 29)","literalExprId":65,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1211,col 35)-(line 1211,col 35)","literalExprId":66,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1212,col 24)-(line 1212,col 25)","literalExprId":67,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1212,col 28)-(line 1212,col 29)","literalExprId":68,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1212,col 35)-(line 1212,col 35)","literalExprId":69,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1213,col 24)-(line 1213,col 24)","literalExprId":70,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1213,col 27)-(line 1213,col 28)","literalExprId":71,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1213,col 34)-(line 1213,col 35)","literalExprId":72,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1214,col 24)-(line 1214,col 25)","literalExprId":73,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1214,col 28)-(line 1214,col 28)","literalExprId":74,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1214,col 34)-(line 1214,col 35)","literalExprId":75,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1215,col 24)-(line 1215,col 25)","literalExprId":76,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1215,col 29)-(line 1215,col 30)","literalExprId":77,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1215,col 36)-(line 1215,col 36)","literalExprId":78,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1216,col 25)-(line 1216,col 26)","literalExprId":79,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1216,col 30)-(line 1216,col 31)","literalExprId":80,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1216,col 37)-(line 1216,col 37)","literalExprId":81,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1217,col 25)-(line 1217,col 26)","literalExprId":82,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1217,col 29)-(line 1217,col 30)","literalExprId":83,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1217,col 36)-(line 1217,col 36)","literalExprId":84,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1220,col 35)-(line 1220,col 35)","literalExprId":85,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1220,col 38)-(line 1220,col 39)","literalExprId":86,"literalExpr":"50","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1220,col 46)-(line 1220,col 46)","literalExprId":87,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1221,col 35)-(line 1221,col 36)","literalExprId":88,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1221,col 39)-(line 1221,col 41)","literalExprId":89,"literalExpr":"144","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1221,col 48)-(line 1221,col 49)","literalExprId":90,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1222,col 35)-(line 1222,col 36)","literalExprId":91,"literalExpr":"96","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1222,col 39)-(line 1222,col 41)","literalExprId":92,"literalExpr":"144","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1222,col 48)-(line 1222,col 49)","literalExprId":93,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1223,col 35)-(line 1223,col 36)","literalExprId":94,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1223,col 39)-(line 1223,col 40)","literalExprId":95,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1223,col 47)-(line 1223,col 47)","literalExprId":96,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1224,col 35)-(line 1224,col 37)","literalExprId":97,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1224,col 40)-(line 1224,col 41)","literalExprId":98,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1224,col 44)-(line 1224,col 45)","literalExprId":99,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1224,col 52)-(line 1224,col 52)","literalExprId":100,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1225,col 35)-(line 1225,col 37)","literalExprId":101,"literalExpr":"768","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1225,col 40)-(line 1225,col 42)","literalExprId":102,"literalExpr":"324","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1225,col 49)-(line 1225,col 50)","literalExprId":103,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1226,col 35)-(line 1226,col 38)","literalExprId":104,"literalExpr":"2400","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1226,col 41)-(line 1226,col 42)","literalExprId":105,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1226,col 45)-(line 1226,col 46)","literalExprId":106,"literalExpr":"36","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1226,col 53)-(line 1226,col 54)","literalExprId":107,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1227,col 35)-(line 1227,col 38)","literalExprId":108,"literalExpr":"2400","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1227,col 41)-(line 1227,col 42)","literalExprId":109,"literalExpr":"72","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1227,col 45)-(line 1227,col 46)","literalExprId":110,"literalExpr":"36","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1227,col 53)-(line 1227,col 54)","literalExprId":111,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1231,col 47)-(line 1231,col 47)","literalExprId":112,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1231,col 50)-(line 1231,col 50)","literalExprId":113,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1231,col 53)-(line 1231,col 54)","literalExprId":114,"literalExpr":"52","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1231,col 61)-(line 1231,col 61)","literalExprId":115,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1232,col 47)-(line 1232,col 47)","literalExprId":116,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1232,col 50)-(line 1232,col 51)","literalExprId":117,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1232,col 54)-(line 1232,col 56)","literalExprId":118,"literalExpr":"156","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1232,col 63)-(line 1232,col 64)","literalExprId":119,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1233,col 47)-(line 1233,col 47)","literalExprId":120,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1233,col 50)-(line 1233,col 51)","literalExprId":121,"literalExpr":"96","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1233,col 54)-(line 1233,col 56)","literalExprId":122,"literalExpr":"240","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1233,col 63)-(line 1233,col 64)","literalExprId":123,"literalExpr":"48","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1234,col 47)-(line 1234,col 47)","literalExprId":124,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1234,col 50)-(line 1234,col 51)","literalExprId":125,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1234,col 54)-(line 1234,col 55)","literalExprId":126,"literalExpr":"35","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1234,col 62)-(line 1234,col 62)","literalExprId":127,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1235,col 47)-(line 1235,col 47)","literalExprId":128,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1235,col 50)-(line 1235,col 52)","literalExprId":129,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1235,col 55)-(line 1235,col 57)","literalExprId":130,"literalExpr":"110","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1235,col 60)-(line 1235,col 62)","literalExprId":131,"literalExpr":"135","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1235,col 69)-(line 1235,col 69)","literalExprId":132,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1236,col 47)-(line 1236,col 47)","literalExprId":133,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1236,col 50)-(line 1236,col 52)","literalExprId":134,"literalExpr":"768","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1236,col 55)-(line 1236,col 58)","literalExprId":135,"literalExpr":"1092","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1236,col 65)-(line 1236,col 66)","literalExprId":136,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1237,col 47)-(line 1237,col 47)","literalExprId":137,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1237,col 50)-(line 1237,col 53)","literalExprId":138,"literalExpr":"2400","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1237,col 56)-(line 1237,col 59)","literalExprId":139,"literalExpr":"2448","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1237,col 62)-(line 1237,col 65)","literalExprId":140,"literalExpr":"2484","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1237,col 72)-(line 1237,col 73)","literalExprId":141,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1238,col 47)-(line 1238,col 47)","literalExprId":142,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1238,col 50)-(line 1238,col 53)","literalExprId":143,"literalExpr":"2400","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1238,col 56)-(line 1238,col 59)","literalExprId":144,"literalExpr":"2472","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1238,col 62)-(line 1238,col 65)","literalExprId":145,"literalExpr":"2508","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1238,col 72)-(line 1238,col 73)","literalExprId":146,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 47)-(line 1239,col 47)","literalExprId":147,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 50)-(line 1239,col 50)","literalExprId":148,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 53)-(line 1239,col 53)","literalExprId":149,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 56)-(line 1239,col 56)","literalExprId":150,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1239,col 63)-(line 1239,col 63)","literalExprId":151,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1242,col 33)-(line 1242,col 34)","literalExprId":152,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1242,col 37)-(line 1242,col 37)","literalExprId":153,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1242,col 43)-(line 1242,col 43)","literalExprId":154,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1243,col 34)-(line 1243,col 35)","literalExprId":155,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1243,col 38)-(line 1243,col 38)","literalExprId":156,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1243,col 44)-(line 1243,col 44)","literalExprId":157,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1244,col 33)-(line 1244,col 34)","literalExprId":158,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1244,col 38)-(line 1244,col 38)","literalExprId":159,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1244,col 44)-(line 1244,col 44)","literalExprId":160,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1245,col 34)-(line 1245,col 35)","literalExprId":161,"literalExpr":"33","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1245,col 39)-(line 1245,col 39)","literalExprId":162,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1245,col 45)-(line 1245,col 45)","literalExprId":163,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1248,col 61)-(line 1248,col 61)","literalExprId":164,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1248,col 64)-(line 1248,col 64)","literalExprId":165,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1248,col 67)-(line 1248,col 67)","literalExprId":166,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1248,col 70)-(line 1248,col 70)","literalExprId":167,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1248,col 73)-(line 1248,col 73)","literalExprId":168,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1248,col 76)-(line 1248,col 76)","literalExprId":169,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1249,col 61)-(line 1249,col 61)","literalExprId":170,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1249,col 64)-(line 1249,col 64)","literalExprId":171,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1249,col 67)-(line 1249,col 67)","literalExprId":172,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1249,col 70)-(line 1249,col 70)","literalExprId":173,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1249,col 73)-(line 1249,col 73)","literalExprId":174,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1249,col 89)-(line 1249,col 89)","literalExprId":175,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1250,col 61)-(line 1250,col 61)","literalExprId":176,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1250,col 64)-(line 1250,col 64)","literalExprId":177,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1250,col 67)-(line 1250,col 67)","literalExprId":178,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1250,col 83)-(line 1250,col 83)","literalExprId":179,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1250,col 86)-(line 1250,col 86)","literalExprId":180,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1250,col 89)-(line 1250,col 89)","literalExprId":181,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1251,col 61)-(line 1251,col 61)","literalExprId":182,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1251,col 64)-(line 1251,col 64)","literalExprId":183,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1251,col 67)-(line 1251,col 67)","literalExprId":184,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1251,col 70)-(line 1251,col 70)","literalExprId":185,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1251,col 86)-(line 1251,col 86)","literalExprId":186,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1251,col 89)-(line 1251,col 89)","literalExprId":187,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1252,col 61)-(line 1252,col 61)","literalExprId":188,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1252,col 64)-(line 1252,col 64)","literalExprId":189,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1252,col 67)-(line 1252,col 67)","literalExprId":190,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1252,col 83)-(line 1252,col 83)","literalExprId":191,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1252,col 86)-(line 1252,col 86)","literalExprId":192,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1252,col 89)-(line 1252,col 89)","literalExprId":193,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 26)-(line 1267,col 26)","literalExprId":194,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 29)-(line 1267,col 29)","literalExprId":195,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 32)-(line 1267,col 32)","literalExprId":196,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 35)-(line 1267,col 35)","literalExprId":197,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 38)-(line 1267,col 38)","literalExprId":198,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 41)-(line 1267,col 41)","literalExprId":199,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1267,col 45)-(line 1267,col 49)","literalExprId":200,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1268,col 26)-(line 1268,col 26)","literalExprId":201,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1268,col 29)-(line 1268,col 29)","literalExprId":202,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1268,col 32)-(line 1268,col 32)","literalExprId":203,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1268,col 35)-(line 1268,col 35)","literalExprId":204,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1268,col 38)-(line 1268,col 38)","literalExprId":205,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1268,col 42)-(line 1268,col 46)","literalExprId":206,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1268,col 60)-(line 1268,col 60)","literalExprId":207,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1269,col 26)-(line 1269,col 26)","literalExprId":208,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1269,col 29)-(line 1269,col 29)","literalExprId":209,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1269,col 32)-(line 1269,col 32)","literalExprId":210,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1269,col 36)-(line 1269,col 40)","literalExprId":211,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1269,col 54)-(line 1269,col 54)","literalExprId":212,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1269,col 57)-(line 1269,col 57)","literalExprId":213,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1269,col 60)-(line 1269,col 60)","literalExprId":214,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 26)-(line 1270,col 26)","literalExprId":215,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 29)-(line 1270,col 29)","literalExprId":216,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 32)-(line 1270,col 32)","literalExprId":217,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 35)-(line 1270,col 35)","literalExprId":218,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 39)-(line 1270,col 43)","literalExprId":219,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1270,col 57)-(line 1270,col 57)","literalExprId":220,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1270,col 60)-(line 1270,col 60)","literalExprId":221,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1271,col 26)-(line 1271,col 26)","literalExprId":222,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1271,col 29)-(line 1271,col 29)","literalExprId":223,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1271,col 32)-(line 1271,col 32)","literalExprId":224,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1271,col 36)-(line 1271,col 40)","literalExprId":225,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1271,col 54)-(line 1271,col 54)","literalExprId":226,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1271,col 57)-(line 1271,col 57)","literalExprId":227,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1271,col 60)-(line 1271,col 60)","literalExprId":228,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1272,col 26)-(line 1272,col 26)","literalExprId":229,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1272,col 30)-(line 1272,col 34)","literalExprId":230,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1273,col 26)-(line 1273,col 26)","literalExprId":231,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1273,col 29)-(line 1273,col 29)","literalExprId":232,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1273,col 32)-(line 1273,col 32)","literalExprId":233,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1273,col 36)-(line 1273,col 40)","literalExprId":234,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1274,col 26)-(line 1274,col 26)","literalExprId":235,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 29)-(line 1274,col 29)","literalExprId":236,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 32)-(line 1274,col 32)","literalExprId":237,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 35)-(line 1274,col 35)","literalExprId":238,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 38)-(line 1274,col 38)","literalExprId":239,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 41)-(line 1274,col 41)","literalExprId":240,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 45)-(line 1274,col 48)","literalExprId":241,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1274,col 62)-(line 1274,col 62)","literalExprId":242,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1274,col 65)-(line 1274,col 65)","literalExprId":243,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 26)-(line 1275,col 26)","literalExprId":244,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 29)-(line 1275,col 29)","literalExprId":245,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 32)-(line 1275,col 32)","literalExprId":246,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 35)-(line 1275,col 35)","literalExprId":247,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 38)-(line 1275,col 38)","literalExprId":248,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 42)-(line 1275,col 45)","literalExprId":249,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1275,col 59)-(line 1275,col 59)","literalExprId":250,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 62)-(line 1275,col 62)","literalExprId":251,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1275,col 65)-(line 1275,col 65)","literalExprId":252,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 26)-(line 1276,col 26)","literalExprId":253,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 29)-(line 1276,col 29)","literalExprId":254,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 32)-(line 1276,col 32)","literalExprId":255,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 36)-(line 1276,col 39)","literalExprId":256,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1276,col 53)-(line 1276,col 53)","literalExprId":257,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 56)-(line 1276,col 56)","literalExprId":258,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 59)-(line 1276,col 59)","literalExprId":259,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 62)-(line 1276,col 62)","literalExprId":260,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1276,col 65)-(line 1276,col 65)","literalExprId":261,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 26)-(line 1277,col 26)","literalExprId":262,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 29)-(line 1277,col 29)","literalExprId":263,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 32)-(line 1277,col 32)","literalExprId":264,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 35)-(line 1277,col 35)","literalExprId":265,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 39)-(line 1277,col 42)","literalExprId":266,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1277,col 56)-(line 1277,col 56)","literalExprId":267,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 59)-(line 1277,col 59)","literalExprId":268,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 62)-(line 1277,col 62)","literalExprId":269,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1277,col 65)-(line 1277,col 65)","literalExprId":270,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 26)-(line 1278,col 26)","literalExprId":271,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 29)-(line 1278,col 29)","literalExprId":272,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 32)-(line 1278,col 32)","literalExprId":273,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 36)-(line 1278,col 39)","literalExprId":274,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1278,col 53)-(line 1278,col 53)","literalExprId":275,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 56)-(line 1278,col 56)","literalExprId":276,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 59)-(line 1278,col 59)","literalExprId":277,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 62)-(line 1278,col 62)","literalExprId":278,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1278,col 65)-(line 1278,col 65)","literalExprId":279,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1279,col 26)-(line 1279,col 26)","literalExprId":280,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1279,col 29)-(line 1279,col 29)","literalExprId":281,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1279,col 32)-(line 1279,col 32)","literalExprId":282,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1279,col 36)-(line 1279,col 39)","literalExprId":283,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1279,col 53)-(line 1279,col 53)","literalExprId":284,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1279,col 56)-(line 1279,col 56)","literalExprId":285,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 27)-(line 1281,col 27)","literalExprId":286,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 30)-(line 1281,col 30)","literalExprId":287,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 33)-(line 1281,col 33)","literalExprId":288,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 36)-(line 1281,col 36)","literalExprId":289,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 39)-(line 1281,col 39)","literalExprId":290,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 42)-(line 1281,col 42)","literalExprId":291,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 45)-(line 1281,col 45)","literalExprId":292,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 48)-(line 1281,col 48)","literalExprId":293,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 52)-(line 1281,col 55)","literalExprId":294,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1281,col 70)-(line 1281,col 70)","literalExprId":295,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 73)-(line 1281,col 73)","literalExprId":296,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 76)-(line 1281,col 76)","literalExprId":297,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 79)-(line 1281,col 79)","literalExprId":298,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1281,col 82)-(line 1281,col 83)","literalExprId":299,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1292,col 15)-(line 1292,col 31)","literalExprId":300,"literalExpr":"\"Expected (r,m)=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1294,col 21)-(line 1294,col 34)","literalExprId":301,"literalExpr":"\", saw (r,m)=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1297,col 19)-(line 1297,col 22)","literalExprId":302,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1300,col 25)-(line 1300,col 25)","literalExprId":303,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1301,col 20)-(line 1301,col 20)","literalExprId":304,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1302,col 22)-(line 1302,col 22)","literalExprId":305,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1304,col 19)-(line 1304,col 19)","literalExprId":306,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1308,col 29)-(line 1308,col 39)","literalExprId":307,"literalExpr":"\"Expected \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1308,col 53)-(line 1308,col 57)","literalExprId":308,"literalExpr":"\" % \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1308,col 65)-(line 1308,col 69)","literalExprId":309,"literalExpr":"\" = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1308,col 82)-(line 1308,col 89)","literalExprId":310,"literalExpr":"\", got \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1329,col 34)-(line 1329,col 34)","literalExprId":311,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1329,col 37)-(line 1329,col 37)","literalExprId":312,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1329,col 40)-(line 1329,col 41)","literalExprId":313,"literalExpr":"47","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1329,col 44)-(line 1329,col 45)","literalExprId":314,"literalExpr":"51","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1329,col 60)-(line 1329,col 60)","literalExprId":315,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1329,col 63)-(line 1329,col 63)","literalExprId":316,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1330,col 34)-(line 1330,col 34)","literalExprId":317,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1330,col 37)-(line 1330,col 38)","literalExprId":318,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1330,col 41)-(line 1330,col 42)","literalExprId":319,"literalExpr":"43","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1330,col 45)-(line 1330,col 46)","literalExprId":320,"literalExpr":"51","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1330,col 61)-(line 1330,col 61)","literalExprId":321,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1330,col 64)-(line 1330,col 64)","literalExprId":322,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1331,col 34)-(line 1331,col 34)","literalExprId":323,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1331,col 37)-(line 1331,col 38)","literalExprId":324,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1331,col 41)-(line 1331,col 42)","literalExprId":325,"literalExpr":"47","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1331,col 45)-(line 1331,col 46)","literalExprId":326,"literalExpr":"55","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1331,col 61)-(line 1331,col 61)","literalExprId":327,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1331,col 64)-(line 1331,col 64)","literalExprId":328,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 34)-(line 1332,col 37)","literalExprId":329,"literalExpr":"2383","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 40)-(line 1332,col 43)","literalExprId":330,"literalExpr":"4015","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 47)-(line 1332,col 48)","literalExprId":331,"literalExpr":"81","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 51)-(line 1332,col 53)","literalExprId":332,"literalExpr":"463","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 57)-(line 1332,col 59)","literalExprId":333,"literalExpr":"689","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 74)-(line 1332,col 75)","literalExprId":334,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1332,col 78)-(line 1332,col 79)","literalExprId":335,"literalExpr":"32","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1333,col 37)-(line 1333,col 40)","literalExprId":336,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1334,col 34)-(line 1334,col 34)","literalExprId":337,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1334,col 38)-(line 1334,col 41)","literalExprId":338,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1335,col 34)-(line 1335,col 34)","literalExprId":339,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1335,col 37)-(line 1335,col 37)","literalExprId":340,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1335,col 41)-(line 1335,col 44)","literalExprId":341,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1336,col 34)-(line 1336,col 34)","literalExprId":342,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1336,col 37)-(line 1336,col 37)","literalExprId":343,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1336,col 40)-(line 1336,col 40)","literalExprId":344,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1336,col 43)-(line 1336,col 43)","literalExprId":345,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1336,col 47)-(line 1336,col 50)","literalExprId":346,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1337,col 34)-(line 1337,col 34)","literalExprId":347,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1337,col 37)-(line 1337,col 38)","literalExprId":348,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1337,col 41)-(line 1337,col 43)","literalExprId":349,"literalExpr":"101","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1337,col 47)-(line 1337,col 50)","literalExprId":350,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1338,col 34)-(line 1338,col 34)","literalExprId":351,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1338,col 37)-(line 1338,col 37)","literalExprId":352,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1338,col 40)-(line 1338,col 40)","literalExprId":353,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1338,col 43)-(line 1338,col 43)","literalExprId":354,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1338,col 46)-(line 1338,col 46)","literalExprId":355,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1338,col 50)-(line 1338,col 53)","literalExprId":356,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1340,col 46)-(line 1340,col 49)","literalExprId":357,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1341,col 43)-(line 1341,col 43)","literalExprId":358,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1341,col 47)-(line 1341,col 50)","literalExprId":359,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1342,col 43)-(line 1342,col 43)","literalExprId":360,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1342,col 46)-(line 1342,col 46)","literalExprId":361,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1342,col 49)-(line 1342,col 50)","literalExprId":362,"literalExpr":"47","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1342,col 53)-(line 1342,col 54)","literalExprId":363,"literalExpr":"51","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1342,col 69)-(line 1342,col 69)","literalExprId":364,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1342,col 72)-(line 1342,col 72)","literalExprId":365,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 43)-(line 1343,col 43)","literalExprId":366,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 46)-(line 1343,col 47)","literalExprId":367,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 50)-(line 1343,col 51)","literalExprId":368,"literalExpr":"43","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 54)-(line 1343,col 55)","literalExprId":369,"literalExpr":"51","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 70)-(line 1343,col 70)","literalExprId":370,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1343,col 73)-(line 1343,col 73)","literalExprId":371,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1344,col 43)-(line 1344,col 43)","literalExprId":372,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1344,col 46)-(line 1344,col 47)","literalExprId":373,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1344,col 50)-(line 1344,col 51)","literalExprId":374,"literalExpr":"47","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1344,col 54)-(line 1344,col 55)","literalExprId":375,"literalExpr":"55","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1344,col 70)-(line 1344,col 70)","literalExprId":376,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1344,col 73)-(line 1344,col 73)","literalExprId":377,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 43)-(line 1345,col 46)","literalExprId":378,"literalExpr":"2383","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 49)-(line 1345,col 52)","literalExprId":379,"literalExpr":"4015","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 56)-(line 1345,col 57)","literalExprId":380,"literalExpr":"81","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 60)-(line 1345,col 62)","literalExprId":381,"literalExpr":"463","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 66)-(line 1345,col 68)","literalExprId":382,"literalExpr":"689","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 83)-(line 1345,col 84)","literalExprId":383,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1345,col 87)-(line 1345,col 88)","literalExprId":384,"literalExpr":"32","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 43)-(line 1346,col 43)","literalExprId":385,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 46)-(line 1346,col 46)","literalExprId":386,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 49)-(line 1346,col 49)","literalExprId":387,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 52)-(line 1346,col 52)","literalExprId":388,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 55)-(line 1346,col 55)","literalExprId":389,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1346,col 59)-(line 1346,col 62)","literalExprId":390,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1355,col 30)-(line 1355,col 33)","literalExprId":391,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1362,col 30)-(line 1362,col 34)","literalExprId":392,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1375,col 15)-(line 1375,col 31)","literalExprId":393,"literalExpr":"\"Expected (r,m)=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1377,col 21)-(line 1377,col 34)","literalExprId":394,"literalExpr":"\", saw (r,m)=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1380,col 19)-(line 1380,col 22)","literalExprId":395,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1383,col 25)-(line 1383,col 25)","literalExprId":396,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1384,col 20)-(line 1384,col 20)","literalExprId":397,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1385,col 22)-(line 1385,col 22)","literalExprId":398,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1387,col 19)-(line 1387,col 19)","literalExprId":399,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1391,col 29)-(line 1391,col 55)","literalExprId":400,"literalExpr":"\"Expected inequality, saw \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1391,col 69)-(line 1391,col 73)","literalExprId":401,"literalExpr":"\" % \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1391,col 81)-(line 1391,col 85)","literalExprId":402,"literalExpr":"\" = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1399,col 44)-(line 1399,col 44)","literalExprId":403,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 47)-(line 1399,col 47)","literalExprId":404,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 50)-(line 1399,col 50)","literalExprId":405,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 53)-(line 1399,col 53)","literalExprId":406,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 56)-(line 1399,col 56)","literalExprId":407,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 59)-(line 1399,col 59)","literalExprId":408,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 62)-(line 1399,col 62)","literalExprId":409,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1399,col 66)-(line 1399,col 69)","literalExprId":410,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1400,col 45)-(line 1400,col 45)","literalExprId":411,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 48)-(line 1400,col 48)","literalExprId":412,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 51)-(line 1400,col 51)","literalExprId":413,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 54)-(line 1400,col 54)","literalExprId":414,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 57)-(line 1400,col 57)","literalExprId":415,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 60)-(line 1400,col 60)","literalExprId":416,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 63)-(line 1400,col 63)","literalExprId":417,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 66)-(line 1400,col 66)","literalExprId":418,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 81)-(line 1400,col 81)","literalExprId":419,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1400,col 84)-(line 1400,col 84)","literalExprId":420,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 44)-(line 1401,col 44)","literalExprId":421,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 47)-(line 1401,col 47)","literalExprId":422,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 50)-(line 1401,col 50)","literalExprId":423,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 53)-(line 1401,col 53)","literalExprId":424,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 56)-(line 1401,col 56)","literalExprId":425,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 59)-(line 1401,col 59)","literalExprId":426,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 62)-(line 1401,col 62)","literalExprId":427,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 65)-(line 1401,col 66)","literalExprId":428,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1401,col 70)-(line 1401,col 73)","literalExprId":429,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1402,col 44)-(line 1402,col 44)","literalExprId":430,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 47)-(line 1402,col 47)","literalExprId":431,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 50)-(line 1402,col 50)","literalExprId":432,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 53)-(line 1402,col 53)","literalExprId":433,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 56)-(line 1402,col 56)","literalExprId":434,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 59)-(line 1402,col 59)","literalExprId":435,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 62)-(line 1402,col 63)","literalExprId":436,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1402,col 67)-(line 1402,col 70)","literalExprId":437,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1403,col 44)-(line 1403,col 44)","literalExprId":438,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1403,col 47)-(line 1403,col 47)","literalExprId":439,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1403,col 50)-(line 1403,col 50)","literalExprId":440,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1403,col 53)-(line 1403,col 53)","literalExprId":441,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1403,col 56)-(line 1403,col 56)","literalExprId":442,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1403,col 59)-(line 1403,col 60)","literalExprId":443,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1403,col 64)-(line 1403,col 67)","literalExprId":444,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1406,col 47)-(line 1406,col 47)","literalExprId":445,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 50)-(line 1406,col 50)","literalExprId":446,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 53)-(line 1406,col 53)","literalExprId":447,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 56)-(line 1406,col 56)","literalExprId":448,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 59)-(line 1406,col 59)","literalExprId":449,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 62)-(line 1406,col 62)","literalExprId":450,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 65)-(line 1406,col 65)","literalExprId":451,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1406,col 69)-(line 1406,col 72)","literalExprId":452,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1407,col 47)-(line 1407,col 47)","literalExprId":453,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 50)-(line 1407,col 50)","literalExprId":454,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 53)-(line 1407,col 53)","literalExprId":455,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 56)-(line 1407,col 56)","literalExprId":456,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 59)-(line 1407,col 59)","literalExprId":457,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 62)-(line 1407,col 62)","literalExprId":458,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 65)-(line 1407,col 65)","literalExprId":459,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 68)-(line 1407,col 69)","literalExprId":460,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 84)-(line 1407,col 84)","literalExprId":461,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1407,col 87)-(line 1407,col 87)","literalExprId":462,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 47)-(line 1408,col 47)","literalExprId":463,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 50)-(line 1408,col 50)","literalExprId":464,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 53)-(line 1408,col 53)","literalExprId":465,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 56)-(line 1408,col 56)","literalExprId":466,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 59)-(line 1408,col 59)","literalExprId":467,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 62)-(line 1408,col 62)","literalExprId":468,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 65)-(line 1408,col 65)","literalExprId":469,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 68)-(line 1408,col 69)","literalExprId":470,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 84)-(line 1408,col 84)","literalExprId":471,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1408,col 87)-(line 1408,col 87)","literalExprId":472,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 47)-(line 1409,col 47)","literalExprId":473,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 50)-(line 1409,col 50)","literalExprId":474,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 53)-(line 1409,col 53)","literalExprId":475,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 56)-(line 1409,col 56)","literalExprId":476,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 59)-(line 1409,col 59)","literalExprId":477,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 62)-(line 1409,col 62)","literalExprId":478,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 65)-(line 1409,col 65)","literalExprId":479,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 68)-(line 1409,col 69)","literalExprId":480,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 72)-(line 1409,col 73)","literalExprId":481,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 76)-(line 1409,col 77)","literalExprId":482,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1409,col 81)-(line 1409,col 84)","literalExprId":483,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1411,col 20)-(line 1411,col 20)","literalExprId":484,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 23)-(line 1411,col 23)","literalExprId":485,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 26)-(line 1411,col 26)","literalExprId":486,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 29)-(line 1411,col 29)","literalExprId":487,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 32)-(line 1411,col 32)","literalExprId":488,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 35)-(line 1411,col 35)","literalExprId":489,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 38)-(line 1411,col 38)","literalExprId":490,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 41)-(line 1411,col 42)","literalExprId":491,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 45)-(line 1411,col 46)","literalExprId":492,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 49)-(line 1411,col 50)","literalExprId":493,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 53)-(line 1411,col 54)","literalExprId":494,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 57)-(line 1411,col 58)","literalExprId":495,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 73)-(line 1411,col 73)","literalExprId":496,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1411,col 76)-(line 1411,col 76)","literalExprId":497,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 47)-(line 1412,col 47)","literalExprId":498,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 50)-(line 1412,col 50)","literalExprId":499,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 53)-(line 1412,col 53)","literalExprId":500,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 56)-(line 1412,col 56)","literalExprId":501,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 59)-(line 1412,col 59)","literalExprId":502,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 62)-(line 1412,col 62)","literalExprId":503,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 65)-(line 1412,col 65)","literalExprId":504,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 68)-(line 1412,col 69)","literalExprId":505,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 72)-(line 1412,col 73)","literalExprId":506,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 76)-(line 1412,col 77)","literalExprId":507,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 80)-(line 1412,col 81)","literalExprId":508,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 84)-(line 1412,col 85)","literalExprId":509,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 88)-(line 1412,col 89)","literalExprId":510,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1412,col 93)-(line 1412,col 96)","literalExprId":511,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testMathMDE()"},{"methodDeclaration":"public void testOrderedPairIterator()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    final int NULL = -2222;\n    Vector<Integer> ones = new Vector<Integer>();\n    for (int i = 1; i <= 30; i++) {\n        ones.add(new Integer(i));\n    }\n    Vector<Integer> twos = new Vector<Integer>();\n    for (int i = 2; i <= 30; i += 2) {\n        twos.add(new Integer(i));\n    }\n    Vector<Integer> threes = new Vector<Integer>();\n    for (int i = 3; i <= 30; i += 3) {\n        threes.add(new Integer(i));\n    }\n    compareOrderedPairIterator(new OrderedPairIterator<Integer>(ones.iterator(), ones.iterator()), new int[][] { { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 }, { 8, 8 }, { 9, 9 }, { 10, 10 }, { 11, 11 }, { 12, 12 }, { 13, 13 }, { 14, 14 }, { 15, 15 }, { 16, 16 }, { 17, 17 }, { 18, 18 }, { 19, 19 }, { 20, 20 }, { 21, 21 }, { 22, 22 }, { 23, 23 }, { 24, 24 }, { 25, 25 }, { 26, 26 }, { 27, 27 }, { 28, 28 }, { 29, 29 }, { 30, 30 } });\n    compareOrderedPairIterator(new OrderedPairIterator<Integer>(ones.iterator(), twos.iterator()), new int[][] { { 1, NULL }, { 2, 2 }, { 3, NULL }, { 4, 4 }, { 5, NULL }, { 6, 6 }, { 7, NULL }, { 8, 8 }, { 9, NULL }, { 10, 10 }, { 11, NULL }, { 12, 12 }, { 13, NULL }, { 14, 14 }, { 15, NULL }, { 16, 16 }, { 17, NULL }, { 18, 18 }, { 19, NULL }, { 20, 20 }, { 21, NULL }, { 22, 22 }, { 23, NULL }, { 24, 24 }, { 25, NULL }, { 26, 26 }, { 27, NULL }, { 28, 28 }, { 29, NULL }, { 30, 30 } });\n    compareOrderedPairIterator(new OrderedPairIterator<Integer>(twos.iterator(), ones.iterator()), new int[][] { { NULL, 1 }, { 2, 2 }, { NULL, 3 }, { 4, 4 }, { NULL, 5 }, { 6, 6 }, { NULL, 7 }, { 8, 8 }, { NULL, 9 }, { 10, 10 }, { NULL, 11 }, { 12, 12 }, { NULL, 13 }, { 14, 14 }, { NULL, 15 }, { 16, 16 }, { NULL, 17 }, { 18, 18 }, { NULL, 19 }, { 20, 20 }, { NULL, 21 }, { 22, 22 }, { NULL, 23 }, { 24, 24 }, { NULL, 25 }, { 26, 26 }, { NULL, 27 }, { 28, 28 }, { NULL, 29 }, { 30, 30 } });\n    compareOrderedPairIterator(new OrderedPairIterator<Integer>(ones.iterator(), threes.iterator()), new int[][] { { 1, NULL }, { 2, NULL }, { 3, 3 }, { 4, NULL }, { 5, NULL }, { 6, 6 }, { 7, NULL }, { 8, NULL }, { 9, 9 }, { 10, NULL }, { 11, NULL }, { 12, 12 }, { 13, NULL }, { 14, NULL }, { 15, 15 }, { 16, NULL }, { 17, NULL }, { 18, 18 }, { 19, NULL }, { 20, NULL }, { 21, 21 }, { 22, NULL }, { 23, NULL }, { 24, 24 }, { 25, NULL }, { 26, NULL }, { 27, 27 }, { 28, NULL }, { 29, NULL }, { 30, 30 } });\n    compareOrderedPairIterator(new OrderedPairIterator<Integer>(twos.iterator(), threes.iterator()), new int[][] { { 2, NULL }, { NULL, 3 }, { 4, NULL }, { 6, 6 }, { 8, NULL }, { NULL, 9 }, { 10, NULL }, { 12, 12 }, { 14, NULL }, { NULL, 15 }, { 16, NULL }, { 18, 18 }, { 20, NULL }, { NULL, 21 }, { 22, NULL }, { 24, 24 }, { 26, NULL }, { NULL, 27 }, { 28, NULL }, { 30, 30 } });\n}","methodRange":"(line 1415,col 3)-(line 1573,col 3)","methodTokenRange":"@Test\n  public void testOrderedPairIterator() {\n    final int NULL = -2222;\n\n    Vector<Integer> ones = new Vector<Integer>();\n    for (int i = 1; i <= 30; i++) {\n      ones.add(new Integer(i));\n    }\n    Vector<Integer> twos = new Vector<Integer>();\n    for (int i = 2; i <= 30; i += 2) {\n      twos.add(new Integer(i));\n    }\n    Vector<Integer> threes = new Vector<Integer>();\n    for (int i = 3; i <= 30; i += 3) {\n      threes.add(new Integer(i));\n    }\n\n    \/\/ I've replaced the nulls by 0 in order to permit the array elements\n    \/\/ to be ints instead of Integers.\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), ones.iterator()),\n        new int[][] {\n          {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}, {6, 6}, {7, 7}, {8, 8}, {9, 9}, {10, 10},\n          {11, 11}, {12, 12}, {13, 13}, {14, 14}, {15, 15}, {16, 16}, {17, 17}, {18, 18}, {19, 19},\n          {20, 20}, {21, 21}, {22, 22}, {23, 23}, {24, 24}, {25, 25}, {26, 26}, {27, 27}, {28, 28},\n          {29, 29}, {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), twos.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, 2},\n          {3, NULL},\n          {4, 4},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, 8},\n          {9, NULL},\n          {10, 10},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, 14},\n          {15, NULL},\n          {16, 16},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, 20},\n          {21, NULL},\n          {22, 22},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, 26},\n          {27, NULL},\n          {28, 28},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), ones.iterator()),\n        new int[][] {\n          {NULL, 1},\n          {2, 2},\n          {NULL, 3},\n          {4, 4},\n          {NULL, 5},\n          {6, 6},\n          {NULL, 7},\n          {8, 8},\n          {NULL, 9},\n          {10, 10},\n          {NULL, 11},\n          {12, 12},\n          {NULL, 13},\n          {14, 14},\n          {NULL, 15},\n          {16, 16},\n          {NULL, 17},\n          {18, 18},\n          {NULL, 19},\n          {20, 20},\n          {NULL, 21},\n          {22, 22},\n          {NULL, 23},\n          {24, 24},\n          {NULL, 25},\n          {26, 26},\n          {NULL, 27},\n          {28, 28},\n          {NULL, 29},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(ones.iterator(), threes.iterator()),\n        new int[][] {\n          {1, NULL},\n          {2, NULL},\n          {3, 3},\n          {4, NULL},\n          {5, NULL},\n          {6, 6},\n          {7, NULL},\n          {8, NULL},\n          {9, 9},\n          {10, NULL},\n          {11, NULL},\n          {12, 12},\n          {13, NULL},\n          {14, NULL},\n          {15, 15},\n          {16, NULL},\n          {17, NULL},\n          {18, 18},\n          {19, NULL},\n          {20, NULL},\n          {21, 21},\n          {22, NULL},\n          {23, NULL},\n          {24, 24},\n          {25, NULL},\n          {26, NULL},\n          {27, 27},\n          {28, NULL},\n          {29, NULL},\n          {30, 30},\n        });\n\n    compareOrderedPairIterator(\n        new OrderedPairIterator<Integer>(twos.iterator(), threes.iterator()),\n        new int[][] {\n          {2, NULL},\n          {NULL, 3},\n          {4, NULL},\n          {6, 6},\n          {8, NULL},\n          {NULL, 9},\n          {10, NULL},\n          {12, 12},\n          {14, NULL},\n          {NULL, 15},\n          {16, NULL},\n          {18, 18},\n          {20, NULL},\n          {NULL, 21},\n          {22, NULL},\n          {24, 24},\n          {26, NULL},\n          {NULL, 27},\n          {28, NULL},\n          {30, 30},\n        });\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testOrderedPairIterator","methodQualifiedSignature":"plume.TestPlume.testOrderedPairIterator","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1417,col 23)-(line 1417,col 26)","literalExprId":1,"literalExpr":"2222","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1420,col 18)-(line 1420,col 18)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1420,col 26)-(line 1420,col 27)","literalExprId":3,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1424,col 18)-(line 1424,col 18)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1424,col 26)-(line 1424,col 27)","literalExprId":5,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1424,col 35)-(line 1424,col 35)","literalExprId":6,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1428,col 18)-(line 1428,col 18)","literalExprId":7,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1428,col 26)-(line 1428,col 27)","literalExprId":8,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1428,col 35)-(line 1428,col 35)","literalExprId":9,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 12)-(line 1438,col 12)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 15)-(line 1438,col 15)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 20)-(line 1438,col 20)","literalExprId":12,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 23)-(line 1438,col 23)","literalExprId":13,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 28)-(line 1438,col 28)","literalExprId":14,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 31)-(line 1438,col 31)","literalExprId":15,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 36)-(line 1438,col 36)","literalExprId":16,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 39)-(line 1438,col 39)","literalExprId":17,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 44)-(line 1438,col 44)","literalExprId":18,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 47)-(line 1438,col 47)","literalExprId":19,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 52)-(line 1438,col 52)","literalExprId":20,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 55)-(line 1438,col 55)","literalExprId":21,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 60)-(line 1438,col 60)","literalExprId":22,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 63)-(line 1438,col 63)","literalExprId":23,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 68)-(line 1438,col 68)","literalExprId":24,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 71)-(line 1438,col 71)","literalExprId":25,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 76)-(line 1438,col 76)","literalExprId":26,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 79)-(line 1438,col 79)","literalExprId":27,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 84)-(line 1438,col 85)","literalExprId":28,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1438,col 88)-(line 1438,col 89)","literalExprId":29,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 12)-(line 1439,col 13)","literalExprId":30,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 16)-(line 1439,col 17)","literalExprId":31,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 22)-(line 1439,col 23)","literalExprId":32,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 26)-(line 1439,col 27)","literalExprId":33,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 32)-(line 1439,col 33)","literalExprId":34,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 36)-(line 1439,col 37)","literalExprId":35,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 42)-(line 1439,col 43)","literalExprId":36,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 46)-(line 1439,col 47)","literalExprId":37,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 52)-(line 1439,col 53)","literalExprId":38,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 56)-(line 1439,col 57)","literalExprId":39,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 62)-(line 1439,col 63)","literalExprId":40,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 66)-(line 1439,col 67)","literalExprId":41,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 72)-(line 1439,col 73)","literalExprId":42,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 76)-(line 1439,col 77)","literalExprId":43,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 82)-(line 1439,col 83)","literalExprId":44,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 86)-(line 1439,col 87)","literalExprId":45,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 92)-(line 1439,col 93)","literalExprId":46,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1439,col 96)-(line 1439,col 97)","literalExprId":47,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 12)-(line 1440,col 13)","literalExprId":48,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 16)-(line 1440,col 17)","literalExprId":49,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 22)-(line 1440,col 23)","literalExprId":50,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 26)-(line 1440,col 27)","literalExprId":51,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 32)-(line 1440,col 33)","literalExprId":52,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 36)-(line 1440,col 37)","literalExprId":53,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 42)-(line 1440,col 43)","literalExprId":54,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 46)-(line 1440,col 47)","literalExprId":55,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 52)-(line 1440,col 53)","literalExprId":56,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 56)-(line 1440,col 57)","literalExprId":57,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 62)-(line 1440,col 63)","literalExprId":58,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 66)-(line 1440,col 67)","literalExprId":59,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 72)-(line 1440,col 73)","literalExprId":60,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 76)-(line 1440,col 77)","literalExprId":61,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 82)-(line 1440,col 83)","literalExprId":62,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 86)-(line 1440,col 87)","literalExprId":63,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 92)-(line 1440,col 93)","literalExprId":64,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1440,col 96)-(line 1440,col 97)","literalExprId":65,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1441,col 12)-(line 1441,col 13)","literalExprId":66,"literalExpr":"29","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1441,col 16)-(line 1441,col 17)","literalExprId":67,"literalExpr":"29","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1441,col 22)-(line 1441,col 23)","literalExprId":68,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1441,col 26)-(line 1441,col 27)","literalExprId":69,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1447,col 12)-(line 1447,col 12)","literalExprId":70,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1448,col 12)-(line 1448,col 12)","literalExprId":71,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1448,col 15)-(line 1448,col 15)","literalExprId":72,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1449,col 12)-(line 1449,col 12)","literalExprId":73,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1450,col 12)-(line 1450,col 12)","literalExprId":74,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1450,col 15)-(line 1450,col 15)","literalExprId":75,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1451,col 12)-(line 1451,col 12)","literalExprId":76,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1452,col 12)-(line 1452,col 12)","literalExprId":77,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1452,col 15)-(line 1452,col 15)","literalExprId":78,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1453,col 12)-(line 1453,col 12)","literalExprId":79,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1454,col 12)-(line 1454,col 12)","literalExprId":80,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1454,col 15)-(line 1454,col 15)","literalExprId":81,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1455,col 12)-(line 1455,col 12)","literalExprId":82,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1456,col 12)-(line 1456,col 13)","literalExprId":83,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1456,col 16)-(line 1456,col 17)","literalExprId":84,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1457,col 12)-(line 1457,col 13)","literalExprId":85,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1458,col 12)-(line 1458,col 13)","literalExprId":86,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1458,col 16)-(line 1458,col 17)","literalExprId":87,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1459,col 12)-(line 1459,col 13)","literalExprId":88,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1460,col 12)-(line 1460,col 13)","literalExprId":89,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1460,col 16)-(line 1460,col 17)","literalExprId":90,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1461,col 12)-(line 1461,col 13)","literalExprId":91,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1462,col 12)-(line 1462,col 13)","literalExprId":92,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1462,col 16)-(line 1462,col 17)","literalExprId":93,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1463,col 12)-(line 1463,col 13)","literalExprId":94,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1464,col 12)-(line 1464,col 13)","literalExprId":95,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1464,col 16)-(line 1464,col 17)","literalExprId":96,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1465,col 12)-(line 1465,col 13)","literalExprId":97,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1466,col 12)-(line 1466,col 13)","literalExprId":98,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1466,col 16)-(line 1466,col 17)","literalExprId":99,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1467,col 12)-(line 1467,col 13)","literalExprId":100,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1468,col 12)-(line 1468,col 13)","literalExprId":101,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1468,col 16)-(line 1468,col 17)","literalExprId":102,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1469,col 12)-(line 1469,col 13)","literalExprId":103,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1470,col 12)-(line 1470,col 13)","literalExprId":104,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1470,col 16)-(line 1470,col 17)","literalExprId":105,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1471,col 12)-(line 1471,col 13)","literalExprId":106,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1472,col 12)-(line 1472,col 13)","literalExprId":107,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1472,col 16)-(line 1472,col 17)","literalExprId":108,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1473,col 12)-(line 1473,col 13)","literalExprId":109,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1474,col 12)-(line 1474,col 13)","literalExprId":110,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1474,col 16)-(line 1474,col 17)","literalExprId":111,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1475,col 12)-(line 1475,col 13)","literalExprId":112,"literalExpr":"29","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1476,col 12)-(line 1476,col 13)","literalExprId":113,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1476,col 16)-(line 1476,col 17)","literalExprId":114,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1482,col 18)-(line 1482,col 18)","literalExprId":115,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1483,col 12)-(line 1483,col 12)","literalExprId":116,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1483,col 15)-(line 1483,col 15)","literalExprId":117,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1484,col 18)-(line 1484,col 18)","literalExprId":118,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1485,col 12)-(line 1485,col 12)","literalExprId":119,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1485,col 15)-(line 1485,col 15)","literalExprId":120,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1486,col 18)-(line 1486,col 18)","literalExprId":121,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1487,col 12)-(line 1487,col 12)","literalExprId":122,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1487,col 15)-(line 1487,col 15)","literalExprId":123,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1488,col 18)-(line 1488,col 18)","literalExprId":124,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1489,col 12)-(line 1489,col 12)","literalExprId":125,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1489,col 15)-(line 1489,col 15)","literalExprId":126,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1490,col 18)-(line 1490,col 18)","literalExprId":127,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1491,col 12)-(line 1491,col 13)","literalExprId":128,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1491,col 16)-(line 1491,col 17)","literalExprId":129,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1492,col 18)-(line 1492,col 19)","literalExprId":130,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1493,col 12)-(line 1493,col 13)","literalExprId":131,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1493,col 16)-(line 1493,col 17)","literalExprId":132,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1494,col 18)-(line 1494,col 19)","literalExprId":133,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1495,col 12)-(line 1495,col 13)","literalExprId":134,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1495,col 16)-(line 1495,col 17)","literalExprId":135,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1496,col 18)-(line 1496,col 19)","literalExprId":136,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1497,col 12)-(line 1497,col 13)","literalExprId":137,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1497,col 16)-(line 1497,col 17)","literalExprId":138,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1498,col 18)-(line 1498,col 19)","literalExprId":139,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1499,col 12)-(line 1499,col 13)","literalExprId":140,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1499,col 16)-(line 1499,col 17)","literalExprId":141,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1500,col 18)-(line 1500,col 19)","literalExprId":142,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1501,col 12)-(line 1501,col 13)","literalExprId":143,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1501,col 16)-(line 1501,col 17)","literalExprId":144,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1502,col 18)-(line 1502,col 19)","literalExprId":145,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1503,col 12)-(line 1503,col 13)","literalExprId":146,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1503,col 16)-(line 1503,col 17)","literalExprId":147,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1504,col 18)-(line 1504,col 19)","literalExprId":148,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1505,col 12)-(line 1505,col 13)","literalExprId":149,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1505,col 16)-(line 1505,col 17)","literalExprId":150,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1506,col 18)-(line 1506,col 19)","literalExprId":151,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1507,col 12)-(line 1507,col 13)","literalExprId":152,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1507,col 16)-(line 1507,col 17)","literalExprId":153,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1508,col 18)-(line 1508,col 19)","literalExprId":154,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1509,col 12)-(line 1509,col 13)","literalExprId":155,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1509,col 16)-(line 1509,col 17)","literalExprId":156,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1510,col 18)-(line 1510,col 19)","literalExprId":157,"literalExpr":"29","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1511,col 12)-(line 1511,col 13)","literalExprId":158,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1511,col 16)-(line 1511,col 17)","literalExprId":159,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1517,col 12)-(line 1517,col 12)","literalExprId":160,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1518,col 12)-(line 1518,col 12)","literalExprId":161,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1519,col 12)-(line 1519,col 12)","literalExprId":162,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1519,col 15)-(line 1519,col 15)","literalExprId":163,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1520,col 12)-(line 1520,col 12)","literalExprId":164,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1521,col 12)-(line 1521,col 12)","literalExprId":165,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1522,col 12)-(line 1522,col 12)","literalExprId":166,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1522,col 15)-(line 1522,col 15)","literalExprId":167,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1523,col 12)-(line 1523,col 12)","literalExprId":168,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1524,col 12)-(line 1524,col 12)","literalExprId":169,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1525,col 12)-(line 1525,col 12)","literalExprId":170,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1525,col 15)-(line 1525,col 15)","literalExprId":171,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1526,col 12)-(line 1526,col 13)","literalExprId":172,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1527,col 12)-(line 1527,col 13)","literalExprId":173,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1528,col 12)-(line 1528,col 13)","literalExprId":174,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1528,col 16)-(line 1528,col 17)","literalExprId":175,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1529,col 12)-(line 1529,col 13)","literalExprId":176,"literalExpr":"13","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1530,col 12)-(line 1530,col 13)","literalExprId":177,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1531,col 12)-(line 1531,col 13)","literalExprId":178,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1531,col 16)-(line 1531,col 17)","literalExprId":179,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1532,col 12)-(line 1532,col 13)","literalExprId":180,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1533,col 12)-(line 1533,col 13)","literalExprId":181,"literalExpr":"17","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1534,col 12)-(line 1534,col 13)","literalExprId":182,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1534,col 16)-(line 1534,col 17)","literalExprId":183,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1535,col 12)-(line 1535,col 13)","literalExprId":184,"literalExpr":"19","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1536,col 12)-(line 1536,col 13)","literalExprId":185,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1537,col 12)-(line 1537,col 13)","literalExprId":186,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1537,col 16)-(line 1537,col 17)","literalExprId":187,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1538,col 12)-(line 1538,col 13)","literalExprId":188,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1539,col 12)-(line 1539,col 13)","literalExprId":189,"literalExpr":"23","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1540,col 12)-(line 1540,col 13)","literalExprId":190,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1540,col 16)-(line 1540,col 17)","literalExprId":191,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1541,col 12)-(line 1541,col 13)","literalExprId":192,"literalExpr":"25","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1542,col 12)-(line 1542,col 13)","literalExprId":193,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1543,col 12)-(line 1543,col 13)","literalExprId":194,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1543,col 16)-(line 1543,col 17)","literalExprId":195,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1544,col 12)-(line 1544,col 13)","literalExprId":196,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1545,col 12)-(line 1545,col 13)","literalExprId":197,"literalExpr":"29","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1546,col 12)-(line 1546,col 13)","literalExprId":198,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1546,col 16)-(line 1546,col 17)","literalExprId":199,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1552,col 12)-(line 1552,col 12)","literalExprId":200,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1553,col 18)-(line 1553,col 18)","literalExprId":201,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1554,col 12)-(line 1554,col 12)","literalExprId":202,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1555,col 12)-(line 1555,col 12)","literalExprId":203,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1555,col 15)-(line 1555,col 15)","literalExprId":204,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1556,col 12)-(line 1556,col 12)","literalExprId":205,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1557,col 18)-(line 1557,col 18)","literalExprId":206,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1558,col 12)-(line 1558,col 13)","literalExprId":207,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1559,col 12)-(line 1559,col 13)","literalExprId":208,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1559,col 16)-(line 1559,col 17)","literalExprId":209,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1560,col 12)-(line 1560,col 13)","literalExprId":210,"literalExpr":"14","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1561,col 18)-(line 1561,col 19)","literalExprId":211,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1562,col 12)-(line 1562,col 13)","literalExprId":212,"literalExpr":"16","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1563,col 12)-(line 1563,col 13)","literalExprId":213,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1563,col 16)-(line 1563,col 17)","literalExprId":214,"literalExpr":"18","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1564,col 12)-(line 1564,col 13)","literalExprId":215,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1565,col 18)-(line 1565,col 19)","literalExprId":216,"literalExpr":"21","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1566,col 12)-(line 1566,col 13)","literalExprId":217,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1567,col 12)-(line 1567,col 13)","literalExprId":218,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1567,col 16)-(line 1567,col 17)","literalExprId":219,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1568,col 12)-(line 1568,col 13)","literalExprId":220,"literalExpr":"26","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1569,col 18)-(line 1569,col 19)","literalExprId":221,"literalExpr":"27","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1570,col 12)-(line 1570,col 13)","literalExprId":222,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1571,col 12)-(line 1571,col 13)","literalExprId":223,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1571,col 16)-(line 1571,col 17)","literalExprId":224,"literalExpr":"30","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testOrderedPairIterator()"},{"javadocBlockTags":[],"methodDeclaration":"public static void compareOrderedPairIterator(OrderedPairIterator<Integer> opi, int[][] ints)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int pairno = 0;\n    while (opi.hasNext()) {\n        Pair<Integer, Integer> pair = opi.next();\n        assert (pair.a == null) || (pair.a.intValue() == ints[pairno][0]);\n        assert (pair.b == null) || (pair.b.intValue() == ints[pairno][1]);\n        pairno++;\n    }\n    assert pairno == ints.length;\n}","methodRange":"(line 1576,col 3)-(line 1586,col 3)","methodTokenRange":"public static void compareOrderedPairIterator(OrderedPairIterator<Integer> opi, int[][] ints) {\n    int pairno = 0;\n    while (opi.hasNext()) {\n      Pair<\/*@Nullable*\/ Integer, \/*@Nullable*\/ Integer> pair = opi.next();\n      \/\/ System.out.println(\"Iterator: <\" + pair.a + \",\" + pair.b + \">, array: <\" + ints[pairno][0] + \",\" + ints[pairno][1] + \">\");\n      assert (pair.a == null) || (pair.a.intValue() == ints[pairno][0]);\n      assert (pair.b == null) || (pair.b.intValue() == ints[pairno][1]);\n      pairno++;\n    }\n    assert pairno == ints.length;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Throws an assertion unless the paired iterator contains the same values as the argument array. ","methodParameters":[{"parameterType":"OrderedPairIterator<Integer>","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.OrderedPairIterator, typeParametersMap=TypeParametersMap{nameToValue={plume.OrderedPairIterator.T=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","parameterTypeResolvedDescribed":"plume.OrderedPairIterator<java.lang.Integer>","parameter":"OrderedPairIterator<Integer> opi","parameterName":"opi"},{"parameterType":"int[][]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{ResolvedArrayType{PrimitiveTypeUsage{name='int'}}}","parameterTypeResolvedDescribed":"int[][]","parameter":"int[][] ints","parameterName":"ints"}],"methodName":"compareOrderedPairIterator","methodQualifiedSignature":"plume.TestPlume.compareOrderedPairIterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Throws an assertion unless the paired iterator contains the same values as the argument array.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1577,col 18)-(line 1577,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1581,col 25)-(line 1581,col 28)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1581,col 69)-(line 1581,col 69)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1582,col 25)-(line 1582,col 28)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 1582,col 69)-(line 1582,col 69)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.compareOrderedPairIterator(plume.OrderedPairIterator<java.lang.Integer>, int[][])"},{"methodDeclaration":"private static Triple<Integer, String, String> printFive(int timePerNumber, int timeLimit, boolean cache_stdout)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    String command = \"java plume.TestPlume$PrintOneIntPerTimePeriod 5 \" + timePerNumber;\n    TimeLimitProcess p;\n    try {\n        p = new TimeLimitProcess(runtime.exec(command), timeLimit, cache_stdout);\n    } catch (IOException e) {\n        throw new Error(e);\n    }\n    int result;\n    try {\n        result = p.waitFor();\n    } catch (InterruptedException e) {\n        throw new Error(e);\n    }\n    String out = UtilMDE.streamString(p.getInputStream());\n    String err = UtilMDE.streamString(p.getErrorStream());\n    return Triple.of(result, out, err);\n}","methodRange":"(line 1624,col 3)-(line 1648,col 3)","methodTokenRange":"private static Triple<Integer, String, String> printFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout) {\n    String command = \"java plume.TestPlume$PrintOneIntPerTimePeriod 5 \" + timePerNumber;\n    TimeLimitProcess p;\n    try {\n      p = new TimeLimitProcess(runtime.exec(command), timeLimit, cache_stdout);\n    } catch (IOException e) {\n      throw new Error(e);\n    }\n    int result;\n    try {\n      result = p.waitFor();\n    } catch (InterruptedException e) {\n      throw new Error(e);\n    }\n    \/\/ System.out.printf(\"command:%s%n\", command);\n    \/\/ System.out.printf(\"result:%s%n\", result);\n    \/\/ System.out.printf(\"buffered stdout:%s%n\", p.cached_stdout);\n    \/\/ System.out.printf(\"buffered stderr:%s%n\", p.cached_stderr);\n    String out = UtilMDE.streamString(p.getInputStream());\n    String err = UtilMDE.streamString(p.getErrorStream());\n    \/\/ System.out.printf(\"out:%s%n\", out);\n    \/\/ System.out.printf(\"err:%s%n\", err);\n    return Triple.of(result, out, err);\n  }","methodReturnTypeResolved":"","methodJavadocComment":" more output doesn't sneak out before the timeout kicks in.","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int timePerNumber","parameterName":"timePerNumber"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int timeLimit","parameterName":"timeLimit"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cache_stdout","parameterName":"cache_stdout"}],"methodName":"printFive","methodQualifiedSignature":"plume.TestPlume.printFive","methodJavadoc":"","methodReturnTypeDescribed":"","methodType":"Triple<Integer, String, String>","literalExprs":[{"literalExprRange":"(line 1626,col 22)-(line 1626,col 71)","literalExprId":1,"literalExpr":"\"java plume.TestPlume$PrintOneIntPerTimePeriod 5 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.printFive(int, int, boolean)"},{"methodDeclaration":"private static void checkPrintFive(int timePerNumber, int timeLimit, boolean cache_stdout, String out, String err)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    Triple<Integer, String, String> results = printFive(timePerNumber, timeLimit, cache_stdout);\n    if (!results.b.equals(out)) {\n        throw new Error(String.format(\"Expected %s, got %s\", out, results.b));\n    }\n    if (!results.c.equals(err)) {\n        throw new Error(String.format(\"Expected %s, got %s\", err, results.c));\n    }\n}","methodRange":"(line 1650,col 3)-(line 1659,col 3)","methodTokenRange":"private static void checkPrintFive(\n      int timePerNumber, int timeLimit, boolean cache_stdout, String out, String err) {\n    Triple<Integer, String, String> results = printFive(timePerNumber, timeLimit, cache_stdout);\n    if (!results.b.equals(out)) {\n      throw new Error(String.format(\"Expected %s, got %s\", out, results.b));\n    }\n    if (!results.c.equals(err)) {\n      throw new Error(String.format(\"Expected %s, got %s\", err, results.c));\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int timePerNumber","parameterName":"timePerNumber"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int timeLimit","parameterName":"timeLimit"},{"parameterType":"boolean","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean cache_stdout","parameterName":"cache_stdout"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String out","parameterName":"out"},{"parameterType":"String","parameterId":5,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String err","parameterName":"err"}],"methodName":"checkPrintFive","methodQualifiedSignature":"plume.TestPlume.checkPrintFive","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1654,col 37)-(line 1654,col 57)","literalExprId":1,"literalExpr":"\"Expected %s, got %s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1657,col 37)-(line 1657,col 57)","literalExprId":2,"literalExpr":"\"Expected %s, got %s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.checkPrintFive(int, int, boolean, java.lang.String, java.lang.String)"},{"javadocBlockTags":[],"methodDeclaration":"public void testTimeLimitProcess()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 1666,col 3)-(line 1678,col 3)","methodTokenRange":"@Test\n  public void testTimeLimitProcess() {\n    \/\/ checkPrintFive(10, 1000, false, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n    \/\/ checkPrintFive(10, 1000, true, \"out0 out1 out2 out3 out4 \", \"err0 err1 err2 err3 err4 \");\n\n    \/\/ These are too timing-dependent -- they sometimes succeed and\n    \/\/ sometimes fail -- so leave them commented out.\n    \/\/ checkPrintFive(2000, 1000, true, \"out0 \", \"err0 \");\n    \/\/ checkPrintFive(2000, 3000, true, \"out0 out1 \", \"err0 err1 \");\n\n    \/\/ This is expected to fail because of trying to read a closed stream.\n    \/\/ printFive(3, false);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * On a heavily-loaded machine, this test fails.\n   * Try again when the load is lower.\n   * (Better might be exponential backoff up to some limit.)\n   ","methodParameters":[],"methodName":"testTimeLimitProcess","methodQualifiedSignature":"plume.TestPlume.testTimeLimitProcess","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='On a heavily-loaded machine, this test fails.\nTry again when the load is lower.\n(Better might be exponential backoff up to some limit.)'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.TestPlume.testTimeLimitProcess()"},{"methodDeclaration":"private static BitSet randomBitSet(int length, Random r)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    BitSet result = new BitSet(length);\n    for (int i = 0; i < length; i++) {\n        result.set(i, r.nextBoolean());\n    }\n    return result;\n}","methodRange":"(line 1684,col 3)-(line 1690,col 3)","methodTokenRange":"private static BitSet randomBitSet(int length, Random r) {\n    BitSet result = new BitSet(length);\n    for (int i = 0; i < length; i++) {\n      result.set(i, r.nextBoolean());\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.BitSet, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int length","parameterName":"length"},{"parameterType":"Random","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.Random, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.Random","parameter":"Random r","parameterName":"r"}],"methodName":"randomBitSet","methodQualifiedSignature":"plume.TestPlume.randomBitSet","methodJavadoc":"","methodReturnTypeDescribed":"java.util.BitSet","methodType":"BitSet","literalExprs":[{"literalExprRange":"(line 1686,col 18)-(line 1686,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.randomBitSet(int, java.util.Random)"},{"methodDeclaration":"public void testStringBuilderDelimited()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    compareJoinAndSBD(new String[] { \"foo\", \"bar\", \"baz\" });\n    compareJoinAndSBD(new String[] { \"foo\" });\n    compareJoinAndSBD(new String[] {});\n}","methodRange":"(line 1692,col 3)-(line 1697,col 3)","methodTokenRange":"@Test\n  public void testStringBuilderDelimited() {\n    compareJoinAndSBD(new String[] {\"foo\", \"bar\", \"baz\"});\n    compareJoinAndSBD(new String[] {\"foo\"});\n    compareJoinAndSBD(new String[] {});\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testStringBuilderDelimited","methodQualifiedSignature":"plume.TestPlume.testStringBuilderDelimited","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1694,col 37)-(line 1694,col 41)","literalExprId":1,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1694,col 44)-(line 1694,col 48)","literalExprId":2,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1694,col 51)-(line 1694,col 55)","literalExprId":3,"literalExpr":"\"baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1695,col 37)-(line 1695,col 41)","literalExprId":4,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testStringBuilderDelimited()"},{"methodDeclaration":"public void compareJoinAndSBD(String[] strings)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    StringBuilderDelimited sbd = new StringBuilderDelimited(\",\");\n    for (String str : strings) {\n        sbd.append(str);\n    }\n    assert sbd.toString().equals(UtilMDE.join(strings, \",\"));\n}","methodRange":"(line 1699,col 3)-(line 1705,col 3)","methodTokenRange":"public void compareJoinAndSBD(String[] strings) {\n    StringBuilderDelimited sbd = new StringBuilderDelimited(\",\");\n    for (String str : strings) {\n      sbd.append(str);\n    }\n    assert sbd.toString().equals(UtilMDE.join(strings, \",\"));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] strings","parameterName":"strings"}],"methodName":"compareJoinAndSBD","methodQualifiedSignature":"plume.TestPlume.compareJoinAndSBD","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1700,col 61)-(line 1700,col 63)","literalExprId":1,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1704,col 56)-(line 1704,col 58)","literalExprId":2,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.compareJoinAndSBD(java.lang.String[])"},{"methodDeclaration":"private static void checkTypeStrings(String fqn, String bn, String cgn, String fd)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    checkTypeStrings(fqn, bn, cgn, fd, false);\n}","methodRange":"(line 1707,col 3)-(line 1713,col 3)","methodTokenRange":"private static void checkTypeStrings(\n      \/*@FullyQualifiedName*\/ String fqn,\n      \/*@BinaryName*\/ String bn,\n      \/*@ClassGetName*\/ String cgn,\n      \/*@FieldDescriptor*\/ String fd) {\n    checkTypeStrings(fqn, bn, cgn, fd, false);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fqn","parameterName":"fqn"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String bn","parameterName":"bn"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String cgn","parameterName":"cgn"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fd","parameterName":"fd"}],"methodName":"checkTypeStrings","methodQualifiedSignature":"plume.TestPlume.checkTypeStrings","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1712,col 40)-(line 1712,col 44)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.checkTypeStrings(java.lang.String, java.lang.String, java.lang.String, java.lang.String)"},{"methodDeclaration":"private static void checkTypeStrings(String fqn, String bn, String cgn, String fd, boolean skipClassForName)","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (!skipClassForName) {\n        try {\n            UtilMDE.classForName(cgn);\n        } catch (ClassNotFoundException e) {\n            throw new Error(e);\n        }\n    }\n    assert fd.equals(UtilMDE.binaryNameToFieldDescriptor(bn));\n    assert cgn.equals(UtilMDE.binaryNameToClassGetName(bn)) : bn + \" => \" + UtilMDE.binaryNameToClassGetName(bn) + \", should be \" + cgn;\n    assert cgn.equals(UtilMDE.fieldDescriptorToClassGetName(fd)) : fd + \" => \" + cgn;\n    assert bn.equals(UtilMDE.fieldDescriptorToBinaryName(fd));\n}","methodRange":"(line 1715,col 3)-(line 1733,col 3)","methodTokenRange":"private static void checkTypeStrings(\n      \/*@FullyQualifiedName*\/ String fqn,\n      \/*@BinaryName*\/ String bn,\n      \/*@ClassGetName*\/ String cgn,\n      \/*@FieldDescriptor*\/ String fd,\n      boolean skipClassForName) {\n    if (!skipClassForName) {\n      try {\n        UtilMDE.classForName(cgn); \/\/ ensure this does not crash\n      } catch (ClassNotFoundException e) {\n        throw new Error(e);\n      }\n    }\n    assert fd.equals(UtilMDE.binaryNameToFieldDescriptor(bn));\n    assert cgn.equals(UtilMDE.binaryNameToClassGetName(bn))\n        : bn + \" => \" + UtilMDE.binaryNameToClassGetName(bn) + \", should be \" + cgn;\n    assert cgn.equals(UtilMDE.fieldDescriptorToClassGetName(fd)) : fd + \" => \" + cgn;\n    assert bn.equals(UtilMDE.fieldDescriptorToBinaryName(fd));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fqn","parameterName":"fqn"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String bn","parameterName":"bn"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String cgn","parameterName":"cgn"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String fd","parameterName":"fd"},{"parameterType":"boolean","parameterId":5,"parameterTypeResolved":"PrimitiveTypeUsage{name='boolean'}","parameterTypeResolvedDescribed":"boolean","parameter":"boolean skipClassForName","parameterName":"skipClassForName"}],"methodName":"checkTypeStrings","methodQualifiedSignature":"plume.TestPlume.checkTypeStrings","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1730,col 16)-(line 1730,col 21)","literalExprId":1,"literalExpr":"\" => \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1730,col 64)-(line 1730,col 77)","literalExprId":2,"literalExpr":"\", should be \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1731,col 73)-(line 1731,col 78)","literalExprId":3,"literalExpr":"\" => \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.checkTypeStrings(java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean)"},{"methodDeclaration":"public void testUtilMDE()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    {\n        Random r = new Random(20031008);\n        for (int i = 0; i < 100; i++) {\n            BitSet b1 = randomBitSet(r.nextInt(100), r);\n            BitSet b2 = randomBitSet(r.nextInt(100), r);\n            BitSet b3 = randomBitSet(r.nextInt(100), r);\n            BitSet intersection = (BitSet) b1.clone();\n            intersection.and(b2);\n            int card = intersection.cardinality();\n            for (int j = 0; j < 100; j++) {\n                assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, j) == (card >= j);\n            }\n            intersection.and(b3);\n            card = intersection.cardinality();\n            for (int j = 0; j < 100; j++) {\n                assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, b3, j) == (card >= j);\n            }\n        }\n    }\n    assert UtilMDE.isSubtype(Integer.class, Integer.class);\n    assert UtilMDE.isSubtype(Cloneable.class, Cloneable.class);\n    assert UtilMDE.isSubtype(Object.class, Object.class);\n    assert UtilMDE.isSubtype(Integer.class, Number.class);\n    assert !UtilMDE.isSubtype(Number.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Comparable.class);\n    assert !UtilMDE.isSubtype(Comparable.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Object.class);\n    assert !UtilMDE.isSubtype(Object.class, Integer.class);\n    assert !UtilMDE.isSubtype(Integer.class, Float.class);\n    assert UtilMDE.isSubtype(Collection.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, Collection.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Cloneable.class);\n    assert !UtilMDE.isSubtype(Cloneable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, List.class);\n    assert !UtilMDE.isSubtype(List.class, ArrayList.class);\n    assert UtilMDE.binaryNameToFieldDescriptor(\"boolean\").equals(\"Z\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"byte\").equals(\"B\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"char\").equals(\"C\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"double\").equals(\"D\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"float\").equals(\"F\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int\").equals(\"I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"long\").equals(\"J\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"short\").equals(\"S\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Integer\").equals(\"LInteger;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer\").equals(\"LJava\/lang\/Integer;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer[][][]\").equals(\"[[[LJava\/lang\/Integer;\");\n    assert UtilMDE.binaryNameToClassGetName(\"boolean\").equals(\"boolean\");\n    assert UtilMDE.binaryNameToClassGetName(\"byte\").equals(\"byte\");\n    assert UtilMDE.binaryNameToClassGetName(\"char\").equals(\"char\");\n    assert UtilMDE.binaryNameToClassGetName(\"double\").equals(\"double\");\n    assert UtilMDE.binaryNameToClassGetName(\"float\").equals(\"float\");\n    assert UtilMDE.binaryNameToClassGetName(\"int\").equals(\"int\");\n    assert UtilMDE.binaryNameToClassGetName(\"long\").equals(\"long\");\n    assert UtilMDE.binaryNameToClassGetName(\"short\").equals(\"short\");\n    assert UtilMDE.binaryNameToClassGetName(\"Integer\").equals(\"Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer[][][]\").equals(\"[[[LJava.lang.Integer;\");\n    assert UtilMDE.arglistToJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistToJvm(\"(int)\").equals(\"(I)\");\n    assert UtilMDE.arglistToJvm(\"(int, int)\").equals(\"(II)\");\n    assert UtilMDE.arglistToJvm(\"(int, long, short)\").equals(\"(IJS)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer, int, java.lang.Integer)\").equals(\"(Ljava\/lang\/Integer;ILjava\/lang\/Integer;)\");\n    assert UtilMDE.arglistToJvm(\"(int[])\").equals(\"([I)\");\n    assert UtilMDE.arglistToJvm(\"(int[], int, int)\").equals(\"([III)\");\n    assert UtilMDE.arglistToJvm(\"(int, int[][], int)\").equals(\"(I[[II)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer[], int, java.lang.Integer[][])\").equals(\"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LJava\/lang\/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[I\").equals(\"int[][]\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[LJava\/lang\/Integer;\").equals(\"Java.lang.Integer[][]\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LJava\/lang\/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[I\").equals(\"[[I\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[LJava\/lang\/Integer;\").equals(\"[[LJava.lang.Integer;\");\n    assert UtilMDE.arglistFromJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistFromJvm(\"(I)\").equals(\"(int)\");\n    assert UtilMDE.arglistFromJvm(\"(II)\").equals(\"(int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(IJS)\").equals(\"(int, long, short)\");\n    assert UtilMDE.arglistFromJvm(\"(Ljava\/lang\/Integer;ILjava\/lang\/Integer;)\").equals(\"(java.lang.Integer, int, java.lang.Integer)\");\n    assert UtilMDE.arglistFromJvm(\"([I)\").equals(\"(int[])\");\n    assert UtilMDE.arglistFromJvm(\"([III)\").equals(\"(int[], int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(I[[II)\").equals(\"(int, int[][], int)\");\n    assert UtilMDE.arglistFromJvm(\"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\").equals(\"(java.lang.Integer[], int, java.lang.Integer[][])\");\n    checkTypeStrings(\"int\", \"int\", \"int\", \"I\");\n    checkTypeStrings(\"int[][]\", \"int[][]\", \"[[I\", \"[[I\");\n    checkTypeStrings(\"MyClass\", \"MyClass\", \"MyClass\", \"LMyClass;\", true);\n    checkTypeStrings(\"MyClass[]\", \"MyClass[]\", \"[LMyClass;\", \"[LMyClass;\", true);\n    checkTypeStrings(\"java.lang.Integer\", \"java.lang.Integer\", \"java.lang.Integer\", \"Ljava\/lang\/Integer;\");\n    checkTypeStrings(\"java.lang.Integer[]\", \"java.lang.Integer[]\", \"[Ljava.lang.Integer;\", \"[Ljava\/lang\/Integer;\");\n    checkTypeStrings(\"java.lang.Byte.ByteCache\", \"java.lang.Byte$ByteCache\", \"java.lang.Byte$ByteCache\", \"Ljava\/lang\/Byte$ByteCache;\");\n    checkTypeStrings(\"java.lang.Byte.ByteCache[]\", \"java.lang.Byte$ByteCache[]\", \"[Ljava.lang.Byte$ByteCache;\", \"[Ljava\/lang\/Byte$ByteCache;\");\n    try {\n        assert UtilMDE.canCreateAndWrite(new File(\"TestPlume.java\"));\n        if (!System.getProperty(\"user.name\").equals(\"root\")) {\n            File readOnly = new File(\"temp\");\n            readOnly.createNewFile();\n            readOnly.setReadOnly();\n            assert !UtilMDE.canCreateAndWrite(readOnly);\n            readOnly.delete();\n        }\n        assert UtilMDE.canCreateAndWrite(new File(\"temp\"));\n        assert !UtilMDE.canCreateAndWrite(new File(\"temp\/temp\"));\n    } catch (IOException e) {\n        e.printStackTrace();\n        org.junit.Assert.fail(\"failure while testing UtilMDE.canCreateAndWrite(): \" + e.toString());\n    }\n    {\n        Vector<Integer> iota0 = new Vector<Integer>();\n        Vector<Integer> iota10 = new Vector<Integer>();\n        for (int i = 0; i < 10; i++) {\n            iota10.add(new Integer(i));\n        }\n        Vector<Integer> iota10_twice = new Vector<Integer>();\n        iota10_twice.addAll(iota10);\n        iota10_twice.addAll(iota10);\n        Vector<Integer> iota10_thrice = new Vector<Integer>();\n        iota10_thrice.addAll(iota10);\n        iota10_thrice.addAll(iota10);\n        iota10_thrice.addAll(iota10);\n        assert iota0.equals(toVector(iota0.iterator()));\n        assert iota0.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota0.iterator())));\n        assert iota0.equals(toVector(iota0.elements()));\n        assert iota0.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota0.elements())));\n        assert iota10.equals(toVector(iota10.iterator()));\n        assert iota10.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota10.iterator())));\n        assert iota10.equals(toVector(iota10.elements()));\n        assert iota10.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota10.elements())));\n        assert iota10_twice.equals(toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota10.iterator())));\n        assert iota10.equals(toVector(new UtilMDE.MergedIterator2<Integer>(iota0.iterator(), iota10.iterator())));\n        assert iota10.equals(toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota0.iterator())));\n        Vector<Iterator<Integer>> iota10_iterator_thrice = new Vector<Iterator<Integer>>();\n        iota10_iterator_thrice.add(iota10.iterator());\n        iota10_iterator_thrice.add(iota10.iterator());\n        iota10_iterator_thrice.add(iota10.iterator());\n        assert iota10_thrice.equals(toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_thrice.iterator())));\n        Vector<Iterator<Integer>> iota10_iterator_twice_1 = new Vector<Iterator<Integer>>();\n        iota10_iterator_twice_1.add(iota0.iterator());\n        iota10_iterator_twice_1.add(iota10.iterator());\n        iota10_iterator_twice_1.add(iota10.iterator());\n        Vector<Iterator<Integer>> iota10_iterator_twice_2 = new Vector<Iterator<Integer>>();\n        iota10_iterator_twice_2.add(iota10.iterator());\n        iota10_iterator_twice_2.add(iota0.iterator());\n        iota10_iterator_twice_2.add(iota10.iterator());\n        Vector<Iterator<Integer>> iota10_iterator_twice_3 = new Vector<Iterator<Integer>>();\n        iota10_iterator_twice_3.add(iota10.iterator());\n        iota10_iterator_twice_3.add(iota10.iterator());\n        iota10_iterator_twice_3.add(iota0.iterator());\n        assert iota10_twice.equals(toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_1.iterator())));\n        assert iota10_twice.equals(toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_2.iterator())));\n        assert iota10_twice.equals(toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_3.iterator())));\n        class OddFilter implements Filter<Integer> {\n\n            public OddFilter() {\n            }\n\n            public boolean accept(Integer i) {\n                return i.intValue() % 2 != 0;\n            }\n        }\n        Vector<Integer> iota10_odd = new Vector<Integer>();\n        for (int i = 0; i < iota10.size(); i++) {\n            if (i % 2 != 0) {\n                iota10_odd.add(new Integer(i));\n            }\n        }\n        assert iota10_odd.equals(toVector(new UtilMDE.FilteredIterator<Integer>(iota10.iterator(), new OddFilter())));\n    }\n    {\n        Vector<Integer> iota5 = new Vector<Integer>();\n        for (int i = 0; i < 5; i++) {\n            iota5.add(new Integer(i));\n        }\n        Vector<Integer> iota5middle = new Vector<Integer>();\n        for (int i = 1; i < 4; i++) {\n            iota5middle.add(new Integer(i));\n        }\n        UtilMDE.RemoveFirstAndLastIterator<Integer> rfali = new UtilMDE.RemoveFirstAndLastIterator<Integer>(iota5.iterator());\n        Vector<Integer> rfali_vector = toVector(rfali);\n        assert iota5middle.equals(rfali_vector);\n        assert rfali.getFirst().equals(new Integer(0));\n        assert rfali.getLast().equals(new Integer(4));\n    }\n    class IotaIterator implements Iterator<Integer> {\n\n        int i = 0;\n\n        int limit;\n\n        public IotaIterator(int limit) {\n            this.limit = limit;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return i < limit;\n        }\n\n        @Override\n        public Integer next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return new Integer(i++);\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    {\n        Calendar nextNotification = Calendar.getInstance();\n        nextNotification.add(Calendar.MINUTE, 1);\n        DateFormat df = new SimpleDateFormat();\n        int itor_size = 10;\n        int num_elts_limit = 12;\n        int tries = short_run ? 100 : 100000;\n        double ratio_limit = .02;\n        Random r = new Random(20020311);\n        for (int i = 1; i < num_elts_limit; i += 3) {\n            int[] totals = new int[num_elts_limit];\n            for (int j = 0; j < tries; j++) {\n                if (j % 100 == 0) {\n                    Calendar now = Calendar.getInstance();\n                    if (now.after(nextNotification)) {\n                        System.out.printf(\"%s: iteration (%d,%d) out of (%d,%d)%n\", df.format(nextNotification.getTime()), i, j, num_elts_limit, tries);\n                        nextNotification.add(Calendar.MINUTE, 1);\n                    }\n                }\n                List<Integer> chosen = UtilMDE.randomElements(new IotaIterator(itor_size), i, r);\n                for (int m = 0; m < chosen.size(); m++) {\n                    for (int n = m + 1; n < chosen.size(); n++) {\n                        if (chosen.get(m).intValue() == chosen.get(n).intValue()) {\n                            throw new Error(\"Duplicate at \" + m + \",\" + n);\n                        }\n                    }\n                }\n                for (int k = 0; k < chosen.size(); k++) {\n                    totals[chosen.get(k).intValue()]++;\n                }\n            }\n            int i_truncated = Math.min(itor_size, i);\n            int grand_total = tries * i_truncated;\n            assert ArraysMDE.sum(totals) == grand_total : \"Totals = \" + ArraysMDE.sum(totals);\n            for (int k = 0; k < num_elts_limit; k++) {\n                int this_total = totals[k];\n                int expected = tries * i_truncated \/ itor_size;\n                double ratio = (double) this_total \/ (double) expected;\n                assert k >= itor_size || (ratio > ratio_limit && ratio < 1 \/ ratio_limit);\n            }\n        }\n    }\n    try {\n        assert null != UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\");\n        assert null != UtilMDE.methodForName(\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\");\n        assert null != UtilMDE.methodForName(\"java.lang.Math.min(int,int)\");\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new Error(e);\n    }\n    try {\n        java.lang.reflect.Method m = UtilMDE.methodForName(\"plume.UtilMDE.methodForName()\");\n        throw new Error(\"Didn't throw NoSuchMethodException\");\n    } catch (NoSuchMethodException e) {\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new Error(e);\n    }\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \" \", \"  \").equals(\"hello  dolly  well  hello  dolly\");\n    assert UtilMDE.replaceString(\"  hello  dolly well hello dolly  \", \" \", \"  \").equals(\"    hello    dolly  well  hello  dolly    \");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"ll\", \"y\").equals(\"heyo doyy wey heyo doyy\");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"q\", \"yyy\").equals(\"hello dolly well hello dolly\");\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", ','), new String[] { \"foo\", \"bar\", \"baz\" });\n    assert Arrays.equals(UtilMDE.split(\"foo\", ','), new String[] { \"foo\" });\n    assert Arrays.equals(UtilMDE.split(\"\", ','), new String[] { \"\" });\n    assert Arrays.equals(UtilMDE.split(\",foo,\", ','), new String[] { \"\", \"foo\", \"\" });\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", \",\"), new String[] { \"foo\", \"bar\", \"baz\" });\n    assert Arrays.equals(UtilMDE.split(\"foo\", \",\"), new String[] { \"foo\" });\n    assert Arrays.equals(UtilMDE.split(\"\", \",\"), new String[] { \"\" });\n    assert Arrays.equals(UtilMDE.split(\",foo,\", \",\"), new String[] { \"\", \"foo\", \"\" });\n    assert Arrays.equals(UtilMDE.split(\"foo, bar, baz\", \", \"), new String[] { \"foo\", \"bar\", \"baz\" });\n    assert Arrays.equals(UtilMDE.split(\"foo\", \", \"), new String[] { \"foo\" });\n    assert Arrays.equals(UtilMDE.split(\"\", \", \"), new String[] { \"\" });\n    assert Arrays.equals(UtilMDE.split(\", foo, \", \", \"), new String[] { \"\", \"foo\", \"\" });\n    assert UtilMDE.join(new String[] { \"foo\", \"bar\", \"baz\" }, \", \").equals(\"foo, bar, baz\");\n    assert UtilMDE.join(new String[] { \"foo\" }, \", \").equals(\"foo\");\n    assert UtilMDE.join(new String[] {}, \", \").equals(\"\");\n    assert UtilMDE.join(new Integer[] { new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4) }, \"\").equals(\"01234\");\n    Vector<Object> potpourri = new Vector<Object>();\n    potpourri.add(\"day\");\n    potpourri.add(new Integer(2));\n    potpourri.add(\"day\");\n    assert UtilMDE.join(potpourri, \" \").equals(\"day 2 day\");\n    assert UtilMDE.escapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.escapeNonJava(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonJava(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonJava(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonASCII(\"\").equals(\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonASCII(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\0\\1\\2\\7\\12\\70\\100\\111\\222\").equals(\"\\\\000\\\\001\\\\002\\\\007\\\\n8@I\\\\222\");\n    assert UtilMDE.escapeNonASCII(\"\\u0100\\u1000\\ucafe\\uffff\").equals(\"\\\\u0100\\\\u1000\\\\ucafe\\\\uffff\");\n    assert UtilMDE.unescapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.unescapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"\").equals(\"\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\n\").equals(\"\\n\");\n    assert UtilMDE.unescapeNonJava(\"\\\\r\").equals(\"\\r\");\n    assert UtilMDE.unescapeNonJava(\"split\\\\nlines\").equals(\"split\\nlines\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\").equals(\"\\\\\\n\");\n    assert UtilMDE.unescapeNonJava(\"\\\\n\\\\r\").equals(\"\\n\\r\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\").equals(\"\\\\\\n\\r\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\relax\").equals(\"\\\\relax\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\"\").equals(\"\\\"hello\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\").equals(\"\\\"hello\\\" \\\"world\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"foo\\\\\").equals(\"foo\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\*abc\").equals(\"*abc\");\n    assert UtilMDE.removeWhitespaceBefore(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a, b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a , b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=> cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab => cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a ,b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a , b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab =>cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab => cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123 cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123 \", \"123\").equals(\"cd 123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123\", \"123\").equals(\"cd 123\");\n    assert UtilMDE.removeWhitespaceAround(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a , b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab => cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.nplural(0, \"fuss\").equals(\"0 fusses\");\n    assert UtilMDE.nplural(1, \"fuss\").equals(\"1 fuss\");\n    assert UtilMDE.nplural(2, \"fuss\").equals(\"2 fusses\");\n    assert UtilMDE.nplural(0, \"fox\").equals(\"0 foxes\");\n    assert UtilMDE.nplural(1, \"fox\").equals(\"1 fox\");\n    assert UtilMDE.nplural(2, \"fox\").equals(\"2 foxes\");\n    assert UtilMDE.nplural(0, \"fish\").equals(\"0 fishes\");\n    assert UtilMDE.nplural(1, \"fish\").equals(\"1 fish\");\n    assert UtilMDE.nplural(2, \"fish\").equals(\"2 fishes\");\n    assert UtilMDE.nplural(0, \"fletch\").equals(\"0 fletches\");\n    assert UtilMDE.nplural(1, \"fletch\").equals(\"1 fletch\");\n    assert UtilMDE.nplural(2, \"fletch\").equals(\"2 fletches\");\n    assert UtilMDE.nplural(0, \"fund\").equals(\"0 funds\");\n    assert UtilMDE.nplural(1, \"fund\").equals(\"1 fund\");\n    assert UtilMDE.nplural(2, \"fund\").equals(\"2 funds\");\n    assert UtilMDE.nplural(0, \"f-stop\").equals(\"0 f-stops\");\n    assert UtilMDE.nplural(1, \"f-stop\").equals(\"1 f-stop\");\n    assert UtilMDE.nplural(2, \"f-stop\").equals(\"2 f-stops\");\n    assert UtilMDE.rpad(\"\", 5).equals(\"     \");\n    assert UtilMDE.rpad(\"abcd\", 5).equals(\"abcd \");\n    assert UtilMDE.rpad(\"abcde\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcdef\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcde ghij\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(10, 5).equals(\"10   \");\n    assert UtilMDE.rpad(3.14, 5).equals(\"3.14 \");\n    assert UtilMDE.count(\"abcde\", 'a') == 1;\n    assert UtilMDE.count(\"abcde\", 'c') == 1;\n    assert UtilMDE.count(\"abcde\", 'e') == 1;\n    assert UtilMDE.count(\"abcde\", 'z') == 0;\n    assert UtilMDE.count(\"abacadaea\", 'a') == 5;\n    assert UtilMDE.count(\"aaa aea\", 'a') == 5;\n    assert UtilMDE.count(\"daeaaa\", 'a') == 4;\n    List<Integer> l123 = new ArrayList<Integer>();\n    l123.add(1);\n    l123.add(2);\n    l123.add(3);\n    List<Integer> l123123 = new ArrayList<Integer>();\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    List<Integer> l12223 = new ArrayList<Integer>();\n    l12223.add(1);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(3);\n    List<Integer> l1123 = new ArrayList<Integer>();\n    l1123.add(1);\n    l1123.add(1);\n    l1123.add(2);\n    l1123.add(3);\n    List<Integer> l1233 = new ArrayList<Integer>();\n    l1233.add(1);\n    l1233.add(1);\n    l1233.add(2);\n    l1233.add(3);\n    assert UtilMDE.removeDuplicates(l123).equals(l123);\n    assert UtilMDE.removeDuplicates(l123123).equals(l123);\n    assert UtilMDE.removeDuplicates(l12223).equals(l123);\n    assert UtilMDE.removeDuplicates(l1123).equals(l123);\n    assert UtilMDE.removeDuplicates(l1233).equals(l123);\n    boolean[] zatft1 = new boolean[] { true, false, true };\n    boolean[] zatft2 = new boolean[] { true, false, true };\n    boolean[] zatff = new boolean[] { true, false, false };\n    assert !zatft1.equals(zatft2);\n    assert UtilMDE.deepEquals(zatft1, zatft2);\n    assert !zatft1.equals(zatff);\n    assert !UtilMDE.deepEquals(zatft1, zatff);\n    List<Object> l1 = new ArrayList<Object>();\n    List<Object> l2 = new ArrayList<Object>();\n    List<Object> l3 = new ArrayList<Object>();\n    l1.add(l1);\n    l2.add(l2);\n    l3.add(l3);\n    l1.add(zatft1);\n    l2.add(zatft2);\n    l3.add(zatff);\n    assert UtilMDE.deepEquals(l1, l2);\n    assert !UtilMDE.deepEquals(l1, l3);\n    assert !UtilMDE.deepEquals(l2, l3);\n    Locale.setDefault(Locale.US);\n    assert UtilMDE.abbreviateNumber(5).equals(\"5.00\");\n    assert UtilMDE.abbreviateNumber(5000).equals(\"5.00K\");\n    assert UtilMDE.abbreviateNumber(5000000).equals(\"5.00M\");\n    assert UtilMDE.abbreviateNumber(1000000000).equals(\"1.00G\");\n    assert UtilMDE.abbreviateNumber(1).equals(\"1.00\");\n    assert UtilMDE.abbreviateNumber(12).equals(\"12.0\");\n    assert UtilMDE.abbreviateNumber(123).equals(\"123\");\n    assert UtilMDE.abbreviateNumber(1234).equals(\"1.23K\");\n    assert UtilMDE.abbreviateNumber(12345).equals(\"12.3K\");\n    assert UtilMDE.abbreviateNumber(123456).equals(\"123K\");\n    assert UtilMDE.abbreviateNumber(1234567).equals(\"1.23M\");\n    assert UtilMDE.abbreviateNumber(12345678).equals(\"12.3M\");\n    assert UtilMDE.abbreviateNumber(123456789).equals(\"123M\");\n    assert UtilMDE.abbreviateNumber(1234567890).equals(\"1.23G\");\n    assert UtilMDE.abbreviateNumber(9).equals(\"9.00\");\n    assert UtilMDE.abbreviateNumber(98).equals(\"98.0\");\n    assert UtilMDE.abbreviateNumber(987).equals(\"987\");\n    assert UtilMDE.abbreviateNumber(9876).equals(\"9.88K\");\n    assert UtilMDE.abbreviateNumber(98765).equals(\"98.8K\");\n    assert UtilMDE.abbreviateNumber(987654).equals(\"988K\");\n    assert UtilMDE.abbreviateNumber(9876543).equals(\"9.88M\");\n    assert UtilMDE.abbreviateNumber(98765432).equals(\"98.8M\");\n    assert UtilMDE.abbreviateNumber(987654321).equals(\"988M\");\n    assert UtilMDE.abbreviateNumber(9876543210L).equals(\"9.88G\");\n}","methodRange":"(line 1736,col 3)-(line 2448,col 3)","methodTokenRange":"@Test\n  public void testUtilMDE() {\n\n    \/\/ public static intersectionCardinalityAtLeast(BitSet a, BitSet b, int i)\n    {\n      Random r = new Random(20031008);\n      for (int i = 0; i < 100; i++) {\n        BitSet b1 = randomBitSet(r.nextInt(100), r);\n        BitSet b2 = randomBitSet(r.nextInt(100), r);\n        BitSet b3 = randomBitSet(r.nextInt(100), r);\n        BitSet intersection = (BitSet) b1.clone();\n        intersection.and(b2);\n        int card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, j) == (card >= j);\n        }\n        intersection.and(b3);\n        card = intersection.cardinality();\n        for (int j = 0; j < 100; j++) {\n          assert UtilMDE.intersectionCardinalityAtLeast(b1, b2, b3, j) == (card >= j);\n        }\n      }\n    }\n\n    \/\/ public static BufferedReader bufferedFileReader(String filename)\n    \/\/ public static LineNumberReader lineNumberFileReader(String filename)\n    \/\/ public static BufferedWriter bufferedFileWriter(String filename) throws IOException\n    \/\/ public static Class classForName(String className)\n\n    \/\/ private boolean isSubtype(Class<?> sub, Class<?> sup) {\n    assert UtilMDE.isSubtype(Integer.class, Integer.class);\n    assert UtilMDE.isSubtype(Cloneable.class, Cloneable.class);\n    assert UtilMDE.isSubtype(Object.class, Object.class);\n    assert UtilMDE.isSubtype(Integer.class, Number.class);\n    assert !UtilMDE.isSubtype(Number.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Comparable.class);\n    assert !UtilMDE.isSubtype(Comparable.class, Integer.class);\n    assert UtilMDE.isSubtype(Integer.class, Object.class);\n    assert !UtilMDE.isSubtype(Object.class, Integer.class);\n    assert !UtilMDE.isSubtype(Integer.class, Float.class);\n    assert UtilMDE.isSubtype(Collection.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, Collection.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Iterable.class);\n    assert !UtilMDE.isSubtype(Iterable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, Cloneable.class);\n    assert !UtilMDE.isSubtype(Cloneable.class, ArrayList.class);\n    assert UtilMDE.isSubtype(ArrayList.class, List.class);\n    assert !UtilMDE.isSubtype(List.class, ArrayList.class);\n\n    \/\/ public static String binaryNameToFieldDescriptor(String classname)\n    assert UtilMDE.binaryNameToFieldDescriptor(\"boolean\").equals(\"Z\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"byte\").equals(\"B\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"char\").equals(\"C\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"double\").equals(\"D\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"float\").equals(\"F\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int\").equals(\"I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"long\").equals(\"J\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"short\").equals(\"S\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Integer\").equals(\"LInteger;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer\").equals(\"LJava\/lang\/Integer;\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToFieldDescriptor(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava\/lang\/Integer;\");\n\n    \/\/ public static \/*@ClassGetName*\/ String binaryNameToClassGetName(\/*BinaryName*\/ String bn)\n    assert UtilMDE.binaryNameToClassGetName(\"boolean\").equals(\"boolean\");\n    assert UtilMDE.binaryNameToClassGetName(\"byte\").equals(\"byte\");\n    assert UtilMDE.binaryNameToClassGetName(\"char\").equals(\"char\");\n    assert UtilMDE.binaryNameToClassGetName(\"double\").equals(\"double\");\n    assert UtilMDE.binaryNameToClassGetName(\"float\").equals(\"float\");\n    assert UtilMDE.binaryNameToClassGetName(\"int\").equals(\"int\");\n    assert UtilMDE.binaryNameToClassGetName(\"long\").equals(\"long\");\n    assert UtilMDE.binaryNameToClassGetName(\"short\").equals(\"short\");\n    assert UtilMDE.binaryNameToClassGetName(\"Integer\").equals(\"Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.binaryNameToClassGetName(\"int[][]\").equals(\"[[I\");\n    assert UtilMDE.binaryNameToClassGetName(\"Java.lang.Integer[][][]\")\n        .equals(\"[[[LJava.lang.Integer;\");\n\n    \/\/ public static String arglistToJvm(String arglist)\n    assert UtilMDE.arglistToJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistToJvm(\"(int)\").equals(\"(I)\");\n    assert UtilMDE.arglistToJvm(\"(int, int)\").equals(\"(II)\");\n    assert UtilMDE.arglistToJvm(\"(int, long, short)\").equals(\"(IJS)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer, int, java.lang.Integer)\")\n        .equals(\"(Ljava\/lang\/Integer;ILjava\/lang\/Integer;)\");\n    assert UtilMDE.arglistToJvm(\"(int[])\").equals(\"([I)\");\n    assert UtilMDE.arglistToJvm(\"(int[], int, int)\").equals(\"([III)\");\n    assert UtilMDE.arglistToJvm(\"(int, int[][], int)\").equals(\"(I[[II)\");\n    assert UtilMDE.arglistToJvm(\"(java.lang.Integer[], int, java.lang.Integer[][])\")\n        .equals(\"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\");\n\n    \/\/ public static String fieldDescriptorToBinaryName(String classname)\n    assert UtilMDE.fieldDescriptorToBinaryName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"LJava\/lang\/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[I\").equals(\"int[][]\");\n    assert UtilMDE.fieldDescriptorToBinaryName(\"[[LJava\/lang\/Integer;\")\n        .equals(\"Java.lang.Integer[][]\");\n\n    \/\/ public static \/*@ClassGetName*\/ String fieldDescriptorToClassGetName(\/*FieldDescriptor*\/ String fd)\n    assert UtilMDE.fieldDescriptorToClassGetName(\"Z\").equals(\"boolean\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"B\").equals(\"byte\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"C\").equals(\"char\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"D\").equals(\"double\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"F\").equals(\"float\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"I\").equals(\"int\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"J\").equals(\"long\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"S\").equals(\"short\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LInteger;\").equals(\"Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"LJava\/lang\/Integer;\").equals(\"Java.lang.Integer\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[I\").equals(\"[[I\");\n    assert UtilMDE.fieldDescriptorToClassGetName(\"[[LJava\/lang\/Integer;\")\n        .equals(\"[[LJava.lang.Integer;\");\n\n    \/\/ public static String arglistFromJvm(String arglist)\n    assert UtilMDE.arglistFromJvm(\"()\").equals(\"()\");\n    assert UtilMDE.arglistFromJvm(\"(I)\").equals(\"(int)\");\n    assert UtilMDE.arglistFromJvm(\"(II)\").equals(\"(int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(IJS)\").equals(\"(int, long, short)\");\n    assert UtilMDE.arglistFromJvm(\"(Ljava\/lang\/Integer;ILjava\/lang\/Integer;)\")\n        .equals(\"(java.lang.Integer, int, java.lang.Integer)\");\n    assert UtilMDE.arglistFromJvm(\"([I)\").equals(\"(int[])\");\n    assert UtilMDE.arglistFromJvm(\"([III)\").equals(\"(int[], int, int)\");\n    assert UtilMDE.arglistFromJvm(\"(I[[II)\").equals(\"(int, int[][], int)\");\n    assert UtilMDE.arglistFromJvm(\"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\")\n        .equals(\"(java.lang.Integer[], int, java.lang.Integer[][])\");\n\n    \/\/ More tests for type representation conversions.\n    \/\/ Table from Signature Checker manual.\n    checkTypeStrings(\"int\", \"int\", \"int\", \"I\");\n    checkTypeStrings(\"int[][]\", \"int[][]\", \"[[I\", \"[[I\");\n    checkTypeStrings(\"MyClass\", \"MyClass\", \"MyClass\", \"LMyClass;\", true);\n    checkTypeStrings(\"MyClass[]\", \"MyClass[]\", \"[LMyClass;\", \"[LMyClass;\", true);\n    checkTypeStrings(\n        \"java.lang.Integer\", \"java.lang.Integer\", \"java.lang.Integer\", \"Ljava\/lang\/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Integer[]\",\n        \"java.lang.Integer[]\",\n        \"[Ljava.lang.Integer;\",\n        \"[Ljava\/lang\/Integer;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"java.lang.Byte$ByteCache\",\n        \"Ljava\/lang\/Byte$ByteCache;\");\n    checkTypeStrings(\n        \"java.lang.Byte.ByteCache[]\",\n        \"java.lang.Byte$ByteCache[]\",\n        \"[Ljava.lang.Byte$ByteCache;\",\n        \"[Ljava\/lang\/Byte$ByteCache;\");\n\n    \/\/ public static void addToClasspath(String dir)\n    \/\/ public static final class WildcardFilter implements FilenameFilter\n    \/\/   public WildcardFilter(String filename)\n    \/\/   public boolean accept(File dir, String name)\n    \/\/ public static boolean canCreateAndWrite(File file)\n    \/\/ public static void writeObject(Object o, File file) throws IOException\n    \/\/ public static Object readObject(File file)\n    \/\/ public static File createTempDir(String prefix, String suffix)\n\n    \/\/ public Object incrementHashMap(HashMap hm, Object key, int count)\n\n    try {\n      assert UtilMDE.canCreateAndWrite(new File(\"TestPlume.java\"));\n\n      \/\/ This test fails if run by the superuser (who can overwrite\n      \/\/ any file).\n      if (!System.getProperty(\"user.name\").equals(\"root\")) {\n        File readOnly = new File(\"temp\");\n        readOnly.createNewFile();\n        readOnly.setReadOnly();\n        assert !UtilMDE.canCreateAndWrite(readOnly);\n        readOnly.delete();\n      }\n\n      assert UtilMDE.canCreateAndWrite(new File(\"temp\"));\n      assert !UtilMDE.canCreateAndWrite(new File(\"temp\/temp\"));\n    } catch (IOException e) {\n      e.printStackTrace();\n      org.junit.Assert.fail(\"failure while testing UtilMDE.canCreateAndWrite(): \" + e.toString());\n    }\n\n    {\n      \/\/ These names are taken from APL notation, where iota creates an\n      \/\/ array of all the numbers up to its argument.\n      Vector<Integer> iota0 = new Vector<Integer>();\n      Vector<Integer> iota10 = new Vector<Integer>();\n      for (int i = 0; i < 10; i++) {\n        iota10.add(new Integer(i));\n      }\n      Vector<Integer> iota10_twice = new Vector<Integer>();\n      iota10_twice.addAll(iota10);\n      iota10_twice.addAll(iota10);\n      Vector<Integer> iota10_thrice = new Vector<Integer>();\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n      iota10_thrice.addAll(iota10);\n\n      \/\/ public static class EnumerationIterator implements Iterator\n      \/\/ public static class IteratorEnumeration implements Enumeration\n\n      assert iota0.equals(toVector(iota0.iterator()));\n      assert iota0.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota0.iterator())));\n      assert iota0.equals(toVector(iota0.elements()));\n      assert iota0.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota0.elements())));\n      assert iota10.equals(toVector(iota10.iterator()));\n      assert iota10.equals(toVector(new UtilMDE.IteratorEnumeration<Integer>(iota10.iterator())));\n      assert iota10.equals(toVector(iota10.elements()));\n      assert iota10.equals(toVector(new UtilMDE.EnumerationIterator<Integer>(iota10.elements())));\n\n      \/\/ public static class MergedIterator2 implements Iterator {\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota0.iterator(), iota10.iterator())));\n      assert iota10.equals(\n          toVector(new UtilMDE.MergedIterator2<Integer>(iota10.iterator(), iota0.iterator())));\n\n      \/\/ public static class MergedIterator implements Iterator {\n      Vector<Iterator<Integer>> iota10_iterator_thrice = new Vector<Iterator<Integer>>();\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      iota10_iterator_thrice.add(iota10.iterator());\n      assert iota10_thrice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_thrice.iterator())));\n      Vector<Iterator<Integer>> iota10_iterator_twice_1 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_1.add(iota0.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      iota10_iterator_twice_1.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_2 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_2.add(iota10.iterator());\n      iota10_iterator_twice_2.add(iota0.iterator());\n      iota10_iterator_twice_2.add(iota10.iterator());\n      Vector<Iterator<Integer>> iota10_iterator_twice_3 = new Vector<Iterator<Integer>>();\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota10.iterator());\n      iota10_iterator_twice_3.add(iota0.iterator());\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_1.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_2.iterator())));\n      assert iota10_twice.equals(\n          toVector(new UtilMDE.MergedIterator<Integer>(iota10_iterator_twice_3.iterator())));\n\n      class OddFilter implements Filter<Integer> {\n        public OddFilter() {}\n\n        public boolean accept(Integer i) {\n          return i.intValue() % 2 != 0;\n        }\n      }\n\n      \/\/ public static final class FilteredIterator implements Iterator\n\n      Vector<Integer> iota10_odd = new Vector<Integer>();\n      for (int i = 0; i < iota10.size(); i++) {\n        if (i % 2 != 0) {\n          iota10_odd.add(new Integer(i));\n        }\n      }\n      assert iota10_odd.equals(\n          toVector(new UtilMDE.FilteredIterator<Integer>(iota10.iterator(), new OddFilter())));\n    }\n\n    \/\/ public static final class RemoveFirstAndLastIterator implements Iterator\n    {\n      Vector<Integer> iota5 = new Vector<Integer>();\n      for (int i = 0; i < 5; i++) {\n        iota5.add(new Integer(i));\n      }\n      Vector<Integer> iota5middle = new Vector<Integer>();\n      for (int i = 1; i < 4; i++) {\n        iota5middle.add(new Integer(i));\n      }\n      UtilMDE.RemoveFirstAndLastIterator<Integer> rfali =\n          new UtilMDE.RemoveFirstAndLastIterator<Integer>(iota5.iterator());\n      Vector<Integer> rfali_vector = toVector(rfali);\n      assert iota5middle.equals(rfali_vector);\n      assert rfali.getFirst().equals(new Integer(0));\n      assert rfali.getLast().equals(new Integer(4));\n    }\n\n    \/\/ public static ArrayList randomElements(Iterator itor, int num_elts)\n    \/\/ public static ArrayList randomElements(Iterator itor, int num_elts, Random random)\n\n    \/\/ Iterate through numbers from zero up to the argument (non-inclusive)\n    class IotaIterator implements Iterator<Integer> {\n      int i = 0;\n      int limit;\n\n      public IotaIterator(int limit) {\n        this.limit = limit;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return i < limit;\n      }\n\n      @Override\n      public Integer next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        return new Integer(i++);\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    }\n    {\n      \/\/ Typically, no progress reports are printed, because the loop\n      \/\/ finishes in well under 1 minute.  Users will see progress reports\n      \/\/ when this class is slowed down by instrumentation.\n      Calendar nextNotification = Calendar.getInstance();\n      nextNotification.add(Calendar.MINUTE, 1);\n      DateFormat df = new SimpleDateFormat();\n\n      int itor_size = 10;\n      int num_elts_limit = 12;\n      int tries = short_run ? 100 : 100000;\n      double ratio_limit = .02;\n      Random r = new Random(20020311);\n      \/\/ \"i++\" instead of \"i+=3\" here works, but is slow\n      for (int i = 1; i < num_elts_limit; i += 3) {\n        int[] totals = new int[num_elts_limit];\n        for (int j = 0; j < tries; j++) {\n          if (j % 100 == 0) {\n            Calendar now = Calendar.getInstance();\n            if (now.after(nextNotification)) {\n              System.out.printf(\n                  \"%s: iteration (%d,%d) out of (%d,%d)%n\",\n                  df.format(nextNotification.getTime()),\n                  i,\n                  j,\n                  num_elts_limit,\n                  tries);\n              nextNotification.add(Calendar.MINUTE, 1);\n            }\n          }\n          List<Integer> chosen = UtilMDE.randomElements(new IotaIterator(itor_size), i, r);\n          for (int m = 0; m < chosen.size(); m++) {\n            for (int n = m + 1; n < chosen.size(); n++) {\n              if (chosen.get(m).intValue() == chosen.get(n).intValue()) {\n                throw new Error(\"Duplicate at \" + m + \",\" + n);\n              }\n            }\n          }\n          for (int k = 0; k < chosen.size(); k++) {\n            totals[chosen.get(k).intValue()]++;\n          }\n        }\n        int i_truncated = Math.min(itor_size, i);\n        int grand_total = tries * i_truncated;\n        assert ArraysMDE.sum(totals) == grand_total : \"Totals = \" + ArraysMDE.sum(totals);\n        \/\/ System.out.print(\"chosen:\\t\");\n        for (int k = 0; k < num_elts_limit; k++) {\n          int this_total = totals[k];\n          int expected = tries * i_truncated \/ itor_size;\n          double ratio = (double) this_total \/ (double) expected;\n          \/\/ System.out.print(((k<10) ? \" \" : \"\") + k + \" \" + this_total + \"\\t\");\n          \/\/ System.out.print(\"\\nExp=\" + expected + \"\\tratio=\" + ratio + \"\\t\");\n          assert k >= itor_size || (ratio > ratio_limit && ratio < 1 \/ ratio_limit);\n        }\n        \/\/ System.out.println();\n      }\n    }\n\n    \/\/ public static <T> \/*@Nullable*\/ Integer incrementMap(Map<T,Integer> m, T key, int count) {\n    \/\/ public static <K,V> String mapToString(Map<K,V> m) {\n    \/\/ public static <K,V> void mapToString(Appendable sb, Map<K,V> m, String linePrefix) {\n    \/\/ public static <K extends Comparable<? super K>,V> Collection<\/*@KeyFor(\"#1\")*\/ K> sortedKeySet(Map<K,V> m) {\n    \/\/ public static <K,V> Collection<\/*@KeyFor(\"#1\")*\/ K> sortedKeySet(Map<K,V> m, Comparator<K> comparator) {\n\n    \/\/ public static Method methodForName(String methodname) throws ClassNotFoundException\n    \/\/\n    \/\/ essentially I am just testing whether the return is erroneous\n    try {\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\");\n      assert null\n          != UtilMDE.methodForName(\n              \"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\");\n      assert null != UtilMDE.methodForName(\"java.lang.Math.min(int,int)\");\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n    try {\n      java.lang.reflect.Method m = UtilMDE.methodForName(\"plume.UtilMDE.methodForName()\");\n      throw new Error(\"Didn't throw NoSuchMethodException\");\n    } catch (NoSuchMethodException e) {\n      \/\/ nothing to do; this is the expected case\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new Error(e);\n    }\n\n    \/\/ public static boolean propertyIsTrue(Properties p, String key)\n    \/\/ public static String appendProperty(Properties p, String key, String value)\n    \/\/ public static String setDefault(Properties p, String key, String value)\n    \/\/ public static void streamCopy(java.io.InputStream from, java.io.OutputStream to)\n\n    \/\/ public static String replaceString(String target, String oldStr, String newStr)\n\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \" \", \"  \")\n        .equals(\"hello  dolly  well  hello  dolly\");\n    assert UtilMDE.replaceString(\"  hello  dolly well hello dolly  \", \" \", \"  \")\n        .equals(\"    hello    dolly  well  hello  dolly    \");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"ll\", \"y\")\n        .equals(\"heyo doyy wey heyo doyy\");\n    assert UtilMDE.replaceString(\"hello dolly well hello dolly\", \"q\", \"yyy\")\n        .equals(\"hello dolly well hello dolly\");\n\n    \/\/ public static String[] split(String s, char delim)\n    \/\/ public static String[] split(String s, String delim)\n\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", ','), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", ','), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", ','), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", ','), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo,bar,baz\", \",\"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \",\"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \",\"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\",foo,\", \",\"), new String[] {\"\", \"foo\", \"\"});\n    assert Arrays.equals(UtilMDE.split(\"foo, bar, baz\", \", \"), new String[] {\"foo\", \"bar\", \"baz\"});\n    assert Arrays.equals(UtilMDE.split(\"foo\", \", \"), new String[] {\"foo\"});\n    assert Arrays.equals(UtilMDE.split(\"\", \", \"), new String[] {\"\"});\n    assert Arrays.equals(UtilMDE.split(\", foo, \", \", \"), new String[] {\"\", \"foo\", \"\"});\n\n    \/\/ public static String join(Object[] a, String delim)\n    \/\/ public static String join(Vector v, String delim)\n\n    assert UtilMDE.join(new String[] {\"foo\", \"bar\", \"baz\"}, \", \").equals(\"foo, bar, baz\");\n    assert UtilMDE.join(new String[] {\"foo\"}, \", \").equals(\"foo\");\n    assert UtilMDE.join(new String[] {}, \", \").equals(\"\");\n    assert UtilMDE.join(\n            new Integer[] {\n              new Integer(0), new Integer(1), new Integer(2), new Integer(3), new Integer(4)\n            },\n            \"\")\n        .equals(\"01234\");\n    Vector<Object> potpourri = new Vector<Object>();\n    potpourri.add(\"day\");\n    potpourri.add(new Integer(2));\n    potpourri.add(\"day\");\n    assert UtilMDE.join(potpourri, \" \").equals(\"day 2 day\");\n\n    \/\/ public static String escapeNonJava(String orig)\n    \/\/ public static String escapeNonJava(Character ch)\n\n    assert UtilMDE.escapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.escapeNonJava(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonJava(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonJava(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonJava(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n\n    \/\/ public static String escapeNonASCII(String orig)\n\n    assert UtilMDE.escapeNonASCII(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.escapeNonASCII(\"\").equals(\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\").equals(\"\\\\\\\\\");\n    assert UtilMDE.escapeNonASCII(\"\\\\\\n\\r\\\"\").equals(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"split\\nlines\").equals(\"split\\\\nlines\");\n    assert UtilMDE.escapeNonASCII(\"\\\\relax\").equals(\"\\\\\\\\relax\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\"\").equals(\"\\\\\\\"hello\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\\"hello\\\" \\\"world\\\"\").equals(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\");\n    assert UtilMDE.escapeNonASCII(\"\\0\\1\\2\\7\\12\\70\\100\\111\\222\")\n        .equals(\"\\\\000\\\\001\\\\002\\\\007\\\\n8@I\\\\222\");\n    assert UtilMDE.escapeNonASCII(\"\\u0100\\u1000\\ucafe\\uffff\")\n        .equals(\"\\\\u0100\\\\u1000\\\\ucafe\\\\uffff\");\n\n    \/\/ private static String escapeNonASCII(char c)\n\n    \/\/ public static String unescapeNonJava(String orig)\n\n    assert UtilMDE.unescapeNonJava(\"foobar\").equals(\"foobar\");\n    assert UtilMDE.unescapeNonJava(\"\").equals(\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"\").equals(\"\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\n\").equals(\"\\n\"); \/\/ not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\r\").equals(\"\\r\");\n    assert UtilMDE.unescapeNonJava(\"split\\\\nlines\").equals(\"split\\nlines\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\").equals(\"\\\\\\n\"); \/\/ not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\n\\\\r\").equals(\"\\n\\r\"); \/\/ not lineSep\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\\\\\n\\\\r\\\\\\\"\").equals(\"\\\\\\n\\r\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\\relax\").equals(\"\\\\relax\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\"\").equals(\"\\\"hello\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\").equals(\"\\\"hello\\\" \\\"world\\\"\");\n    assert UtilMDE.unescapeNonJava(\"\\\\\").equals(\"\\\\\");\n    assert UtilMDE.unescapeNonJava(\"foo\\\\\").equals(\"foo\\\\\");\n    assert UtilMDE.unescapeNonJava(\"\\\\*abc\").equals(\"*abc\");\n    \/\/ Should add more tests here.\n\n    \/\/ Unfortunately, there isn't yet a unescapeNonASCII function.\n    \/\/ If implemented, it should have the following behavior:\n    \/\/ assert UtilMDE.unescapeNonASCII(\"\\\\115\").equals(\"M\");\n    \/\/ assert UtilMDE.unescapeNonASCII(\"\\\\115\\\\111\\\\124\").equals(\"MIT\");\n\n    \/\/ public static String removeWhitespaceAround(String arg, String delimiter)\n    \/\/ public static String removeWhitespaceAfter(String arg, String delimiter)\n    \/\/ public static String removeWhitespaceBefore(String arg, String delimiter)\n\n    assert UtilMDE.removeWhitespaceBefore(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a, b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceBefore(\"a , b\", \",\").equals(\"a, b\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab=> cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"ab => cd\", \"=>\").equals(\"ab=> cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"123 cd\", \"123\").equals(\"123 cd\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd123 \", \"123\").equals(\"cd123 \");\n    assert UtilMDE.removeWhitespaceBefore(\"cd 123\", \"123\").equals(\"cd123\");\n\n    assert UtilMDE.removeWhitespaceAfter(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a ,b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"a , b\", \",\").equals(\"a ,b\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab =>cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"ab => cd\", \"=>\").equals(\"ab =>cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123 cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\" 123cd\", \"123\").equals(\" 123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123 \", \"123\").equals(\"cd 123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAfter(\"cd 123\", \"123\").equals(\"cd 123\");\n\n    assert UtilMDE.removeWhitespaceAround(\"a,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a, b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a ,b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"a , b\", \",\").equals(\"a,b\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab=> cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab =>cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"ab => cd\", \"=>\").equals(\"ab=>cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\" 123cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"123 cd\", \"123\").equals(\"123cd\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123\", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd123 \", \"123\").equals(\"cd123\");\n    assert UtilMDE.removeWhitespaceAround(\"cd 123\", \"123\").equals(\"cd123\");\n\n    \/\/ public static String nplural(int n, String noun)\n\n    assert UtilMDE.nplural(0, \"fuss\").equals(\"0 fusses\");\n    assert UtilMDE.nplural(1, \"fuss\").equals(\"1 fuss\");\n    assert UtilMDE.nplural(2, \"fuss\").equals(\"2 fusses\");\n    assert UtilMDE.nplural(0, \"fox\").equals(\"0 foxes\");\n    assert UtilMDE.nplural(1, \"fox\").equals(\"1 fox\");\n    assert UtilMDE.nplural(2, \"fox\").equals(\"2 foxes\");\n    assert UtilMDE.nplural(0, \"fish\").equals(\"0 fishes\");\n    assert UtilMDE.nplural(1, \"fish\").equals(\"1 fish\");\n    assert UtilMDE.nplural(2, \"fish\").equals(\"2 fishes\");\n    assert UtilMDE.nplural(0, \"fletch\").equals(\"0 fletches\");\n    assert UtilMDE.nplural(1, \"fletch\").equals(\"1 fletch\");\n    assert UtilMDE.nplural(2, \"fletch\").equals(\"2 fletches\");\n    assert UtilMDE.nplural(0, \"fund\").equals(\"0 funds\");\n    assert UtilMDE.nplural(1, \"fund\").equals(\"1 fund\");\n    assert UtilMDE.nplural(2, \"fund\").equals(\"2 funds\");\n    assert UtilMDE.nplural(0, \"f-stop\").equals(\"0 f-stops\");\n    assert UtilMDE.nplural(1, \"f-stop\").equals(\"1 f-stop\");\n    assert UtilMDE.nplural(2, \"f-stop\").equals(\"2 f-stops\");\n\n    \/\/ public static String rpad(String s, int length)\n    \/\/ public static String rpad(int num, int length)\n    \/\/ public static String rpad(double num, int length)\n\n    assert UtilMDE.rpad(\"\", 5).equals(\"     \");\n    assert UtilMDE.rpad(\"abcd\", 5).equals(\"abcd \");\n    assert UtilMDE.rpad(\"abcde\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcdef\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(\"abcde ghij\", 5).equals(\"abcde\");\n    assert UtilMDE.rpad(10, 5).equals(\"10   \");\n    assert UtilMDE.rpad(3.14, 5).equals(\"3.14 \");\n\n    \/\/ public static class NullableStringComparator\n    \/\/   public int compare(Object o1, Object o2)\n\n    \/\/ public static int count(String s, int ch)\n    \/\/ public static int count(String s, String sub)\n\n    assert UtilMDE.count(\"abcde\", 'a') == 1;\n    assert UtilMDE.count(\"abcde\", 'c') == 1;\n    assert UtilMDE.count(\"abcde\", 'e') == 1;\n    assert UtilMDE.count(\"abcde\", 'z') == 0;\n    assert UtilMDE.count(\"abacadaea\", 'a') == 5;\n    assert UtilMDE.count(\"aaa aea\", 'a') == 5;\n    assert UtilMDE.count(\"daeaaa\", 'a') == 4;\n\n    \/\/ This will be easy to write tests for, when I get around to it.\n    \/\/ public static Vector tokens(String str, String delim, boolean returnTokens)\n    \/\/ public static Vector tokens(String str, String delim)\n    \/\/ public static Vector tokens(String str)\n\n    \/\/ public static List sortList (List l, Comparator c)\n    \/\/ public static <T> List<T> removeDuplicates(List<T> l) {\n\n    List<Integer> l123 = new ArrayList<Integer>();\n    l123.add(1);\n    l123.add(2);\n    l123.add(3);\n    List<Integer> l123123 = new ArrayList<Integer>();\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    l123123.add(1);\n    l123123.add(2);\n    l123123.add(3);\n    List<Integer> l12223 = new ArrayList<Integer>();\n    l12223.add(1);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(2);\n    l12223.add(3);\n    List<Integer> l1123 = new ArrayList<Integer>();\n    l1123.add(1);\n    l1123.add(1);\n    l1123.add(2);\n    l1123.add(3);\n    List<Integer> l1233 = new ArrayList<Integer>();\n    l1233.add(1);\n    l1233.add(1);\n    l1233.add(2);\n    l1233.add(3);\n\n    assert UtilMDE.removeDuplicates(l123).equals(l123);\n    assert UtilMDE.removeDuplicates(l123123).equals(l123);\n    assert UtilMDE.removeDuplicates(l12223).equals(l123);\n    assert UtilMDE.removeDuplicates(l1123).equals(l123);\n    assert UtilMDE.removeDuplicates(l1233).equals(l123);\n\n    \/\/ public boolean deepEquals(Object o1, Object o2)\n\n    boolean[] zatft1 = new boolean[] {true, false, true};\n    boolean[] zatft2 = new boolean[] {true, false, true};\n    boolean[] zatff = new boolean[] {true, false, false};\n    assert !zatft1.equals(zatft2);\n    assert UtilMDE.deepEquals(zatft1, zatft2);\n    assert !zatft1.equals(zatff);\n    assert !UtilMDE.deepEquals(zatft1, zatff);\n\n    List<Object> l1 = new ArrayList<Object>();\n    List<Object> l2 = new ArrayList<Object>();\n    List<Object> l3 = new ArrayList<Object>();\n    l1.add(l1);\n    l2.add(l2);\n    l3.add(l3);\n    l1.add(zatft1);\n    l2.add(zatft2);\n    l3.add(zatff);\n    \/\/ Don't test .equals because it suffers infinite recursion.\n    \/\/ assert ! l1.equals(l2);\n    \/\/ assert ! l1.equals(l3);\n    \/\/ assert ! l2.equals(l3);\n    assert UtilMDE.deepEquals(l1, l2);\n    assert !UtilMDE.deepEquals(l1, l3);\n    assert !UtilMDE.deepEquals(l2, l3);\n\n    \/\/ This is tested by the tokens methods.\n    \/\/ public static Vector makeVector(Enumeration e)\n\n    Locale.setDefault(Locale.US);\n    assert UtilMDE.abbreviateNumber(5).equals(\"5.00\");\n    assert UtilMDE.abbreviateNumber(5000).equals(\"5.00K\");\n    assert UtilMDE.abbreviateNumber(5000000).equals(\"5.00M\");\n    assert UtilMDE.abbreviateNumber(1000000000).equals(\"1.00G\");\n    assert UtilMDE.abbreviateNumber(1).equals(\"1.00\");\n    assert UtilMDE.abbreviateNumber(12).equals(\"12.0\");\n    assert UtilMDE.abbreviateNumber(123).equals(\"123\");\n    assert UtilMDE.abbreviateNumber(1234).equals(\"1.23K\");\n    assert UtilMDE.abbreviateNumber(12345).equals(\"12.3K\");\n    assert UtilMDE.abbreviateNumber(123456).equals(\"123K\");\n    assert UtilMDE.abbreviateNumber(1234567).equals(\"1.23M\");\n    assert UtilMDE.abbreviateNumber(12345678).equals(\"12.3M\");\n    assert UtilMDE.abbreviateNumber(123456789).equals(\"123M\");\n    assert UtilMDE.abbreviateNumber(1234567890).equals(\"1.23G\");\n    assert UtilMDE.abbreviateNumber(9).equals(\"9.00\");\n    assert UtilMDE.abbreviateNumber(98).equals(\"98.0\");\n    assert UtilMDE.abbreviateNumber(987).equals(\"987\");\n    assert UtilMDE.abbreviateNumber(9876).equals(\"9.88K\");\n    assert UtilMDE.abbreviateNumber(98765).equals(\"98.8K\");\n    assert UtilMDE.abbreviateNumber(987654).equals(\"988K\");\n    assert UtilMDE.abbreviateNumber(9876543).equals(\"9.88M\");\n    assert UtilMDE.abbreviateNumber(98765432).equals(\"98.8M\");\n    assert UtilMDE.abbreviateNumber(987654321).equals(\"988M\");\n    assert UtilMDE.abbreviateNumber(9876543210L).equals(\"9.88G\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" This cannot be static because it instantiates an inner class.","methodParameters":[],"methodName":"testUtilMDE","methodQualifiedSignature":"plume.TestPlume.testUtilMDE","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 1741,col 29)-(line 1741,col 36)","literalExprId":1,"literalExpr":"20031008","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1742,col 20)-(line 1742,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1742,col 27)-(line 1742,col 29)","literalExprId":3,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1743,col 44)-(line 1743,col 46)","literalExprId":4,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1744,col 44)-(line 1744,col 46)","literalExprId":5,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1745,col 44)-(line 1745,col 46)","literalExprId":6,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1749,col 22)-(line 1749,col 22)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1749,col 29)-(line 1749,col 31)","literalExprId":8,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1754,col 22)-(line 1754,col 22)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1754,col 29)-(line 1754,col 31)","literalExprId":10,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1786,col 48)-(line 1786,col 56)","literalExprId":11,"literalExpr":"\"boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1786,col 66)-(line 1786,col 68)","literalExprId":12,"literalExpr":"\"Z\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1787,col 48)-(line 1787,col 53)","literalExprId":13,"literalExpr":"\"byte\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1787,col 63)-(line 1787,col 65)","literalExprId":14,"literalExpr":"\"B\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1788,col 48)-(line 1788,col 53)","literalExprId":15,"literalExpr":"\"char\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1788,col 63)-(line 1788,col 65)","literalExprId":16,"literalExpr":"\"C\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1789,col 48)-(line 1789,col 55)","literalExprId":17,"literalExpr":"\"double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1789,col 65)-(line 1789,col 67)","literalExprId":18,"literalExpr":"\"D\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1790,col 48)-(line 1790,col 54)","literalExprId":19,"literalExpr":"\"float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1790,col 64)-(line 1790,col 66)","literalExprId":20,"literalExpr":"\"F\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1791,col 48)-(line 1791,col 52)","literalExprId":21,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1791,col 62)-(line 1791,col 64)","literalExprId":22,"literalExpr":"\"I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1792,col 48)-(line 1792,col 53)","literalExprId":23,"literalExpr":"\"long\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1792,col 63)-(line 1792,col 65)","literalExprId":24,"literalExpr":"\"J\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1793,col 48)-(line 1793,col 54)","literalExprId":25,"literalExpr":"\"short\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1793,col 64)-(line 1793,col 66)","literalExprId":26,"literalExpr":"\"S\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1794,col 48)-(line 1794,col 56)","literalExprId":27,"literalExpr":"\"Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1794,col 66)-(line 1794,col 76)","literalExprId":28,"literalExpr":"\"LInteger;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1795,col 48)-(line 1795,col 66)","literalExprId":29,"literalExpr":"\"Java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1795,col 76)-(line 1795,col 96)","literalExprId":30,"literalExpr":"\"LJava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1796,col 48)-(line 1796,col 56)","literalExprId":31,"literalExpr":"\"int[][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1796,col 66)-(line 1796,col 70)","literalExprId":32,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1797,col 48)-(line 1797,col 72)","literalExprId":33,"literalExpr":"\"Java.lang.Integer[][][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1798,col 17)-(line 1798,col 40)","literalExprId":34,"literalExpr":"\"[[[LJava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1801,col 45)-(line 1801,col 53)","literalExprId":35,"literalExpr":"\"boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1801,col 63)-(line 1801,col 71)","literalExprId":36,"literalExpr":"\"boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1802,col 45)-(line 1802,col 50)","literalExprId":37,"literalExpr":"\"byte\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1802,col 60)-(line 1802,col 65)","literalExprId":38,"literalExpr":"\"byte\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1803,col 45)-(line 1803,col 50)","literalExprId":39,"literalExpr":"\"char\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1803,col 60)-(line 1803,col 65)","literalExprId":40,"literalExpr":"\"char\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1804,col 45)-(line 1804,col 52)","literalExprId":41,"literalExpr":"\"double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1804,col 62)-(line 1804,col 69)","literalExprId":42,"literalExpr":"\"double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1805,col 45)-(line 1805,col 51)","literalExprId":43,"literalExpr":"\"float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1805,col 61)-(line 1805,col 67)","literalExprId":44,"literalExpr":"\"float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1806,col 45)-(line 1806,col 49)","literalExprId":45,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1806,col 59)-(line 1806,col 63)","literalExprId":46,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1807,col 45)-(line 1807,col 50)","literalExprId":47,"literalExpr":"\"long\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1807,col 60)-(line 1807,col 65)","literalExprId":48,"literalExpr":"\"long\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1808,col 45)-(line 1808,col 51)","literalExprId":49,"literalExpr":"\"short\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1808,col 61)-(line 1808,col 67)","literalExprId":50,"literalExpr":"\"short\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1809,col 45)-(line 1809,col 53)","literalExprId":51,"literalExpr":"\"Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1809,col 63)-(line 1809,col 71)","literalExprId":52,"literalExpr":"\"Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1810,col 45)-(line 1810,col 63)","literalExprId":53,"literalExpr":"\"Java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1810,col 73)-(line 1810,col 91)","literalExprId":54,"literalExpr":"\"Java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1811,col 45)-(line 1811,col 53)","literalExprId":55,"literalExpr":"\"int[][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1811,col 63)-(line 1811,col 67)","literalExprId":56,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1812,col 45)-(line 1812,col 69)","literalExprId":57,"literalExpr":"\"Java.lang.Integer[][][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1813,col 17)-(line 1813,col 40)","literalExprId":58,"literalExpr":"\"[[[LJava.lang.Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1816,col 33)-(line 1816,col 36)","literalExprId":59,"literalExpr":"\"()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1816,col 46)-(line 1816,col 49)","literalExprId":60,"literalExpr":"\"()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1817,col 33)-(line 1817,col 39)","literalExprId":61,"literalExpr":"\"(int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1817,col 49)-(line 1817,col 53)","literalExprId":62,"literalExpr":"\"(I)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1818,col 33)-(line 1818,col 44)","literalExprId":63,"literalExpr":"\"(int, int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1818,col 54)-(line 1818,col 59)","literalExprId":64,"literalExpr":"\"(II)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1819,col 33)-(line 1819,col 52)","literalExprId":65,"literalExpr":"\"(int, long, short)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1819,col 62)-(line 1819,col 68)","literalExprId":66,"literalExpr":"\"(IJS)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1820,col 33)-(line 1820,col 77)","literalExprId":67,"literalExpr":"\"(java.lang.Integer, int, java.lang.Integer)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1821,col 17)-(line 1821,col 59)","literalExprId":68,"literalExpr":"\"(Ljava\/lang\/Integer;ILjava\/lang\/Integer;)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1822,col 33)-(line 1822,col 41)","literalExprId":69,"literalExpr":"\"(int[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1822,col 51)-(line 1822,col 56)","literalExprId":70,"literalExpr":"\"([I)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1823,col 33)-(line 1823,col 51)","literalExprId":71,"literalExpr":"\"(int[], int, int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1823,col 61)-(line 1823,col 68)","literalExprId":72,"literalExpr":"\"([III)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1824,col 33)-(line 1824,col 53)","literalExprId":73,"literalExpr":"\"(int, int[][], int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1824,col 63)-(line 1824,col 71)","literalExprId":74,"literalExpr":"\"(I[[II)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1825,col 33)-(line 1825,col 83)","literalExprId":75,"literalExpr":"\"(java.lang.Integer[], int, java.lang.Integer[][])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1826,col 17)-(line 1826,col 62)","literalExprId":76,"literalExpr":"\"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1829,col 48)-(line 1829,col 50)","literalExprId":77,"literalExpr":"\"Z\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1829,col 60)-(line 1829,col 68)","literalExprId":78,"literalExpr":"\"boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1830,col 48)-(line 1830,col 50)","literalExprId":79,"literalExpr":"\"B\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1830,col 60)-(line 1830,col 65)","literalExprId":80,"literalExpr":"\"byte\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1831,col 48)-(line 1831,col 50)","literalExprId":81,"literalExpr":"\"C\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1831,col 60)-(line 1831,col 65)","literalExprId":82,"literalExpr":"\"char\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1832,col 48)-(line 1832,col 50)","literalExprId":83,"literalExpr":"\"D\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1832,col 60)-(line 1832,col 67)","literalExprId":84,"literalExpr":"\"double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1833,col 48)-(line 1833,col 50)","literalExprId":85,"literalExpr":"\"F\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1833,col 60)-(line 1833,col 66)","literalExprId":86,"literalExpr":"\"float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1834,col 48)-(line 1834,col 50)","literalExprId":87,"literalExpr":"\"I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1834,col 60)-(line 1834,col 64)","literalExprId":88,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1835,col 48)-(line 1835,col 50)","literalExprId":89,"literalExpr":"\"J\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1835,col 60)-(line 1835,col 65)","literalExprId":90,"literalExpr":"\"long\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1836,col 48)-(line 1836,col 50)","literalExprId":91,"literalExpr":"\"S\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1836,col 60)-(line 1836,col 66)","literalExprId":92,"literalExpr":"\"short\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1837,col 48)-(line 1837,col 58)","literalExprId":93,"literalExpr":"\"LInteger;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1837,col 68)-(line 1837,col 76)","literalExprId":94,"literalExpr":"\"Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1838,col 48)-(line 1838,col 68)","literalExprId":95,"literalExpr":"\"LJava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1838,col 78)-(line 1838,col 96)","literalExprId":96,"literalExpr":"\"Java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1839,col 48)-(line 1839,col 52)","literalExprId":97,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1839,col 62)-(line 1839,col 70)","literalExprId":98,"literalExpr":"\"int[][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1840,col 48)-(line 1840,col 70)","literalExprId":99,"literalExpr":"\"[[LJava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1841,col 17)-(line 1841,col 39)","literalExprId":100,"literalExpr":"\"Java.lang.Integer[][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1844,col 50)-(line 1844,col 52)","literalExprId":101,"literalExpr":"\"Z\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1844,col 62)-(line 1844,col 70)","literalExprId":102,"literalExpr":"\"boolean\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1845,col 50)-(line 1845,col 52)","literalExprId":103,"literalExpr":"\"B\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1845,col 62)-(line 1845,col 67)","literalExprId":104,"literalExpr":"\"byte\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1846,col 50)-(line 1846,col 52)","literalExprId":105,"literalExpr":"\"C\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1846,col 62)-(line 1846,col 67)","literalExprId":106,"literalExpr":"\"char\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1847,col 50)-(line 1847,col 52)","literalExprId":107,"literalExpr":"\"D\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1847,col 62)-(line 1847,col 69)","literalExprId":108,"literalExpr":"\"double\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1848,col 50)-(line 1848,col 52)","literalExprId":109,"literalExpr":"\"F\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1848,col 62)-(line 1848,col 68)","literalExprId":110,"literalExpr":"\"float\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1849,col 50)-(line 1849,col 52)","literalExprId":111,"literalExpr":"\"I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1849,col 62)-(line 1849,col 66)","literalExprId":112,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1850,col 50)-(line 1850,col 52)","literalExprId":113,"literalExpr":"\"J\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1850,col 62)-(line 1850,col 67)","literalExprId":114,"literalExpr":"\"long\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1851,col 50)-(line 1851,col 52)","literalExprId":115,"literalExpr":"\"S\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1851,col 62)-(line 1851,col 68)","literalExprId":116,"literalExpr":"\"short\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1852,col 50)-(line 1852,col 60)","literalExprId":117,"literalExpr":"\"LInteger;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1852,col 70)-(line 1852,col 78)","literalExprId":118,"literalExpr":"\"Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1853,col 50)-(line 1853,col 70)","literalExprId":119,"literalExpr":"\"LJava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1853,col 80)-(line 1853,col 98)","literalExprId":120,"literalExpr":"\"Java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1854,col 50)-(line 1854,col 54)","literalExprId":121,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1854,col 64)-(line 1854,col 68)","literalExprId":122,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1855,col 50)-(line 1855,col 72)","literalExprId":123,"literalExpr":"\"[[LJava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1856,col 17)-(line 1856,col 39)","literalExprId":124,"literalExpr":"\"[[LJava.lang.Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1859,col 35)-(line 1859,col 38)","literalExprId":125,"literalExpr":"\"()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1859,col 48)-(line 1859,col 51)","literalExprId":126,"literalExpr":"\"()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1860,col 35)-(line 1860,col 39)","literalExprId":127,"literalExpr":"\"(I)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1860,col 49)-(line 1860,col 55)","literalExprId":128,"literalExpr":"\"(int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1861,col 35)-(line 1861,col 40)","literalExprId":129,"literalExpr":"\"(II)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1861,col 50)-(line 1861,col 61)","literalExprId":130,"literalExpr":"\"(int, int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1862,col 35)-(line 1862,col 41)","literalExprId":131,"literalExpr":"\"(IJS)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1862,col 51)-(line 1862,col 70)","literalExprId":132,"literalExpr":"\"(int, long, short)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1863,col 35)-(line 1863,col 77)","literalExprId":133,"literalExpr":"\"(Ljava\/lang\/Integer;ILjava\/lang\/Integer;)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1864,col 17)-(line 1864,col 61)","literalExprId":134,"literalExpr":"\"(java.lang.Integer, int, java.lang.Integer)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1865,col 35)-(line 1865,col 40)","literalExprId":135,"literalExpr":"\"([I)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1865,col 50)-(line 1865,col 58)","literalExprId":136,"literalExpr":"\"(int[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1866,col 35)-(line 1866,col 42)","literalExprId":137,"literalExpr":"\"([III)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1866,col 52)-(line 1866,col 70)","literalExprId":138,"literalExpr":"\"(int[], int, int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1867,col 35)-(line 1867,col 43)","literalExprId":139,"literalExpr":"\"(I[[II)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1867,col 53)-(line 1867,col 73)","literalExprId":140,"literalExpr":"\"(int, int[][], int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1868,col 35)-(line 1868,col 80)","literalExprId":141,"literalExpr":"\"([Ljava\/lang\/Integer;I[[Ljava\/lang\/Integer;)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1869,col 17)-(line 1869,col 67)","literalExprId":142,"literalExpr":"\"(java.lang.Integer[], int, java.lang.Integer[][])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1873,col 22)-(line 1873,col 26)","literalExprId":143,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1873,col 29)-(line 1873,col 33)","literalExprId":144,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1873,col 36)-(line 1873,col 40)","literalExprId":145,"literalExpr":"\"int\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1873,col 43)-(line 1873,col 45)","literalExprId":146,"literalExpr":"\"I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1874,col 22)-(line 1874,col 30)","literalExprId":147,"literalExpr":"\"int[][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1874,col 33)-(line 1874,col 41)","literalExprId":148,"literalExpr":"\"int[][]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1874,col 44)-(line 1874,col 48)","literalExprId":149,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1874,col 51)-(line 1874,col 55)","literalExprId":150,"literalExpr":"\"[[I\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1875,col 22)-(line 1875,col 30)","literalExprId":151,"literalExpr":"\"MyClass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1875,col 33)-(line 1875,col 41)","literalExprId":152,"literalExpr":"\"MyClass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1875,col 44)-(line 1875,col 52)","literalExprId":153,"literalExpr":"\"MyClass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1875,col 55)-(line 1875,col 65)","literalExprId":154,"literalExpr":"\"LMyClass;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1875,col 68)-(line 1875,col 71)","literalExprId":155,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1876,col 22)-(line 1876,col 32)","literalExprId":156,"literalExpr":"\"MyClass[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1876,col 35)-(line 1876,col 45)","literalExprId":157,"literalExpr":"\"MyClass[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1876,col 48)-(line 1876,col 59)","literalExprId":158,"literalExpr":"\"[LMyClass;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1876,col 62)-(line 1876,col 73)","literalExprId":159,"literalExpr":"\"[LMyClass;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1876,col 76)-(line 1876,col 79)","literalExprId":160,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 1878,col 9)-(line 1878,col 27)","literalExprId":161,"literalExpr":"\"java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1878,col 30)-(line 1878,col 48)","literalExprId":162,"literalExpr":"\"java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1878,col 51)-(line 1878,col 69)","literalExprId":163,"literalExpr":"\"java.lang.Integer\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1878,col 72)-(line 1878,col 92)","literalExprId":164,"literalExpr":"\"Ljava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1880,col 9)-(line 1880,col 29)","literalExprId":165,"literalExpr":"\"java.lang.Integer[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1881,col 9)-(line 1881,col 29)","literalExprId":166,"literalExpr":"\"java.lang.Integer[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1882,col 9)-(line 1882,col 30)","literalExprId":167,"literalExpr":"\"[Ljava.lang.Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1883,col 9)-(line 1883,col 30)","literalExprId":168,"literalExpr":"\"[Ljava\/lang\/Integer;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1885,col 9)-(line 1885,col 34)","literalExprId":169,"literalExpr":"\"java.lang.Byte.ByteCache\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1886,col 9)-(line 1886,col 34)","literalExprId":170,"literalExpr":"\"java.lang.Byte$ByteCache\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1887,col 9)-(line 1887,col 34)","literalExprId":171,"literalExpr":"\"java.lang.Byte$ByteCache\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1888,col 9)-(line 1888,col 36)","literalExprId":172,"literalExpr":"\"Ljava\/lang\/Byte$ByteCache;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1890,col 9)-(line 1890,col 36)","literalExprId":173,"literalExpr":"\"java.lang.Byte.ByteCache[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1891,col 9)-(line 1891,col 36)","literalExprId":174,"literalExpr":"\"java.lang.Byte$ByteCache[]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1892,col 9)-(line 1892,col 37)","literalExprId":175,"literalExpr":"\"[Ljava.lang.Byte$ByteCache;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1893,col 9)-(line 1893,col 37)","literalExprId":176,"literalExpr":"\"[Ljava\/lang\/Byte$ByteCache;\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1907,col 49)-(line 1907,col 64)","literalExprId":177,"literalExpr":"\"TestPlume.java\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1911,col 31)-(line 1911,col 41)","literalExprId":178,"literalExpr":"\"user.name\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1911,col 51)-(line 1911,col 56)","literalExprId":179,"literalExpr":"\"root\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1912,col 34)-(line 1912,col 39)","literalExprId":180,"literalExpr":"\"temp\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1919,col 49)-(line 1919,col 54)","literalExprId":181,"literalExpr":"\"temp\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1920,col 50)-(line 1920,col 60)","literalExprId":182,"literalExpr":"\"temp\/temp\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1923,col 29)-(line 1923,col 81)","literalExprId":183,"literalExpr":"\"failure while testing UtilMDE.canCreateAndWrite(): \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 1931,col 20)-(line 1931,col 20)","literalExprId":184,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1931,col 27)-(line 1931,col 28)","literalExprId":185,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1992,col 33)-(line 1992,col 33)","literalExprId":186,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1992,col 38)-(line 1992,col 38)","literalExprId":187,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 1999,col 20)-(line 1999,col 20)","literalExprId":188,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2000,col 17)-(line 2000,col 17)","literalExprId":189,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2000,col 22)-(line 2000,col 22)","literalExprId":190,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2011,col 20)-(line 2011,col 20)","literalExprId":191,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2011,col 27)-(line 2011,col 27)","literalExprId":192,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2015,col 20)-(line 2015,col 20)","literalExprId":193,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2015,col 27)-(line 2015,col 27)","literalExprId":194,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2022,col 50)-(line 2022,col 50)","literalExprId":195,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2023,col 49)-(line 2023,col 49)","literalExprId":196,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2031,col 15)-(line 2031,col 15)","literalExprId":197,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2061,col 45)-(line 2061,col 45)","literalExprId":198,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2064,col 23)-(line 2064,col 24)","literalExprId":199,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2065,col 28)-(line 2065,col 29)","literalExprId":200,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2066,col 31)-(line 2066,col 33)","literalExprId":201,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2066,col 37)-(line 2066,col 42)","literalExprId":202,"literalExpr":"100000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2067,col 28)-(line 2067,col 30)","literalExprId":203,"literalExpr":".02","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2068,col 29)-(line 2068,col 36)","literalExprId":204,"literalExpr":"20020311","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2070,col 20)-(line 2070,col 20)","literalExprId":205,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2070,col 48)-(line 2070,col 48)","literalExprId":206,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2072,col 22)-(line 2072,col 22)","literalExprId":207,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2073,col 19)-(line 2073,col 21)","literalExprId":208,"literalExpr":"100","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2073,col 26)-(line 2073,col 26)","literalExprId":209,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2077,col 19)-(line 2077,col 58)","literalExprId":210,"literalExpr":"\"%s: iteration (%d,%d) out of (%d,%d)%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2083,col 53)-(line 2083,col 53)","literalExprId":211,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2087,col 24)-(line 2087,col 24)","literalExprId":212,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2088,col 30)-(line 2088,col 30)","literalExprId":213,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2090,col 33)-(line 2090,col 47)","literalExprId":214,"literalExpr":"\"Duplicate at \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2090,col 55)-(line 2090,col 57)","literalExprId":215,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2094,col 24)-(line 2094,col 24)","literalExprId":216,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2100,col 55)-(line 2100,col 65)","literalExprId":217,"literalExpr":"\"Totals = \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2102,col 22)-(line 2102,col 22)","literalExprId":218,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2108,col 68)-(line 2108,col 68)","literalExprId":219,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2124,col 14)-(line 2124,col 17)","literalExprId":220,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2126,col 15)-(line 2126,col 98)","literalExprId":221,"literalExpr":"\"plume.UtilMDE.methodForName(java.lang.String, java.lang.String, java.lang.Class[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2127,col 14)-(line 2127,col 17)","literalExprId":222,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2129,col 15)-(line 2129,col 96)","literalExprId":223,"literalExpr":"\"plume.UtilMDE.methodForName(java.lang.String,java.lang.String,java.lang.Class[])\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2130,col 14)-(line 2130,col 17)","literalExprId":224,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2130,col 44)-(line 2130,col 72)","literalExprId":225,"literalExpr":"\"java.lang.Math.min(int,int)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2136,col 58)-(line 2136,col 88)","literalExprId":226,"literalExpr":"\"plume.UtilMDE.methodForName()\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2137,col 23)-(line 2137,col 58)","literalExprId":227,"literalExpr":"\"Didn't throw NoSuchMethodException\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2152,col 34)-(line 2152,col 63)","literalExprId":228,"literalExpr":"\"hello dolly well hello dolly\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2152,col 66)-(line 2152,col 68)","literalExprId":229,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2152,col 71)-(line 2152,col 74)","literalExprId":230,"literalExpr":"\"  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2153,col 17)-(line 2153,col 50)","literalExprId":231,"literalExpr":"\"hello  dolly  well  hello  dolly\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2154,col 34)-(line 2154,col 68)","literalExprId":232,"literalExpr":"\"  hello  dolly well hello dolly  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2154,col 71)-(line 2154,col 73)","literalExprId":233,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2154,col 76)-(line 2154,col 79)","literalExprId":234,"literalExpr":"\"  \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2155,col 17)-(line 2155,col 60)","literalExprId":235,"literalExpr":"\"    hello    dolly  well  hello  dolly    \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2156,col 34)-(line 2156,col 63)","literalExprId":236,"literalExpr":"\"hello dolly well hello dolly\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2156,col 66)-(line 2156,col 69)","literalExprId":237,"literalExpr":"\"ll\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2156,col 72)-(line 2156,col 74)","literalExprId":238,"literalExpr":"\"y\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2157,col 17)-(line 2157,col 41)","literalExprId":239,"literalExpr":"\"heyo doyy wey heyo doyy\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2158,col 34)-(line 2158,col 63)","literalExprId":240,"literalExpr":"\"hello dolly well hello dolly\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2158,col 66)-(line 2158,col 68)","literalExprId":241,"literalExpr":"\"q\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2158,col 71)-(line 2158,col 75)","literalExprId":242,"literalExpr":"\"yyy\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2159,col 17)-(line 2159,col 46)","literalExprId":243,"literalExpr":"\"hello dolly well hello dolly\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2164,col 40)-(line 2164,col 52)","literalExprId":244,"literalExpr":"\"foo,bar,baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2164,col 55)-(line 2164,col 57)","literalExprId":245,"literalExpr":"','","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2164,col 75)-(line 2164,col 79)","literalExprId":246,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2164,col 82)-(line 2164,col 86)","literalExprId":247,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2164,col 89)-(line 2164,col 93)","literalExprId":248,"literalExpr":"\"baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2165,col 40)-(line 2165,col 44)","literalExprId":249,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2165,col 47)-(line 2165,col 49)","literalExprId":250,"literalExpr":"','","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2165,col 67)-(line 2165,col 71)","literalExprId":251,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2166,col 40)-(line 2166,col 41)","literalExprId":252,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2166,col 44)-(line 2166,col 46)","literalExprId":253,"literalExpr":"','","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2166,col 64)-(line 2166,col 65)","literalExprId":254,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2167,col 40)-(line 2167,col 46)","literalExprId":255,"literalExpr":"\",foo,\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2167,col 49)-(line 2167,col 51)","literalExprId":256,"literalExpr":"','","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2167,col 69)-(line 2167,col 70)","literalExprId":257,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2167,col 73)-(line 2167,col 77)","literalExprId":258,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2167,col 80)-(line 2167,col 81)","literalExprId":259,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2168,col 40)-(line 2168,col 52)","literalExprId":260,"literalExpr":"\"foo,bar,baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2168,col 55)-(line 2168,col 57)","literalExprId":261,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2168,col 75)-(line 2168,col 79)","literalExprId":262,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2168,col 82)-(line 2168,col 86)","literalExprId":263,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2168,col 89)-(line 2168,col 93)","literalExprId":264,"literalExpr":"\"baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2169,col 40)-(line 2169,col 44)","literalExprId":265,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2169,col 47)-(line 2169,col 49)","literalExprId":266,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2169,col 67)-(line 2169,col 71)","literalExprId":267,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2170,col 40)-(line 2170,col 41)","literalExprId":268,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2170,col 44)-(line 2170,col 46)","literalExprId":269,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2170,col 64)-(line 2170,col 65)","literalExprId":270,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2171,col 40)-(line 2171,col 46)","literalExprId":271,"literalExpr":"\",foo,\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2171,col 49)-(line 2171,col 51)","literalExprId":272,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2171,col 69)-(line 2171,col 70)","literalExprId":273,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2171,col 73)-(line 2171,col 77)","literalExprId":274,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2171,col 80)-(line 2171,col 81)","literalExprId":275,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2172,col 40)-(line 2172,col 54)","literalExprId":276,"literalExpr":"\"foo, bar, baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2172,col 57)-(line 2172,col 60)","literalExprId":277,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2172,col 78)-(line 2172,col 82)","literalExprId":278,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2172,col 85)-(line 2172,col 89)","literalExprId":279,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2172,col 92)-(line 2172,col 96)","literalExprId":280,"literalExpr":"\"baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2173,col 40)-(line 2173,col 44)","literalExprId":281,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2173,col 47)-(line 2173,col 50)","literalExprId":282,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2173,col 68)-(line 2173,col 72)","literalExprId":283,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2174,col 40)-(line 2174,col 41)","literalExprId":284,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2174,col 44)-(line 2174,col 47)","literalExprId":285,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2174,col 65)-(line 2174,col 66)","literalExprId":286,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2175,col 40)-(line 2175,col 48)","literalExprId":287,"literalExpr":"\", foo, \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2175,col 51)-(line 2175,col 54)","literalExprId":288,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2175,col 72)-(line 2175,col 73)","literalExprId":289,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2175,col 76)-(line 2175,col 80)","literalExprId":290,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2175,col 83)-(line 2175,col 84)","literalExprId":291,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2180,col 39)-(line 2180,col 43)","literalExprId":292,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2180,col 46)-(line 2180,col 50)","literalExprId":293,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2180,col 53)-(line 2180,col 57)","literalExprId":294,"literalExpr":"\"baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2180,col 61)-(line 2180,col 64)","literalExprId":295,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2180,col 74)-(line 2180,col 88)","literalExprId":296,"literalExpr":"\"foo, bar, baz\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2181,col 39)-(line 2181,col 43)","literalExprId":297,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2181,col 47)-(line 2181,col 50)","literalExprId":298,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2181,col 60)-(line 2181,col 64)","literalExprId":299,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2182,col 42)-(line 2182,col 45)","literalExprId":300,"literalExpr":"\", \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2182,col 55)-(line 2182,col 56)","literalExprId":301,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2185,col 27)-(line 2185,col 27)","literalExprId":302,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2185,col 43)-(line 2185,col 43)","literalExprId":303,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2185,col 59)-(line 2185,col 59)","literalExprId":304,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2185,col 75)-(line 2185,col 75)","literalExprId":305,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2185,col 91)-(line 2185,col 91)","literalExprId":306,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2187,col 13)-(line 2187,col 14)","literalExprId":307,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2188,col 17)-(line 2188,col 23)","literalExprId":308,"literalExpr":"\"01234\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2190,col 19)-(line 2190,col 23)","literalExprId":309,"literalExpr":"\"day\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2191,col 31)-(line 2191,col 31)","literalExprId":310,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2192,col 19)-(line 2192,col 23)","literalExprId":311,"literalExpr":"\"day\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2193,col 36)-(line 2193,col 38)","literalExprId":312,"literalExpr":"\" \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2193,col 48)-(line 2193,col 58)","literalExprId":313,"literalExpr":"\"day 2 day\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2198,col 34)-(line 2198,col 41)","literalExprId":314,"literalExpr":"\"foobar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2198,col 51)-(line 2198,col 58)","literalExprId":315,"literalExpr":"\"foobar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2199,col 34)-(line 2199,col 35)","literalExprId":316,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2199,col 45)-(line 2199,col 46)","literalExprId":317,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2200,col 34)-(line 2200,col 37)","literalExprId":318,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2200,col 47)-(line 2200,col 52)","literalExprId":319,"literalExpr":"\"\\\\\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2201,col 34)-(line 2201,col 43)","literalExprId":320,"literalExpr":"\"\\\\\\n\\r\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2201,col 53)-(line 2201,col 68)","literalExprId":321,"literalExpr":"\"\\\\\\\\\\\\n\\\\r\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2202,col 34)-(line 2202,col 47)","literalExprId":322,"literalExpr":"\"split\\nlines\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2202,col 57)-(line 2202,col 71)","literalExprId":323,"literalExpr":"\"split\\\\nlines\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2203,col 34)-(line 2203,col 42)","literalExprId":324,"literalExpr":"\"\\\\relax\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2203,col 52)-(line 2203,col 62)","literalExprId":325,"literalExpr":"\"\\\\\\\\relax\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2204,col 34)-(line 2204,col 44)","literalExprId":326,"literalExpr":"\"\\\"hello\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2204,col 54)-(line 2204,col 68)","literalExprId":327,"literalExpr":"\"\\\\\\\"hello\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2205,col 34)-(line 2205,col 54)","literalExprId":328,"literalExpr":"\"\\\"hello\\\" \\\"world\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2205,col 64)-(line 2205,col 92)","literalExprId":329,"literalExpr":"\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2209,col 35)-(line 2209,col 42)","literalExprId":330,"literalExpr":"\"foobar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2209,col 52)-(line 2209,col 59)","literalExprId":331,"literalExpr":"\"foobar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2210,col 35)-(line 2210,col 36)","literalExprId":332,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2210,col 46)-(line 2210,col 47)","literalExprId":333,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2211,col 35)-(line 2211,col 38)","literalExprId":334,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2211,col 48)-(line 2211,col 53)","literalExprId":335,"literalExpr":"\"\\\\\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2212,col 35)-(line 2212,col 44)","literalExprId":336,"literalExpr":"\"\\\\\\n\\r\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2212,col 54)-(line 2212,col 69)","literalExprId":337,"literalExpr":"\"\\\\\\\\\\\\n\\\\r\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2213,col 35)-(line 2213,col 48)","literalExprId":338,"literalExpr":"\"split\\nlines\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2213,col 58)-(line 2213,col 72)","literalExprId":339,"literalExpr":"\"split\\\\nlines\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2214,col 35)-(line 2214,col 43)","literalExprId":340,"literalExpr":"\"\\\\relax\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2214,col 53)-(line 2214,col 63)","literalExprId":341,"literalExpr":"\"\\\\\\\\relax\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2215,col 35)-(line 2215,col 45)","literalExprId":342,"literalExpr":"\"\\\"hello\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2215,col 55)-(line 2215,col 69)","literalExprId":343,"literalExpr":"\"\\\\\\\"hello\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2216,col 35)-(line 2216,col 55)","literalExprId":344,"literalExpr":"\"\\\"hello\\\" \\\"world\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2216,col 65)-(line 2216,col 93)","literalExprId":345,"literalExpr":"\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2217,col 35)-(line 2217,col 62)","literalExprId":346,"literalExpr":"\"\\0\\1\\2\\7\\12\\70\\100\\111\\222\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2218,col 17)-(line 2218,col 49)","literalExprId":347,"literalExpr":"\"\\\\000\\\\001\\\\002\\\\007\\\\n8@I\\\\222\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2219,col 35)-(line 2219,col 60)","literalExprId":348,"literalExpr":"\"\\u0100\\u1000\\ucafe\\uffff\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2220,col 17)-(line 2220,col 46)","literalExprId":349,"literalExpr":"\"\\\\u0100\\\\u1000\\\\ucafe\\\\uffff\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2226,col 36)-(line 2226,col 43)","literalExprId":350,"literalExpr":"\"foobar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2226,col 53)-(line 2226,col 60)","literalExprId":351,"literalExpr":"\"foobar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2227,col 36)-(line 2227,col 37)","literalExprId":352,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2227,col 47)-(line 2227,col 48)","literalExprId":353,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2228,col 36)-(line 2228,col 41)","literalExprId":354,"literalExpr":"\"\\\\\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2228,col 51)-(line 2228,col 54)","literalExprId":355,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2229,col 36)-(line 2229,col 41)","literalExprId":356,"literalExpr":"\"\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2229,col 51)-(line 2229,col 54)","literalExprId":357,"literalExpr":"\"\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2230,col 36)-(line 2230,col 40)","literalExprId":358,"literalExpr":"\"\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2230,col 50)-(line 2230,col 53)","literalExprId":359,"literalExpr":"\"\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2231,col 36)-(line 2231,col 40)","literalExprId":360,"literalExpr":"\"\\\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2231,col 50)-(line 2231,col 53)","literalExprId":361,"literalExpr":"\"\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2232,col 36)-(line 2232,col 50)","literalExprId":362,"literalExpr":"\"split\\\\nlines\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2232,col 60)-(line 2232,col 73)","literalExprId":363,"literalExpr":"\"split\\nlines\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2233,col 36)-(line 2233,col 44)","literalExprId":364,"literalExpr":"\"\\\\\\\\\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2233,col 54)-(line 2233,col 59)","literalExprId":365,"literalExpr":"\"\\\\\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2234,col 36)-(line 2234,col 43)","literalExprId":366,"literalExpr":"\"\\\\n\\\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2234,col 53)-(line 2234,col 58)","literalExprId":367,"literalExpr":"\"\\n\\r\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2235,col 36)-(line 2235,col 51)","literalExprId":368,"literalExpr":"\"\\\\\\\\\\\\n\\\\r\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2235,col 61)-(line 2235,col 70)","literalExprId":369,"literalExpr":"\"\\\\\\n\\r\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2236,col 36)-(line 2236,col 46)","literalExprId":370,"literalExpr":"\"\\\\\\\\relax\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2236,col 56)-(line 2236,col 64)","literalExprId":371,"literalExpr":"\"\\\\relax\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2237,col 36)-(line 2237,col 50)","literalExprId":372,"literalExpr":"\"\\\\\\\"hello\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2237,col 60)-(line 2237,col 70)","literalExprId":373,"literalExpr":"\"\\\"hello\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2238,col 36)-(line 2238,col 64)","literalExprId":374,"literalExpr":"\"\\\\\\\"hello\\\\\\\" \\\\\\\"world\\\\\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2238,col 74)-(line 2238,col 94)","literalExprId":375,"literalExpr":"\"\\\"hello\\\" \\\"world\\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2239,col 36)-(line 2239,col 39)","literalExprId":376,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2239,col 49)-(line 2239,col 52)","literalExprId":377,"literalExpr":"\"\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2240,col 36)-(line 2240,col 42)","literalExprId":378,"literalExpr":"\"foo\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2240,col 52)-(line 2240,col 58)","literalExprId":379,"literalExpr":"\"foo\\\\\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2241,col 36)-(line 2241,col 43)","literalExprId":380,"literalExpr":"\"\\\\*abc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2241,col 53)-(line 2241,col 58)","literalExprId":381,"literalExpr":"\"*abc\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2253,col 43)-(line 2253,col 47)","literalExprId":382,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2253,col 50)-(line 2253,col 52)","literalExprId":383,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2253,col 62)-(line 2253,col 66)","literalExprId":384,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2254,col 43)-(line 2254,col 48)","literalExprId":385,"literalExpr":"\"a, b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2254,col 51)-(line 2254,col 53)","literalExprId":386,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2254,col 63)-(line 2254,col 68)","literalExprId":387,"literalExpr":"\"a, b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2255,col 43)-(line 2255,col 48)","literalExprId":388,"literalExpr":"\"a ,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2255,col 51)-(line 2255,col 53)","literalExprId":389,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2255,col 63)-(line 2255,col 67)","literalExprId":390,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2256,col 43)-(line 2256,col 49)","literalExprId":391,"literalExpr":"\"a , b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2256,col 52)-(line 2256,col 54)","literalExprId":392,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2256,col 64)-(line 2256,col 69)","literalExprId":393,"literalExpr":"\"a, b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2257,col 43)-(line 2257,col 50)","literalExprId":394,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2257,col 53)-(line 2257,col 56)","literalExprId":395,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2257,col 66)-(line 2257,col 73)","literalExprId":396,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2258,col 43)-(line 2258,col 51)","literalExprId":397,"literalExpr":"\"ab=> cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2258,col 54)-(line 2258,col 57)","literalExprId":398,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2258,col 67)-(line 2258,col 75)","literalExprId":399,"literalExpr":"\"ab=> cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2259,col 43)-(line 2259,col 51)","literalExprId":400,"literalExpr":"\"ab =>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2259,col 54)-(line 2259,col 57)","literalExprId":401,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2259,col 67)-(line 2259,col 74)","literalExprId":402,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2260,col 43)-(line 2260,col 52)","literalExprId":403,"literalExpr":"\"ab => cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2260,col 55)-(line 2260,col 58)","literalExprId":404,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2260,col 68)-(line 2260,col 76)","literalExprId":405,"literalExpr":"\"ab=> cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2261,col 43)-(line 2261,col 49)","literalExprId":406,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2261,col 52)-(line 2261,col 56)","literalExprId":407,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2261,col 66)-(line 2261,col 72)","literalExprId":408,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2262,col 43)-(line 2262,col 51)","literalExprId":409,"literalExpr":"\" 123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2262,col 54)-(line 2262,col 58)","literalExprId":410,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2262,col 68)-(line 2262,col 75)","literalExprId":411,"literalExpr":"\"123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2263,col 43)-(line 2263,col 50)","literalExprId":412,"literalExpr":"\" 123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2263,col 53)-(line 2263,col 57)","literalExprId":413,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2263,col 67)-(line 2263,col 73)","literalExprId":414,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2264,col 43)-(line 2264,col 50)","literalExprId":415,"literalExpr":"\"123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2264,col 53)-(line 2264,col 57)","literalExprId":416,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2264,col 67)-(line 2264,col 74)","literalExprId":417,"literalExpr":"\"123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2265,col 43)-(line 2265,col 49)","literalExprId":418,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2265,col 52)-(line 2265,col 56)","literalExprId":419,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2265,col 66)-(line 2265,col 72)","literalExprId":420,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2266,col 43)-(line 2266,col 51)","literalExprId":421,"literalExpr":"\"cd 123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2266,col 54)-(line 2266,col 58)","literalExprId":422,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2266,col 68)-(line 2266,col 75)","literalExprId":423,"literalExpr":"\"cd123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2267,col 43)-(line 2267,col 50)","literalExprId":424,"literalExpr":"\"cd123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2267,col 53)-(line 2267,col 57)","literalExprId":425,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2267,col 67)-(line 2267,col 74)","literalExprId":426,"literalExpr":"\"cd123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2268,col 43)-(line 2268,col 50)","literalExprId":427,"literalExpr":"\"cd 123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2268,col 53)-(line 2268,col 57)","literalExprId":428,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2268,col 67)-(line 2268,col 73)","literalExprId":429,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2270,col 42)-(line 2270,col 46)","literalExprId":430,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2270,col 49)-(line 2270,col 51)","literalExprId":431,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2270,col 61)-(line 2270,col 65)","literalExprId":432,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2271,col 42)-(line 2271,col 47)","literalExprId":433,"literalExpr":"\"a, b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2271,col 50)-(line 2271,col 52)","literalExprId":434,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2271,col 62)-(line 2271,col 66)","literalExprId":435,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2272,col 42)-(line 2272,col 47)","literalExprId":436,"literalExpr":"\"a ,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2272,col 50)-(line 2272,col 52)","literalExprId":437,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2272,col 62)-(line 2272,col 67)","literalExprId":438,"literalExpr":"\"a ,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2273,col 42)-(line 2273,col 48)","literalExprId":439,"literalExpr":"\"a , b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2273,col 51)-(line 2273,col 53)","literalExprId":440,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2273,col 63)-(line 2273,col 68)","literalExprId":441,"literalExpr":"\"a ,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2274,col 42)-(line 2274,col 49)","literalExprId":442,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2274,col 52)-(line 2274,col 55)","literalExprId":443,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2274,col 65)-(line 2274,col 72)","literalExprId":444,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2275,col 42)-(line 2275,col 50)","literalExprId":445,"literalExpr":"\"ab=> cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2275,col 53)-(line 2275,col 56)","literalExprId":446,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2275,col 66)-(line 2275,col 73)","literalExprId":447,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2276,col 42)-(line 2276,col 50)","literalExprId":448,"literalExpr":"\"ab =>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2276,col 53)-(line 2276,col 56)","literalExprId":449,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2276,col 66)-(line 2276,col 74)","literalExprId":450,"literalExpr":"\"ab =>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2277,col 42)-(line 2277,col 51)","literalExprId":451,"literalExpr":"\"ab => cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2277,col 54)-(line 2277,col 57)","literalExprId":452,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2277,col 67)-(line 2277,col 75)","literalExprId":453,"literalExpr":"\"ab =>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2278,col 42)-(line 2278,col 48)","literalExprId":454,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2278,col 51)-(line 2278,col 55)","literalExprId":455,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2278,col 65)-(line 2278,col 71)","literalExprId":456,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2279,col 42)-(line 2279,col 50)","literalExprId":457,"literalExpr":"\" 123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2279,col 53)-(line 2279,col 57)","literalExprId":458,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2279,col 67)-(line 2279,col 74)","literalExprId":459,"literalExpr":"\" 123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2280,col 42)-(line 2280,col 49)","literalExprId":460,"literalExpr":"\" 123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2280,col 52)-(line 2280,col 56)","literalExprId":461,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2280,col 66)-(line 2280,col 73)","literalExprId":462,"literalExpr":"\" 123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2281,col 42)-(line 2281,col 49)","literalExprId":463,"literalExpr":"\"123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2281,col 52)-(line 2281,col 56)","literalExprId":464,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2281,col 66)-(line 2281,col 72)","literalExprId":465,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2282,col 42)-(line 2282,col 48)","literalExprId":466,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2282,col 51)-(line 2282,col 55)","literalExprId":467,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2282,col 65)-(line 2282,col 71)","literalExprId":468,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2283,col 42)-(line 2283,col 50)","literalExprId":469,"literalExpr":"\"cd 123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2283,col 53)-(line 2283,col 57)","literalExprId":470,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2283,col 67)-(line 2283,col 74)","literalExprId":471,"literalExpr":"\"cd 123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2284,col 42)-(line 2284,col 49)","literalExprId":472,"literalExpr":"\"cd123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2284,col 52)-(line 2284,col 56)","literalExprId":473,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2284,col 66)-(line 2284,col 72)","literalExprId":474,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2285,col 42)-(line 2285,col 49)","literalExprId":475,"literalExpr":"\"cd 123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2285,col 52)-(line 2285,col 56)","literalExprId":476,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2285,col 66)-(line 2285,col 73)","literalExprId":477,"literalExpr":"\"cd 123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2287,col 43)-(line 2287,col 47)","literalExprId":478,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2287,col 50)-(line 2287,col 52)","literalExprId":479,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2287,col 62)-(line 2287,col 66)","literalExprId":480,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2288,col 43)-(line 2288,col 48)","literalExprId":481,"literalExpr":"\"a, b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2288,col 51)-(line 2288,col 53)","literalExprId":482,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2288,col 63)-(line 2288,col 67)","literalExprId":483,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2289,col 43)-(line 2289,col 48)","literalExprId":484,"literalExpr":"\"a ,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2289,col 51)-(line 2289,col 53)","literalExprId":485,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2289,col 63)-(line 2289,col 67)","literalExprId":486,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2290,col 43)-(line 2290,col 49)","literalExprId":487,"literalExpr":"\"a , b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2290,col 52)-(line 2290,col 54)","literalExprId":488,"literalExpr":"\",\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2290,col 64)-(line 2290,col 68)","literalExprId":489,"literalExpr":"\"a,b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2291,col 43)-(line 2291,col 50)","literalExprId":490,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2291,col 53)-(line 2291,col 56)","literalExprId":491,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2291,col 66)-(line 2291,col 73)","literalExprId":492,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2292,col 43)-(line 2292,col 51)","literalExprId":493,"literalExpr":"\"ab=> cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2292,col 54)-(line 2292,col 57)","literalExprId":494,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2292,col 67)-(line 2292,col 74)","literalExprId":495,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2293,col 43)-(line 2293,col 51)","literalExprId":496,"literalExpr":"\"ab =>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2293,col 54)-(line 2293,col 57)","literalExprId":497,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2293,col 67)-(line 2293,col 74)","literalExprId":498,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2294,col 43)-(line 2294,col 52)","literalExprId":499,"literalExpr":"\"ab => cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2294,col 55)-(line 2294,col 58)","literalExprId":500,"literalExpr":"\"=>\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2294,col 68)-(line 2294,col 75)","literalExprId":501,"literalExpr":"\"ab=>cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2295,col 43)-(line 2295,col 49)","literalExprId":502,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2295,col 52)-(line 2295,col 56)","literalExprId":503,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2295,col 66)-(line 2295,col 72)","literalExprId":504,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2296,col 43)-(line 2296,col 51)","literalExprId":505,"literalExpr":"\" 123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2296,col 54)-(line 2296,col 58)","literalExprId":506,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2296,col 68)-(line 2296,col 74)","literalExprId":507,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2297,col 43)-(line 2297,col 50)","literalExprId":508,"literalExpr":"\" 123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2297,col 53)-(line 2297,col 57)","literalExprId":509,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2297,col 67)-(line 2297,col 73)","literalExprId":510,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2298,col 43)-(line 2298,col 50)","literalExprId":511,"literalExpr":"\"123 cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2298,col 53)-(line 2298,col 57)","literalExprId":512,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2298,col 67)-(line 2298,col 73)","literalExprId":513,"literalExpr":"\"123cd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2299,col 43)-(line 2299,col 49)","literalExprId":514,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2299,col 52)-(line 2299,col 56)","literalExprId":515,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2299,col 66)-(line 2299,col 72)","literalExprId":516,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2300,col 43)-(line 2300,col 51)","literalExprId":517,"literalExpr":"\"cd 123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2300,col 54)-(line 2300,col 58)","literalExprId":518,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2300,col 68)-(line 2300,col 74)","literalExprId":519,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2301,col 43)-(line 2301,col 50)","literalExprId":520,"literalExpr":"\"cd123 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2301,col 53)-(line 2301,col 57)","literalExprId":521,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2301,col 67)-(line 2301,col 73)","literalExprId":522,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2302,col 43)-(line 2302,col 50)","literalExprId":523,"literalExpr":"\"cd 123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2302,col 53)-(line 2302,col 57)","literalExprId":524,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2302,col 67)-(line 2302,col 73)","literalExprId":525,"literalExpr":"\"cd123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2306,col 28)-(line 2306,col 28)","literalExprId":526,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2306,col 31)-(line 2306,col 36)","literalExprId":527,"literalExpr":"\"fuss\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2306,col 46)-(line 2306,col 55)","literalExprId":528,"literalExpr":"\"0 fusses\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2307,col 28)-(line 2307,col 28)","literalExprId":529,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2307,col 31)-(line 2307,col 36)","literalExprId":530,"literalExpr":"\"fuss\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2307,col 46)-(line 2307,col 53)","literalExprId":531,"literalExpr":"\"1 fuss\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2308,col 28)-(line 2308,col 28)","literalExprId":532,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2308,col 31)-(line 2308,col 36)","literalExprId":533,"literalExpr":"\"fuss\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2308,col 46)-(line 2308,col 55)","literalExprId":534,"literalExpr":"\"2 fusses\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2309,col 28)-(line 2309,col 28)","literalExprId":535,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2309,col 31)-(line 2309,col 35)","literalExprId":536,"literalExpr":"\"fox\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2309,col 45)-(line 2309,col 53)","literalExprId":537,"literalExpr":"\"0 foxes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2310,col 28)-(line 2310,col 28)","literalExprId":538,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2310,col 31)-(line 2310,col 35)","literalExprId":539,"literalExpr":"\"fox\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2310,col 45)-(line 2310,col 51)","literalExprId":540,"literalExpr":"\"1 fox\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2311,col 28)-(line 2311,col 28)","literalExprId":541,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2311,col 31)-(line 2311,col 35)","literalExprId":542,"literalExpr":"\"fox\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2311,col 45)-(line 2311,col 53)","literalExprId":543,"literalExpr":"\"2 foxes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2312,col 28)-(line 2312,col 28)","literalExprId":544,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2312,col 31)-(line 2312,col 36)","literalExprId":545,"literalExpr":"\"fish\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2312,col 46)-(line 2312,col 55)","literalExprId":546,"literalExpr":"\"0 fishes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2313,col 28)-(line 2313,col 28)","literalExprId":547,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2313,col 31)-(line 2313,col 36)","literalExprId":548,"literalExpr":"\"fish\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2313,col 46)-(line 2313,col 53)","literalExprId":549,"literalExpr":"\"1 fish\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2314,col 28)-(line 2314,col 28)","literalExprId":550,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2314,col 31)-(line 2314,col 36)","literalExprId":551,"literalExpr":"\"fish\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2314,col 46)-(line 2314,col 55)","literalExprId":552,"literalExpr":"\"2 fishes\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2315,col 28)-(line 2315,col 28)","literalExprId":553,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2315,col 31)-(line 2315,col 38)","literalExprId":554,"literalExpr":"\"fletch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2315,col 48)-(line 2315,col 59)","literalExprId":555,"literalExpr":"\"0 fletches\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2316,col 28)-(line 2316,col 28)","literalExprId":556,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2316,col 31)-(line 2316,col 38)","literalExprId":557,"literalExpr":"\"fletch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2316,col 48)-(line 2316,col 57)","literalExprId":558,"literalExpr":"\"1 fletch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2317,col 28)-(line 2317,col 28)","literalExprId":559,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2317,col 31)-(line 2317,col 38)","literalExprId":560,"literalExpr":"\"fletch\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2317,col 48)-(line 2317,col 59)","literalExprId":561,"literalExpr":"\"2 fletches\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2318,col 28)-(line 2318,col 28)","literalExprId":562,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2318,col 31)-(line 2318,col 36)","literalExprId":563,"literalExpr":"\"fund\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2318,col 46)-(line 2318,col 54)","literalExprId":564,"literalExpr":"\"0 funds\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2319,col 28)-(line 2319,col 28)","literalExprId":565,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2319,col 31)-(line 2319,col 36)","literalExprId":566,"literalExpr":"\"fund\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2319,col 46)-(line 2319,col 53)","literalExprId":567,"literalExpr":"\"1 fund\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2320,col 28)-(line 2320,col 28)","literalExprId":568,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2320,col 31)-(line 2320,col 36)","literalExprId":569,"literalExpr":"\"fund\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2320,col 46)-(line 2320,col 54)","literalExprId":570,"literalExpr":"\"2 funds\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2321,col 28)-(line 2321,col 28)","literalExprId":571,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2321,col 31)-(line 2321,col 38)","literalExprId":572,"literalExpr":"\"f-stop\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2321,col 48)-(line 2321,col 58)","literalExprId":573,"literalExpr":"\"0 f-stops\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2322,col 28)-(line 2322,col 28)","literalExprId":574,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2322,col 31)-(line 2322,col 38)","literalExprId":575,"literalExpr":"\"f-stop\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2322,col 48)-(line 2322,col 57)","literalExprId":576,"literalExpr":"\"1 f-stop\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2323,col 28)-(line 2323,col 28)","literalExprId":577,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2323,col 31)-(line 2323,col 38)","literalExprId":578,"literalExpr":"\"f-stop\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2323,col 48)-(line 2323,col 58)","literalExprId":579,"literalExpr":"\"2 f-stops\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2329,col 25)-(line 2329,col 26)","literalExprId":580,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2329,col 29)-(line 2329,col 29)","literalExprId":581,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2329,col 39)-(line 2329,col 45)","literalExprId":582,"literalExpr":"\"     \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2330,col 25)-(line 2330,col 30)","literalExprId":583,"literalExpr":"\"abcd\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2330,col 33)-(line 2330,col 33)","literalExprId":584,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2330,col 43)-(line 2330,col 49)","literalExprId":585,"literalExpr":"\"abcd \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2331,col 25)-(line 2331,col 31)","literalExprId":586,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2331,col 34)-(line 2331,col 34)","literalExprId":587,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2331,col 44)-(line 2331,col 50)","literalExprId":588,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2332,col 25)-(line 2332,col 32)","literalExprId":589,"literalExpr":"\"abcdef\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2332,col 35)-(line 2332,col 35)","literalExprId":590,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2332,col 45)-(line 2332,col 51)","literalExprId":591,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2333,col 25)-(line 2333,col 36)","literalExprId":592,"literalExpr":"\"abcde ghij\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2333,col 39)-(line 2333,col 39)","literalExprId":593,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2333,col 49)-(line 2333,col 55)","literalExprId":594,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2334,col 25)-(line 2334,col 26)","literalExprId":595,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2334,col 29)-(line 2334,col 29)","literalExprId":596,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2334,col 39)-(line 2334,col 45)","literalExprId":597,"literalExpr":"\"10   \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2335,col 25)-(line 2335,col 28)","literalExprId":598,"literalExpr":"3.14","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2335,col 31)-(line 2335,col 31)","literalExprId":599,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2335,col 41)-(line 2335,col 47)","literalExprId":600,"literalExpr":"\"3.14 \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2343,col 26)-(line 2343,col 32)","literalExprId":601,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2343,col 35)-(line 2343,col 37)","literalExprId":602,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2343,col 43)-(line 2343,col 43)","literalExprId":603,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2344,col 26)-(line 2344,col 32)","literalExprId":604,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2344,col 35)-(line 2344,col 37)","literalExprId":605,"literalExpr":"'c'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2344,col 43)-(line 2344,col 43)","literalExprId":606,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2345,col 26)-(line 2345,col 32)","literalExprId":607,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2345,col 35)-(line 2345,col 37)","literalExprId":608,"literalExpr":"'e'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2345,col 43)-(line 2345,col 43)","literalExprId":609,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2346,col 26)-(line 2346,col 32)","literalExprId":610,"literalExpr":"\"abcde\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2346,col 35)-(line 2346,col 37)","literalExprId":611,"literalExpr":"'z'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2346,col 43)-(line 2346,col 43)","literalExprId":612,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2347,col 26)-(line 2347,col 36)","literalExprId":613,"literalExpr":"\"abacadaea\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2347,col 39)-(line 2347,col 41)","literalExprId":614,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2347,col 47)-(line 2347,col 47)","literalExprId":615,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2348,col 26)-(line 2348,col 34)","literalExprId":616,"literalExpr":"\"aaa aea\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2348,col 37)-(line 2348,col 39)","literalExprId":617,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2348,col 45)-(line 2348,col 45)","literalExprId":618,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2349,col 26)-(line 2349,col 33)","literalExprId":619,"literalExpr":"\"daeaaa\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2349,col 36)-(line 2349,col 38)","literalExprId":620,"literalExpr":"'a'","literalExprClass":"class com.github.javaparser.ast.expr.CharLiteralExpr"},{"literalExprRange":"(line 2349,col 44)-(line 2349,col 44)","literalExprId":621,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2360,col 14)-(line 2360,col 14)","literalExprId":622,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2361,col 14)-(line 2361,col 14)","literalExprId":623,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2362,col 14)-(line 2362,col 14)","literalExprId":624,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2364,col 17)-(line 2364,col 17)","literalExprId":625,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2365,col 17)-(line 2365,col 17)","literalExprId":626,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2366,col 17)-(line 2366,col 17)","literalExprId":627,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2367,col 17)-(line 2367,col 17)","literalExprId":628,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2368,col 17)-(line 2368,col 17)","literalExprId":629,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2369,col 17)-(line 2369,col 17)","literalExprId":630,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2371,col 16)-(line 2371,col 16)","literalExprId":631,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2372,col 16)-(line 2372,col 16)","literalExprId":632,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2373,col 16)-(line 2373,col 16)","literalExprId":633,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2374,col 16)-(line 2374,col 16)","literalExprId":634,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2375,col 16)-(line 2375,col 16)","literalExprId":635,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2377,col 15)-(line 2377,col 15)","literalExprId":636,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2378,col 15)-(line 2378,col 15)","literalExprId":637,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2379,col 15)-(line 2379,col 15)","literalExprId":638,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2380,col 15)-(line 2380,col 15)","literalExprId":639,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2382,col 15)-(line 2382,col 15)","literalExprId":640,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2383,col 15)-(line 2383,col 15)","literalExprId":641,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2384,col 15)-(line 2384,col 15)","literalExprId":642,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2385,col 15)-(line 2385,col 15)","literalExprId":643,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2395,col 39)-(line 2395,col 42)","literalExprId":644,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2395,col 45)-(line 2395,col 49)","literalExprId":645,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2395,col 52)-(line 2395,col 55)","literalExprId":646,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2396,col 39)-(line 2396,col 42)","literalExprId":647,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2396,col 45)-(line 2396,col 49)","literalExprId":648,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2396,col 52)-(line 2396,col 55)","literalExprId":649,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2397,col 38)-(line 2397,col 41)","literalExprId":650,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2397,col 44)-(line 2397,col 48)","literalExprId":651,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2397,col 51)-(line 2397,col 55)","literalExprId":652,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2424,col 37)-(line 2424,col 37)","literalExprId":653,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2424,col 47)-(line 2424,col 52)","literalExprId":654,"literalExpr":"\"5.00\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2425,col 37)-(line 2425,col 40)","literalExprId":655,"literalExpr":"5000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2425,col 50)-(line 2425,col 56)","literalExprId":656,"literalExpr":"\"5.00K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2426,col 37)-(line 2426,col 43)","literalExprId":657,"literalExpr":"5000000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2426,col 53)-(line 2426,col 59)","literalExprId":658,"literalExpr":"\"5.00M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2427,col 37)-(line 2427,col 46)","literalExprId":659,"literalExpr":"1000000000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2427,col 56)-(line 2427,col 62)","literalExprId":660,"literalExpr":"\"1.00G\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2428,col 37)-(line 2428,col 37)","literalExprId":661,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2428,col 47)-(line 2428,col 52)","literalExprId":662,"literalExpr":"\"1.00\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2429,col 37)-(line 2429,col 38)","literalExprId":663,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2429,col 48)-(line 2429,col 53)","literalExprId":664,"literalExpr":"\"12.0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2430,col 37)-(line 2430,col 39)","literalExprId":665,"literalExpr":"123","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2430,col 49)-(line 2430,col 53)","literalExprId":666,"literalExpr":"\"123\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2431,col 37)-(line 2431,col 40)","literalExprId":667,"literalExpr":"1234","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2431,col 50)-(line 2431,col 56)","literalExprId":668,"literalExpr":"\"1.23K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2432,col 37)-(line 2432,col 41)","literalExprId":669,"literalExpr":"12345","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2432,col 51)-(line 2432,col 57)","literalExprId":670,"literalExpr":"\"12.3K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2433,col 37)-(line 2433,col 42)","literalExprId":671,"literalExpr":"123456","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2433,col 52)-(line 2433,col 57)","literalExprId":672,"literalExpr":"\"123K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2434,col 37)-(line 2434,col 43)","literalExprId":673,"literalExpr":"1234567","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2434,col 53)-(line 2434,col 59)","literalExprId":674,"literalExpr":"\"1.23M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2435,col 37)-(line 2435,col 44)","literalExprId":675,"literalExpr":"12345678","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2435,col 54)-(line 2435,col 60)","literalExprId":676,"literalExpr":"\"12.3M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2436,col 37)-(line 2436,col 45)","literalExprId":677,"literalExpr":"123456789","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2436,col 55)-(line 2436,col 60)","literalExprId":678,"literalExpr":"\"123M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2437,col 37)-(line 2437,col 46)","literalExprId":679,"literalExpr":"1234567890","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2437,col 56)-(line 2437,col 62)","literalExprId":680,"literalExpr":"\"1.23G\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2438,col 37)-(line 2438,col 37)","literalExprId":681,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2438,col 47)-(line 2438,col 52)","literalExprId":682,"literalExpr":"\"9.00\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2439,col 37)-(line 2439,col 38)","literalExprId":683,"literalExpr":"98","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2439,col 48)-(line 2439,col 53)","literalExprId":684,"literalExpr":"\"98.0\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2440,col 37)-(line 2440,col 39)","literalExprId":685,"literalExpr":"987","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2440,col 49)-(line 2440,col 53)","literalExprId":686,"literalExpr":"\"987\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2441,col 37)-(line 2441,col 40)","literalExprId":687,"literalExpr":"9876","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2441,col 50)-(line 2441,col 56)","literalExprId":688,"literalExpr":"\"9.88K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2442,col 37)-(line 2442,col 41)","literalExprId":689,"literalExpr":"98765","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2442,col 51)-(line 2442,col 57)","literalExprId":690,"literalExpr":"\"98.8K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2443,col 37)-(line 2443,col 42)","literalExprId":691,"literalExpr":"987654","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2443,col 52)-(line 2443,col 57)","literalExprId":692,"literalExpr":"\"988K\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2444,col 37)-(line 2444,col 43)","literalExprId":693,"literalExpr":"9876543","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2444,col 53)-(line 2444,col 59)","literalExprId":694,"literalExpr":"\"9.88M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2445,col 37)-(line 2445,col 44)","literalExprId":695,"literalExpr":"98765432","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2445,col 54)-(line 2445,col 60)","literalExprId":696,"literalExpr":"\"98.8M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2446,col 37)-(line 2446,col 45)","literalExprId":697,"literalExpr":"987654321","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2446,col 55)-(line 2446,col 60)","literalExprId":698,"literalExpr":"\"988M\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2447,col 37)-(line 2447,col 47)","literalExprId":699,"literalExpr":"9876543210L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"},{"literalExprRange":"(line 2447,col 57)-(line 2447,col 63)","literalExprId":700,"literalExpr":"\"9.88G\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testUtilMDE()"},{"methodDeclaration":"public void testTestUtilMDE()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] a = new int[] { 3, 4, 5 };\n    assert_arrays_equals(int_iterator_array(int_array_iterator(a)), a);\n}","methodRange":"(line 2450,col 3)-(line 2454,col 3)","methodTokenRange":"@Test\n  public void testTestUtilMDE() {\n    int[] a = new int[] {3, 4, 5};\n    assert_arrays_equals(int_iterator_array(int_array_iterator(a)), a);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testTestUtilMDE","methodQualifiedSignature":"plume.TestPlume.testTestUtilMDE","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2452,col 26)-(line 2452,col 26)","literalExprId":1,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2452,col 29)-(line 2452,col 29)","literalExprId":2,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2452,col 32)-(line 2452,col 32)","literalExprId":3,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testTestUtilMDE()"},{"methodDeclaration":"public void testWeakHasherMap()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n}","methodRange":"(line 2456,col 3)-(line 2457,col 36)","methodTokenRange":"@Test\n  public void testWeakHasherMap() {}","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testWeakHasherMap","methodQualifiedSignature":"plume.TestPlume.testWeakHasherMap","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.TestPlume.testWeakHasherMap()"},{"javadocBlockTags":[],"methodDeclaration":"public void testWeakIdentityHashMap()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String s1 = \"one\";\n    String s2 = \"two\";\n    String s3 = \"three\";\n    WeakIdentityHashMap<String, Integer> m = new WeakIdentityHashMap<String, Integer>();\n    m.put(s1, 1);\n    m.put(s2, 2);\n    m.put(s3, 3);\n    String s1a = new String(s1);\n    String s2a = new String(s2);\n    String s3a = new String(s3);\n    m.put(s1a, 1);\n    m.put(s2a, 2);\n    m.put(s3a, 3);\n    assert m.get(s1) == 1;\n    assert m.get(s2) == 2;\n    assert m.get(s3) == 3;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n    m.remove(s1);\n    m.remove(s2);\n    m.remove(s3);\n    assert m.get(s1) == null;\n    assert m.get(s2) == null;\n    assert m.get(s3) == null;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n}","methodRange":"(line 2464,col 3)-(line 2502,col 3)","methodTokenRange":"@Test\n  public void testWeakIdentityHashMap() {\n\n    String s1 = \"one\";\n    String s2 = \"two\";\n    String s3 = \"three\";\n\n    WeakIdentityHashMap<String, Integer> m = new WeakIdentityHashMap<String, Integer>();\n    \/\/ WeakHashMap<String,Integer> m = new WeakHashMap<String,Integer>();\n\n    m.put(s1, 1);\n    m.put(s2, 2);\n    m.put(s3, 3);\n\n    String s1a = new String(s1);\n    String s2a = new String(s2);\n    String s3a = new String(s3);\n\n    m.put(s1a, 1);\n    m.put(s2a, 2);\n    m.put(s3a, 3);\n\n    assert m.get(s1) == 1;\n    assert m.get(s2) == 2;\n    assert m.get(s3) == 3;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n\n    m.remove(s1);\n    m.remove(s2);\n    m.remove(s3);\n    assert m.get(s1) == null;\n    assert m.get(s2) == null;\n    assert m.get(s3) == null;\n    assert m.get(s1a) == 1;\n    assert m.get(s2a) == 2;\n    assert m.get(s3a) == 3;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * These tests could be much more thorough.  Basically all that is tested\n   * is that identity is used rather than a normal hash.  The tests will\n   * fail however, if WeakHashMap is swapped for WeakIdentityHashMap.\n   ","methodParameters":[],"methodName":"testWeakIdentityHashMap","methodQualifiedSignature":"plume.TestPlume.testWeakIdentityHashMap","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='These tests could be much more thorough.  Basically all that is tested\nis that identity is used rather than a normal hash.  The tests will\nfail however, if WeakHashMap is swapped for WeakIdentityHashMap.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2467,col 17)-(line 2467,col 21)","literalExprId":1,"literalExpr":"\"one\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2468,col 17)-(line 2468,col 21)","literalExprId":2,"literalExpr":"\"two\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2469,col 17)-(line 2469,col 23)","literalExprId":3,"literalExpr":"\"three\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2474,col 15)-(line 2474,col 15)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2475,col 15)-(line 2475,col 15)","literalExprId":5,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2476,col 15)-(line 2476,col 15)","literalExprId":6,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2482,col 16)-(line 2482,col 16)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2483,col 16)-(line 2483,col 16)","literalExprId":8,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2484,col 16)-(line 2484,col 16)","literalExprId":9,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2486,col 25)-(line 2486,col 25)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2487,col 25)-(line 2487,col 25)","literalExprId":11,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2488,col 25)-(line 2488,col 25)","literalExprId":12,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2489,col 26)-(line 2489,col 26)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2490,col 26)-(line 2490,col 26)","literalExprId":14,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2491,col 26)-(line 2491,col 26)","literalExprId":15,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2496,col 25)-(line 2496,col 28)","literalExprId":16,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2497,col 25)-(line 2497,col 28)","literalExprId":17,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2498,col 25)-(line 2498,col 28)","literalExprId":18,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2499,col 26)-(line 2499,col 26)","literalExprId":19,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2500,col 26)-(line 2500,col 26)","literalExprId":20,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2501,col 26)-(line 2501,col 26)","literalExprId":21,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testWeakIdentityHashMap()"},{"methodDeclaration":"public void testClassFileVersion()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert ClassFileVersion.versionNumbers(new ByteArrayInputStream(new byte[0])) == null;\n}","methodRange":"(line 2504,col 3)-(line 2508,col 3)","methodTokenRange":"@Test\n  public void testClassFileVersion() {\n    \/\/ public static double [] versionNumbers(InputStream is)\n    assert ClassFileVersion.versionNumbers(new ByteArrayInputStream(new byte[0])) == null;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testClassFileVersion","methodQualifiedSignature":"plume.TestPlume.testClassFileVersion","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2507,col 78)-(line 2507,col 78)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2507,col 86)-(line 2507,col 89)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testClassFileVersion()"},{"javadocBlockTags":[],"methodDeclaration":"public void testCountingPrintWriter()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    CountingPrintWriter c1 = new CountingPrintWriter(new CharArrayWriter());\n    c1.print(\"a\");\n    assert c1.getNumberOfPrintedBytes() == 1;\n    c1.print(1);\n    assert c1.getNumberOfPrintedBytes() == 2;\n    c1.print(true);\n    assert c1.getNumberOfPrintedBytes() == 6;\n    c1.print(1.00);\n    assert c1.getNumberOfPrintedBytes() == 9;\n    c1.write(\"a\");\n    c1.write(\"-\");\n    assert c1.getNumberOfPrintedBytes() == 9;\n    assert c1.getNumberOfWrittenBytes() == 22;\n    assert c1.getNumberOfPrintedChars() == 9;\n    c1.println(\"a b\");\n    String lineSep = System.getProperty(\"line.separator\");\n    int ls_len = lineSep.length();\n    assert c1.getNumberOfPrintedBytes() == (12 + ls_len);\n    assert c1.getNumberOfWrittenBytes() == (28);\n    assert c1.getNumberOfPrintedChars() == (12 + ls_len);\n    c1.print((String) null);\n    c1.print((Object) null);\n    c1.println((String) null);\n}","methodRange":"(line 2515,col 3)-(line 2541,col 3)","methodTokenRange":"@Test\n  public void testCountingPrintWriter() {\n    CountingPrintWriter c1 = new CountingPrintWriter(new CharArrayWriter());\n    c1.print(\"a\");\n    assert c1.getNumberOfPrintedBytes() == 1;\n    c1.print(1);\n    assert c1.getNumberOfPrintedBytes() == 2;\n    c1.print(true);\n    assert c1.getNumberOfPrintedBytes() == 6;\n    c1.print(1.00);\n    assert c1.getNumberOfPrintedBytes() == 9;\n    c1.write(\"a\");\n    c1.write(\"-\");\n    assert c1.getNumberOfPrintedBytes() == 9;\n    assert c1.getNumberOfWrittenBytes() == 22;\n    assert c1.getNumberOfPrintedChars() == 9;\n    c1.println(\"a b\");\n    String lineSep = System.getProperty(\"line.separator\");\n    int ls_len = lineSep.length();\n    assert c1.getNumberOfPrintedBytes() == (12 + ls_len);\n    assert c1.getNumberOfWrittenBytes() == (28);\n    assert c1.getNumberOfPrintedChars() == (12 + ls_len);\n    c1.print((String) null);\n    c1.print((Object) null);\n    c1.println((String) null);\n    \/\/ need to add assertions about what got printed.\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Tests whether CountingPrintWriter\n   * counts the bytes printed, written for\n   * different types (boolean, int, float etc.).\n   ","methodParameters":[],"methodName":"testCountingPrintWriter","methodQualifiedSignature":"plume.TestPlume.testCountingPrintWriter","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests whether CountingPrintWriter\ncounts the bytes printed, written for\ndifferent types (boolean, int, float etc.).'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2518,col 14)-(line 2518,col 16)","literalExprId":1,"literalExpr":"\"a\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2519,col 44)-(line 2519,col 44)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2520,col 14)-(line 2520,col 14)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2521,col 44)-(line 2521,col 44)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2522,col 14)-(line 2522,col 17)","literalExprId":5,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 2523,col 44)-(line 2523,col 44)","literalExprId":6,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2524,col 14)-(line 2524,col 17)","literalExprId":7,"literalExpr":"1.00","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2525,col 44)-(line 2525,col 44)","literalExprId":8,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2526,col 14)-(line 2526,col 16)","literalExprId":9,"literalExpr":"\"a\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2527,col 14)-(line 2527,col 16)","literalExprId":10,"literalExpr":"\"-\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2528,col 44)-(line 2528,col 44)","literalExprId":11,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2529,col 44)-(line 2529,col 45)","literalExprId":12,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2530,col 44)-(line 2530,col 44)","literalExprId":13,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2531,col 16)-(line 2531,col 20)","literalExprId":14,"literalExpr":"\"a b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2532,col 41)-(line 2532,col 56)","literalExprId":15,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2534,col 45)-(line 2534,col 46)","literalExprId":16,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2535,col 45)-(line 2535,col 46)","literalExprId":17,"literalExpr":"28","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2536,col 45)-(line 2536,col 46)","literalExprId":18,"literalExpr":"12","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2537,col 23)-(line 2537,col 26)","literalExprId":19,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2538,col 23)-(line 2538,col 26)","literalExprId":20,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 2539,col 25)-(line 2539,col 28)","literalExprId":21,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testCountingPrintWriter()"},{"javadocBlockTags":[],"methodDeclaration":"public void testSequenceAndIndices()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int[] a1 = Intern.intern(new int[] { 1, 2, 3, 4, 5, 6, 7 });\n    int[] a2 = Intern.intern(new int[] { 1, 2, 3, 4, 5, 6, 7 });\n    int[] a3 = Intern.intern(new int[] { 2, 3, 4, 5, 6, 7 });\n    int i = 2;\n    int j = 4;\n    int k = 5;\n    int[] s1 = Intern.internSubsequence(a1, i, j);\n    int[] s2 = Intern.internSubsequence(a2, i, j);\n    int[] s3 = Intern.internSubsequence(a1, j, k);\n    int[] s4 = Intern.internSubsequence(a1, j, k);\n    int[] s5 = Intern.internSubsequence(a3, j - 1, k - 1);\n    assert a1 == a2;\n    assert s1 == s2;\n    assert s3 == s4;\n    assert s3 == s5;\n    assert ArraysMDE.isSubarray(s1, ArraysMDE.subarray(a1, i, j - i), 0);\n    assert ArraysMDE.isSubarray(ArraysMDE.subarray(a1, i, j - i), s1, 0);\n    long[] l1 = Intern.intern(new long[] { 1, 2, 3, 4, 5, 6 });\n    assert l1 == Intern.internSubsequence(l1, 0, l1.length);\n}","methodRange":"(line 2547,col 3)-(line 2571,col 3)","methodTokenRange":"@Test\n  public void testSequenceAndIndices() {\n    int[] a1 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a2 = Intern.intern(new int[] {1, 2, 3, 4, 5, 6, 7});\n    int[] a3 = Intern.intern(new int[] {2, 3, 4, 5, 6, 7});\n    int i = 2;\n    int j = 4;\n    int k = 5;\n\n    int[] s1 = Intern.internSubsequence(a1, i, j);\n    int[] s2 = Intern.internSubsequence(a2, i, j);\n    int[] s3 = Intern.internSubsequence(a1, j, k);\n    int[] s4 = Intern.internSubsequence(a1, j, k);\n    int[] s5 = Intern.internSubsequence(a3, j - 1, k - 1);\n\n    assert a1 == a2;\n    assert s1 == s2;\n    assert s3 == s4;\n    assert s3 == s5;\n    assert ArraysMDE.isSubarray(s1, ArraysMDE.subarray(a1, i, j - i), 0);\n    assert ArraysMDE.isSubarray(ArraysMDE.subarray(a1, i, j - i), s1, 0);\n\n    long[] l1 = Intern.intern(new long[] {1, 2, 3, 4, 5, 6});\n    assert l1 == Intern.internSubsequence(l1, 0, l1.length);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Test the intering of subsequences as triples of the original\n   * sequence, the start and the end indices.\n   ","methodParameters":[],"methodName":"testSequenceAndIndices","methodQualifiedSignature":"plume.TestPlume.testSequenceAndIndices","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test the intering of subsequences as triples of the original\nsequence, the start and the end indices.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2549,col 41)-(line 2549,col 41)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2549,col 44)-(line 2549,col 44)","literalExprId":2,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2549,col 47)-(line 2549,col 47)","literalExprId":3,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2549,col 50)-(line 2549,col 50)","literalExprId":4,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2549,col 53)-(line 2549,col 53)","literalExprId":5,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2549,col 56)-(line 2549,col 56)","literalExprId":6,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2549,col 59)-(line 2549,col 59)","literalExprId":7,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 41)-(line 2550,col 41)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 44)-(line 2550,col 44)","literalExprId":9,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 47)-(line 2550,col 47)","literalExprId":10,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 50)-(line 2550,col 50)","literalExprId":11,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 53)-(line 2550,col 53)","literalExprId":12,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 56)-(line 2550,col 56)","literalExprId":13,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2550,col 59)-(line 2550,col 59)","literalExprId":14,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2551,col 41)-(line 2551,col 41)","literalExprId":15,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2551,col 44)-(line 2551,col 44)","literalExprId":16,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2551,col 47)-(line 2551,col 47)","literalExprId":17,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2551,col 50)-(line 2551,col 50)","literalExprId":18,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2551,col 53)-(line 2551,col 53)","literalExprId":19,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2551,col 56)-(line 2551,col 56)","literalExprId":20,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2552,col 13)-(line 2552,col 13)","literalExprId":21,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2553,col 13)-(line 2553,col 13)","literalExprId":22,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2554,col 13)-(line 2554,col 13)","literalExprId":23,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2560,col 49)-(line 2560,col 49)","literalExprId":24,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2560,col 56)-(line 2560,col 56)","literalExprId":25,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2566,col 71)-(line 2566,col 71)","literalExprId":26,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2567,col 71)-(line 2567,col 71)","literalExprId":27,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2569,col 43)-(line 2569,col 43)","literalExprId":28,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2569,col 46)-(line 2569,col 46)","literalExprId":29,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2569,col 49)-(line 2569,col 49)","literalExprId":30,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2569,col 52)-(line 2569,col 52)","literalExprId":31,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2569,col 55)-(line 2569,col 55)","literalExprId":32,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2569,col 58)-(line 2569,col 58)","literalExprId":33,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2570,col 47)-(line 2570,col 47)","literalExprId":34,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testSequenceAndIndices()"},{"javadocBlockTags":[],"methodDeclaration":"public void testFuzzyFloat()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FuzzyFloat ff = new FuzzyFloat(0.0001);\n    double offset = 0.00007;\n    double offhigh = 1 + offset;\n    double offlow = 1 - offset;\n    double offhigh2 = 1 + 2 * offset;\n    double offlow2 = 1 - 2 * offset;\n    for (double d = -20000; d < 20000; d += 1000.36) {\n        assert ff.eq(d, d * offhigh);\n        assert ff.eq(d, d * offlow);\n        assert !ff.eq(d, d * offhigh2);\n        assert !ff.eq(d, d * offlow2);\n        assert !ff.ne(d, d * offhigh);\n        assert !ff.ne(d, d * offlow);\n        assert ff.ne(d, d * offhigh2);\n        assert ff.ne(d, d * offlow2);\n    }\n    assert ff.eq(0, Double.MIN_VALUE);\n    assert ff.eq(0, -Double.MIN_VALUE);\n    assert !ff.ne(0, Double.MIN_VALUE);\n    assert !ff.ne(0, -Double.MIN_VALUE);\n    assert ff.eq(0, 0);\n    assert !ff.ne(0, 0);\n    assert !ff.eq(Double.NaN, Double.NaN);\n    assert ff.eq(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    assert ff.eq(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n    {\n        double d = 2563.789;\n        assert !ff.gt(d, d * offlow);\n        assert !ff.lt(d, d * offhigh);\n        assert ff.gt(d, d * offlow2);\n        assert ff.lt(d, d * offhigh2);\n        assert ff.gte(d, d * offhigh);\n        assert ff.lte(d, d * offlow);\n        assert !ff.gte(d, d * offhigh2);\n        assert !ff.lte(d, d * offlow2);\n    }\n    {\n        double[] a = new double[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = i;\n        }\n        double[] a_copy = a.clone();\n        assert ff.indexOf(a, -1) == -1;\n        assert ff.indexOf(a, 0) == 0;\n        assert ff.indexOf(a, 7) == 7;\n        assert ff.indexOf(a, 9) == 9;\n        assert ff.indexOf(a, 10) == -1;\n        assert ff.indexOf(a, 20) == -1;\n        assert ff.indexOf(a, Double.MIN_VALUE) == 0;\n        assert ff.indexOf(a, 7 * offhigh) == 7;\n        assert ff.indexOf(a, 9 * offlow) == 9;\n        assert ff.indexOf(a, 7 * offhigh2) == -1;\n        assert ff.indexOf(a, 9 * offlow2) == -1;\n        assert_arrays_equals(a, a_copy);\n    }\n    {\n        double[] a = new double[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = i;\n        }\n        double[] b = new double[] {};\n        double[] c = new double[] { a[0], a[1], a[2] };\n        double[] d = new double[] { a[1], a[2] };\n        double[] e = new double[] { a[2], a[3], a[4], a[5] };\n        double[] f = new double[] { a[7], a[8], a[9] };\n        double[] g = new double[] { a[7], 22, a[9] };\n        double[] h = new double[] { a[7], a[8], a[9], 10 };\n        assert ff.indexOf(a, b) == 0;\n        assert ff.indexOf(a, c) == 0;\n        assert ff.indexOf(a, d) == 1;\n        assert ff.indexOf(a, e) == 2;\n        assert ff.indexOf(a, f) == 7;\n        assert ff.indexOf(a, g) == -1;\n        assert ff.indexOf(a, h) == -1;\n    }\n    {\n        double[] a = new double[10];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = i;\n        }\n        double[] b = new double[] {};\n        double[] c = new double[] { a[0] * offlow, a[1] * offhigh, a[2] * offlow };\n        double[] d = new double[] { a[1] * offhigh, a[2] * offlow };\n        double[] e = new double[] { a[2], a[3], a[4] * offlow, a[5] * offhigh };\n        double[] f = new double[] { a[7], a[8] * offlow, a[9] * offhigh };\n        double[] g = new double[] { a[7], 22, a[9] };\n        double[] h = new double[] { a[7], a[8], a[9], 10 };\n        double[] a_copy = a.clone();\n        double[] b_copy = b.clone();\n        double[] c_copy = c.clone();\n        double[] d_copy = d.clone();\n        double[] e_copy = e.clone();\n        double[] f_copy = f.clone();\n        double[] g_copy = g.clone();\n        double[] h_copy = h.clone();\n        assert ff.indexOf(a, b) == 0;\n        assert ff.indexOf(a, c) == 0;\n        assert ff.indexOf(a, d) == 1;\n        assert ff.indexOf(a, e) == 2;\n        assert ff.indexOf(a, f) == 7;\n        assert ff.indexOf(a, g) == -1;\n        assert ff.indexOf(a, h) == -1;\n        assert_arrays_equals(a, a_copy);\n        assert_arrays_equals(b, b_copy);\n        assert_arrays_equals(c, c_copy);\n        assert_arrays_equals(d, d_copy);\n        assert_arrays_equals(e, e_copy);\n        assert_arrays_equals(f, f_copy);\n        assert_arrays_equals(g, g_copy);\n        assert_arrays_equals(h, h_copy);\n    }\n    {\n        double[] f1 = new double[10];\n        double[] f2 = new double[20];\n        for (int j = 0; j < 10; j++) {\n            initialize_f1_and_f2(j, f1, f2);\n            f2[7] = f2[7] * (1 + offset);\n            f2[8] = f2[8] * (1 - offset);\n            if ((j % 2) == 0) {\n                assert ff.isElemMatch(f1, f2);\n            } else {\n                assert ff.isElemMatch(f2, f1);\n            }\n        }\n        for (int j = 0; j < 200; j++) {\n            initialize_f1_and_f2(j, f1, f2);\n            f2[7] = f2[7] * (1 + 2 * offset);\n            f2[8] = f2[8] * (1 - 2 * offset);\n            double[] f1_copy = f1.clone();\n            double[] f2_copy = f2.clone();\n            if ((j % 2) == 0) {\n                assert !ff.isElemMatch(f1, f2);\n            } else {\n                assert !ff.isElemMatch(f2, f1);\n            }\n            assert_arrays_equals(f1, f1_copy);\n            assert_arrays_equals(f2, f2_copy);\n        }\n    }\n    {\n        double[] a = new double[] { 2, 1, 0 };\n        double[] b = new double[] {};\n        double[] c = new double[] { 1, 1, 1, 1 };\n        double[] d = new double[] { 1 };\n        assert !ff.isElemMatch(a, b);\n        assert !ff.isElemMatch(b, a);\n        assert ff.isElemMatch(c, d);\n        assert ff.isElemMatch(d, c);\n        assert ff.isElemMatch(b, b);\n    }\n    {\n        Comparator<double[]> comparator = ff.new DoubleArrayComparatorLexical();\n        double[] a0 = new double[] {};\n        double[] a1 = new double[] {};\n        double[] a2 = new double[] { 0, 1, 2, 3 };\n        double[] a3 = new double[] { 0, 1, 2, 3, 0 };\n        double[] a4 = new double[] { 0, 1, 2, 3, 4 };\n        double[] a5 = new double[] { 0, 1, 2, 3, 4 };\n        double[] a6 = new double[] { 0, 1, 5, 3, 4 };\n        double[] a7 = new double[] { 1, 2, 3, 4 };\n        double[] a0_copy = a0.clone();\n        double[] a1_copy = a1.clone();\n        double[] a2_copy = a2.clone();\n        double[] a3_copy = a3.clone();\n        double[] a4_copy = a4.clone();\n        double[] a5_copy = a5.clone();\n        double[] a6_copy = a6.clone();\n        double[] a7_copy = a7.clone();\n        assert comparator.compare(a0, a1) == 0;\n        assert comparator.compare(a1, a0) == 0;\n        assert comparator.compare(a1, a2) < 0;\n        assert comparator.compare(a2, a1) > 0;\n        assert comparator.compare(a2, a3) < 0;\n        assert comparator.compare(a3, a2) > 0;\n        assert comparator.compare(a3, a4) < 0;\n        assert comparator.compare(a4, a3) > 0;\n        assert comparator.compare(a4, a5) == 0;\n        assert comparator.compare(a5, a4) == 0;\n        assert comparator.compare(a5, a6) < 0;\n        assert comparator.compare(a6, a5) > 0;\n        assert comparator.compare(a6, a7) < 0;\n        assert comparator.compare(a7, a6) > 0;\n        assert comparator.compare(a1, a4) < 0;\n        assert comparator.compare(a4, a1) > 0;\n        assert comparator.compare(a2, a4) < 0;\n        assert comparator.compare(a4, a2) > 0;\n        assert comparator.compare(a6, a4) > 0;\n        assert comparator.compare(a4, a6) < 0;\n        assert comparator.compare(a7, a4) > 0;\n        assert comparator.compare(a4, a7) < 0;\n        assert_arrays_equals(a0, a0_copy);\n        assert_arrays_equals(a1, a1_copy);\n        assert_arrays_equals(a2, a2_copy);\n        assert_arrays_equals(a3, a3_copy);\n        assert_arrays_equals(a4, a4_copy);\n        assert_arrays_equals(a5, a5_copy);\n        assert_arrays_equals(a6, a6_copy);\n        assert_arrays_equals(a7, a7_copy);\n    }\n    {\n        double[] f1 = new double[10];\n        double[] f2 = new double[20];\n        for (int j = 0; j < f2.length; j++) {\n            f2[j] = j;\n        }\n        for (int i = 0; i < f2.length - f1.length; i++) {\n            for (int j = 0; j < f1.length; j++) {\n                f1[j] = f2[i + j];\n            }\n            f1[5] = f2[i] * offhigh;\n            double[] f1_copy = f1.clone();\n            double[] f2_copy = f2.clone();\n            assert ff.isSubset(f1, f2);\n            assert_arrays_equals(f1, f1_copy);\n            assert_arrays_equals(f2, f2_copy);\n        }\n        double[] a1 = new double[] { 1, 5, 10 };\n        double[] a2 = new double[] {};\n        double[] a3 = new double[] { 1 };\n        double[] a4 = new double[] { 10 };\n        double[] a5 = new double[] { 1, 10, 15, 20 };\n        double[] a6 = new double[] { 10, 10, 10, 10, 10, 1 };\n        assert ff.isSubset(a2, a1);\n        assert !ff.isSubset(a1, a2);\n        assert !ff.isSubset(a1, a5);\n        assert ff.isSubset(a3, a1);\n        assert ff.isSubset(a4, a1);\n        assert ff.isSubset(a6, a1);\n        assert !ff.isSubset(a1, a6);\n    }\n}","methodRange":"(line 2582,col 3)-(line 2863,col 3)","methodTokenRange":"@Test\n  public void testFuzzyFloat() {\n\n    FuzzyFloat ff = new FuzzyFloat(0.0001);\n    double offset = 0.00007;\n    double offhigh = 1 + offset;\n    double offlow = 1 - offset;\n    double offhigh2 = 1 + 2 * offset;\n    double offlow2 = 1 - 2 * offset;\n\n    \/\/test equality for a variety of postive and negative numbers\n    for (double d = -20000; d < 20000; d += 1000.36) {\n      assert ff.eq(d, d * offhigh);\n      assert ff.eq(d, d * offlow);\n      assert !ff.eq(d, d * offhigh2);\n      assert !ff.eq(d, d * offlow2);\n      assert !ff.ne(d, d * offhigh);\n      assert !ff.ne(d, d * offlow);\n      assert ff.ne(d, d * offhigh2);\n      assert ff.ne(d, d * offlow2);\n    }\n\n    \/\/make sure nothing is equal to zero\n    assert ff.eq(0, Double.MIN_VALUE);\n    assert ff.eq(0, -Double.MIN_VALUE);\n    assert !ff.ne(0, Double.MIN_VALUE);\n    assert !ff.ne(0, -Double.MIN_VALUE);\n\n    \/\/make sure that 0 equals 0\n    assert ff.eq(0, 0);\n    assert !ff.ne(0, 0);\n\n    \/\/make sure that NaNs are not equal\n    assert !ff.eq(Double.NaN, Double.NaN);\n\n    \/\/make sure that various unusual values are equal\n    assert ff.eq(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    assert ff.eq(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n\n    \/\/rudimentary checks on the comparison operators (since they all just\n    \/\/use eq and ne anyway)\n    {\n      double d = 2563.789;\n      assert !ff.gt(d, d * offlow);\n      assert !ff.lt(d, d * offhigh);\n      assert ff.gt(d, d * offlow2);\n      assert ff.lt(d, d * offhigh2);\n      assert ff.gte(d, d * offhigh);\n      assert ff.lte(d, d * offlow);\n      assert !ff.gte(d, d * offhigh2);\n      assert !ff.lte(d, d * offlow2);\n    }\n\n    \/\/ public int indexOf (double[] a, double elt)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] a_copy = a.clone();\n      assert ff.indexOf(a, -1) == -1;\n      assert ff.indexOf(a, 0) == 0;\n      assert ff.indexOf(a, 7) == 7;\n      assert ff.indexOf(a, 9) == 9;\n      assert ff.indexOf(a, 10) == -1;\n      assert ff.indexOf(a, 20) == -1;\n      assert ff.indexOf(a, Double.MIN_VALUE) == 0;\n      assert ff.indexOf(a, 7 * offhigh) == 7;\n      assert ff.indexOf(a, 9 * offlow) == 9;\n      assert ff.indexOf(a, 7 * offhigh2) == -1;\n      assert ff.indexOf(a, 9 * offlow2) == -1;\n      assert_arrays_equals(a, a_copy);\n    }\n\n    \/\/ public int indexOf (double[] a, double[] sub)\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0], a[1], a[2]};\n      double[] d = new double[] {a[1], a[2]};\n      double[] e = new double[] {a[2], a[3], a[4], a[5]};\n      double[] f = new double[] {a[7], a[8], a[9]};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n    }\n    {\n      double[] a = new double[10];\n      for (int i = 0; i < a.length; i++) {\n        a[i] = i;\n      }\n      double[] b = new double[] {};\n      double[] c = new double[] {a[0] * offlow, a[1] * offhigh, a[2] * offlow};\n      double[] d = new double[] {a[1] * offhigh, a[2] * offlow};\n      double[] e = new double[] {a[2], a[3], a[4] * offlow, a[5] * offhigh};\n      double[] f = new double[] {a[7], a[8] * offlow, a[9] * offhigh};\n      double[] g = new double[] {a[7], 22, a[9]};\n      double[] h = new double[] {a[7], a[8], a[9], 10};\n      double[] a_copy = a.clone();\n      double[] b_copy = b.clone();\n      double[] c_copy = c.clone();\n      double[] d_copy = d.clone();\n      double[] e_copy = e.clone();\n      double[] f_copy = f.clone();\n      double[] g_copy = g.clone();\n      double[] h_copy = h.clone();\n\n      assert ff.indexOf(a, b) == 0;\n      assert ff.indexOf(a, c) == 0;\n      assert ff.indexOf(a, d) == 1;\n      assert ff.indexOf(a, e) == 2;\n      assert ff.indexOf(a, f) == 7;\n      assert ff.indexOf(a, g) == -1;\n      assert ff.indexOf(a, h) == -1;\n\n      assert_arrays_equals(a, a_copy);\n      assert_arrays_equals(b, b_copy);\n      assert_arrays_equals(c, c_copy);\n      assert_arrays_equals(d, d_copy);\n      assert_arrays_equals(e, e_copy);\n      assert_arrays_equals(f, f_copy);\n      assert_arrays_equals(g, g_copy);\n      assert_arrays_equals(h, h_copy);\n    }\n\n    \/\/ public boolean isElemMatch (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < 10; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        \/\/make two elements off just a little\n        f2[7] = f2[7] * (1 + offset);\n        f2[8] = f2[8] * (1 - offset);\n\n        \/\/test with each array the bigger one\n        if ((j % 2) == 0) {\n          assert ff.isElemMatch(f1, f2);\n        } else {\n          assert ff.isElemMatch(f2, f1);\n        }\n      }\n      for (int j = 0; j < 200; j++) {\n\n        initialize_f1_and_f2(j, f1, f2);\n\n        \/\/make two elements off just a little\n        f2[7] = f2[7] * (1 + 2 * offset);\n        f2[8] = f2[8] * (1 - 2 * offset);\n\n        \/\/test with each array the bigger one\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n        if ((j % 2) == 0) {\n          assert !ff.isElemMatch(f1, f2);\n        } else {\n          assert !ff.isElemMatch(f2, f1);\n        }\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n    }\n    {\n      double[] a = new double[] {2, 1, 0};\n      double[] b = new double[] {};\n      double[] c = new double[] {1, 1, 1, 1};\n      double[] d = new double[] {1};\n      assert !ff.isElemMatch(a, b);\n      assert !ff.isElemMatch(b, a);\n      assert ff.isElemMatch(c, d);\n      assert ff.isElemMatch(d, c);\n      assert ff.isElemMatch(b, b);\n    }\n\n    \/\/ public class DoubleArrayComparatorLexical implements Comparator\n    \/\/ public int compare(Object o1, Object o2)\n    {\n      Comparator<double[]> comparator = ff.new DoubleArrayComparatorLexical();\n      double[] a0 = new double[] {};\n      double[] a1 = new double[] {};\n      double[] a2 = new double[] {0, 1, 2, 3};\n      double[] a3 = new double[] {0, 1, 2, 3, 0};\n      double[] a4 = new double[] {0, 1, 2, 3, 4};\n      double[] a5 = new double[] {0, 1, 2, 3, 4};\n      double[] a6 = new double[] {0, 1, 5, 3, 4};\n      double[] a7 = new double[] {1, 2, 3, 4};\n      double[] a0_copy = a0.clone();\n      double[] a1_copy = a1.clone();\n      double[] a2_copy = a2.clone();\n      double[] a3_copy = a3.clone();\n      double[] a4_copy = a4.clone();\n      double[] a5_copy = a5.clone();\n      double[] a6_copy = a6.clone();\n      double[] a7_copy = a7.clone();\n\n      assert comparator.compare(a0, a1) == 0;\n      assert comparator.compare(a1, a0) == 0;\n      assert comparator.compare(a1, a2) < 0;\n      assert comparator.compare(a2, a1) > 0;\n      assert comparator.compare(a2, a3) < 0;\n      assert comparator.compare(a3, a2) > 0;\n      assert comparator.compare(a3, a4) < 0;\n      assert comparator.compare(a4, a3) > 0;\n      assert comparator.compare(a4, a5) == 0;\n      assert comparator.compare(a5, a4) == 0;\n      assert comparator.compare(a5, a6) < 0;\n      assert comparator.compare(a6, a5) > 0;\n      assert comparator.compare(a6, a7) < 0;\n      assert comparator.compare(a7, a6) > 0;\n      assert comparator.compare(a1, a4) < 0;\n      assert comparator.compare(a4, a1) > 0;\n      assert comparator.compare(a2, a4) < 0;\n      assert comparator.compare(a4, a2) > 0;\n      assert comparator.compare(a6, a4) > 0;\n      assert comparator.compare(a4, a6) < 0;\n      assert comparator.compare(a7, a4) > 0;\n      assert comparator.compare(a4, a7) < 0;\n\n      assert_arrays_equals(a0, a0_copy);\n      assert_arrays_equals(a1, a1_copy);\n      assert_arrays_equals(a2, a2_copy);\n      assert_arrays_equals(a3, a3_copy);\n      assert_arrays_equals(a4, a4_copy);\n      assert_arrays_equals(a5, a5_copy);\n      assert_arrays_equals(a6, a6_copy);\n      assert_arrays_equals(a7, a7_copy);\n    }\n\n    \/\/ public boolean FuzzyFloat.isSubset (double[] a1, double[] a2)\n    {\n      double[] f1 = new double[10];\n      double[] f2 = new double[20];\n\n      for (int j = 0; j < f2.length; j++) {\n        f2[j] = j;\n      }\n      for (int i = 0; i < f2.length - f1.length; i++) {\n\n        \/\/fill up f1 with elements of f2\n        for (int j = 0; j < f1.length; j++) {\n          f1[j] = f2[i + j];\n        }\n\n        f1[5] = f2[i] * offhigh;\n\n        double[] f1_copy = f1.clone();\n        double[] f2_copy = f2.clone();\n\n        assert ff.isSubset(f1, f2);\n        assert_arrays_equals(f1, f1_copy);\n        assert_arrays_equals(f2, f2_copy);\n      }\n\n      double[] a1 = new double[] {1, 5, 10};\n      double[] a2 = new double[] {};\n      double[] a3 = new double[] {1};\n      double[] a4 = new double[] {10};\n      double[] a5 = new double[] {1, 10, 15, 20};\n      double[] a6 = new double[] {10, 10, 10, 10, 10, 1};\n\n      assert ff.isSubset(a2, a1);\n      assert !ff.isSubset(a1, a2);\n      assert !ff.isSubset(a1, a5);\n      assert ff.isSubset(a3, a1);\n      assert ff.isSubset(a4, a1);\n      assert ff.isSubset(a6, a1);\n      assert !ff.isSubset(a1, a6);\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Test the comparison, indexof, and set equivalence calls in fuzzy\n   * float.\n   ","methodParameters":[],"methodName":"testFuzzyFloat","methodQualifiedSignature":"plume.TestPlume.testFuzzyFloat","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test the comparison, indexof, and set equivalence calls in fuzzy\nfloat.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2585,col 36)-(line 2585,col 41)","literalExprId":1,"literalExpr":"0.0001","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2586,col 21)-(line 2586,col 27)","literalExprId":2,"literalExpr":"0.00007","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2587,col 22)-(line 2587,col 22)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2588,col 21)-(line 2588,col 21)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2589,col 23)-(line 2589,col 23)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2589,col 27)-(line 2589,col 27)","literalExprId":6,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2590,col 22)-(line 2590,col 22)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2590,col 26)-(line 2590,col 26)","literalExprId":8,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2593,col 22)-(line 2593,col 26)","literalExprId":9,"literalExpr":"20000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2593,col 33)-(line 2593,col 37)","literalExprId":10,"literalExpr":"20000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2593,col 45)-(line 2593,col 51)","literalExprId":11,"literalExpr":"1000.36","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2605,col 18)-(line 2605,col 18)","literalExprId":12,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2606,col 18)-(line 2606,col 18)","literalExprId":13,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2607,col 19)-(line 2607,col 19)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2608,col 19)-(line 2608,col 19)","literalExprId":15,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2611,col 18)-(line 2611,col 18)","literalExprId":16,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2611,col 21)-(line 2611,col 21)","literalExprId":17,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2612,col 19)-(line 2612,col 19)","literalExprId":18,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2612,col 22)-(line 2612,col 22)","literalExprId":19,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2624,col 18)-(line 2624,col 25)","literalExprId":20,"literalExpr":"2563.789","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 2637,col 31)-(line 2637,col 32)","literalExprId":21,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2638,col 20)-(line 2638,col 20)","literalExprId":22,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2642,col 29)-(line 2642,col 29)","literalExprId":23,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2642,col 36)-(line 2642,col 36)","literalExprId":24,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2643,col 28)-(line 2643,col 28)","literalExprId":25,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2643,col 34)-(line 2643,col 34)","literalExprId":26,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2644,col 28)-(line 2644,col 28)","literalExprId":27,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2644,col 34)-(line 2644,col 34)","literalExprId":28,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2645,col 28)-(line 2645,col 28)","literalExprId":29,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2645,col 34)-(line 2645,col 34)","literalExprId":30,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2646,col 28)-(line 2646,col 29)","literalExprId":31,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2646,col 36)-(line 2646,col 36)","literalExprId":32,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2647,col 28)-(line 2647,col 29)","literalExprId":33,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2647,col 36)-(line 2647,col 36)","literalExprId":34,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2648,col 49)-(line 2648,col 49)","literalExprId":35,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2649,col 28)-(line 2649,col 28)","literalExprId":36,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2649,col 44)-(line 2649,col 44)","literalExprId":37,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2650,col 28)-(line 2650,col 28)","literalExprId":38,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2650,col 43)-(line 2650,col 43)","literalExprId":39,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2651,col 28)-(line 2651,col 28)","literalExprId":40,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2651,col 46)-(line 2651,col 46)","literalExprId":41,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2652,col 28)-(line 2652,col 28)","literalExprId":42,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2652,col 45)-(line 2652,col 45)","literalExprId":43,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2658,col 31)-(line 2658,col 32)","literalExprId":44,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2659,col 20)-(line 2659,col 20)","literalExprId":45,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2663,col 36)-(line 2663,col 36)","literalExprId":46,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2663,col 42)-(line 2663,col 42)","literalExprId":47,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2663,col 48)-(line 2663,col 48)","literalExprId":48,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2664,col 36)-(line 2664,col 36)","literalExprId":49,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2664,col 42)-(line 2664,col 42)","literalExprId":50,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2665,col 36)-(line 2665,col 36)","literalExprId":51,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2665,col 42)-(line 2665,col 42)","literalExprId":52,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2665,col 48)-(line 2665,col 48)","literalExprId":53,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2665,col 54)-(line 2665,col 54)","literalExprId":54,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2666,col 36)-(line 2666,col 36)","literalExprId":55,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2666,col 42)-(line 2666,col 42)","literalExprId":56,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2666,col 48)-(line 2666,col 48)","literalExprId":57,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2667,col 36)-(line 2667,col 36)","literalExprId":58,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2667,col 40)-(line 2667,col 41)","literalExprId":59,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2667,col 46)-(line 2667,col 46)","literalExprId":60,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2668,col 36)-(line 2668,col 36)","literalExprId":61,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2668,col 42)-(line 2668,col 42)","literalExprId":62,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2668,col 48)-(line 2668,col 48)","literalExprId":63,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2668,col 52)-(line 2668,col 53)","literalExprId":64,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2670,col 34)-(line 2670,col 34)","literalExprId":65,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2671,col 34)-(line 2671,col 34)","literalExprId":66,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2672,col 34)-(line 2672,col 34)","literalExprId":67,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2673,col 34)-(line 2673,col 34)","literalExprId":68,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2674,col 34)-(line 2674,col 34)","literalExprId":69,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2675,col 35)-(line 2675,col 35)","literalExprId":70,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2676,col 35)-(line 2676,col 35)","literalExprId":71,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2679,col 31)-(line 2679,col 32)","literalExprId":72,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2680,col 20)-(line 2680,col 20)","literalExprId":73,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2684,col 36)-(line 2684,col 36)","literalExprId":74,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2684,col 51)-(line 2684,col 51)","literalExprId":75,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2684,col 67)-(line 2684,col 67)","literalExprId":76,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2685,col 36)-(line 2685,col 36)","literalExprId":77,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2685,col 52)-(line 2685,col 52)","literalExprId":78,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2686,col 36)-(line 2686,col 36)","literalExprId":79,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2686,col 42)-(line 2686,col 42)","literalExprId":80,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2686,col 48)-(line 2686,col 48)","literalExprId":81,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2686,col 63)-(line 2686,col 63)","literalExprId":82,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2687,col 36)-(line 2687,col 36)","literalExprId":83,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2687,col 42)-(line 2687,col 42)","literalExprId":84,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2687,col 57)-(line 2687,col 57)","literalExprId":85,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2688,col 36)-(line 2688,col 36)","literalExprId":86,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2688,col 40)-(line 2688,col 41)","literalExprId":87,"literalExpr":"22","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2688,col 46)-(line 2688,col 46)","literalExprId":88,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2689,col 36)-(line 2689,col 36)","literalExprId":89,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2689,col 42)-(line 2689,col 42)","literalExprId":90,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2689,col 48)-(line 2689,col 48)","literalExprId":91,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2689,col 52)-(line 2689,col 53)","literalExprId":92,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2699,col 34)-(line 2699,col 34)","literalExprId":93,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2700,col 34)-(line 2700,col 34)","literalExprId":94,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2701,col 34)-(line 2701,col 34)","literalExprId":95,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2702,col 34)-(line 2702,col 34)","literalExprId":96,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2703,col 34)-(line 2703,col 34)","literalExprId":97,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2704,col 35)-(line 2704,col 35)","literalExprId":98,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2705,col 35)-(line 2705,col 35)","literalExprId":99,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2719,col 32)-(line 2719,col 33)","literalExprId":100,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2720,col 32)-(line 2720,col 33)","literalExprId":101,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2722,col 20)-(line 2722,col 20)","literalExprId":102,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2722,col 27)-(line 2722,col 28)","literalExprId":103,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2727,col 12)-(line 2727,col 12)","literalExprId":104,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2727,col 20)-(line 2727,col 20)","literalExprId":105,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2727,col 26)-(line 2727,col 26)","literalExprId":106,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2728,col 12)-(line 2728,col 12)","literalExprId":107,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2728,col 20)-(line 2728,col 20)","literalExprId":108,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2728,col 26)-(line 2728,col 26)","literalExprId":109,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2731,col 18)-(line 2731,col 18)","literalExprId":110,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2731,col 24)-(line 2731,col 24)","literalExprId":111,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2737,col 20)-(line 2737,col 20)","literalExprId":112,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2737,col 27)-(line 2737,col 29)","literalExprId":113,"literalExpr":"200","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2742,col 12)-(line 2742,col 12)","literalExprId":114,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2742,col 20)-(line 2742,col 20)","literalExprId":115,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2742,col 26)-(line 2742,col 26)","literalExprId":116,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2742,col 30)-(line 2742,col 30)","literalExprId":117,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2743,col 12)-(line 2743,col 12)","literalExprId":118,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2743,col 20)-(line 2743,col 20)","literalExprId":119,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2743,col 26)-(line 2743,col 26)","literalExprId":120,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2743,col 30)-(line 2743,col 30)","literalExprId":121,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2748,col 18)-(line 2748,col 18)","literalExprId":122,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2748,col 24)-(line 2748,col 24)","literalExprId":123,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2758,col 34)-(line 2758,col 34)","literalExprId":124,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2758,col 37)-(line 2758,col 37)","literalExprId":125,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2758,col 40)-(line 2758,col 40)","literalExprId":126,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2760,col 34)-(line 2760,col 34)","literalExprId":127,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2760,col 37)-(line 2760,col 37)","literalExprId":128,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2760,col 40)-(line 2760,col 40)","literalExprId":129,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2760,col 43)-(line 2760,col 43)","literalExprId":130,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2761,col 34)-(line 2761,col 34)","literalExprId":131,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2775,col 35)-(line 2775,col 35)","literalExprId":132,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2775,col 38)-(line 2775,col 38)","literalExprId":133,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2775,col 41)-(line 2775,col 41)","literalExprId":134,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2775,col 44)-(line 2775,col 44)","literalExprId":135,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2776,col 35)-(line 2776,col 35)","literalExprId":136,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2776,col 38)-(line 2776,col 38)","literalExprId":137,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2776,col 41)-(line 2776,col 41)","literalExprId":138,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2776,col 44)-(line 2776,col 44)","literalExprId":139,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2776,col 47)-(line 2776,col 47)","literalExprId":140,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2777,col 35)-(line 2777,col 35)","literalExprId":141,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2777,col 38)-(line 2777,col 38)","literalExprId":142,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2777,col 41)-(line 2777,col 41)","literalExprId":143,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2777,col 44)-(line 2777,col 44)","literalExprId":144,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2777,col 47)-(line 2777,col 47)","literalExprId":145,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2778,col 35)-(line 2778,col 35)","literalExprId":146,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2778,col 38)-(line 2778,col 38)","literalExprId":147,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2778,col 41)-(line 2778,col 41)","literalExprId":148,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2778,col 44)-(line 2778,col 44)","literalExprId":149,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2778,col 47)-(line 2778,col 47)","literalExprId":150,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2779,col 35)-(line 2779,col 35)","literalExprId":151,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2779,col 38)-(line 2779,col 38)","literalExprId":152,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2779,col 41)-(line 2779,col 41)","literalExprId":153,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2779,col 44)-(line 2779,col 44)","literalExprId":154,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2779,col 47)-(line 2779,col 47)","literalExprId":155,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2780,col 35)-(line 2780,col 35)","literalExprId":156,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2780,col 38)-(line 2780,col 38)","literalExprId":157,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2780,col 41)-(line 2780,col 41)","literalExprId":158,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2780,col 44)-(line 2780,col 44)","literalExprId":159,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2790,col 44)-(line 2790,col 44)","literalExprId":160,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2791,col 44)-(line 2791,col 44)","literalExprId":161,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2792,col 43)-(line 2792,col 43)","literalExprId":162,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2793,col 43)-(line 2793,col 43)","literalExprId":163,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2794,col 43)-(line 2794,col 43)","literalExprId":164,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2795,col 43)-(line 2795,col 43)","literalExprId":165,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2796,col 43)-(line 2796,col 43)","literalExprId":166,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2797,col 43)-(line 2797,col 43)","literalExprId":167,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2798,col 44)-(line 2798,col 44)","literalExprId":168,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2799,col 44)-(line 2799,col 44)","literalExprId":169,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2800,col 43)-(line 2800,col 43)","literalExprId":170,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2801,col 43)-(line 2801,col 43)","literalExprId":171,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2802,col 43)-(line 2802,col 43)","literalExprId":172,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2803,col 43)-(line 2803,col 43)","literalExprId":173,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2804,col 43)-(line 2804,col 43)","literalExprId":174,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2805,col 43)-(line 2805,col 43)","literalExprId":175,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2806,col 43)-(line 2806,col 43)","literalExprId":176,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2807,col 43)-(line 2807,col 43)","literalExprId":177,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2808,col 43)-(line 2808,col 43)","literalExprId":178,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2809,col 43)-(line 2809,col 43)","literalExprId":179,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2810,col 43)-(line 2810,col 43)","literalExprId":180,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2811,col 43)-(line 2811,col 43)","literalExprId":181,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2825,col 32)-(line 2825,col 33)","literalExprId":182,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2826,col 32)-(line 2826,col 33)","literalExprId":183,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2828,col 20)-(line 2828,col 20)","literalExprId":184,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2831,col 20)-(line 2831,col 20)","literalExprId":185,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2834,col 22)-(line 2834,col 22)","literalExprId":186,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2838,col 12)-(line 2838,col 12)","literalExprId":187,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2848,col 35)-(line 2848,col 35)","literalExprId":188,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2848,col 38)-(line 2848,col 38)","literalExprId":189,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2848,col 41)-(line 2848,col 42)","literalExprId":190,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2850,col 35)-(line 2850,col 35)","literalExprId":191,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2851,col 35)-(line 2851,col 36)","literalExprId":192,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2852,col 35)-(line 2852,col 35)","literalExprId":193,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2852,col 38)-(line 2852,col 39)","literalExprId":194,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2852,col 42)-(line 2852,col 43)","literalExprId":195,"literalExpr":"15","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2852,col 46)-(line 2852,col 47)","literalExprId":196,"literalExpr":"20","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2853,col 35)-(line 2853,col 36)","literalExprId":197,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2853,col 39)-(line 2853,col 40)","literalExprId":198,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2853,col 43)-(line 2853,col 44)","literalExprId":199,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2853,col 47)-(line 2853,col 48)","literalExprId":200,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2853,col 51)-(line 2853,col 52)","literalExprId":201,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2853,col 55)-(line 2853,col 55)","literalExprId":202,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testFuzzyFloat()"},{"javadocBlockTags":[],"methodDeclaration":" void initialize_f1_and_f2(int j, double[] f1, double[] f2)","methodAccessSpecifier":"NONE","methodBody":"{\n    for (int i = 0; i < f1.length; i++) {\n        f1[i] = j + i * 10;\n        f2[i] = j + i * 10;\n    }\n    for (int i = 10; i < f2.length; i++) {\n        f2[i] = j + (i - 10) * 10;\n    }\n}","methodRange":"(line 2866,col 3)-(line 2879,col 3)","methodTokenRange":"@SuppressWarnings(\"index\") \/\/ length of f1 is exactly 10, length of f2 is exactly 20\n  void initialize_f1_and_f2(int j, double[] f1, double[] f2) {\n\n    \/\/start two arrays out exactly equal\n    for (int i = 0; i < f1.length; i++) {\n      f1[i] = j + i * 10;\n      f2[i] = j + i * 10;\n    }\n\n    \/\/fill out the second half of f2 with dup of f1\n    for (int i = 10; i < f2.length; i++) {\n      f2[i] = j + (i - 10) * 10;\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Initialize f2 to be the same as two copies of f1 ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int j","parameterName":"j"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] f1","parameterName":"f1"},{"parameterType":"double[]","parameterId":3,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] f2","parameterName":"f2"}],"methodName":"initialize_f1_and_f2","methodQualifiedSignature":"plume.TestPlume.initialize_f1_and_f2","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Initialize f2 to be the same as two copies of f1'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2866,col 21)-(line 2866,col 27)","literalExprId":1,"literalExpr":"\"index\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2870,col 18)-(line 2870,col 18)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2871,col 23)-(line 2871,col 24)","literalExprId":3,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2872,col 23)-(line 2872,col 24)","literalExprId":4,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2876,col 18)-(line 2876,col 19)","literalExprId":5,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2877,col 24)-(line 2877,col 25)","literalExprId":6,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2877,col 30)-(line 2877,col 31)","literalExprId":7,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.initialize_f1_and_f2(int, double[], double[])"},{"javadocBlockTags":[],"methodDeclaration":"public void test_create_combinations()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Object a = new Object();\n    Object b = new Object();\n    Object c = new Object();\n    List<Object> a_list = Arrays.<Object>asList(new Object[] { a });\n    List<Object> b_list = Arrays.<Object>asList(new Object[] { b });\n    List<Object> c_list = Arrays.<Object>asList(new Object[] { c });\n    List<Object> aa = Arrays.<Object>asList(new Object[] { a, a });\n    List<Object> bb = Arrays.<Object>asList(new Object[] { b, b });\n    List<Object> cc = Arrays.<Object>asList(new Object[] { c, c });\n    List<Object> ab = Arrays.<Object>asList(new Object[] { a, b });\n    List<Object> ac = Arrays.<Object>asList(new Object[] { a, c });\n    List<Object> bc = Arrays.<Object>asList(new Object[] { b, c });\n    List<Object> abc = Arrays.asList(a, b, c);\n    List<List<Object>> combo1 = UtilMDE.create_combinations(1, 0, abc);\n    assert combo1.size() == 3;\n    assert combo1.contains(a_list);\n    assert combo1.contains(b_list);\n    assert combo1.contains(c_list);\n    List<List<Object>> combo2 = UtilMDE.create_combinations(2, 0, abc);\n    assert combo2.size() == 6;\n    assert combo2.contains(aa);\n    assert combo2.contains(ab);\n    assert combo2.contains(ac);\n    assert combo2.contains(bb);\n    assert combo2.contains(bc);\n    assert combo2.contains(cc);\n    Integer i0 = new Integer(0);\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n    List<ArrayList<Integer>> combo3 = UtilMDE.create_combinations(1, 0, 2);\n    assert combo3.size() == 3;\n    assert combo3.contains(Arrays.asList(new Integer[] { i0 }));\n    assert combo3.contains(Arrays.asList(new Integer[] { i1 }));\n    assert combo3.contains(Arrays.asList(new Integer[] { i2 }));\n    List<ArrayList<Integer>> combo4 = UtilMDE.create_combinations(2, 0, 2);\n    assert combo4.size() == 6;\n    assert combo4.contains(Arrays.asList(new Integer[] { i0, i0 }));\n    assert combo4.contains(Arrays.asList(new Integer[] { i0, i1 }));\n    assert combo4.contains(Arrays.asList(new Integer[] { i0, i2 }));\n    assert combo4.contains(Arrays.asList(new Integer[] { i1, i1 }));\n    assert combo4.contains(Arrays.asList(new Integer[] { i1, i2 }));\n    assert combo4.contains(Arrays.asList(new Integer[] { i2, i2 }));\n}","methodRange":"(line 2884,col 3)-(line 2936,col 3)","methodTokenRange":"@Test\n  public void test_create_combinations() {\n\n    \/\/ public static List create_combinations (int dims, int start, List objs)\n    Object a = new Object();\n    Object b = new Object();\n    Object c = new Object();\n    List<Object> a_list = Arrays.<Object>asList(new Object[] {a});\n    List<Object> b_list = Arrays.<Object>asList(new Object[] {b});\n    List<Object> c_list = Arrays.<Object>asList(new Object[] {c});\n    List<Object> aa = Arrays.<Object>asList(new Object[] {a, a});\n    List<Object> bb = Arrays.<Object>asList(new Object[] {b, b});\n    List<Object> cc = Arrays.<Object>asList(new Object[] {c, c});\n    List<Object> ab = Arrays.<Object>asList(new Object[] {a, b});\n    List<Object> ac = Arrays.<Object>asList(new Object[] {a, c});\n    List<Object> bc = Arrays.<Object>asList(new Object[] {b, c});\n\n    List<Object> abc = Arrays.asList(a, b, c);\n    List<List<Object>> combo1 = UtilMDE.create_combinations(1, 0, abc);\n    assert combo1.size() == 3;\n    assert combo1.contains(a_list);\n    assert combo1.contains(b_list);\n    assert combo1.contains(c_list);\n\n    List<List<Object>> combo2 = UtilMDE.create_combinations(2, 0, abc);\n    assert combo2.size() == 6;\n    assert combo2.contains(aa);\n    assert combo2.contains(ab);\n    assert combo2.contains(ac);\n    assert combo2.contains(bb);\n    assert combo2.contains(bc);\n    assert combo2.contains(cc);\n\n    \/\/ public static List create_combinations (int arity, int start, int cnt)\n    Integer i0 = new Integer(0);\n    Integer i1 = new Integer(1);\n    Integer i2 = new Integer(2);\n\n    List<ArrayList<Integer>> combo3 = UtilMDE.create_combinations(1, 0, 2);\n    assert combo3.size() == 3;\n    assert combo3.contains(Arrays.asList(new Integer[] {i0}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i1}));\n    assert combo3.contains(Arrays.asList(new Integer[] {i2}));\n\n    List<ArrayList<Integer>> combo4 = UtilMDE.create_combinations(2, 0, 2);\n    assert combo4.size() == 6;\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i0}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i0, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i1}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i1, i2}));\n    assert combo4.contains(Arrays.asList(new Integer[] {i2, i2}));\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Tests UtilMDE create_combinations routines.\n   ","methodParameters":[],"methodName":"test_create_combinations","methodQualifiedSignature":"plume.TestPlume.test_create_combinations","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests UtilMDE create_combinations routines.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2902,col 61)-(line 2902,col 61)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2902,col 64)-(line 2902,col 64)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2903,col 29)-(line 2903,col 29)","literalExprId":3,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2908,col 61)-(line 2908,col 61)","literalExprId":4,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2908,col 64)-(line 2908,col 64)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2909,col 29)-(line 2909,col 29)","literalExprId":6,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2918,col 30)-(line 2918,col 30)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2919,col 30)-(line 2919,col 30)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2920,col 30)-(line 2920,col 30)","literalExprId":9,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2922,col 67)-(line 2922,col 67)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2922,col 70)-(line 2922,col 70)","literalExprId":11,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2922,col 73)-(line 2922,col 73)","literalExprId":12,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2923,col 29)-(line 2923,col 29)","literalExprId":13,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2928,col 67)-(line 2928,col 67)","literalExprId":14,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2928,col 70)-(line 2928,col 70)","literalExprId":15,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2928,col 73)-(line 2928,col 73)","literalExprId":16,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 2929,col 29)-(line 2929,col 29)","literalExprId":17,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.test_create_combinations()"},{"methodDeclaration":"public void test_fullyQualifiedNameToSimpleName()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"java.lang.String\").equals(\"String\");\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"String\").equals(\"String\");\n}","methodRange":"(line 2938,col 3)-(line 2943,col 3)","methodTokenRange":"@Test\n  public void test_fullyQualifiedNameToSimpleName() {\n\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"java.lang.String\").equals(\"String\");\n    assert UtilMDE.fullyQualifiedNameToSimpleName(\"String\").equals(\"String\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"test_fullyQualifiedNameToSimpleName","methodQualifiedSignature":"plume.TestPlume.test_fullyQualifiedNameToSimpleName","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2941,col 51)-(line 2941,col 68)","literalExprId":1,"literalExpr":"\"java.lang.String\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2941,col 78)-(line 2941,col 85)","literalExprId":2,"literalExpr":"\"String\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2942,col 51)-(line 2942,col 58)","literalExprId":3,"literalExpr":"\"String\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2942,col 68)-(line 2942,col 75)","literalExprId":4,"literalExpr":"\"String\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.test_fullyQualifiedNameToSimpleName()"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is an illegal argument","javadocBlockTagName":"ArgException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is an illegal argument'}]}', name=Optional[ArgException]}"}],"methodDeclaration":"public void testOptions() throws ArgException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TestOptions t = new TestOptions();\n    Options options = new Options(\"test\", t);\n    options.parse(new String[] { \"--lp=foo\", \"--lp\", \"bar\", \"-i\", \"24\", \"-d=37.8\", \"-b\", \"-b=false\", \"--ld\", \"34.6\", \"--ld\", \"17.8\" });\n    assert t.lp.get(0).toString().equals(\"foo\");\n    assert t.lp.get(1).toString().equals(\"bar\");\n    assert t.integer_reference != null && t.integer_reference.intValue() == 24;\n    assert t.temperature == 37.8;\n    assert t.bool == false;\n    assert t.ld.get(0).doubleValue() == 34.6;\n    assert t.ld.get(1).doubleValue() == 17.8;\n    t.bool = false;\n    String[] args = options.parse(new String[] { \"one\", \"two\", \"three\", \"-b\" });\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"three\") : args[2];\n    assert t.bool;\n    t.bool = false;\n    args = options.parse(new String[] { \"--\", \"one\", \"two\", \"-b\" });\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"-b\") : args[2];\n    assert !t.bool;\n    t.ld.clear();\n    Options.split_lists = true;\n    args = options.parse(new String[] { \"--ld\", \"42.1 9.3 10.5\", \"--ld\", \"2.7\" });\n    assert args.length == 0;\n    assert t.ld.size() == 4;\n    assert t.ld.get(0).doubleValue() == 42.1;\n    assert t.ld.get(1).doubleValue() == 9.3;\n    assert t.ld.get(2).doubleValue() == 10.5;\n    assert t.ld.get(3).doubleValue() == 2.7;\n    args = options.parse(new String[] { \"--ls\", \"hello\", \"--ls\", \"world\" });\n    assert args.length == 0;\n    assert t.ls != null : \"@AssumeAssertion(nullness)\";\n    assert t.ls.size() == 2;\n    assert t.ls.get(0).equals(\"hello\");\n    assert t.ls.get(1).equals(\"world\");\n}","methodRange":"(line 2984,col 3)-(line 3046,col 3)","methodTokenRange":"@Test\n  public void testOptions() throws ArgException {\n\n    TestOptions t = new TestOptions();\n    Options options = new Options(\"test\", t);\n    options.parse(\n        new String[] {\n          \"--lp=foo\",\n          \"--lp\",\n          \"bar\",\n          \"-i\",\n          \"24\",\n          \"-d=37.8\",\n          \"-b\",\n          \"-b=false\",\n          \"--ld\",\n          \"34.6\",\n          \"--ld\",\n          \"17.8\",\n        });\n    assert t.lp.get(0).toString().equals(\"foo\");\n    assert t.lp.get(1).toString().equals(\"bar\");\n    assert t.integer_reference != null && t.integer_reference.intValue() == 24;\n    assert t.temperature == 37.8;\n    assert t.bool == false;\n    assert t.ld.get(0).doubleValue() == 34.6;\n    assert t.ld.get(1).doubleValue() == 17.8;\n\n    \/\/ Test non-options\n    t.bool = false;\n    String[] args = options.parse(new String[] {\"one\", \"two\", \"three\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"three\") : args[2];\n    assert t.bool;\n\n    \/\/ Test --\n    t.bool = false;\n    args = options.parse(new String[] {\"--\", \"one\", \"two\", \"-b\"});\n    assert args[0].equals(\"one\") : args[0];\n    assert args[1].equals(\"two\") : args[1];\n    assert args[2].equals(\"-b\") : args[2];\n    assert !t.bool;\n\n    \/\/ Test split_lists\n    t.ld.clear();\n    Options.split_lists = true;\n    args = options.parse(new String[] {\"--ld\", \"42.1 9.3 10.5\", \"--ld\", \"2.7\"});\n    assert args.length == 0;\n    assert t.ld.size() == 4;\n    assert t.ld.get(0).doubleValue() == 42.1;\n    assert t.ld.get(1).doubleValue() == 9.3;\n    assert t.ld.get(2).doubleValue() == 10.5;\n    assert t.ld.get(3).doubleValue() == 2.7;\n\n    \/\/ Test list with no default\n    args = options.parse(new String[] {\"--ls\", \"hello\", \"--ls\", \"world\"});\n    assert args.length == 0;\n    assert t.ls != null : \"@AssumeAssertion(nullness)\";\n    assert t.ls.size() == 2;\n    assert t.ls.get(0).equals(\"hello\");\n    assert t.ls.get(1).equals(\"world\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Test command line option parsing (Options).\n   * @throws ArgException if there is an illegal argument\n   ","methodParameters":[],"methodName":"testOptions","methodQualifiedSignature":"plume.TestPlume.testOptions","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test command line option parsing (Options).'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is an illegal argument'}]}', name=Optional[ArgException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 2988,col 35)-(line 2988,col 40)","literalExprId":1,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2991,col 11)-(line 2991,col 20)","literalExprId":2,"literalExpr":"\"--lp=foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2992,col 11)-(line 2992,col 16)","literalExprId":3,"literalExpr":"\"--lp\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2993,col 11)-(line 2993,col 15)","literalExprId":4,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2994,col 11)-(line 2994,col 14)","literalExprId":5,"literalExpr":"\"-i\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2995,col 11)-(line 2995,col 14)","literalExprId":6,"literalExpr":"\"24\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2996,col 11)-(line 2996,col 19)","literalExprId":7,"literalExpr":"\"-d=37.8\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2997,col 11)-(line 2997,col 14)","literalExprId":8,"literalExpr":"\"-b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2998,col 11)-(line 2998,col 20)","literalExprId":9,"literalExpr":"\"-b=false\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 2999,col 11)-(line 2999,col 16)","literalExprId":10,"literalExpr":"\"--ld\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3000,col 11)-(line 3000,col 16)","literalExprId":11,"literalExpr":"\"34.6\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3001,col 11)-(line 3001,col 16)","literalExprId":12,"literalExpr":"\"--ld\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3002,col 11)-(line 3002,col 16)","literalExprId":13,"literalExpr":"\"17.8\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3004,col 21)-(line 3004,col 21)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3004,col 42)-(line 3004,col 46)","literalExprId":15,"literalExpr":"\"foo\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3005,col 21)-(line 3005,col 21)","literalExprId":16,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3005,col 42)-(line 3005,col 46)","literalExprId":17,"literalExpr":"\"bar\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3006,col 35)-(line 3006,col 38)","literalExprId":18,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3006,col 77)-(line 3006,col 78)","literalExprId":19,"literalExpr":"24","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3007,col 29)-(line 3007,col 32)","literalExprId":20,"literalExpr":"37.8","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3008,col 22)-(line 3008,col 26)","literalExprId":21,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3009,col 21)-(line 3009,col 21)","literalExprId":22,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3009,col 41)-(line 3009,col 44)","literalExprId":23,"literalExpr":"34.6","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3010,col 21)-(line 3010,col 21)","literalExprId":24,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3010,col 41)-(line 3010,col 44)","literalExprId":25,"literalExpr":"17.8","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3013,col 14)-(line 3013,col 18)","literalExprId":26,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3014,col 49)-(line 3014,col 53)","literalExprId":27,"literalExpr":"\"one\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3014,col 56)-(line 3014,col 60)","literalExprId":28,"literalExpr":"\"two\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3014,col 63)-(line 3014,col 69)","literalExprId":29,"literalExpr":"\"three\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3014,col 72)-(line 3014,col 75)","literalExprId":30,"literalExpr":"\"-b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3015,col 17)-(line 3015,col 17)","literalExprId":31,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3015,col 27)-(line 3015,col 31)","literalExprId":32,"literalExpr":"\"one\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3015,col 41)-(line 3015,col 41)","literalExprId":33,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3016,col 17)-(line 3016,col 17)","literalExprId":34,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3016,col 27)-(line 3016,col 31)","literalExprId":35,"literalExpr":"\"two\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3016,col 41)-(line 3016,col 41)","literalExprId":36,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3017,col 17)-(line 3017,col 17)","literalExprId":37,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3017,col 27)-(line 3017,col 33)","literalExprId":38,"literalExpr":"\"three\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3017,col 43)-(line 3017,col 43)","literalExprId":39,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3021,col 14)-(line 3021,col 18)","literalExprId":40,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3022,col 40)-(line 3022,col 43)","literalExprId":41,"literalExpr":"\"--\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3022,col 46)-(line 3022,col 50)","literalExprId":42,"literalExpr":"\"one\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3022,col 53)-(line 3022,col 57)","literalExprId":43,"literalExpr":"\"two\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3022,col 60)-(line 3022,col 63)","literalExprId":44,"literalExpr":"\"-b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3023,col 17)-(line 3023,col 17)","literalExprId":45,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3023,col 27)-(line 3023,col 31)","literalExprId":46,"literalExpr":"\"one\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3023,col 41)-(line 3023,col 41)","literalExprId":47,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3024,col 17)-(line 3024,col 17)","literalExprId":48,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3024,col 27)-(line 3024,col 31)","literalExprId":49,"literalExpr":"\"two\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3024,col 41)-(line 3024,col 41)","literalExprId":50,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3025,col 17)-(line 3025,col 17)","literalExprId":51,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3025,col 27)-(line 3025,col 30)","literalExprId":52,"literalExpr":"\"-b\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3025,col 40)-(line 3025,col 40)","literalExprId":53,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3030,col 27)-(line 3030,col 30)","literalExprId":54,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3031,col 40)-(line 3031,col 45)","literalExprId":55,"literalExpr":"\"--ld\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3031,col 48)-(line 3031,col 62)","literalExprId":56,"literalExpr":"\"42.1 9.3 10.5\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3031,col 65)-(line 3031,col 70)","literalExprId":57,"literalExpr":"\"--ld\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3031,col 73)-(line 3031,col 77)","literalExprId":58,"literalExpr":"\"2.7\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3032,col 27)-(line 3032,col 27)","literalExprId":59,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3033,col 27)-(line 3033,col 27)","literalExprId":60,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3034,col 21)-(line 3034,col 21)","literalExprId":61,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3034,col 41)-(line 3034,col 44)","literalExprId":62,"literalExpr":"42.1","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3035,col 21)-(line 3035,col 21)","literalExprId":63,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3035,col 41)-(line 3035,col 43)","literalExprId":64,"literalExpr":"9.3","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3036,col 21)-(line 3036,col 21)","literalExprId":65,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3036,col 41)-(line 3036,col 44)","literalExprId":66,"literalExpr":"10.5","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3037,col 21)-(line 3037,col 21)","literalExprId":67,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3037,col 41)-(line 3037,col 43)","literalExprId":68,"literalExpr":"2.7","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3040,col 40)-(line 3040,col 45)","literalExprId":69,"literalExpr":"\"--ls\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3040,col 48)-(line 3040,col 54)","literalExprId":70,"literalExpr":"\"hello\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3040,col 57)-(line 3040,col 62)","literalExprId":71,"literalExpr":"\"--ls\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3040,col 65)-(line 3040,col 71)","literalExprId":72,"literalExpr":"\"world\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3041,col 27)-(line 3041,col 27)","literalExprId":73,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3042,col 20)-(line 3042,col 23)","literalExprId":74,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3042,col 27)-(line 3042,col 54)","literalExprId":75,"literalExpr":"\"@AssumeAssertion(nullness)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3043,col 27)-(line 3043,col 27)","literalExprId":76,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3044,col 21)-(line 3044,col 21)","literalExprId":77,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3044,col 31)-(line 3044,col 37)","literalExprId":78,"literalExpr":"\"hello\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3045,col 21)-(line 3045,col 21)","literalExprId":79,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3045,col 31)-(line 3045,col 37)","literalExprId":80,"literalExpr":"\"world\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testOptions()"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is an illegal argument","javadocBlockTagName":"ArgException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is an illegal argument'}]}', name=Optional[ArgException]}"}],"methodDeclaration":"public void testOptionsAliases() throws ArgException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    TestOptionsAliases t = new TestOptionsAliases();\n    Options options = new Options(\"test\", t);\n    options.parse(new String[] { \"-d\", \"Monday\", \"-temp\", \"-12.3\" });\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n    options.parse(\"-d Monday -temp -12.3\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n    options.parse(new String[] { \"-t\", \"21.7\", \"-version\" });\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n    options.parse(\"-t 21.7 -version\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n    t.printVersion = false;\n    options.parse(new String[] { \"--version\", \"-temp=-60.1\", \"--day\", \"Tuesday\" });\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n    t.printVersion = false;\n    options.parse(\"--version -temp=-60.1 --day Tuesday\");\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n}","methodRange":"(line 3070,col 3)-(line 3106,col 3)","methodTokenRange":"@Test\n  public void testOptionsAliases() throws ArgException {\n    TestOptionsAliases t = new TestOptionsAliases();\n    Options options = new Options(\"test\", t);\n\n    options.parse(new String[] {\"-d\", \"Monday\", \"-temp\", \"-12.3\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(\"-d Monday -temp -12.3\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == -12.3;\n    assert !t.printVersion;\n\n    options.parse(new String[] {\"-t\", \"21.7\", \"-version\"});\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    options.parse(\"-t 21.7 -version\");\n    assert t.day.equals(\"Monday\");\n    assert t.temperature == 21.7;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(new String[] {\"--version\", \"-temp=-60.1\", \"--day\", \"Tuesday\"});\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n\n    t.printVersion = false;\n    options.parse(\"--version -temp=-60.1 --day Tuesday\");\n    assert t.day.equals(\"Tuesday\");\n    assert t.temperature == -60.1;\n    assert t.printVersion;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Test option aliases (Options).\n   * @throws ArgException if there is an illegal argument\n   ","methodParameters":[],"methodName":"testOptionsAliases","methodQualifiedSignature":"plume.TestPlume.testOptionsAliases","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test option aliases (Options).'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is an illegal argument'}]}', name=Optional[ArgException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3073,col 35)-(line 3073,col 40)","literalExprId":1,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3075,col 33)-(line 3075,col 36)","literalExprId":2,"literalExpr":"\"-d\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3075,col 39)-(line 3075,col 46)","literalExprId":3,"literalExpr":"\"Monday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3075,col 49)-(line 3075,col 55)","literalExprId":4,"literalExpr":"\"-temp\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3075,col 58)-(line 3075,col 64)","literalExprId":5,"literalExpr":"\"-12.3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3076,col 25)-(line 3076,col 32)","literalExprId":6,"literalExpr":"\"Monday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3077,col 30)-(line 3077,col 33)","literalExprId":7,"literalExpr":"12.3","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3080,col 19)-(line 3080,col 41)","literalExprId":8,"literalExpr":"\"-d Monday -temp -12.3\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3081,col 25)-(line 3081,col 32)","literalExprId":9,"literalExpr":"\"Monday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3082,col 30)-(line 3082,col 33)","literalExprId":10,"literalExpr":"12.3","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3085,col 33)-(line 3085,col 36)","literalExprId":11,"literalExpr":"\"-t\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3085,col 39)-(line 3085,col 44)","literalExprId":12,"literalExpr":"\"21.7\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3085,col 47)-(line 3085,col 56)","literalExprId":13,"literalExpr":"\"-version\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3086,col 25)-(line 3086,col 32)","literalExprId":14,"literalExpr":"\"Monday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3087,col 29)-(line 3087,col 32)","literalExprId":15,"literalExpr":"21.7","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3090,col 19)-(line 3090,col 36)","literalExprId":16,"literalExpr":"\"-t 21.7 -version\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3091,col 25)-(line 3091,col 32)","literalExprId":17,"literalExpr":"\"Monday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3092,col 29)-(line 3092,col 32)","literalExprId":18,"literalExpr":"21.7","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3095,col 22)-(line 3095,col 26)","literalExprId":19,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3096,col 33)-(line 3096,col 43)","literalExprId":20,"literalExpr":"\"--version\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3096,col 46)-(line 3096,col 58)","literalExprId":21,"literalExpr":"\"-temp=-60.1\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3096,col 61)-(line 3096,col 67)","literalExprId":22,"literalExpr":"\"--day\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3096,col 70)-(line 3096,col 78)","literalExprId":23,"literalExpr":"\"Tuesday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3097,col 25)-(line 3097,col 33)","literalExprId":24,"literalExpr":"\"Tuesday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3098,col 30)-(line 3098,col 33)","literalExprId":25,"literalExpr":"60.1","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3101,col 22)-(line 3101,col 26)","literalExprId":26,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3102,col 19)-(line 3102,col 55)","literalExprId":27,"literalExpr":"\"--version -temp=-60.1 --day Tuesday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3103,col 25)-(line 3103,col 33)","literalExprId":28,"literalExpr":"\"Tuesday\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3104,col 30)-(line 3104,col 33)","literalExprId":29,"literalExpr":"60.1","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testOptionsAliases()"},{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is an illegal argument","javadocBlockTagName":"ArgException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is an illegal argument'}]}', name=Optional[ArgException]}"}],"methodDeclaration":"public void testOptionGroups() throws ArgException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        Options options = new Options(\"test\", TestOptionGroups1.class);\n    } catch (Error e) {\n        assert e.getMessage() != null && e.getMessage().indexOf(\"missing @OptionGroup annotation on the first @Option-annotated field\") > -1;\n    }\n    try {\n        Options options = new Options(\"test\", TestOptionGroups2.class, TestOptionGroups1.class);\n    } catch (Error e) {\n        assert e.getMessage() != null && e.getMessage().indexOf(\"missing @OptionGroup annotation in field\") > -1;\n    }\n    Options options = new Options(\"test\", TestOptionGroups2.class);\n    assert options.usage().indexOf(\"General options\") > -1;\n    assert options.usage().indexOf(\"Display options\") > -1;\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    assert options.usage(\"Internal options\").indexOf(\"Set mu\") > -1;\n    assert options.usage(\"Internal options\").indexOf(\"Set pi\") == -1;\n    options.parse(new String[] { \"--colour\", \"--pi\", \"3.15\" });\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n    options.parse(\"--colour --pi 3.15\");\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n    Options options2 = new Options(\"test\", TestOptionGroups3.class);\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    assert options.usage(true).indexOf(\"Internal options\") > -1;\n}","methodRange":"(line 3179,col 3)-(line 3226,col 3)","methodTokenRange":"@Test\n  public void testOptionGroups() throws ArgException {\n    \/\/ TODO: The following two exception tests are not adequate.  There must be\n    \/\/ a better way to do these.\n    try {\n      Options options = new Options(\"test\", TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage()\n                  .indexOf(\"missing @OptionGroup annotation on the first @Option-annotated field\")\n              > -1;\n    }\n\n    try {\n      Options options = new Options(\"test\", TestOptionGroups2.class, TestOptionGroups1.class);\n    } catch (Error e) {\n      assert e.getMessage() != null\n          && e.getMessage().indexOf(\"missing @OptionGroup annotation in field\") > -1;\n    }\n\n    Options options = new Options(\"test\", TestOptionGroups2.class);\n\n    assert options.usage().indexOf(\"General options\") > -1;\n    assert options.usage().indexOf(\"Display options\") > -1;\n    \/\/ \"Internal options\" is unpublicized so it should not occur in the default\n    \/\/ usage message.\n    assert options.usage().indexOf(\"Internal options\") == -1;\n\n    assert options.usage(\"Internal options\").indexOf(\"Set mu\") > -1;\n    \/\/ \"Set pi\" should not appear in the usage message for \"Internal options\"\n    \/\/ because it is marked with @Unpublicized.\n    assert options.usage(\"Internal options\").indexOf(\"Set pi\") == -1;\n\n    options.parse(new String[] {\"--colour\", \"--pi\", \"3.15\"});\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    options.parse(\"--colour --pi 3.15\");\n    assert TestOptionGroups2.color;\n    assert TestOptionGroups2.pi == 3.15;\n\n    \/\/ Test that an option group that contains only unpublicized options is not\n    \/\/ included in the usage message.\n    Options options2 = new Options(\"test\", TestOptionGroups3.class);\n    assert options.usage().indexOf(\"Internal options\") == -1;\n    \/\/ ...unless include_unpublicized is true.\n    assert options.usage(true).indexOf(\"Internal options\") > -1;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Test option groups (Options).\n   * @throws ArgException if there is an illegal argument\n   ","methodParameters":[],"methodName":"testOptionGroups","methodQualifiedSignature":"plume.TestPlume.testOptionGroups","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Test option groups (Options).'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is an illegal argument'}]}', name=Optional[ArgException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3184,col 37)-(line 3184,col 42)","literalExprId":1,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3186,col 32)-(line 3186,col 35)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3188,col 28)-(line 3188,col 97)","literalExprId":3,"literalExpr":"\"missing @OptionGroup annotation on the first @Option-annotated field\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3189,col 18)-(line 3189,col 18)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3193,col 37)-(line 3193,col 42)","literalExprId":5,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3195,col 32)-(line 3195,col 35)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3196,col 37)-(line 3196,col 78)","literalExprId":7,"literalExpr":"\"missing @OptionGroup annotation in field\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3196,col 84)-(line 3196,col 84)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3199,col 35)-(line 3199,col 40)","literalExprId":9,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3201,col 36)-(line 3201,col 52)","literalExprId":10,"literalExpr":"\"General options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3201,col 58)-(line 3201,col 58)","literalExprId":11,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3202,col 36)-(line 3202,col 52)","literalExprId":12,"literalExpr":"\"Display options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3202,col 58)-(line 3202,col 58)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3205,col 36)-(line 3205,col 53)","literalExprId":14,"literalExpr":"\"Internal options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3205,col 60)-(line 3205,col 60)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3207,col 26)-(line 3207,col 43)","literalExprId":16,"literalExpr":"\"Internal options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3207,col 54)-(line 3207,col 61)","literalExprId":17,"literalExpr":"\"Set mu\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3207,col 67)-(line 3207,col 67)","literalExprId":18,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3210,col 26)-(line 3210,col 43)","literalExprId":19,"literalExpr":"\"Internal options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3210,col 54)-(line 3210,col 61)","literalExprId":20,"literalExpr":"\"Set pi\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3210,col 68)-(line 3210,col 68)","literalExprId":21,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3212,col 33)-(line 3212,col 42)","literalExprId":22,"literalExpr":"\"--colour\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3212,col 45)-(line 3212,col 50)","literalExprId":23,"literalExpr":"\"--pi\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3212,col 53)-(line 3212,col 58)","literalExprId":24,"literalExpr":"\"3.15\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3214,col 36)-(line 3214,col 39)","literalExprId":25,"literalExpr":"3.15","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3216,col 19)-(line 3216,col 38)","literalExprId":26,"literalExpr":"\"--colour --pi 3.15\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3218,col 36)-(line 3218,col 39)","literalExprId":27,"literalExpr":"3.15","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 3222,col 36)-(line 3222,col 41)","literalExprId":28,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3223,col 36)-(line 3223,col 53)","literalExprId":29,"literalExpr":"\"Internal options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3223,col 60)-(line 3223,col 60)","literalExprId":30,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3225,col 26)-(line 3225,col 29)","literalExprId":31,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 3225,col 40)-(line 3225,col 57)","literalExprId":32,"literalExpr":"\"Internal options\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3225,col 63)-(line 3225,col 63)","literalExprId":33,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testOptionGroups()"},{"methodDeclaration":"public void testOptionsEnums() throws ArgException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n    options.parse(new String[] { \"--firstPass\", \"SMART_RLE\" });\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n    options.parse(new String[] { \"--firstPass\", \"smart_rle\" });\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n    options.parse(new String[] { \"--firstPass\", \"smart-rle\" });\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    options.parse(new String[] { \"--firstPass\", \"rle\", \"--secondPass\", \"SMART-RLE\" });\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.SMART_RLE;\n    options.parse(new String[] { \"--secondPass\", \"Huffman\" });\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.HUFFMAN;\n}","methodRange":"(line 3242,col 3)-(line 3264,col 3)","methodTokenRange":"@Test\n  public void testOptionsEnums() throws ArgException {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n\n    options.parse(new String[] {\"--firstPass\", \"SMART_RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart_rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n    TestOptionsEnums.firstPass = TestOptionsEnums.Compressor.HUFFMAN;\n\n    options.parse(new String[] {\"--firstPass\", \"smart-rle\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--firstPass\", \"rle\", \"--secondPass\", \"SMART-RLE\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.SMART_RLE;\n\n    options.parse(new String[] {\"--secondPass\", \"Huffman\"});\n    assert TestOptionsEnums.firstPass == TestOptionsEnums.Compressor.RLE;\n    assert TestOptionsEnums.secondPass == TestOptionsEnums.Compressor.HUFFMAN;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testOptionsEnums","methodQualifiedSignature":"plume.TestPlume.testOptionsEnums","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3244,col 35)-(line 3244,col 40)","literalExprId":1,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3246,col 33)-(line 3246,col 45)","literalExprId":2,"literalExpr":"\"--firstPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3246,col 48)-(line 3246,col 58)","literalExprId":3,"literalExpr":"\"SMART_RLE\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3250,col 33)-(line 3250,col 45)","literalExprId":4,"literalExpr":"\"--firstPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3250,col 48)-(line 3250,col 58)","literalExprId":5,"literalExpr":"\"smart_rle\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3254,col 33)-(line 3254,col 45)","literalExprId":6,"literalExpr":"\"--firstPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3254,col 48)-(line 3254,col 58)","literalExprId":7,"literalExpr":"\"smart-rle\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3257,col 33)-(line 3257,col 45)","literalExprId":8,"literalExpr":"\"--firstPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3257,col 48)-(line 3257,col 52)","literalExprId":9,"literalExpr":"\"rle\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3257,col 55)-(line 3257,col 68)","literalExprId":10,"literalExpr":"\"--secondPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3257,col 71)-(line 3257,col 81)","literalExprId":11,"literalExpr":"\"SMART-RLE\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3261,col 33)-(line 3261,col 46)","literalExprId":12,"literalExpr":"\"--secondPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3261,col 49)-(line 3261,col 57)","literalExprId":13,"literalExpr":"\"Huffman\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testOptionsEnums()"},{"methodDeclaration":"public void testOptionsEnumsFail()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n    try {\n        options.parse(new String[] { \"--firstPass\", \"smartrle\" });\n        org.junit.Assert.fail(\"Didn't throw ArgException as expected\");\n    } catch (ArgException e) {\n    }\n}","methodRange":"(line 3266,col 3)-(line 3275,col 3)","methodTokenRange":"@Test\n  public void testOptionsEnumsFail() {\n    Options options = new Options(\"test\", TestOptionsEnums.class);\n    try {\n      \/\/ should fail: can not leave out _ or -\n      options.parse(new String[] {\"--firstPass\", \"smartrle\"});\n      org.junit.Assert.fail(\"Didn't throw ArgException as expected\");\n    } catch (ArgException e) {\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testOptionsEnumsFail","methodQualifiedSignature":"plume.TestPlume.testOptionsEnumsFail","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3268,col 35)-(line 3268,col 40)","literalExprId":1,"literalExpr":"\"test\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3271,col 35)-(line 3271,col 47)","literalExprId":2,"literalExpr":"\"--firstPass\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3271,col 50)-(line 3271,col 59)","literalExprId":3,"literalExpr":"\"smartrle\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3272,col 29)-(line 3272,col 67)","literalExprId":4,"literalExpr":"\"Didn't throw ArgException as expected\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testOptionsEnumsFail()"},{"methodDeclaration":"public void testSplitLines()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String str = \"one\\ntwo\\n\\rthree\\r\\nfour\\rfive\\n\\n\\nsix\\r\\n\\r\\n\\r\\n\";\n    String[] sa = UtilMDE.splitLines(str);\n    assert sa.length == 11;\n    assert sa[0].equals(\"one\");\n    assert sa[1].equals(\"two\");\n    assert sa[2].equals(\"three\");\n    assert sa[3].equals(\"four\");\n    assert sa[4].equals(\"five\");\n    assert sa[5].equals(\"\");\n    assert sa[6].equals(\"\");\n    assert sa[7].equals(\"six\");\n    assert sa[8].equals(\"\");\n    assert sa[9].equals(\"\");\n    assert sa[10].equals(\"\");\n}","methodRange":"(line 3277,col 3)-(line 3296,col 3)","methodTokenRange":"@Test\n  public void testSplitLines() {\n\n    String str = \"one\\ntwo\\n\\rthree\\r\\nfour\\rfive\\n\\n\\nsix\\r\\n\\r\\n\\r\\n\";\n    String[] sa = UtilMDE.splitLines(str);\n    \/\/ for (String s : sa)\n    \/\/   System.out.printf (\"'%s'%n\", s);\n    assert sa.length == 11;\n    assert sa[0].equals(\"one\");\n    assert sa[1].equals(\"two\");\n    assert sa[2].equals(\"three\");\n    assert sa[3].equals(\"four\");\n    assert sa[4].equals(\"five\");\n    assert sa[5].equals(\"\");\n    assert sa[6].equals(\"\");\n    assert sa[7].equals(\"six\");\n    assert sa[8].equals(\"\");\n    assert sa[9].equals(\"\");\n    assert sa[10].equals(\"\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testSplitLines","methodQualifiedSignature":"plume.TestPlume.testSplitLines","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3280,col 18)-(line 3280,col 71)","literalExprId":1,"literalExpr":"\"one\\ntwo\\n\\rthree\\r\\nfour\\rfive\\n\\n\\nsix\\r\\n\\r\\n\\r\\n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3284,col 25)-(line 3284,col 26)","literalExprId":2,"literalExpr":"11","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3285,col 15)-(line 3285,col 15)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3285,col 25)-(line 3285,col 29)","literalExprId":4,"literalExpr":"\"one\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3286,col 15)-(line 3286,col 15)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3286,col 25)-(line 3286,col 29)","literalExprId":6,"literalExpr":"\"two\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3287,col 15)-(line 3287,col 15)","literalExprId":7,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3287,col 25)-(line 3287,col 31)","literalExprId":8,"literalExpr":"\"three\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3288,col 15)-(line 3288,col 15)","literalExprId":9,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3288,col 25)-(line 3288,col 30)","literalExprId":10,"literalExpr":"\"four\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3289,col 15)-(line 3289,col 15)","literalExprId":11,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3289,col 25)-(line 3289,col 30)","literalExprId":12,"literalExpr":"\"five\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3290,col 15)-(line 3290,col 15)","literalExprId":13,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3290,col 25)-(line 3290,col 26)","literalExprId":14,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3291,col 15)-(line 3291,col 15)","literalExprId":15,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3291,col 25)-(line 3291,col 26)","literalExprId":16,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3292,col 15)-(line 3292,col 15)","literalExprId":17,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3292,col 25)-(line 3292,col 29)","literalExprId":18,"literalExpr":"\"six\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3293,col 15)-(line 3293,col 15)","literalExprId":19,"literalExpr":"8","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3293,col 25)-(line 3293,col 26)","literalExprId":20,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3294,col 15)-(line 3294,col 15)","literalExprId":21,"literalExpr":"9","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3294,col 25)-(line 3294,col 26)","literalExprId":22,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3295,col 15)-(line 3295,col 16)","literalExprId":23,"literalExpr":"10","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3295,col 26)-(line 3295,col 27)","literalExprId":24,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testSplitLines()"},{"methodDeclaration":"private static void initializePreds1AndSucc1()","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (preds1 != null) {\n        return;\n    }\n    preds1 = new LinkedHashMap<Integer, List<Integer>>();\n    succs1 = new LinkedHashMap<Integer, List<Integer>>();\n    for (int i = 0; i <= 7; i++) {\n        preds1.put(new Integer(i), new ArrayList<Integer>());\n        succs1.put(new Integer(i), new ArrayList<Integer>());\n    }\n    succs1.get(0).add(1);\n    preds1.get(1).add(0);\n    succs1.get(1).add(2);\n    preds1.get(2).add(1);\n    succs1.get(1).add(3);\n    preds1.get(3).add(1);\n    succs1.get(2).add(7);\n    preds1.get(7).add(2);\n    succs1.get(3).add(4);\n    preds1.get(4).add(3);\n    succs1.get(4).add(5);\n    preds1.get(5).add(4);\n    succs1.get(4).add(6);\n    preds1.get(6).add(4);\n    succs1.get(5).add(7);\n    preds1.get(7).add(5);\n    succs1.get(6).add(4);\n    preds1.get(4).add(6);\n}","methodRange":"(line 3302,col 3)-(line 3333,col 3)","methodTokenRange":"@SuppressWarnings({\"keyfor\", \"nullness\"})\n  \/*@EnsuresNonNull({\"preds1\", \"succs1\"})*\/\n  private static void initializePreds1AndSucc1() {\n    if (preds1 != null) {\n      return;\n    }\n\n    preds1 = new LinkedHashMap<Integer, List<Integer>>();\n    succs1 = new LinkedHashMap<Integer, List<Integer>>();\n    for (int i = 0; i <= 7; i++) {\n      preds1.put(new Integer(i), new ArrayList<Integer>());\n      succs1.put(new Integer(i), new ArrayList<Integer>());\n    }\n    succs1.get(0).add(1);\n    preds1.get(1).add(0);\n    succs1.get(1).add(2);\n    preds1.get(2).add(1);\n    succs1.get(1).add(3);\n    preds1.get(3).add(1);\n    succs1.get(2).add(7);\n    preds1.get(7).add(2);\n    succs1.get(3).add(4);\n    preds1.get(4).add(3);\n    succs1.get(4).add(5);\n    preds1.get(5).add(4);\n    succs1.get(4).add(6);\n    preds1.get(6).add(4);\n    succs1.get(5).add(7);\n    preds1.get(7).add(5);\n    succs1.get(6).add(4);\n    preds1.get(4).add(6);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"initializePreds1AndSucc1","methodQualifiedSignature":"plume.TestPlume.initializePreds1AndSucc1","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3302,col 22)-(line 3302,col 29)","literalExprId":1,"literalExpr":"\"keyfor\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3302,col 32)-(line 3302,col 41)","literalExprId":2,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3305,col 19)-(line 3305,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 3311,col 18)-(line 3311,col 18)","literalExprId":4,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3311,col 26)-(line 3311,col 26)","literalExprId":5,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3315,col 16)-(line 3315,col 16)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3315,col 23)-(line 3315,col 23)","literalExprId":7,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3316,col 16)-(line 3316,col 16)","literalExprId":8,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3316,col 23)-(line 3316,col 23)","literalExprId":9,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3317,col 16)-(line 3317,col 16)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3317,col 23)-(line 3317,col 23)","literalExprId":11,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3318,col 16)-(line 3318,col 16)","literalExprId":12,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3318,col 23)-(line 3318,col 23)","literalExprId":13,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3319,col 16)-(line 3319,col 16)","literalExprId":14,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3319,col 23)-(line 3319,col 23)","literalExprId":15,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3320,col 16)-(line 3320,col 16)","literalExprId":16,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3320,col 23)-(line 3320,col 23)","literalExprId":17,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3321,col 16)-(line 3321,col 16)","literalExprId":18,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3321,col 23)-(line 3321,col 23)","literalExprId":19,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3322,col 16)-(line 3322,col 16)","literalExprId":20,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3322,col 23)-(line 3322,col 23)","literalExprId":21,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3323,col 16)-(line 3323,col 16)","literalExprId":22,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3323,col 23)-(line 3323,col 23)","literalExprId":23,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3324,col 16)-(line 3324,col 16)","literalExprId":24,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3324,col 23)-(line 3324,col 23)","literalExprId":25,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3325,col 16)-(line 3325,col 16)","literalExprId":26,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3325,col 23)-(line 3325,col 23)","literalExprId":27,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3326,col 16)-(line 3326,col 16)","literalExprId":28,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3326,col 23)-(line 3326,col 23)","literalExprId":29,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3327,col 16)-(line 3327,col 16)","literalExprId":30,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3327,col 23)-(line 3327,col 23)","literalExprId":31,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3328,col 16)-(line 3328,col 16)","literalExprId":32,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3328,col 23)-(line 3328,col 23)","literalExprId":33,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3329,col 16)-(line 3329,col 16)","literalExprId":34,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3329,col 23)-(line 3329,col 23)","literalExprId":35,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3330,col 16)-(line 3330,col 16)","literalExprId":36,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3330,col 23)-(line 3330,col 23)","literalExprId":37,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3331,col 16)-(line 3331,col 16)","literalExprId":38,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3331,col 23)-(line 3331,col 23)","literalExprId":39,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3332,col 16)-(line 3332,col 16)","literalExprId":40,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3332,col 23)-(line 3332,col 23)","literalExprId":41,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.initializePreds1AndSucc1()"},{"methodDeclaration":"public void testGraphMDE()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    initializePreds1AndSucc1();\n    Map<Integer, List<Integer>> dom1post = GraphMDE.dominators(succs1);\n    assert dom1post.get(0).toString().equals(\"[7, 1, 0]\");\n    assert dom1post.get(1).toString().equals(\"[7, 1]\");\n    assert dom1post.get(2).toString().equals(\"[7, 2]\");\n    assert dom1post.get(3).toString().equals(\"[7, 5, 4, 3]\");\n    assert dom1post.get(4).toString().equals(\"[7, 5, 4]\");\n    assert dom1post.get(5).toString().equals(\"[7, 5]\");\n    assert dom1post.get(6).toString().equals(\"[7, 5, 4, 6]\");\n    assert dom1post.get(7).toString().equals(\"[7]\");\n    Map<Integer, List<Integer>> dom1pre = GraphMDE.dominators(preds1);\n    assert dom1pre.get(0).toString().equals(\"[0]\");\n    assert dom1pre.get(1).toString().equals(\"[0, 1]\");\n    assert dom1pre.get(2).toString().equals(\"[0, 1, 2]\");\n    assert dom1pre.get(3).toString().equals(\"[0, 1, 3]\");\n    assert dom1pre.get(4).toString().equals(\"[0, 1, 3, 4]\");\n    assert dom1pre.get(5).toString().equals(\"[0, 1, 3, 4, 5]\");\n    assert dom1pre.get(6).toString().equals(\"[0, 1, 3, 4, 6]\");\n    assert dom1pre.get(7).toString().equals(\"[0, 1, 7]\");\n}","methodRange":"(line 3335,col 3)-(line 3363,col 3)","methodTokenRange":"@SuppressWarnings(\"nullness\")\n  @Test\n  public void testGraphMDE() {\n\n    initializePreds1AndSucc1();\n\n    Map<Integer, List<Integer>> dom1post = GraphMDE.dominators(succs1);\n    assert dom1post.get(0).toString().equals(\"[7, 1, 0]\");\n    assert dom1post.get(1).toString().equals(\"[7, 1]\");\n    assert dom1post.get(2).toString().equals(\"[7, 2]\");\n    assert dom1post.get(3).toString().equals(\"[7, 5, 4, 3]\");\n    assert dom1post.get(4).toString().equals(\"[7, 5, 4]\");\n    assert dom1post.get(5).toString().equals(\"[7, 5]\");\n    assert dom1post.get(6).toString().equals(\"[7, 5, 4, 6]\");\n    assert dom1post.get(7).toString().equals(\"[7]\");\n\n    Map<Integer, List<Integer>> dom1pre = GraphMDE.dominators(preds1);\n    assert dom1pre.get(0).toString().equals(\"[0]\");\n    assert dom1pre.get(1).toString().equals(\"[0, 1]\");\n    assert dom1pre.get(2).toString().equals(\"[0, 1, 2]\");\n    assert dom1pre.get(3).toString().equals(\"[0, 1, 3]\");\n    assert dom1pre.get(4).toString().equals(\"[0, 1, 3, 4]\");\n    assert dom1pre.get(5).toString().equals(\"[0, 1, 3, 4, 5]\");\n    assert dom1pre.get(6).toString().equals(\"[0, 1, 3, 4, 6]\");\n    assert dom1pre.get(7).toString().equals(\"[0, 1, 7]\");\n\n    \/\/ I should add some more tests.\n\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[],"methodName":"testGraphMDE","methodQualifiedSignature":"plume.TestPlume.testGraphMDE","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 3335,col 21)-(line 3335,col 30)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3342,col 25)-(line 3342,col 25)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3342,col 46)-(line 3342,col 56)","literalExprId":3,"literalExpr":"\"[7, 1, 0]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3343,col 25)-(line 3343,col 25)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3343,col 46)-(line 3343,col 53)","literalExprId":5,"literalExpr":"\"[7, 1]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3344,col 25)-(line 3344,col 25)","literalExprId":6,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3344,col 46)-(line 3344,col 53)","literalExprId":7,"literalExpr":"\"[7, 2]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3345,col 25)-(line 3345,col 25)","literalExprId":8,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3345,col 46)-(line 3345,col 59)","literalExprId":9,"literalExpr":"\"[7, 5, 4, 3]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3346,col 25)-(line 3346,col 25)","literalExprId":10,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3346,col 46)-(line 3346,col 56)","literalExprId":11,"literalExpr":"\"[7, 5, 4]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3347,col 25)-(line 3347,col 25)","literalExprId":12,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3347,col 46)-(line 3347,col 53)","literalExprId":13,"literalExpr":"\"[7, 5]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3348,col 25)-(line 3348,col 25)","literalExprId":14,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3348,col 46)-(line 3348,col 59)","literalExprId":15,"literalExpr":"\"[7, 5, 4, 6]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3349,col 25)-(line 3349,col 25)","literalExprId":16,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3349,col 46)-(line 3349,col 50)","literalExprId":17,"literalExpr":"\"[7]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3352,col 24)-(line 3352,col 24)","literalExprId":18,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3352,col 45)-(line 3352,col 49)","literalExprId":19,"literalExpr":"\"[0]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3353,col 24)-(line 3353,col 24)","literalExprId":20,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3353,col 45)-(line 3353,col 52)","literalExprId":21,"literalExpr":"\"[0, 1]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3354,col 24)-(line 3354,col 24)","literalExprId":22,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3354,col 45)-(line 3354,col 55)","literalExprId":23,"literalExpr":"\"[0, 1, 2]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3355,col 24)-(line 3355,col 24)","literalExprId":24,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3355,col 45)-(line 3355,col 55)","literalExprId":25,"literalExpr":"\"[0, 1, 3]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3356,col 24)-(line 3356,col 24)","literalExprId":26,"literalExpr":"4","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3356,col 45)-(line 3356,col 58)","literalExprId":27,"literalExpr":"\"[0, 1, 3, 4]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3357,col 24)-(line 3357,col 24)","literalExprId":28,"literalExpr":"5","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3357,col 45)-(line 3357,col 61)","literalExprId":29,"literalExpr":"\"[0, 1, 3, 4, 5]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3358,col 24)-(line 3358,col 24)","literalExprId":30,"literalExpr":"6","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3358,col 45)-(line 3358,col 61)","literalExprId":31,"literalExpr":"\"[0, 1, 3, 4, 6]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 3359,col 24)-(line 3359,col 24)","literalExprId":32,"literalExpr":"7","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 3359,col 45)-(line 3359,col 55)","literalExprId":33,"literalExpr":"\"[0, 1, 7]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.TestPlume.testGraphMDE()"}],"classJavadoc":"\/**\n * Test code for the plume package.\n *\/\n","className":"TestPlume","fields":[{"fieldRange":"(line 63,col 3)-(line 63,col 35)","fieldName":"short_run","fieldJavadocComment":" under instrumentation such as that of Chicory.","fieldTokenRange":"static boolean short_run = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 63,col 30)-(line 63,col 34)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"","fieldTypeResolvedDescribed":"boolean"},{"fieldRange":"(line 1620,col 3)-(line 1620,col 66)","fieldName":"runtime","fieldJavadocComment":"","fieldTokenRange":"private static Runtime runtime = java.lang.Runtime.getRuntime();","fieldTypeResolved":"ReferenceType{java.lang.Runtime, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[java.lang.Runtime.getRuntime()]","fieldType":"Runtime","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.Runtime"},{"fieldRange":"(line 3299,col 3)-(line 3299,col 88)","fieldName":"preds1","fieldJavadocComment":" Figure 1 from http:\/\/www.boost.org\/libs\/graph\/doc\/lengauer_tarjan_dominator.htm#fig:dominator-tree-example","fieldTokenRange":"private static \/*@Nullable*\/ Map<Integer, List<\/*@KeyFor(\"preds1\")*\/ Integer>> preds1;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<Integer, List<Integer>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<java.lang.Integer, java.util.List<java.lang.Integer>>"},{"fieldRange":"(line 3300,col 3)-(line 3300,col 88)","fieldName":"succs1","fieldJavadocComment":"","fieldTokenRange":"private static \/*@Nullable*\/ Map<Integer, List<\/*@KeyFor(\"succs1\")*\/ Integer>> succs1;","fieldTypeResolved":"ReferenceType{java.util.Map, typeParametersMap=TypeParametersMap{nameToValue={java.util.Map.K=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}, java.util.Map.V=ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{java.lang.Integer, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Map<Integer, List<Integer>>","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.util.Map<java.lang.Integer, java.util.List<java.lang.Integer>>"}]}],"sourceFileId":45,"packageName":"plume"},{"sourceFileName":"plume.LimitedSizeSet","imports":[{"importId":1,"import":"import java.io.Serializable;\n"},{"importId":2,"import":"import java.util.List;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum number of values this set will be able to hold","javadocBlockTagName":"max_values","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum number of values this set will be able to hold'}]}', name=Optional[max_values]}"}],"constructorQualifiedSignature":"plume.LimitedSizeSet.LimitedSizeSet(int)","variableDeclarationExprs":[{"variableType":"T[]","variableName":"new_values_array","variableDeclarationExprId":1,"variableDeclarationExpr":"@SuppressWarnings(\"unchecked\")\nT[] new_values_array = (T[]) new Object[max_values]","variableDeclarationExprRange":"(line 40,col 5)-(line 41,col 97)","variableTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","variableRange":"(line 41,col 23)-(line 41,col 97)"}],"constructorRange":"(line 37,col 3)-(line 44,col 3)","constructorJavadocComment":"\n   * Create a new LimitedSizeSet that can hold max_values values.\n   * @param max_values the maximum number of values this set will be able to hold\n   ","constructorDeclaration":"public LimitedSizeSet(int max_values)","constructorBody":"{\n    assert max_values > 0;\n    @SuppressWarnings(\"unchecked\")\n    T[] new_values_array = (T[]) new Object[max_values];\n    values = new_values_array;\n    num_values = 0;\n}","constructorName":"LimitedSizeSet","constructorQualifiedName":"plume.LimitedSizeSet.LimitedSizeSet","constructorParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int max_values","parameterName":"max_values"}],"literalExprs":[{"literalExprRange":"(line 38,col 25)-(line 38,col 25)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 40,col 23)-(line 40,col 33)","literalExprId":2,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 43,col 18)-(line 43,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"constructorTokenRange":"public LimitedSizeSet(int max_values) {\n    assert max_values > 0;\n    \/\/ this.max_values = max_values;\n    @SuppressWarnings(\"unchecked\")\n    \/*@Nullable*\/ T[] new_values_array = (\/*@Nullable*\/ T[]) new \/*@Nullable*\/ Object[max_values];\n    values = new_values_array;\n    num_values = 0;\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new LimitedSizeSet that can hold max_values values.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum number of values this set will be able to hold'}]}', name=Optional[max_values]}]}"}],"classOrInterface":[],"methods":[{"methodDeclaration":"public void add(T elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (values == null) {\n        return;\n    }\n    if (contains(elt)) {\n        return;\n    }\n    if (num_values == values.length) {\n        values = null;\n        num_values++;\n        return;\n    }\n    values[num_values] = elt;\n    num_values++;\n}","methodRange":"(line 46,col 3)-(line 61,col 3)","methodTokenRange":"public void add(T elt) {\n    if (values == null) {\n      return;\n    }\n\n    if (contains(elt)) {\n      return;\n    }\n    if (num_values == values.length) {\n      values = null;\n      num_values++;\n      return;\n    }\n    values[num_values] = elt;\n    num_values++;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T elt","parameterName":"elt"}],"methodName":"add","methodQualifiedSignature":"plume.LimitedSizeSet.add","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 47,col 19)-(line 47,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 55,col 16)-(line 55,col 19)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.add(T)"},{"methodDeclaration":"public void addAll(LimitedSizeSet<? extends T> s)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    @SuppressWarnings(\"interning\")\n    boolean sameObject = (this == s);\n    if (sameObject) {\n        return;\n    }\n    if (repNulled()) {\n        return;\n    }\n    if (s.repNulled()) {\n        int values_length = values.length;\n        if (s.size() > values_length) {\n            num_values = values_length + 1;\n            values = null;\n            return;\n        } else {\n            throw new Error(\"Arg is rep-nulled, so we don't know its values and can't add them to this.\");\n        }\n    }\n    for (int i = 0; i < s.size(); i++) {\n        assert s.values != null : \"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\";\n        assert s.values[i] != null : \"@AssumeAssertion(nullness): used portion of array\";\n        add(s.values[i]);\n        if (repNulled()) {\n            return;\n        }\n    }\n}","methodRange":"(line 63,col 3)-(line 95,col 3)","methodTokenRange":"public void addAll(LimitedSizeSet<? extends T> s) {\n    @SuppressWarnings(\"interning\") \/\/ optimization; not a subclass of Collection, though\n    boolean sameObject = (this == s);\n    if (sameObject) {\n      return;\n    }\n    if (repNulled()) {\n      return;\n    }\n    if (s.repNulled()) {\n      int values_length = values.length;\n      \/\/ We don't know whether the elements of this and the argument were\n      \/\/ disjoint.  There might be anywhere from max(size(), s.size()) to\n      \/\/ (size() + s.size()) elements in the resulting set.\n      if (s.size() > values_length) {\n        num_values = values_length + 1;\n        values = null;\n        return;\n      } else {\n        throw new Error(\n            \"Arg is rep-nulled, so we don't know its values and can't add them to this.\");\n      }\n    }\n    for (int i = 0; i < s.size(); i++) {\n      assert s.values != null\n          : \"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\";\n      assert s.values[i] != null : \"@AssumeAssertion(nullness): used portion of array\";\n      add(s.values[i]);\n      if (repNulled()) {\n        return; \/\/ optimization, not necessary for correctness\n      }\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"","methodParameters":[{"parameterType":"LimitedSizeSet<? extends T>","parameterId":1,"parameterTypeResolved":"ReferenceType{plume.LimitedSizeSet, typeParametersMap=TypeParametersMap{nameToValue={plume.LimitedSizeSet.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}","parameterTypeResolvedDescribed":"plume.LimitedSizeSet<? extends T>","parameter":"LimitedSizeSet<? extends T> s","parameterName":"s"}],"methodName":"addAll","methodQualifiedSignature":"plume.LimitedSizeSet.addAll","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 64,col 23)-(line 64,col 33)","literalExprId":1,"literalExpr":"\"interning\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 78,col 38)-(line 78,col 38)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 79,col 18)-(line 79,col 21)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 83,col 13)-(line 83,col 88)","literalExprId":4,"literalExpr":"\"Arg is rep-nulled, so we don't know its values and can't add them to this.\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 86,col 18)-(line 86,col 18)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 87,col 26)-(line 87,col 29)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 88,col 13)-(line 88,col 109)","literalExprId":7,"literalExpr":"\"@AssumeAssertion(nullness): no relevant side effect:  add's side effects do not affect s.values\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 89,col 29)-(line 89,col 32)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 89,col 36)-(line 89,col 86)","literalExprId":9,"literalExpr":"\"@AssumeAssertion(nullness): used portion of array\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.addAll(plume.LimitedSizeSet<? extends T>)"},{"methodDeclaration":"public boolean contains(T elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (values == null) {\n        throw new UnsupportedOperationException();\n    }\n    for (int i = 0; i < num_values; i++) {\n        @SuppressWarnings(\"nullness\")\n        T value = values[i];\n        if (value == elt || (value != null && value.equals(elt))) {\n            return true;\n        }\n    }\n    return false;\n}","methodRange":"(line 97,col 3)-(line 111,col 3)","methodTokenRange":"@SuppressWarnings(\"deterministic\") \/\/ pure wrt equals() but not ==: throws a new exception\n  \/*@Pure*\/\n  public boolean contains(T elt) {\n    if (values == null) {\n      throw new UnsupportedOperationException();\n    }\n    for (int i = 0; i < num_values; i++) {\n      @SuppressWarnings(\"nullness\") \/\/ object invariant: used portion of array\n      T value = values[i];\n      if (value == elt || (value != null && value.equals(elt))) {\n        return true;\n      }\n    }\n    return false;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[])}","parameterTypeResolvedDescribed":"T","parameter":"T elt","parameterName":"elt"}],"methodName":"contains","methodQualifiedSignature":"plume.LimitedSizeSet.contains","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 97,col 21)-(line 97,col 35)","literalExprId":1,"literalExpr":"\"deterministic\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 100,col 19)-(line 100,col 22)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 103,col 18)-(line 103,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 104,col 25)-(line 104,col 34)","literalExprId":4,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 106,col 37)-(line 106,col 40)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 107,col 16)-(line 107,col 19)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 110,col 12)-(line 110,col 16)","literalExprId":7,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.contains(T)"},{"methodDeclaration":"public int size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return num_values;\n}","methodRange":"(line 120,col 3)-(line 122,col 3)","methodTokenRange":"public int size(\/*>>>@GuardSatisfied LimitedSizeSet<T> this*\/) {\n    return num_values;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"size","methodQualifiedSignature":"plume.LimitedSizeSet.size","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[],"methodQualifiedName":"plume.LimitedSizeSet.size()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"maximum capacity of the set representation","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum capacity of the set representation'}]}', name=Optional.empty}"}],"methodDeclaration":"public int max_size()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (values == null) {\n        return num_values;\n    } else {\n        return values.length + 1;\n    }\n}","methodRange":"(line 130,col 3)-(line 136,col 3)","methodTokenRange":"public int max_size() {\n    if (values == null) {\n      return num_values;\n    } else {\n      return values.length + 1;\n    }\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * An upper bound on how many distinct elements can be individually\n   * represented in the set.\n   * Returns max_values+1 (where max_values is the argument to the constructor).\n   * @return maximum capacity of the set representation\n   ","methodParameters":[],"methodName":"max_size","methodQualifiedSignature":"plume.LimitedSizeSet.max_size","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='An upper bound on how many distinct elements can be individually\nrepresented in the set.\nReturns max_values+1 (where max_values is the argument to the constructor).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='maximum capacity of the set representation'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 131,col 19)-(line 131,col 22)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 134,col 30)-(line 134,col 30)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.max_size()"},{"methodDeclaration":"public boolean repNulled()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return values == null;\n}","methodRange":"(line 140,col 3)-(line 142,col 3)","methodTokenRange":"public boolean repNulled() {\n    return values == null;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[],"methodName":"repNulled","methodQualifiedSignature":"plume.LimitedSizeSet.repNulled","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 141,col 22)-(line 141,col 25)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.repNulled()"},{"methodDeclaration":"public LimitedSizeSet<T> clone()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    LimitedSizeSet<T> result;\n    try {\n        @SuppressWarnings(\"unchecked\")\n        LimitedSizeSet<T> result_as_lss = (LimitedSizeSet<T>) super.clone();\n        result = result_as_lss;\n    } catch (CloneNotSupportedException e) {\n        throw new Error();\n    }\n    if (values != null) {\n        result.values = values.clone();\n    }\n    return result;\n}","methodRange":"(line 144,col 3)-(line 159,col 3)","methodTokenRange":"@SuppressWarnings(\"sideeffectfree\") \/\/ side effect to local state (clone)\n  \/*@SideEffectFree*\/\n  public LimitedSizeSet<T> clone(\/*>>>@GuardSatisfied LimitedSizeSet<T> this*\/) {\n    LimitedSizeSet<T> result;\n    try {\n      @SuppressWarnings(\"unchecked\")\n      LimitedSizeSet<T> result_as_lss = (LimitedSizeSet<T>) super.clone();\n      result = result_as_lss;\n    } catch (CloneNotSupportedException e) {\n      throw new Error(); \/\/ can't happen\n    }\n    if (values != null) {\n      result.values = values.clone();\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{plume.LimitedSizeSet, typeParametersMap=TypeParametersMap{nameToValue={plume.LimitedSizeSet.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"","methodParameters":[],"methodName":"clone","methodQualifiedSignature":"plume.LimitedSizeSet.clone","methodJavadoc":"","methodReturnTypeDescribed":"plume.LimitedSizeSet<T>","methodType":"LimitedSizeSet<T>","literalExprs":[{"literalExprRange":"(line 144,col 21)-(line 144,col 36)","literalExprId":1,"literalExpr":"\"sideeffectfree\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 149,col 25)-(line 149,col 35)","literalExprId":2,"literalExpr":"\"unchecked\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 155,col 19)-(line 155,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.clone()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"(super)type of elements of the sets","javadocBlockTagName":"<T>","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='(super)type of elements of the sets'}]}', name=Optional[<T>]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the maximum size for the returned LimitedSizeSet","javadocBlockTagName":"max_values","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum size for the returned LimitedSizeSet'}]}', name=Optional[max_values]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"a list of LimitedSizeSet, whose elements will be merged","javadocBlockTagName":"slist","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list of LimitedSizeSet, whose elements will be merged'}]}', name=Optional[slist]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"a LimitedSizeSet that merges the elements of slist","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LimitedSizeSet that merges the elements of slist'}]}', name=Optional.empty}"}],"methodDeclaration":"public static LimitedSizeSet<T> merge(int max_values, List<LimitedSizeSet<? extends T>> slist)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n        result.addAll(s);\n    }\n    return result;\n}","methodRange":"(line 170,col 3)-(line 177,col 3)","methodTokenRange":"public static <T> LimitedSizeSet<T> merge(\n      int max_values, List<LimitedSizeSet<? extends T>> slist) {\n    LimitedSizeSet<T> result = new LimitedSizeSet<T>(max_values);\n    for (LimitedSizeSet<? extends T> s : slist) {\n      result.addAll(s);\n    }\n    return result;\n  }","methodReturnTypeResolved":"ReferenceType{plume.LimitedSizeSet, typeParametersMap=TypeParametersMap{nameToValue={plume.LimitedSizeSet.T=TypeVariable {JPTypeParameter(T, bounds=[])}}}}","methodJavadocComment":"\n   * Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\n   * represents the values seen by the entire list.  Returns the new\n   * object, whose max_values is the given integer.\n   * @param <T> (super)type of elements of the sets\n   * @param max_values the maximum size for the returned LimitedSizeSet\n   * @param slist a list of LimitedSizeSet, whose elements will be merged\n   * @return a LimitedSizeSet that merges the elements of slist\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int max_values","parameterName":"max_values"},{"parameterType":"List<LimitedSizeSet<? extends T>>","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.List, typeParametersMap=TypeParametersMap{nameToValue={java.util.List.E=ReferenceType{plume.LimitedSizeSet, typeParametersMap=TypeParametersMap{nameToValue={plume.LimitedSizeSet.T=WildcardUsage{type=EXTENDS, boundedType=TypeVariable {JPTypeParameter(T, bounds=[])}}}}}}}}","parameterTypeResolvedDescribed":"java.util.List<plume.LimitedSizeSet<? extends T>>","parameter":"List<LimitedSizeSet<? extends T>> slist","parameterName":"slist"}],"methodName":"merge","methodQualifiedSignature":"plume.LimitedSizeSet.merge","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Merges a list of LimitedSizeSet&lt;T&gt; objects into a single object that\nrepresents the values seen by the entire list.  Returns the new\nobject, whose max_values is the given integer.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='(super)type of elements of the sets'}]}', name=Optional[<T>]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the maximum size for the returned LimitedSizeSet'}]}', name=Optional[max_values]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='a list of LimitedSizeSet, whose elements will be merged'}]}', name=Optional[slist]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a LimitedSizeSet that merges the elements of slist'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"plume.LimitedSizeSet<T>","methodType":"LimitedSizeSet<T>","literalExprs":[],"methodQualifiedName":"plume.LimitedSizeSet.merge(int, java.util.List<plume.LimitedSizeSet<? extends T>>)"},{"methodDeclaration":"public String toString()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (\"[size=\" + size() + \"; \" + ((values == null) ? \"null\" : ArraysMDE.toString(values)) + \"]\");\n}","methodRange":"(line 179,col 3)-(line 187,col 3)","methodTokenRange":"@SuppressWarnings(\"nullness\") \/\/ bug in flow; to fix later\n  \/*@SideEffectFree*\/\n  public String toString(\/*>>>@GuardSatisfied LimitedSizeSet<T> this*\/) {\n    return (\"[size=\"\n        + size()\n        + \"; \"\n        + ((values == null) ? \"null\" : ArraysMDE.toString(values))\n        + \"]\");\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"","methodParameters":[],"methodName":"toString","methodQualifiedSignature":"plume.LimitedSizeSet.toString","methodJavadoc":"","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 179,col 21)-(line 179,col 30)","literalExprId":1,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 182,col 13)-(line 182,col 20)","literalExprId":2,"literalExpr":"\"[size=\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 184,col 11)-(line 184,col 14)","literalExprId":3,"literalExpr":"\"; \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 185,col 23)-(line 185,col 26)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 185,col 31)-(line 185,col 36)","literalExprId":5,"literalExpr":"\"null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 186,col 11)-(line 186,col 13)","literalExprId":6,"literalExpr":"\"]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.LimitedSizeSet.toString()"}],"classJavadoc":"\/**\n * LimitedSizeSet stores up to some maximum number of unique\n * values, at which point its rep is nulled, in order to save space.\n * @param <T> the type of elements in the set\n *\/\n","className":"LimitedSizeSet","fields":[{"fieldRange":"(line 21,col 3)-(line 21,col 49)","fieldName":"serialVersionUID","fieldJavadocComment":" remove fields, you should change this number to the current date.","fieldTokenRange":"static final long serialVersionUID = 20031021L;","fieldTypeResolved":"PrimitiveTypeUsage{name='long'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 21,col 40)-(line 21,col 48)","literalExprId":1,"literalExpr":"20031021L","literalExprClass":"class com.github.javaparser.ast.expr.LongLiteralExpr"}],"fieldInitializer":"Optional[20031021L]","fieldType":"long","fieldJavadoc":"","fieldTypeResolvedDescribed":"long"},{"fieldRange":"(line 29,col 3)-(line 29,col 52)","fieldName":"values","fieldJavadocComment":"\n   * If null, then at least num_values distinct values have been seen.\n   * The size is not separately stored, because that would take extra space.\n   ","fieldTokenRange":"protected \/*@Nullable*\/ T \/*@Nullable*\/ [] values;","fieldTypeResolved":"ResolvedArrayType{TypeVariable {JPTypeParameter(T, bounds=[])}}","fieldAccessSpecifier":"PROTECTED","literalExprs":[],"fieldInitializer":"","fieldType":"T[]","fieldJavadoc":"If null, then at least num_values distinct values have been seen.\nThe size is not separately stored, because that would take extra space.\n","fieldTypeResolvedDescribed":"T[]"},{"fieldRange":"(line 31,col 3)-(line 31,col 17)","fieldName":"num_values","fieldJavadocComment":" The number of active elements (equivalently, the first unused index). ","fieldTokenRange":"int num_values;","fieldTypeResolved":"PrimitiveTypeUsage{name='int'}","fieldAccessSpecifier":"NONE","literalExprs":[],"fieldInitializer":"","fieldType":"int","fieldJavadoc":"The number of active elements (equivalently, the first unused index).\n","fieldTypeResolvedDescribed":"int"}]}],"sourceFileId":46,"packageName":"plume"},{"sourceFileName":"plume.package-info","imports":[],"typeDeclarations":[],"sourceFileId":47,"packageName":"plume"},{"sourceFileName":"plume.EntryReader","imports":[{"importId":1,"import":"import java.io.File;\n"},{"importId":2,"import":"import java.io.FileInputStream;\n"},{"importId":3,"import":"import java.io.IOException;\n"},{"importId":4,"import":"import java.io.InputStream;\n"},{"importId":5,"import":"import java.io.InputStreamReader;\n"},{"importId":6,"import":"import java.io.LineNumberReader;\n"},{"importId":7,"import":"import java.io.Reader;\n"},{"importId":8,"import":"import java.io.UnsupportedEncodingException;\n"},{"importId":9,"import":"import java.nio.CharBuffer;\n"},{"importId":10,"import":"import java.util.Iterator;\n"},{"importId":11,"import":"import java.util.NoSuchElementException;\n"},{"importId":12,"import":"import java.util.Stack;\n"},{"importId":13,"import":"import java.util.regex.Matcher;\n"},{"importId":14,"import":"import java.util.regex.Pattern;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the charset encoding is not supported","javadocBlockTagName":"UnsupportedEncodingException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the charset encoding is not supported'}]}', name=Optional[UnsupportedEncodingException]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"source from which to read entries","javadocBlockTagName":"in","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[in]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the character set to use","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"non-null file name for stream being read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null file name for stream being read'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.","javadocBlockTagName":"comment_re_string","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re_string]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.","javadocBlockTagName":"include_re_string","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re_string]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(InputStream,String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.InputStream, java.lang.String, java.lang.String, java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 209,col 3)-(line 217,col 3)","constructorJavadocComment":" Create a EntryReader that uses the given character set.\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @param in source from which to read entries\n   * @param charsetName the character set to use\n   * @param filename non-null file name for stream being read\n   * @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   * @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @see #EntryReader(InputStream,String,String,String)\n   ","constructorDeclaration":"public EntryReader(InputStream in, String charsetName, String filename, String comment_re_string, String include_re_string) throws UnsupportedEncodingException","constructorBody":"{\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream in","parameterName":"in"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String comment_re_string","parameterName":"comment_re_string"},{"parameterType":"String","parameterId":5,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String include_re_string","parameterName":"include_re_string"}],"literalExprs":[],"constructorTokenRange":"public EntryReader(\n      InputStream in,\n      String charsetName,\n      String filename,\n      \/*@Nullable*\/ \/*@Regex*\/ String comment_re_string,\n      \/*@Nullable*\/ \/*@Regex(1)*\/ String include_re_string)\n      throws UnsupportedEncodingException {\n    this(new InputStreamReader(in, charsetName), filename, comment_re_string, include_re_string);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that uses the given character set.'}]}, blockTags=[JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the charset encoding is not supported'}]}', name=Optional[UnsupportedEncodingException]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[in]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null file name for stream being read'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re_string]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re_string]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the InputStream","javadocBlockTagName":"in","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the InputStream'}]}', name=Optional[in]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the character set to use","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file name","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file name'}]}', name=Optional[filename]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if the charset encoding is not supported","javadocBlockTagName":"UnsupportedEncodingException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the charset encoding is not supported'}]}', name=Optional[UnsupportedEncodingException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(InputStream,String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.InputStream, java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 226,col 3)-(line 229,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @param charsetName the character set to use\n   * @param filename the file name\n   * @throws UnsupportedEncodingException if the charset encoding is not supported\n   * @see #EntryReader(InputStream,String,String,String)\n   ","constructorDeclaration":"public EntryReader(InputStream in, String charsetName, String filename) throws UnsupportedEncodingException","constructorBody":"{\n    this(in, charsetName, filename, null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream in","parameterName":"in"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"literalExprs":[{"literalExprRange":"(line 228,col 37)-(line 228,col 40)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 228,col 43)-(line 228,col 46)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(InputStream in, String charsetName, String filename)\n      throws UnsupportedEncodingException {\n    this(in, charsetName, filename, null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the InputStream'}]}', name=Optional[in]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file name'}]}', name=Optional[filename]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if the charset encoding is not supported'}]}', name=Optional[UnsupportedEncodingException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source from which to read entries","javadocBlockTagName":"in","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[in]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"non-null file name for stream being read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null file name for stream being read'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.","javadocBlockTagName":"comment_re_string","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re_string]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.","javadocBlockTagName":"include_re_string","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re_string]}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.InputStream, java.lang.String, java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 245,col 3)-(line 251,col 3)","constructorJavadocComment":"\n   * Create a EntryReader.\n   *\n   *    @param in source from which to read entries\n   *    @param filename non-null file name for stream being read\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   ","constructorDeclaration":"public EntryReader(InputStream in, String filename, String comment_re_string, String include_re_string)","constructorBody":"{\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream in","parameterName":"in"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String comment_re_string","parameterName":"comment_re_string"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String include_re_string","parameterName":"include_re_string"}],"literalExprs":[],"constructorTokenRange":"public EntryReader(\n      InputStream in,\n      String filename,\n      \/*@Nullable*\/ \/*@Regex*\/ String comment_re_string,\n      \/*@Nullable*\/ \/*@Regex(1)*\/ String include_re_string) {\n    this(new InputStreamReader(in), filename, comment_re_string, include_re_string);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[in]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='non-null file name for stream being read'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re_string]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re_string]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the InputStream","javadocBlockTagName":"in","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the InputStream'}]}', name=Optional[in]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file name","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file name'}]}', name=Optional[filename]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(InputStream,String,String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.InputStream, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 260,col 3)-(line 262,col 3)","constructorJavadocComment":"\n   * Create a EntryReader that uses the default character set and does not\n   * support comments or include directives.\n   * @param in the InputStream\n   * @param filename the file name\n   * @see #EntryReader(InputStream,String,String,String,String)\n   ","constructorDeclaration":"public EntryReader(InputStream in, String filename)","constructorBody":"{\n    this(in, filename, null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream in","parameterName":"in"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"literalExprs":[{"literalExprRange":"(line 261,col 24)-(line 261,col 27)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 261,col 30)-(line 261,col 33)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(InputStream in, String filename) {\n    this(in, filename, null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that uses the default character set and does not\nsupport comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the InputStream'}]}', name=Optional[in]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file name'}]}', name=Optional[filename]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the InputStream","javadocBlockTagName":"in","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the InputStream'}]}', name=Optional[in]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(InputStream,String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.InputStream)","variableDeclarationExprs":[],"constructorRange":"(line 268,col 3)-(line 270,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param in the InputStream\n   * @see #EntryReader(InputStream,String,String,String)\n   ","constructorDeclaration":"public EntryReader(InputStream in)","constructorBody":"{\n    this(in, \"(InputStream)\", null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"InputStream","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.InputStream, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.InputStream","parameter":"InputStream in","parameterName":"in"}],"literalExprs":[{"literalExprRange":"(line 269,col 14)-(line 269,col 28)","literalExprId":1,"literalExpr":"\"(InputStream)\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 269,col 31)-(line 269,col 34)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 269,col 37)-(line 269,col 40)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(InputStream in) {\n    this(in, \"(InputStream)\", null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the InputStream'}]}', name=Optional[in]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(InputStream,String,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source from which to read entries","javadocBlockTagName":"reader","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[reader]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"file name corresponding to reader, for use in error messages","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file name corresponding to reader, for use in error messages'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored","javadocBlockTagName":"comment_re_string","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored'}]}', name=Optional[comment_re_string]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name","javadocBlockTagName":"include_re_string","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name'}]}', name=Optional[include_re_string]}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.Reader, java.lang.String, java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 338,col 3)-(line 357,col 3)","constructorJavadocComment":"\n   * Create a EntryReader.\n   *\n   *    @param reader source from which to read entries\n   *    @param filename file name corresponding to reader, for use in error messages\n   *    @param comment_re_string regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored\n   *    @param include_re_string regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name\n   ","constructorDeclaration":"public EntryReader(Reader reader, String filename, String comment_re_string, String include_re_string)","constructorBody":"{\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n        comment_re = null;\n    } else {\n        comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n        include_re = null;\n    } else {\n        include_re = Pattern.compile(include_re_string);\n    }\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"Reader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Reader","parameter":"Reader reader","parameterName":"reader"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String comment_re_string","parameterName":"comment_re_string"},{"parameterType":"String","parameterId":4,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String include_re_string","parameterName":"include_re_string"}],"literalExprs":[{"literalExprRange":"(line 347,col 30)-(line 347,col 33)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 348,col 20)-(line 348,col 23)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 352,col 30)-(line 352,col 33)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 353,col 20)-(line 353,col 23)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(\n      Reader reader,\n      String filename,\n      \/*@Nullable*\/ \/*@Regex*\/ String comment_re_string,\n      \/*@Nullable*\/ \/*@Regex(1)*\/ String include_re_string) {\n    \/\/ we won't use superclass methods, but passing null as an argument\n    \/\/ leads to a NullPointerException.\n    super(new DummyReader());\n    readers.push(new FlnReader(reader, filename));\n    if (comment_re_string == null) {\n      comment_re = null;\n    } else {\n      comment_re = Pattern.compile(comment_re_string);\n    }\n    if (include_re_string == null) {\n      include_re = null;\n    } else {\n      include_re = Pattern.compile(include_re_string);\n    }\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[reader]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='file name corresponding to reader, for use in error messages'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored'}]}', name=Optional[comment_re_string]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name'}]}', name=Optional[include_re_string]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source from which to read entries","javadocBlockTagName":"reader","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[reader]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(Reader,String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(Reader,String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.Reader)","variableDeclarationExprs":[],"constructorRange":"(line 363,col 3)-(line 365,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param reader source from which to read entries\n   * @see #EntryReader(Reader,String,String,String)\n   ","constructorDeclaration":"public EntryReader(Reader reader)","constructorBody":"{\n    this(reader, reader.toString(), null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"Reader","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.Reader, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.Reader","parameter":"Reader reader","parameterName":"reader"}],"literalExprs":[{"literalExprRange":"(line 364,col 37)-(line 364,col 40)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 364,col 43)-(line 364,col 46)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(Reader reader) {\n    this(reader, reader.toString(), null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[reader]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(Reader,String,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"initial file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.","javadocBlockTagName":"comment_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.","javadocBlockTagName":"include_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.File, java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 381,col 3)-(line 387,col 3)","constructorJavadocComment":"\n   * Create an EntryReader.\n   *\n   *    @param file       initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   * @throws IOException if there is a problem reading the file\n   ","constructorDeclaration":"public EntryReader(File file, String comment_re, String include_re) throws IOException","constructorBody":"{\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String comment_re","parameterName":"comment_re"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String include_re","parameterName":"include_re"}],"literalExprs":[],"constructorTokenRange":"public EntryReader(\n      File file,\n      \/*@Nullable*\/ \/*@Regex*\/ String comment_re,\n      \/*@Nullable*\/ \/*@Regex(1)*\/ String include_re)\n      throws IOException {\n    this(UtilMDE.fileReader(file), file.toString(), comment_re, include_re);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create an EntryReader.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(File,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(File,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.File)","variableDeclarationExprs":[],"constructorRange":"(line 394,col 3)-(line 396,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   ","constructorDeclaration":"public EntryReader(File file) throws IOException","constructorBody":"{\n    this(file, null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"}],"literalExprs":[{"literalExprRange":"(line 395,col 16)-(line 395,col 19)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 395,col 22)-(line 395,col 25)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(File file) throws IOException {\n    this(file, null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(File,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the file to read","javadocBlockTagName":"file","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[file]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the character set to use","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(File,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(File,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.io.File, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 404,col 3)-(line 406,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param file the file to read\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(File,String,String)\n   ","constructorDeclaration":"public EntryReader(File file, String charsetName) throws IOException","constructorBody":"{\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"File","parameterId":1,"parameterTypeResolved":"ReferenceType{java.io.File, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.io.File","parameter":"File file","parameterName":"file"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"}],"literalExprs":[{"literalExprRange":"(line 405,col 71)-(line 405,col 74)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 405,col 77)-(line 405,col 80)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(File file, String charsetName) throws IOException {\n    this(UtilMDE.fileInputStream(file), charsetName, file.toString(), null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the file to read'}]}', name=Optional[file]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(File,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"initial file to read","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial file to read'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.","javadocBlockTagName":"comment_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.","javadocBlockTagName":"include_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(File,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(File,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.lang.String, java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 425,col 3)-(line 431,col 3)","constructorJavadocComment":"\n   * Create a new EntryReader starting with the specified file.\n   *\n   *    @param filename   initial file to read\n   *    @param comment_re regular expression that matches comments.\n   *                      Any text that matches comment_re is removed.\n   *                      A line that is entirely a comment is ignored.\n   *    @param include_re regular expression that matches include directives.\n   *                      The expression should define one group that contains\n   *                      the include file name.\n   *\n   * @throws IOException if there is a problem reading the file\n   *\n   * @see #EntryReader(File,String,String)\n   ","constructorDeclaration":"public EntryReader(String filename, String comment_re, String include_re) throws IOException","constructorBody":"{\n    this(new File(filename), comment_re, include_re);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String comment_re","parameterName":"comment_re"},{"parameterType":"String","parameterId":3,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String include_re","parameterName":"include_re"}],"literalExprs":[],"constructorTokenRange":"public EntryReader(\n      String filename,\n      \/*@Nullable*\/ \/*@Regex*\/ String comment_re,\n      \/*@Nullable*\/ \/*@Regex(1)*\/ String include_re)\n      throws IOException {\n    this(new File(filename), comment_re, include_re);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a new EntryReader starting with the specified file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='initial file to read'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches comments.\n                     Any text that matches comment_re is removed.\n                     A line that is entirely a comment is ignored.'}]}', name=Optional[comment_re]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that matches include directives.\n                     The expression should define one group that contains\n                     the include file name.'}]}', name=Optional[include_re]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(File,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source from which to read entries","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[filename]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 438,col 3)-(line 440,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   ","constructorDeclaration":"public EntryReader(String filename) throws IOException","constructorBody":"{\n    this(filename, null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"}],"literalExprs":[{"literalExprRange":"(line 439,col 20)-(line 439,col 23)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 439,col 26)-(line 439,col 29)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(String filename) throws IOException {\n    this(filename, null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[filename]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(String,String,String)'}]}', name=Optional.empty}]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"source from which to read entries","javadocBlockTagName":"filename","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[filename]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the character set to use","javadocBlockTagName":"charsetName","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#EntryReader(String,String,String)","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(String,String,String)'}]}', name=Optional.empty}"}],"constructorQualifiedSignature":"plume.EntryReader.EntryReader(java.lang.String, java.lang.String)","variableDeclarationExprs":[],"constructorRange":"(line 448,col 3)-(line 450,col 3)","constructorJavadocComment":" Create a EntryReader that does not support comments or include directives.\n   * @param filename source from which to read entries\n   * @param charsetName the character set to use\n   * @throws IOException if there is a problem reading the file\n   * @see #EntryReader(String,String,String)\n   ","constructorDeclaration":"public EntryReader(String filename, String charsetName) throws IOException","constructorBody":"{\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n}","constructorName":"EntryReader","constructorQualifiedName":"plume.EntryReader.EntryReader","constructorParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String filename","parameterName":"filename"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String charsetName","parameterName":"charsetName"}],"literalExprs":[{"literalExprRange":"(line 449,col 64)-(line 449,col 67)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 449,col 70)-(line 449,col 73)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"constructorTokenRange":"public EntryReader(String filename, String charsetName) throws IOException {\n    this(new FileInputStream(filename), charsetName, filename, null, null);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Create a EntryReader that does not support comments or include directives.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='source from which to read entries'}]}', name=Optional[filename]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the character set to use'}]}', name=Optional[charsetName]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#EntryReader(String,String,String)'}]}', name=Optional.empty}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 116,col 3)-(line 139,col 3)","classOrInterfaceTokenRange":"private static class FlnReader extends LineNumberReader {\n    \/** The file being read. *\/\n    public String filename;\n\n    \/**\n     * Create a FlnReader.\n     * @param reader source from which to read entries\n     * @param filename file name corresponding to reader, for use in error messages.\n     *   Must be non-null; if there isn't a name, clients should provide a dummy value.\n     *\/\n    public FlnReader(Reader reader, String filename) {\n      super(reader);\n      this.filename = filename;\n    }\n\n    \/**\n     * Create a FlnReader.\n     * @param filename file from which to read\n     *\/\n    public FlnReader(String filename) throws IOException {\n      super(UtilMDE.fileReader(filename));\n      this.filename = filename;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Like LineNumberReader, but also has a filename field.\n   * \"FlnReader\" stands for \"Filename and Line Number Reader\".\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Like LineNumberReader, but also has a filename field.\n\"FlnReader\" stands for \"Filename and Line Number Reader\".'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 142,col 3)-(line 188,col 3)","classOrInterfaceTokenRange":"public static class Entry {\n    \/** First line of the entry. *\/\n    public String first_line;\n    \/** Complete body of the entry including the first line. *\/\n    public String body;\n    \/** True if this is a short entry (blank-line-separated). *\/\n    boolean short_entry;\n    \/** Filename in which the entry was found. *\/\n    String filename;\n    \/** Line number of first line of entry. *\/\n    long line_number;\n\n    \/** Create an entry.\n     * @param first_line first line of the entry\n     * @param body complete body of the entry including the first line\n     * @param short_entry true if this is a short entry (blank-line-separated)\n     * @param filename filename in which the entry was found\n     * @param line_number line number of first line of entry\n     *\/\n    Entry(String first_line, String body, String filename, long line_number, boolean short_entry) {\n      this.first_line = first_line;\n      this.body = body;\n      this.filename = filename;\n      this.line_number = line_number;\n      this.short_entry = short_entry;\n    }\n\n    \/**\n     * Return a substring of the entry body that matches the specified\n     * regular expression.  If no match is found, returns the first_line.\n     * @param re regex to match\n     * @return a substring that matches re\n     *\/\n    String get_description(\/*@Nullable*\/ Pattern re) {\n\n      if (re == null) {\n        return first_line;\n      }\n\n      Matcher descr = re.matcher(body);\n      if (descr.find()) {\n        return descr.group();\n      } else {\n        return first_line;\n      }\n    }\n  }","classOrInterfaceJavadocComment":" Descriptor for an entry (paragraph). ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Descriptor for an entry (paragraph).'}]}, blockTags=[]}]"},{"classOrInterfaceRange":"(line 273,col 3)-(line 324,col 3)","classOrInterfaceTokenRange":"private static class DummyReader extends Reader {\n    @Override\n    public void close(\/*>>>@GuardSatisfied DummyReader this*\/) {\n      \/\/ No error, because closing is OK if it appears in try-with-resources.\n      \/\/ Later maybe create two versions (with and without exception here).\n    }\n\n    @Override\n    public void mark(int readAheadLimit) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean markSupported() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(char[] cbuf, int off, int len) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public int read(CharBuffer target) {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public boolean ready() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public void reset() {\n      throw new Error(\"DummyReader\");\n    }\n\n    @Override\n    public long skip(long n) {\n      throw new Error(\"DummyReader\");\n    }\n  }","classOrInterfaceJavadocComment":" A dummy Reader to be used when null is not acceptable. ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='A dummy Reader to be used when null is not acceptable.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the string that was read, or null at end of file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the string that was read, or null at end of file'}]}', name=Optional.empty}"}],"methodDeclaration":"public String readLine() throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (pushback_line != null) {\n        String line = pushback_line;\n        pushback_line = null;\n        return line;\n    }\n    String line = get_next_line();\n    if (comment_re != null) {\n        while (line != null) {\n            Matcher cmatch = comment_re.matcher(line);\n            if (cmatch.find()) {\n                line = cmatch.replaceFirst(\"\");\n                if (line.length() > 0) {\n                    break;\n                }\n            } else {\n                break;\n            }\n            line = get_next_line();\n        }\n    }\n    if (line == null) {\n        return null;\n    }\n    if (include_re != null) {\n        Matcher m = include_re.matcher(line);\n        if (m.matches()) {\n            String filename_string = m.group(1);\n            if (filename_string == null) {\n                throw new Error(String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n            }\n            File filename = new File(UtilMDE.expandFilename(filename_string));\n            if (!filename.isAbsolute()) {\n                FlnReader reader = readers.peek();\n                File current_filename = new File(reader.filename);\n                File current_parent = current_filename.getParentFile();\n                filename = new File(current_parent, filename.toString());\n            }\n            readers.push(new FlnReader(filename.getAbsolutePath()));\n            return readLine();\n        }\n    }\n    return (line);\n}","methodRange":"(line 462,col 3)-(line 522,col 3)","methodTokenRange":"@Override\n  public \/*@Nullable*\/ String readLine() throws IOException {\n\n    \/\/ System.out.printf (\"Entering size = %d%n\", readers.size());\n\n    \/\/ If a line has been pushed back, return it instead\n    if (pushback_line != null) {\n      String line = pushback_line;\n      pushback_line = null;\n      return line;\n    }\n\n    String line = get_next_line();\n    if (comment_re != null) {\n      while (line != null) {\n        Matcher cmatch = comment_re.matcher(line);\n        if (cmatch.find()) {\n          line = cmatch.replaceFirst(\"\");\n          if (line.length() > 0) {\n            break;\n          }\n        } else {\n          break;\n        }\n        line = get_next_line();\n        \/\/ System.out.printf (\"get_next_line = %s%n\", line);\n      }\n    }\n\n    if (line == null) {\n      return null;\n    }\n\n    \/\/ Handle include files.  Non-absolute pathnames are relative\n    \/\/ to the including file (the current file)\n    if (include_re != null) {\n      Matcher m = include_re.matcher(line);\n      if (m.matches()) {\n        String filename_string = m.group(1);\n        if (filename_string == null) {\n          throw new Error(\n              String.format(\"include_re (%s) does not capture group 1 in %s\", include_re, line));\n        }\n        File filename = new File(UtilMDE.expandFilename(filename_string));\n        \/\/ System.out.printf (\"Trying to include filename %s%n\", filename);\n        if (!filename.isAbsolute()) {\n          FlnReader reader = readers.peek();\n          File current_filename = new File(reader.filename);\n          File current_parent = current_filename.getParentFile();\n          filename = new File(current_parent, filename.toString());\n          \/\/ System.out.printf (\"absolute filename = %s %s %s%n\",\n          \/\/                     current_filename, current_parent, filename);\n        }\n        readers.push(new FlnReader(filename.getAbsolutePath()));\n        return readLine();\n      }\n    }\n\n    \/\/ System.out.printf (\"Returning [%d] '%s'%n\", readers.size(), line);\n    return (line);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Read a line, ignoring comments and processing includes.  Note that\n   * a line that is completely a comment is completely ignored (and\n   * not returned as a blank line).  Returns null at end of file.\n   * @return the string that was read, or null at end of file\n   ","methodParameters":[],"methodName":"readLine","methodQualifiedSignature":"plume.EntryReader.readLine","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Read a line, ignoring comments and processing includes.  Note that\na line that is completely a comment is completely ignored (and\nnot returned as a blank line).  Returns null at end of file.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the string that was read, or null at end of file'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 468,col 26)-(line 468,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 470,col 23)-(line 470,col 26)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 475,col 23)-(line 475,col 26)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 476,col 22)-(line 476,col 25)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 479,col 38)-(line 479,col 39)","literalExprId":5,"literalExpr":"\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 480,col 31)-(line 480,col 31)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 491,col 17)-(line 491,col 20)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 492,col 14)-(line 492,col 17)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 497,col 23)-(line 497,col 26)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 500,col 42)-(line 500,col 42)","literalExprId":10,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 501,col 32)-(line 501,col 35)","literalExprId":11,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 503,col 29)-(line 503,col 76)","literalExprId":12,"literalExpr":"\"include_re (%s) does not capture group 1 in %s\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.readLine()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"a line-by-line iterator for this file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a line-by-line iterator for this file'}]}', name=Optional.empty}"}],"methodDeclaration":"public Iterator<String> iterator()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return this;\n}","methodRange":"(line 534,col 3)-(line 537,col 3)","methodTokenRange":"@Override\n  public Iterator<String> iterator() {\n    return this;\n  }","methodReturnTypeResolved":"ReferenceType{java.util.Iterator, typeParametersMap=TypeParametersMap{nameToValue={java.util.Iterator.E=ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","methodJavadocComment":"\n   * Return a line-by-line iterator for this file.\n   * <p>\n   *\n   * <b>Warning:<\/b> This does not return a fresh iterator each time.  The\n   * iterator is a singleton, the same one is returned each time, and a new\n   * one can never be created after it is exhausted.\n   *\n   * @return a line-by-line iterator for this file\n   ","methodParameters":[],"methodName":"iterator","methodQualifiedSignature":"plume.EntryReader.iterator","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return a line-by-line iterator for this file.\n<p>\n\n<b>Warning:<\/b> This does not return a fresh iterator each time.  The\niterator is a singleton, the same one is returned each time, and a new\none can never be created after it is exhausted.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='a line-by-line iterator for this file'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.util.Iterator<java.lang.String>","methodType":"Iterator<String>","literalExprs":[],"methodQualifiedName":"plume.EntryReader.iterator()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"whether there is another line to read","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether there is another line to read'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean hasNext()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (pushback_line != null) {\n        return true;\n    }\n    String line = null;\n    try {\n        line = readLine();\n    } catch (IOException e) {\n        throw new Error(\"unexpected IOException: \", e);\n    }\n    if (line == null) {\n        return false;\n    }\n    putback(line);\n    return true;\n}","methodRange":"(line 545,col 3)-(line 564,col 3)","methodTokenRange":"@Override\n  public boolean hasNext() {\n    if (pushback_line != null) {\n      return true;\n    }\n\n    String line = null;\n    try {\n      line = readLine();\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException: \", e);\n    }\n\n    if (line == null) {\n      return false;\n    }\n\n    putback(line);\n    return true;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Returns whether or not there is another line to read.  Any IOExceptions\n   * are turned into errors (because the definition of hasNext() in Iterator\n   * doesn't throw any exceptions).\n   * @return whether there is another line to read\n   ","methodParameters":[],"methodName":"hasNext","methodQualifiedSignature":"plume.EntryReader.hasNext","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns whether or not there is another line to read.  Any IOExceptions\nare turned into errors (because the definition of hasNext() in Iterator\ndoesn't throw any exceptions).'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether there is another line to read'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 547,col 26)-(line 547,col 29)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 548,col 14)-(line 548,col 17)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 551,col 19)-(line 551,col 22)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 555,col 23)-(line 555,col 48)","literalExprId":4,"literalExpr":"\"unexpected IOException: \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 558,col 17)-(line 558,col 20)","literalExprId":5,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 559,col 14)-(line 559,col 18)","literalExprId":6,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 563,col 12)-(line 563,col 15)","literalExprId":7,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.hasNext()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the next line in the multi-file\nThrows NoSuchElementException at end of file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next line in the multi-file\nThrows NoSuchElementException at end of file'}]}', name=Optional.empty}"}],"methodDeclaration":"public String next()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    try {\n        String result = readLine();\n        if (result != null) {\n            return result;\n        } else {\n            throw new NoSuchElementException();\n        }\n    } catch (IOException e) {\n        throw new Error(\"unexpected IOException\", e);\n    }\n}","methodRange":"(line 571,col 3)-(line 583,col 3)","methodTokenRange":"@Override\n  public String next() {\n    try {\n      String result = readLine();\n      if (result != null) {\n        return result;\n      } else {\n        throw new NoSuchElementException();\n      }\n    } catch (IOException e) {\n      throw new Error(\"unexpected IOException\", e);\n    }\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Return the next line in the multi-file.\n   * @return the next line in the multi-file\n   * Throws NoSuchElementException at end of file\n   ","methodParameters":[],"methodName":"next","methodQualifiedSignature":"plume.EntryReader.next","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the next line in the multi-file.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next line in the multi-file\nThrows NoSuchElementException at end of file'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 575,col 21)-(line 575,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 581,col 23)-(line 581,col 46)","literalExprId":2,"literalExpr":"\"unexpected IOException\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.next()"},{"javadocBlockTags":[],"methodDeclaration":"public void remove()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n}","methodRange":"(line 586,col 3)-(line 589,col 3)","methodTokenRange":"@Override\n  public void remove() {\n    throw new UnsupportedOperationException(\"can't remove lines from file\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" remove() is not supported. ","methodParameters":[],"methodName":"remove","methodQualifiedSignature":"plume.EntryReader.remove","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='remove() is not supported.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 588,col 45)-(line 588,col 74)","literalExprId":1,"literalExpr":"\"can't remove lines from file\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.remove()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the next entry (paragraph) in the file","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next entry (paragraph) in the file'}]}', name=Optional.empty}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading the file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public Entry get_entry() throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n        line = readLine();\n    }\n    if (line == null) {\n        return (null);\n    }\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n    Matcher entry_match = null;\n    if (entry_start_re != null) {\n        entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n        assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n        assert entry_stop_re != null : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n        if (entry_match.groupCount() > 0) {\n            @SuppressWarnings(\"nullness\")\n            String match_group_1 = entry_match.group(1);\n            line = entry_match.replaceFirst(match_group_1);\n        }\n        String description = line;\n        Matcher end_entry_match = entry_stop_re.matcher(line);\n        while ((line != null) && !entry_match.find() && !end_entry_match.find() && filename.equals(getFileName())) {\n            body.append(line);\n            body.append(lineSep);\n            line = readLine();\n            if (line == null) {\n                break;\n            }\n            entry_match = entry_start_re.matcher(line);\n            end_entry_match = entry_stop_re.matcher(line);\n        }\n        if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n            putback(line);\n        }\n        entry = new Entry(description, body.toString(), filename, line_number, false);\n    } else {\n        String description = line;\n        while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n            body.append(line);\n            body.append(lineSep);\n            line = readLine();\n        }\n        if ((line != null) && !filename.equals(getFileName())) {\n            putback(line);\n        }\n        entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n    return (entry);\n}","methodRange":"(line 599,col 3)-(line 681,col 3)","methodTokenRange":"public \/*@Nullable*\/ Entry get_entry() throws IOException {\n\n    \/\/ Skip any preceding blank lines\n    String line = readLine();\n    while ((line != null) && (line.trim().length() == 0)) {\n      line = readLine();\n    }\n    if (line == null) {\n      return (null);\n    }\n\n    StringBuilder body = new StringBuilder(10000);\n    Entry entry = null;\n    String filename = getFileName();\n    long line_number = getLineNumber();\n\n    \/\/ If first line matches entry_start_re, this is a long entry.\n    \/*@Regex(1)*\/ Matcher entry_match = null;\n    if (entry_start_re != null) {\n      entry_match = entry_start_re.matcher(line);\n    }\n    if ((entry_match != null) && entry_match.find()) {\n      assert entry_start_re != null : \"@AssumeAssertion(nullness): dependent: entry_match != null\";\n      assert entry_stop_re != null\n          : \"@AssumeAssertion(nullness): dependent: entry_start_re != null\";\n\n      \/\/ Remove entry match from the line\n      if (entry_match.groupCount() > 0) {\n        @SuppressWarnings(\n            \"nullness\") \/\/ dependent: just checked that group 1 exists via groupCount(); https:\/\/code.google.com\/p\/checker-framework\/issues\/detail?id=291\n        \/*@NonNull*\/ String match_group_1 = entry_match.group(1);\n        line = entry_match.replaceFirst(match_group_1);\n      }\n\n      \/\/ Description is the first line\n      String description = line;\n\n      \/\/ Read until we find the termination of the entry\n      Matcher end_entry_match = entry_stop_re.matcher(line);\n      while ((line != null)\n          && !entry_match.find()\n          && !end_entry_match.find()\n          && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n        if (line == null) {\n          break; \/\/ end of file serves as entry terminator\n        }\n        entry_match = entry_start_re.matcher(line);\n        end_entry_match = entry_stop_re.matcher(line);\n      }\n\n      \/\/ If this entry was terminated by the start of the next one,\n      \/\/ put that line back\n      if ((line != null) && (entry_match.find(0) || !filename.equals(getFileName()))) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, false);\n\n    } else { \/\/ blank-separated entry\n\n      String description = line;\n\n      \/\/ Read until we find another blank line\n      while ((line != null) && (line.trim().length() != 0) && filename.equals(getFileName())) {\n        body.append(line);\n        body.append(lineSep);\n        line = readLine();\n      }\n\n      \/\/ If this entry was terminated by the start of a new input file\n      \/\/ put that line back\n      if ((line != null) && !filename.equals(getFileName())) {\n        putback(line);\n      }\n\n      entry = new Entry(description, body.toString(), filename, line_number, true);\n    }\n\n    return (entry);\n  }","methodReturnTypeResolved":"ReferenceType{plume.EntryReader.Entry, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the next entry (paragraph) in the file.  Entries are separated\n   * by blank lines unless the entry started with {@link #entry_start_re}\n   * (see {@link #set_entry_start_stop}).  If no more entries are\n   * available, returns null.\n   * @return the next entry (paragraph) in the file\n   * @throws IOException if there is a problem reading the file\n   ","methodParameters":[],"methodName":"get_entry","methodQualifiedSignature":"plume.EntryReader.get_entry","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the next entry (paragraph) in the file.  Entries are separated\nby blank lines unless the entry started with '}, JavadocInlineTag{tagName='link', type=LINK, content=' #entry_start_re'}, JavadocSnippet{text='\n(see '}, JavadocInlineTag{tagName='link', type=LINK, content=' #set_entry_start_stop'}, JavadocSnippet{text=').  If no more entries are\navailable, returns null.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the next entry (paragraph) in the file'}]}', name=Optional.empty}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading the file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"plume.EntryReader.Entry","methodType":"Entry","literalExprs":[{"literalExprRange":"(line 603,col 21)-(line 603,col 24)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 603,col 55)-(line 603,col 55)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 606,col 17)-(line 606,col 20)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 607,col 15)-(line 607,col 18)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 610,col 44)-(line 610,col 48)","literalExprId":5,"literalExpr":"10000","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 611,col 19)-(line 611,col 22)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 616,col 41)-(line 616,col 44)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 617,col 27)-(line 617,col 30)","literalExprId":8,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 620,col 25)-(line 620,col 28)","literalExprId":9,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 621,col 32)-(line 621,col 35)","literalExprId":10,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 621,col 39)-(line 621,col 98)","literalExprId":11,"literalExpr":"\"@AssumeAssertion(nullness): dependent: entry_match != null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 622,col 31)-(line 622,col 34)","literalExprId":12,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 623,col 13)-(line 623,col 75)","literalExprId":13,"literalExpr":"\"@AssumeAssertion(nullness): dependent: entry_start_re != null\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 626,col 38)-(line 626,col 38)","literalExprId":14,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 628,col 13)-(line 628,col 22)","literalExprId":15,"literalExpr":"\"nullness\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 629,col 63)-(line 629,col 63)","literalExprId":16,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 638,col 23)-(line 638,col 26)","literalExprId":17,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 645,col 21)-(line 645,col 24)","literalExprId":18,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 654,col 20)-(line 654,col 23)","literalExprId":19,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 654,col 47)-(line 654,col 47)","literalExprId":20,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 658,col 78)-(line 658,col 82)","literalExprId":21,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 665,col 23)-(line 665,col 26)","literalExprId":22,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 665,col 57)-(line 665,col 57)","literalExprId":23,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 673,col 20)-(line 673,col 23)","literalExprId":24,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 677,col 78)-(line 677,col 81)","literalExprId":25,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.get_entry()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"next line from the reader, or null if there is no more input","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='next line from the reader, or null if there is no more input'}]}', name=Optional.empty}"}],"methodDeclaration":"private String get_next_line() throws IOException","methodAccessSpecifier":"PRIVATE","methodBody":"{\n    if (readers.size() == 0) {\n        return (null);\n    }\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n        readers.pop();\n        if (readers.empty()) {\n            return (null);\n        }\n        FlnReader ri2 = readers.peek();\n        line = ri2.readLine();\n    }\n    return (line);\n}","methodRange":"(line 688,col 3)-(line 705,col 3)","methodTokenRange":"private \/*@Nullable*\/ String get_next_line() throws IOException {\n\n    if (readers.size() == 0) {\n      return (null);\n    }\n\n    FlnReader ri1 = readers.peek();\n    String line = ri1.readLine();\n    while (line == null) {\n      readers.pop();\n      if (readers.empty()) {\n        return (null);\n      }\n      FlnReader ri2 = readers.peek();\n      line = ri2.readLine();\n    }\n    return (line);\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Reads the next line from the current reader.  If EOF is encountered\n   * pop out to the next reader.  Returns null if there is no more input.\n   * @return next line from the reader, or null if there is no more input\n   ","methodParameters":[],"methodName":"get_next_line","methodQualifiedSignature":"plume.EntryReader.get_next_line","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reads the next line from the current reader.  If EOF is encountered\npop out to the next reader.  Returns null if there is no more input.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='next line from the reader, or null if there is no more input'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 690,col 27)-(line 690,col 27)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 691,col 15)-(line 691,col 18)","literalExprId":2,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 696,col 20)-(line 696,col 23)","literalExprId":3,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 699,col 17)-(line 699,col 20)","literalExprId":4,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.get_next_line()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the current filename","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the current filename'}]}', name=Optional.empty}"}],"methodDeclaration":"public String getFileName()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n        throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n}","methodRange":"(line 711,col 3)-(line 717,col 3)","methodTokenRange":"public String getFileName() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.filename;\n  }","methodReturnTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","methodJavadocComment":"\n   * Returns the current filename.\n   * @return the current filename\n   ","methodParameters":[],"methodName":"getFileName","methodQualifiedSignature":"plume.EntryReader.getFileName","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Returns the current filename.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the current filename'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"java.lang.String","methodType":"String","literalExprs":[{"literalExprRange":"(line 713,col 15)-(line 713,col 18)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 714,col 23)-(line 714,col 41)","literalExprId":2,"literalExpr":"\"Past end of input\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.getFileName()"},{"javadocBlockTags":[{"javadocBlockType":"RETURN","javadocBlockTagContent":"the current line number","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the current line number'}]}', name=Optional.empty}"}],"methodDeclaration":"public int getLineNumber()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n        throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n}","methodRange":"(line 723,col 3)-(line 730,col 3)","methodTokenRange":"@Override\n  public int getLineNumber() {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    return ri.getLineNumber();\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"\n   * Return the current line number in the current file.\n   * @return the current line number\n   ","methodParameters":[],"methodName":"getLineNumber","methodQualifiedSignature":"plume.EntryReader.getLineNumber","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Return the current line number in the current file.'}]}, blockTags=[JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='the current line number'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 726,col 15)-(line 726,col 18)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 727,col 23)-(line 727,col 41)","literalExprId":2,"literalExpr":"\"Past end of input\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.getLineNumber()"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"new line number for the current file","javadocBlockTagName":"lineNumber","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new line number for the current file'}]}', name=Optional[lineNumber]}"}],"methodDeclaration":"public void setLineNumber(int lineNumber)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n        throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n}","methodRange":"(line 735,col 3)-(line 742,col 3)","methodTokenRange":"@Override\n  public void setLineNumber(int lineNumber) {\n    FlnReader ri = readers.peek();\n    if (ri == null) {\n      throw new Error(\"Past end of input\");\n    }\n    ri.setLineNumber(lineNumber);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Set the current line number in the current file.\n   * @param lineNumber new line number for the current file\n   ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int lineNumber","parameterName":"lineNumber"}],"methodName":"setLineNumber","methodQualifiedSignature":"plume.EntryReader.setLineNumber","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the current line number in the current file.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='new line number for the current file'}]}', name=Optional[lineNumber]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 738,col 15)-(line 738,col 18)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 739,col 23)-(line 739,col 41)","literalExprId":2,"literalExpr":"\"Past end of input\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.setLineNumber(int)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that starts a long entry","javadocBlockTagName":"entry_start_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that starts a long entry'}]}', name=Optional[entry_start_re]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that ends a long entry","javadocBlockTagName":"entry_stop_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that ends a long entry'}]}', name=Optional[entry_stop_re]}"}],"methodDeclaration":"public void set_entry_start_stop(String entry_start_re, String entry_stop_re)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n}","methodRange":"(line 750,col 3)-(line 754,col 3)","methodTokenRange":"public void set_entry_start_stop(\n      \/*@Regex(1)*\/ String entry_start_re, \/*@Regex*\/ String entry_stop_re) {\n    this.entry_start_re = Pattern.compile(entry_start_re);\n    this.entry_stop_re = Pattern.compile(entry_stop_re);\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   ","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String entry_start_re","parameterName":"entry_start_re"},{"parameterType":"String","parameterId":2,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String entry_stop_re","parameterName":"entry_stop_re"}],"methodName":"set_entry_start_stop","methodQualifiedSignature":"plume.EntryReader.set_entry_start_stop","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the regular expressions for the start and stop of long\nentries (multiple lines that are read as a group by get_entry()).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that starts a long entry'}]}', name=Optional[entry_start_re]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that ends a long entry'}]}', name=Optional[entry_stop_re]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.EntryReader.set_entry_start_stop(java.lang.String, java.lang.String)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that starts a long entry","javadocBlockTagName":"entry_start_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that starts a long entry'}]}', name=Optional[entry_start_re]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"regular expression that ends a long entry","javadocBlockTagName":"entry_stop_re","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that ends a long entry'}]}', name=Optional[entry_stop_re]}"}],"methodDeclaration":"public void set_entry_start_stop(Pattern entry_start_re, Pattern entry_stop_re)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n}","methodRange":"(line 762,col 3)-(line 765,col 3)","methodTokenRange":"public void set_entry_start_stop(\/*@Regex(1)*\/ Pattern entry_start_re, Pattern entry_stop_re) {\n    this.entry_start_re = entry_start_re;\n    this.entry_stop_re = entry_stop_re;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Set the regular expressions for the start and stop of long\n   * entries (multiple lines that are read as a group by get_entry()).\n   * @param entry_start_re regular expression that starts a long entry\n   * @param entry_stop_re regular expression that ends a long entry\n   ","methodParameters":[{"parameterType":"Pattern","parameterId":1,"parameterTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.regex.Pattern","parameter":"Pattern entry_start_re","parameterName":"entry_start_re"},{"parameterType":"Pattern","parameterId":2,"parameterTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.util.regex.Pattern","parameter":"Pattern entry_stop_re","parameterName":"entry_stop_re"}],"methodName":"set_entry_start_stop","methodQualifiedSignature":"plume.EntryReader.set_entry_start_stop","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set the regular expressions for the start and stop of long\nentries (multiple lines that are read as a group by get_entry()).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that starts a long entry'}]}', name=Optional[entry_start_re]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='regular expression that ends a long entry'}]}', name=Optional[entry_stop_re]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[],"methodQualifiedName":"plume.EntryReader.set_entry_start_stop(java.util.regex.Pattern, java.util.regex.Pattern)"},{"methodDeclaration":"public void putback(String line)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    assert pushback_line == null : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n}","methodRange":"(line 774,col 3)-(line 778,col 3)","methodTokenRange":"public void putback(String line) {\n    assert pushback_line == null\n        : \"push back '\" + line + \"' when '\" + pushback_line + \"' already back\";\n    pushback_line = line;\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" of BufferedReader (which is also in LineNumberReader and FlnReader).","methodParameters":[{"parameterType":"String","parameterId":1,"parameterTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","parameterTypeResolvedDescribed":"java.lang.String","parameter":"String line","parameterName":"line"}],"methodName":"putback","methodQualifiedSignature":"plume.EntryReader.putback","methodJavadoc":"","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 775,col 29)-(line 775,col 32)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 776,col 11)-(line 776,col 23)","literalExprId":2,"literalExpr":"\"push back '\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 776,col 34)-(line 776,col 43)","literalExprId":3,"literalExpr":"\"' when '\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 776,col 63)-(line 776,col 78)","literalExprId":4,"literalExpr":"\"' already back\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.putback(java.lang.String)"},{"javadocBlockTags":[],"methodDeclaration":"public void mark(int readAheadLimit)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new Error(\"not yet implemented\");\n}","methodRange":"(line 781,col 3)-(line 784,col 3)","methodTokenRange":"@Override\n  public void mark(int readAheadLimit) {\n    throw new Error(\"not yet implemented\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Mark the present position in the stream. ","methodParameters":[{"parameterType":"int","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int readAheadLimit","parameterName":"readAheadLimit"}],"methodName":"mark","methodQualifiedSignature":"plume.EntryReader.mark","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Mark the present position in the stream.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 783,col 21)-(line 783,col 41)","literalExprId":1,"literalExpr":"\"not yet implemented\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.mark(int)"},{"javadocBlockTags":[],"methodDeclaration":"public int read()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new Error(\"not yet implemented\");\n}","methodRange":"(line 786,col 3)-(line 789,col 3)","methodTokenRange":"@Override\n  public int read() {\n    throw new Error(\"not yet implemented\");\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Read a single character. ","methodParameters":[],"methodName":"read","methodQualifiedSignature":"plume.EntryReader.read","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Read a single character.'}]}, blockTags=[]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 788,col 21)-(line 788,col 41)","literalExprId":1,"literalExpr":"\"not yet implemented\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.read()"},{"javadocBlockTags":[],"methodDeclaration":"public int read(char[] cbuf, int off, int len)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new Error(\"not yet implemented\");\n}","methodRange":"(line 791,col 3)-(line 794,col 3)","methodTokenRange":"@Override\n  public int read(char[] cbuf, int off, int len) {\n    throw new Error(\"not yet implemented\");\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":" Read characters into a portion of an array. ","methodParameters":[{"parameterType":"char[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='char'}}","parameterTypeResolvedDescribed":"char[]","parameter":"char[] cbuf","parameterName":"cbuf"},{"parameterType":"int","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int off","parameterName":"off"},{"parameterType":"int","parameterId":3,"parameterTypeResolved":"PrimitiveTypeUsage{name='int'}","parameterTypeResolvedDescribed":"int","parameter":"int len","parameterName":"len"}],"methodName":"read","methodQualifiedSignature":"plume.EntryReader.read","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Read characters into a portion of an array.'}]}, blockTags=[]}","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 793,col 21)-(line 793,col 41)","literalExprId":1,"literalExpr":"\"not yet implemented\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.read(char[], int, int)"},{"javadocBlockTags":[],"methodDeclaration":"public void reset()","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new Error(\"not yet implemented\");\n}","methodRange":"(line 796,col 3)-(line 799,col 3)","methodTokenRange":"@Override\n  public void reset() {\n    throw new Error(\"not yet implemented\");\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":" Reset the stream to the most recent mark. ","methodParameters":[],"methodName":"reset","methodQualifiedSignature":"plume.EntryReader.reset","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Reset the stream to the most recent mark.'}]}, blockTags=[]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 798,col 21)-(line 798,col 41)","literalExprId":1,"literalExpr":"\"not yet implemented\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.reset()"},{"javadocBlockTags":[],"methodDeclaration":"public long skip(long n)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    throw new Error(\"not yet implemented\");\n}","methodRange":"(line 801,col 3)-(line 804,col 3)","methodTokenRange":"@Override\n  public long skip(long n) {\n    throw new Error(\"not yet implemented\");\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='long'}","methodJavadocComment":" Skip characters. ","methodParameters":[{"parameterType":"long","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='long'}","parameterTypeResolvedDescribed":"long","parameter":"long n","parameterName":"n"}],"methodName":"skip","methodQualifiedSignature":"plume.EntryReader.skip","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Skip characters.'}]}, blockTags=[]}","methodReturnTypeDescribed":"long","methodType":"long","literalExprs":[{"literalExprRange":"(line 803,col 21)-(line 803,col 41)","literalExprId":1,"literalExpr":"\"not yet implemented\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.skip(long)"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"command-line arguments: filename [comment_re [include_re]]","javadocBlockTagName":"args","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments: filename [comment_re [include_re]]'}]}', name=Optional[args]}"},{"javadocBlockType":"THROWS","javadocBlockTagContent":"if there is a problem reading a file","javadocBlockTagName":"IOException","javadocBlockTag":"JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}"}],"methodDeclaration":"public static void main(String[] args) throws IOException","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (args.length < 1 || args.length > 3) {\n        System.err.println(\"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n        System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n        comment_re = args[1];\n        if (!RegexUtil.isRegex(comment_re)) {\n            System.err.println(\"Error parsing comment regex \\\"\" + comment_re + \"\\\": \" + RegexUtil.regexError(comment_re));\n            System.exit(1);\n        }\n    }\n    if (args.length >= 3) {\n        include_re = args[2];\n        if (!RegexUtil.isRegex(include_re, 1)) {\n            System.err.println(\"Error parsing include regex \\\"\" + include_re + \"\\\": \" + RegexUtil.regexError(include_re));\n            System.exit(1);\n        }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n    String line = reader.readLine();\n    while (line != null) {\n        System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n        line = reader.readLine();\n    }\n}","methodRange":"(line 811,col 3)-(line 850,col 3)","methodTokenRange":"public static void main(String[] args) throws IOException {\n\n    if (args.length < 1 || args.length > 3) {\n      System.err.println(\n          \"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\");\n      System.exit(1);\n    }\n    String filename = args[0];\n    String comment_re = null;\n    String include_re = null;\n    if (args.length >= 2) {\n      comment_re = args[1];\n      if (!RegexUtil.isRegex(comment_re)) {\n        System.err.println(\n            \"Error parsing comment regex \\\"\"\n                + comment_re\n                + \"\\\": \"\n                + RegexUtil.regexError(comment_re));\n        System.exit(1);\n      }\n    }\n    if (args.length >= 3) {\n      include_re = args[2];\n      if (!RegexUtil.isRegex(include_re, 1)) {\n        System.err.println(\n            \"Error parsing include regex \\\"\"\n                + include_re\n                + \"\\\": \"\n                + RegexUtil.regexError(include_re));\n        System.exit(1);\n      }\n    }\n    EntryReader reader = new EntryReader(filename, comment_re, include_re);\n\n    String line = reader.readLine();\n    while (line != null) {\n      System.out.printf(\"%s: %d: %s%n\", reader.getFileName(), reader.getLineNumber(), line);\n      line = reader.readLine();\n    }\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Simple usage example.\n   * @param args command-line arguments: filename [comment_re [include_re]]\n   * @throws IOException if there is a problem reading a file\n   ","methodParameters":[{"parameterType":"String[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}}","parameterTypeResolvedDescribed":"java.lang.String[]","parameter":"String[] args","parameterName":"args"}],"methodName":"main","methodQualifiedSignature":"plume.EntryReader.main","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Simple usage example.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='command-line arguments: filename [comment_re [include_re]]'}]}', name=Optional[args]}, JavadocBlockTag{type=THROWS, content='JavadocDescription{elements=[JavadocSnippet{text='if there is a problem reading a file'}]}', name=Optional[IOException]}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 813,col 23)-(line 813,col 23)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 813,col 42)-(line 813,col 42)","literalExprId":2,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 815,col 11)-(line 815,col 92)","literalExprId":3,"literalExpr":"\"EntryReader sample program requires 1-3 args: filename [comment_re [include_re]]\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 816,col 19)-(line 816,col 19)","literalExprId":4,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 818,col 28)-(line 818,col 28)","literalExprId":5,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 819,col 25)-(line 819,col 28)","literalExprId":6,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 820,col 25)-(line 820,col 28)","literalExprId":7,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 821,col 24)-(line 821,col 24)","literalExprId":8,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 822,col 25)-(line 822,col 25)","literalExprId":9,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 825,col 13)-(line 825,col 44)","literalExprId":10,"literalExpr":"\"Error parsing comment regex \\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 827,col 19)-(line 827,col 24)","literalExprId":11,"literalExpr":"\"\\\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 829,col 21)-(line 829,col 21)","literalExprId":12,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 832,col 24)-(line 832,col 24)","literalExprId":13,"literalExpr":"3","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 833,col 25)-(line 833,col 25)","literalExprId":14,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 834,col 42)-(line 834,col 42)","literalExprId":15,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 836,col 13)-(line 836,col 44)","literalExprId":16,"literalExpr":"\"Error parsing include regex \\\"\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 838,col 19)-(line 838,col 24)","literalExprId":17,"literalExpr":"\"\\\": \"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 840,col 21)-(line 840,col 21)","literalExprId":18,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 846,col 20)-(line 846,col 23)","literalExprId":19,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"},{"literalExprRange":"(line 847,col 25)-(line 847,col 38)","literalExprId":20,"literalExpr":"\"%s: %d: %s%n\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"methodQualifiedName":"plume.EntryReader.main(java.lang.String[])"}],"classJavadoc":"\/**\n * Class that reads \"entries\" from a file.  In the simplest case, entries\n * can be lines.  It supports:\n *   include files,\n *   comments, and\n *   multi-line entries (paragraphs).\n * The syntax of each of these is customizable.\n * <p>\n *\n * Example use:\n * <pre>\n *  \/\/ args are filename, comment regexp, include regexp\n *  try (EntryReader er = new EntryReader(filename, \"^#.*\", null)) {\n *    for (String line : er) {\n *      ...\n *    }\n *  } catch (IOException e) {\n *    System.err.println(\"Problem reading \" + filename + \": \" + e.getMessage());\n *    System.exit(2);\n *    throw new Error(\"This can't happen\"); \/\/ for definite assignment check\n *  }\n * <\/pre>\n *\n * @see #get_entry() and @see #set_entry_start_stop(String,String)\n *\/\n","className":"EntryReader","fields":[{"fieldRange":"(line 71,col 3)-(line 71,col 63)","fieldName":"include_re","fieldJavadocComment":" Regular expression that specifies an include file. ","fieldTokenRange":"private final \/*@Nullable*\/ \/*@Regex(1)*\/ Pattern include_re;","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Pattern","fieldJavadoc":"Regular expression that specifies an include file.\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 74,col 3)-(line 74,col 49)","fieldName":"comment_re","fieldJavadocComment":" Regular expression that matches a comment. ","fieldTokenRange":"private final \/*@Nullable*\/ Pattern comment_re;","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"","fieldType":"Pattern","fieldJavadoc":"Regular expression that matches a comment.\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 88,col 3)-(line 88,col 75)","fieldName":"entry_start_re","fieldJavadocComment":"\n   * Regular expression that starts a long entry.\n   * <p>\n   * If the first line of an entry matches this regexp, then the entry is\n   * terminated by:  entry_stop_re, another line that matches\n   * entry_start_re (even not following a newline), or the end of the\n   * current file.\n   * <p>\n   * Otherwise, the first line of an entry does NOT match this regexp (or\n   * the regexp is null), in which case the entry is terminated by a blank\n   * line or the end of the current file.\n   ","fieldTokenRange":"public \/*@MonotonicNonNull*\/ \/*@Regex(1)*\/ Pattern entry_start_re = null;","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 88,col 71)-(line 88,col 74)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Pattern","fieldJavadoc":"Regular expression that starts a long entry.\n<p>\nIf the first line of an entry matches this regexp, then the entry is\nterminated by:  entry_stop_re, another line that matches\nentry_start_re (even not following a newline), or the end of the\ncurrent file.\n<p>\nOtherwise, the first line of an entry does NOT match this regexp (or\nthe regexp is null), in which case the entry is terminated by a blank\nline or the end of the current file.\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 93,col 3)-(line 93,col 60)","fieldName":"entry_stop_re","fieldJavadocComment":"\n   * @see #entry_start_re\n   ","fieldTokenRange":"public \/*@MonotonicNonNull*\/ Pattern entry_stop_re = null;","fieldTypeResolved":"ReferenceType{java.util.regex.Pattern, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PUBLIC","literalExprs":[{"literalExprRange":"(line 93,col 56)-(line 93,col 59)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"Pattern","fieldJavadoc":"\n@see #entry_start_re\n","fieldTypeResolvedDescribed":"java.util.regex.Pattern"},{"fieldRange":"(line 100,col 3)-(line 100,col 66)","fieldName":"readers","fieldJavadocComment":" Stack of readers.  Used to support include files. ","fieldTokenRange":"private final Stack<FlnReader> readers = new Stack<FlnReader>();","fieldTypeResolved":"ReferenceType{java.util.Stack, typeParametersMap=TypeParametersMap{nameToValue={java.util.Stack.E=ReferenceType{plume.EntryReader.FlnReader, typeParametersMap=TypeParametersMap{nameToValue={}}}}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[],"fieldInitializer":"Optional[new Stack<FlnReader>()]","fieldType":"Stack<FlnReader>","fieldJavadoc":"Stack of readers.  Used to support include files.\n","fieldTypeResolvedDescribed":"java.util.Stack<plume.EntryReader.FlnReader>"},{"fieldRange":"(line 103,col 17)-(line 103,col 44)","fieldName":"pushback_line","fieldJavadocComment":"@Nullable","fieldTokenRange":"String pushback_line = null;","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 103,col 40)-(line 103,col 43)","literalExprId":1,"literalExpr":"null","literalExprClass":"class com.github.javaparser.ast.expr.NullLiteralExpr"}],"fieldInitializer":"Optional[null]","fieldType":"String","fieldJavadoc":"","fieldTypeResolvedDescribed":"java.lang.String"},{"fieldRange":"(line 106,col 3)-(line 106,col 77)","fieldName":"lineSep","fieldJavadocComment":" Platform-specific line separator. ","fieldTokenRange":"private static final String lineSep = System.getProperty(\"line.separator\");","fieldTypeResolved":"ReferenceType{java.lang.String, typeParametersMap=TypeParametersMap{nameToValue={}}}","fieldAccessSpecifier":"PRIVATE","literalExprs":[{"literalExprRange":"(line 106,col 60)-(line 106,col 75)","literalExprId":1,"literalExpr":"\"line.separator\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"}],"fieldInitializer":"Optional[System.getProperty(\"line.separator\")]","fieldType":"String","fieldJavadoc":"Platform-specific line separator.\n","fieldTypeResolvedDescribed":"java.lang.String"}]}],"sourceFileId":48,"packageName":"plume"},{"sourceFileName":"plume.Filter","imports":[],"typeDeclarations":[{"constructors":[],"classOrInterface":[],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the object to test","javadocBlockTagName":"o","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to test'}]}', name=Optional[o]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"whether the object satisfies the filter","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether the object satisfies the filter'}]}', name=Optional.empty}"}],"methodDeclaration":" boolean accept(T o)","methodAccessSpecifier":"NONE","methodBody":"","methodRange":"(line 18,col 3)-(line 18,col 22)","methodTokenRange":"boolean accept(T o);","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Tests whether a specified Object satisfies the filter.\n   * @param o the object to test\n   * @return whether the object satisfies the filter\n   ","methodParameters":[{"parameterType":"T","parameterId":1,"parameterTypeResolved":"TypeVariable {JPTypeParameter(T, bounds=[Object])}","parameterTypeResolvedDescribed":"T","parameter":"T o","parameterName":"o"}],"methodName":"accept","methodQualifiedSignature":"plume.Filter.accept","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Tests whether a specified Object satisfies the filter.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the object to test'}]}', name=Optional[o]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='whether the object satisfies the filter'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.Filter.accept(T)"}],"classJavadoc":"\/**\n * Interface for things that make boolean decisions.\n * This is inspired by java.io.FilenameFilter.\n * @param <T> the type of arguments to {@link #accept}.\n *\/\n","className":"Filter","fields":[]}],"sourceFileId":49,"packageName":"plume"},{"sourceFileName":"plume.FuzzyFloat","imports":[{"importId":1,"import":"import java.io.Serializable;\n"},{"importId":2,"import":"import java.util.Arrays;\n"},{"importId":3,"import":"import java.util.Comparator;\n"}],"typeDeclarations":[{"constructors":[{"javadocBlockTags":[],"constructorQualifiedSignature":"plume.FuzzyFloat.FuzzyFloat()","variableDeclarationExprs":[],"constructorRange":"(line 45,col 3)-(line 45,col 24)","constructorJavadocComment":"\n   * Creates a FuzzyFloat with the default rel_diff value of .0001.\n   ","constructorDeclaration":"public FuzzyFloat()","constructorBody":"{\n}","constructorName":"FuzzyFloat","constructorQualifiedName":"plume.FuzzyFloat.FuzzyFloat","constructorParameters":[],"literalExprs":[],"constructorTokenRange":"public FuzzyFloat() {}","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a FuzzyFloat with the default rel_diff value of .0001.'}]}, blockTags=[]}"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the relative diff to use","javadocBlockTagName":"rel_diff","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the relative diff to use'}]}', name=Optional[rel_diff]}"}],"constructorQualifiedSignature":"plume.FuzzyFloat.FuzzyFloat(double)","variableDeclarationExprs":[],"constructorRange":"(line 54,col 3)-(line 56,col 3)","constructorJavadocComment":"\n   * Creates a FuzzyFloat.\n   * Specify the specific relative difference allowed between two\n   * floats in order for them to be equal.  The default is 0.0001\n   * a relative diff of zero, disables it (i.e., only exact matches work).\n   * @param rel_diff the relative diff to use\n   ","constructorDeclaration":"public FuzzyFloat(double rel_diff)","constructorBody":"{\n    set_rel_diff(rel_diff);\n}","constructorName":"FuzzyFloat","constructorQualifiedName":"plume.FuzzyFloat.FuzzyFloat","constructorParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double rel_diff","parameterName":"rel_diff"}],"literalExprs":[],"constructorTokenRange":"public FuzzyFloat(double rel_diff) {\n    set_rel_diff(rel_diff);\n  }","constructorJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Creates a FuzzyFloat.\nSpecify the specific relative difference allowed between two\nfloats in order for them to be equal.  The default is 0.0001\na relative diff of zero, disables it (i.e., only exact matches work).'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the relative diff to use'}]}', name=Optional[rel_diff]}]}"}],"classOrInterface":[{"classOrInterfaceRange":"(line 335,col 3)-(line 358,col 3)","classOrInterfaceTokenRange":"public class DoubleArrayComparatorLexical implements Comparator<double[]>, Serializable {\n    static final long serialVersionUID = 20150812L;\n\n    \/**\n     * Lexically compares o1 and o2 as double arrays.\n     *\n     * @param a1 the first array to compare\n     * @param a2 the second array to compare\n     * @return positive if o1 &gt; 02, 0 if o1 == o2, negative if o1 &lt; o2\n     *\/\n    \/*@Pure*\/\n    public int compare(double[] a1, double[] a2) {\n      if (a1 == a2) {\n        return 0;\n      }\n      int len = Math.min(a1.length, a2.length);\n      for (int i = 0; i < len; i++) {\n        if (ne(a1[i], a2[i])) {\n          return ((a1[i] > a2[i]) ? 1 : -1);\n        }\n      }\n      return a1.length - a2.length;\n    }\n  }","classOrInterfaceJavadocComment":"\n   * Lexically compares two double arrays.\n   ","classOrInterfaceJavadoc":"Optional[Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Lexically compares two double arrays.'}]}, blockTags=[]}]"}],"methods":[{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the new relative diff to use","javadocBlockTagName":"rel_diff","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new relative diff to use'}]}', name=Optional[rel_diff]}"},{"javadocBlockType":"SEE","javadocBlockTagContent":"#FuzzyFloat","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#FuzzyFloat'}]}', name=Optional.empty}"}],"methodDeclaration":"public void set_rel_diff(double rel_diff)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    min_ratio = 1 - rel_diff;\n    max_ratio = 1 + rel_diff;\n    off = (rel_diff == 0.0);\n}","methodRange":"(line 63,col 3)-(line 70,col 3)","methodTokenRange":"public void set_rel_diff(\/*>>> @UnknownInitialization @Raw FuzzyFloat this,*\/ double rel_diff) {\n    min_ratio = 1 - rel_diff;\n    max_ratio = 1 + rel_diff;\n    off = (rel_diff == 0.0);\n    \/\/System.out.println (\"min_ratio = \" + min_ratio + \", max_ratio = \"\n    \/\/                    + max_ratio);\n\n  }","methodReturnTypeResolved":"com.github.javaparser.resolution.types.ResolvedVoidType@243c4f91","methodJavadocComment":"\n   * Set all the fields of this class.\n   * @param rel_diff the new relative diff to use\n   * @see #FuzzyFloat\n   ","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double rel_diff","parameterName":"rel_diff"}],"methodName":"set_rel_diff","methodQualifiedSignature":"plume.FuzzyFloat.set_rel_diff","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Set all the fields of this class.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the new relative diff to use'}]}', name=Optional[rel_diff]}, JavadocBlockTag{type=SEE, content='JavadocDescription{elements=[JavadocSnippet{text='#FuzzyFloat'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"void","methodType":"void","literalExprs":[{"literalExprRange":"(line 64,col 17)-(line 64,col 17)","literalExprId":1,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 65,col 17)-(line 65,col 17)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 66,col 24)-(line 66,col 26)","literalExprId":3,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"plume.FuzzyFloat.set_rel_diff(double)"},{"methodDeclaration":"public boolean eq(double d1, double d2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    if (Double.isNaN(d1) && Double.isNaN(d2)) {\n        return (false);\n    }\n    if (off) {\n        return (d1 == d2);\n    }\n    if (d1 == d2) {\n        return (true);\n    }\n    if (d1 == 0.0 || d2 == 0.0) {\n        double zero_tolerance = Math.pow((max_ratio - 1), 2);\n        if (d1 == 0.0) {\n            return (Math.abs(d2) < zero_tolerance);\n        } else {\n            return (Math.abs(d1) < zero_tolerance);\n        }\n    }\n    double ratio = d1 \/ d2;\n    return ((ratio >= min_ratio) && (ratio <= max_ratio));\n}","methodRange":"(line 86,col 3)-(line 125,col 3)","methodTokenRange":"public boolean eq(double d1, double d2) {\n\n    \/\/ NaNs are not considered equal.\n    if (Double.isNaN(d1) && Double.isNaN(d2)) {\n      return (false);\n    }\n\n    \/\/ if zero was specified for a ratio, don't do the divide.  You might\n    \/\/ get slightly different answers.  And this should be faster.\n    if (off) {\n      return (d1 == d2);\n    }\n\n    \/\/ slightly more efficient for matches and catches positive and negative\n    \/\/ infinity (which match in this test, but not below)\n    if (d1 == d2) {\n      return (true);\n    }\n\n    \/\/ when one number is 0, check that the other is less than the square\n    \/\/ of the fuzzy ration (accommodates round off errors in floating point\n    \/\/ values)\n\n    if (d1 == 0.0 || d2 == 0.0) {\n\n      double zero_tolerance = Math.pow((max_ratio - 1), 2);\n\n      if (d1 == 0.0) {\n\n        return (Math.abs(d2) < zero_tolerance);\n\n      } else {\n\n        return (Math.abs(d1) < zero_tolerance);\n      }\n    }\n\n    double ratio = d1 \/ d2;\n    return ((ratio >= min_ratio) && (ratio <= max_ratio));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d1","parameterName":"d1"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d2","parameterName":"d2"}],"methodName":"eq","methodQualifiedSignature":"plume.FuzzyFloat.eq","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 90,col 15)-(line 90,col 19)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 102,col 15)-(line 102,col 18)","literalExprId":2,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 109,col 15)-(line 109,col 17)","literalExprId":3,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 109,col 28)-(line 109,col 30)","literalExprId":4,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"},{"literalExprRange":"(line 111,col 53)-(line 111,col 53)","literalExprId":5,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 111,col 57)-(line 111,col 57)","literalExprId":6,"literalExpr":"2","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 113,col 17)-(line 113,col 19)","literalExprId":7,"literalExpr":"0.0","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"methodQualifiedName":"plume.FuzzyFloat.eq(double, double)"},{"methodDeclaration":"public boolean ne(double d1, double d2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return (!eq(d1, d2));\n}","methodRange":"(line 135,col 3)-(line 137,col 3)","methodTokenRange":"public boolean ne(double d1, double d2) {\n    return (!eq(d1, d2));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d1","parameterName":"d1"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d2","parameterName":"d2"}],"methodName":"ne","methodQualifiedSignature":"plume.FuzzyFloat.ne","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.FuzzyFloat.ne(double, double)"},{"methodDeclaration":"public boolean lt(double d1, double d2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((d1 < d2) && ne(d1, d2));\n}","methodRange":"(line 148,col 3)-(line 150,col 3)","methodTokenRange":"public boolean lt(double d1, double d2) {\n    return ((d1 < d2) && ne(d1, d2));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d1","parameterName":"d1"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d2","parameterName":"d2"}],"methodName":"lt","methodQualifiedSignature":"plume.FuzzyFloat.lt","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.FuzzyFloat.lt(double, double)"},{"methodDeclaration":"public boolean lte(double d1, double d2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((d1 <= d2) || eq(d1, d2));\n}","methodRange":"(line 161,col 3)-(line 163,col 3)","methodTokenRange":"public boolean lte(double d1, double d2) {\n    return ((d1 <= d2) || eq(d1, d2));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d1","parameterName":"d1"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d2","parameterName":"d2"}],"methodName":"lte","methodQualifiedSignature":"plume.FuzzyFloat.lte","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.FuzzyFloat.lte(double, double)"},{"methodDeclaration":"public boolean gt(double d1, double d2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((d1 > d2) && ne(d1, d2));\n}","methodRange":"(line 174,col 3)-(line 176,col 3)","methodTokenRange":"public boolean gt(double d1, double d2) {\n    return ((d1 > d2) && ne(d1, d2));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d1","parameterName":"d1"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d2","parameterName":"d2"}],"methodName":"gt","methodQualifiedSignature":"plume.FuzzyFloat.gt","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.FuzzyFloat.gt(double, double)"},{"methodDeclaration":"public boolean gte(double d1, double d2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    return ((d1 >= d2) || eq(d1, d2));\n}","methodRange":"(line 187,col 3)-(line 189,col 3)","methodTokenRange":"public boolean gte(double d1, double d2) {\n    return ((d1 >= d2) || eq(d1, d2));\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double","parameterId":1,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d1","parameterName":"d1"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double d2","parameterName":"d2"}],"methodName":"gte","methodQualifiedSignature":"plume.FuzzyFloat.gte","methodJavadoc":"","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[],"methodQualifiedName":"plume.FuzzyFloat.gte(double, double)"},{"methodDeclaration":"public int indexOf(double[] a, double elt)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    for (int i = 0; i < a.length; i++) {\n        if (eq(elt, a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}","methodRange":"(line 202,col 3)-(line 209,col 3)","methodTokenRange":"public int indexOf(double[] a, double elt) {\n    for (int i = 0; i < a.length; i++) {\n      if (eq(elt, a[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double","parameterId":2,"parameterTypeResolved":"PrimitiveTypeUsage{name='double'}","parameterTypeResolvedDescribed":"double","parameter":"double elt","parameterName":"elt"}],"methodName":"indexOf","methodQualifiedSignature":"plume.FuzzyFloat.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 203,col 18)-(line 203,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 208,col 13)-(line 208,col 13)","literalExprId":2,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.FuzzyFloat.indexOf(double[], double)"},{"methodDeclaration":"public int indexOf(double[] a, double[] sub)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    int a_index_max = a.length - sub.length;\n    outer: for (int i = 0; i <= a_index_max; i++) {\n        for (int j = 0; j < sub.length; j++) {\n            if (ne(a[i + j], sub[j])) {\n                continue outer;\n            }\n        }\n        return (i);\n    }\n    return (-1);\n}","methodRange":"(line 224,col 3)-(line 238,col 3)","methodTokenRange":"public int indexOf(double[] a, double[] sub) {\n\n    int a_index_max = a.length - sub.length;\n\n    outer:\n    for (int i = 0; i <= a_index_max; i++) {\n      for (int j = 0; j < sub.length; j++) {\n        if (ne(a[i + j], sub[j])) {\n          continue outer;\n        }\n      }\n      return (i);\n    }\n    return (-1);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='int'}","methodJavadocComment":"@Pure","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a","parameterName":"a"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] sub","parameterName":"sub"}],"methodName":"indexOf","methodQualifiedSignature":"plume.FuzzyFloat.indexOf","methodJavadoc":"","methodReturnTypeDescribed":"int","methodType":"int","literalExprs":[{"literalExprRange":"(line 229,col 18)-(line 229,col 18)","literalExprId":1,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 230,col 20)-(line 230,col 20)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 237,col 14)-(line 237,col 14)","literalExprId":3,"literalExpr":"1","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"}],"methodQualifiedName":"plume.FuzzyFloat.indexOf(double[], double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first value to compare","javadocBlockTagName":"a1","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first value to compare'}]}', name=Optional[a1]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the first value to compare","javadocBlockTagName":"a2","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first value to compare'}]}', name=Optional[a2]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if a1 and a2 are set equivalent, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if a1 and a2 are set equivalent, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isElemMatch(double[] a1, double[] a2)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    a1 = a1.clone();\n    a2 = a2.clone();\n    Arrays.sort(a1);\n    Arrays.sort(a2);\n    int start = 0;\n    outer1: for (int i = 0; i < a2.length; i++) {\n        double val = a2[i];\n        for (int j = start; j < a1.length; j++) {\n            if (eq(val, a1[j])) {\n                start = j;\n                continue outer1;\n            }\n            if (val < a1[j]) {\n                return (false);\n            }\n        }\n        return (false);\n    }\n    start = 0;\n    outer2: for (int i = 0; i < a1.length; i++) {\n        double val = a1[i];\n        for (int j = start; j < a2.length; j++) {\n            if (eq(val, a2[j])) {\n                start = j;\n                continue outer2;\n            }\n            if (val < a2[j]) {\n                return (false);\n            }\n        }\n        return (false);\n    }\n    return (true);\n}","methodRange":"(line 252,col 3)-(line 302,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (arrays)\n  \/*@Pure*\/\n  public boolean isElemMatch(double[] a1, double[] a2) {\n\n    \/\/don't change our parameters\n    a1 = a1.clone();\n    a2 = a2.clone();\n\n    Arrays.sort(a1);\n    Arrays.sort(a2);\n\n    \/\/ look for elements of a2 in a1\n    int start = 0;\n    outer1:\n    for (int i = 0; i < a2.length; i++) {\n      double val = a2[i];\n      for (int j = start; j < a1.length; j++) {\n        if (eq(val, a1[j])) {\n          start = j;\n          continue outer1;\n        }\n        if (val < a1[j]) {\n          \/\/ System.out.println (\"isElemMatch: \" + val + \" \" + a1[j]);\n          return (false);\n        }\n      }\n      \/\/ System.out.println (\"isElemMatch: \" + i);\n      return (false);\n    }\n\n    \/\/ look for elements of a1 in a2\n    start = 0;\n    outer2:\n    for (int i = 0; i < a1.length; i++) {\n      double val = a1[i];\n      for (int j = start; j < a2.length; j++) {\n        if (eq(val, a2[j])) {\n          start = j;\n          continue outer2;\n        }\n        if (val < a2[j]) {\n          \/\/ System.out.println (\"isElemMatch: \" + val + \" \" + a2[j]);\n          return (false);\n        }\n      }\n      \/\/ System.out.println (\"isElemMatch: \" + i);\n      return (false);\n    }\n\n    return (true);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Determines whether or not a1 and a2 are set equivalent (contain only the\n   * same elements).  Element comparison uses {@link #eq}. <p>\n   *\n   * Note that this implementation is optimized for cases where the\n   * elements are actually the same, since it does a sort of both arrays\n   * before starting the comparisons.\n   *\n   * @param a1 the first value to compare\n   * @param a2 the first value to compare\n   * @return true if a1 and a2 are set equivalent, false otherwise\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a1","parameterName":"a1"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] a2","parameterName":"a2"}],"methodName":"isElemMatch","methodQualifiedSignature":"plume.FuzzyFloat.isElemMatch","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determines whether or not a1 and a2 are set equivalent (contain only the\nsame elements).  Element comparison uses '}, JavadocInlineTag{tagName='link', type=LINK, content=' #eq'}, JavadocSnippet{text='. <p>\n\nNote that this implementation is optimized for cases where the\nelements are actually the same, since it does a sort of both arrays\nbefore starting the comparisons.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first value to compare'}]}', name=Optional[a1]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the first value to compare'}]}', name=Optional[a2]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if a1 and a2 are set equivalent, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 252,col 21)-(line 252,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 264,col 17)-(line 264,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 266,col 18)-(line 266,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 275,col 19)-(line 275,col 23)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 279,col 15)-(line 279,col 19)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 283,col 13)-(line 283,col 13)","literalExprId":6,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 285,col 18)-(line 285,col 18)","literalExprId":7,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 294,col 19)-(line 294,col 23)","literalExprId":8,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 298,col 15)-(line 298,col 19)","literalExprId":9,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 301,col 13)-(line 301,col 16)","literalExprId":10,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.FuzzyFloat.isElemMatch(double[], double[])"},{"javadocBlockTags":[{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-smaller subset","javadocBlockTagName":"smaller","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-smaller subset'}]}', name=Optional[smaller]}"},{"javadocBlockType":"PARAM","javadocBlockTagContent":"the possibly-larger set","javadocBlockTagName":"bigger","javadocBlockTag":"JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-larger set'}]}', name=Optional[bigger]}"},{"javadocBlockType":"RETURN","javadocBlockTagContent":"true if smaller is a subset (each element of smaller is\nalso a element of bigger) of bigger, false otherwise","javadocBlockTagName":"","javadocBlockTag":"JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if smaller is a subset (each element of smaller is\nalso a element of bigger) of bigger, false otherwise'}]}', name=Optional.empty}"}],"methodDeclaration":"public boolean isSubset(double[] smaller, double[] bigger)","methodAccessSpecifier":"PUBLIC","methodBody":"{\n    smaller = smaller.clone();\n    bigger = bigger.clone();\n    Arrays.sort(smaller);\n    Arrays.sort(bigger);\n    int start = 0;\n    outer1: for (int i = 0; i < smaller.length; i++) {\n        double val = smaller[i];\n        for (int j = start; j < bigger.length; j++) {\n            if (eq(val, bigger[j])) {\n                start = j;\n                continue outer1;\n            }\n            if (val < bigger[j]) {\n                return (false);\n            }\n        }\n        return (false);\n    }\n    return (true);\n}","methodRange":"(line 373,col 3)-(line 402,col 3)","methodTokenRange":"@SuppressWarnings(\"purity\") \/\/ side effect to local state (arrays)\n  \/*@Pure*\/\n  public boolean isSubset(double[] smaller, double[] bigger) {\n\n    \/\/don't change our parameters\n    smaller = smaller.clone();\n    bigger = bigger.clone();\n\n    Arrays.sort(smaller);\n    Arrays.sort(bigger);\n\n    \/\/ look for elements of smaller in bigger\n    int start = 0;\n    outer1:\n    for (int i = 0; i < smaller.length; i++) {\n      double val = smaller[i];\n      for (int j = start; j < bigger.length; j++) {\n        if (eq(val, bigger[j])) {\n          start = j;\n          continue outer1;\n        }\n        if (val < bigger[j]) {\n          return (false);\n        }\n      }\n      return (false);\n    }\n\n    return (true);\n  }","methodReturnTypeResolved":"PrimitiveTypeUsage{name='boolean'}","methodJavadocComment":"\n   * Determines whether smaller is a subset of bigger.  Element\n   * comparison uses {@link #eq}. <p>\n   *\n   * Note that this implementation is optimized for cases where the\n   * elements are actually the same, since it does a sort of both\n   * arrays before starting the comparisons.\n   *\n   * @param smaller the possibly-smaller subset\n   * @param bigger the possibly-larger set\n   * @return true if smaller is a subset (each element of smaller is\n   * also a element of bigger) of bigger, false otherwise\n   ","methodParameters":[{"parameterType":"double[]","parameterId":1,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] smaller","parameterName":"smaller"},{"parameterType":"double[]","parameterId":2,"parameterTypeResolved":"ResolvedArrayType{PrimitiveTypeUsage{name='double'}}","parameterTypeResolvedDescribed":"double[]","parameter":"double[] bigger","parameterName":"bigger"}],"methodName":"isSubset","methodQualifiedSignature":"plume.FuzzyFloat.isSubset","methodJavadoc":"Javadoc{description=JavadocDescription{elements=[JavadocSnippet{text='Determines whether smaller is a subset of bigger.  Element\ncomparison uses '}, JavadocInlineTag{tagName='link', type=LINK, content=' #eq'}, JavadocSnippet{text='. <p>\n\nNote that this implementation is optimized for cases where the\nelements are actually the same, since it does a sort of both\narrays before starting the comparisons.'}]}, blockTags=[JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-smaller subset'}]}', name=Optional[smaller]}, JavadocBlockTag{type=PARAM, content='JavadocDescription{elements=[JavadocSnippet{text='the possibly-larger set'}]}', name=Optional[bigger]}, JavadocBlockTag{type=RETURN, content='JavadocDescription{elements=[JavadocSnippet{text='true if smaller is a subset (each element of smaller is\nalso a element of bigger) of bigger, false otherwise'}]}', name=Optional.empty}]}","methodReturnTypeDescribed":"boolean","methodType":"boolean","literalExprs":[{"literalExprRange":"(line 373,col 21)-(line 373,col 28)","literalExprId":1,"literalExpr":"\"purity\"","literalExprClass":"class com.github.javaparser.ast.expr.StringLiteralExpr"},{"literalExprRange":"(line 385,col 17)-(line 385,col 17)","literalExprId":2,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 387,col 18)-(line 387,col 18)","literalExprId":3,"literalExpr":"0","literalExprClass":"class com.github.javaparser.ast.expr.IntegerLiteralExpr"},{"literalExprRange":"(line 395,col 19)-(line 395,col 23)","literalExprId":4,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 398,col 15)-(line 398,col 19)","literalExprId":5,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"},{"literalExprRange":"(line 401,col 13)-(line 401,col 16)","literalExprId":6,"literalExpr":"true","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"methodQualifiedName":"plume.FuzzyFloat.isSubset(double[], double[])"}],"classJavadoc":"\/**\n * Routines for doing approximate ('fuzzy') floating point comparisons.\n * Those are comparisons that only require the floating point numbers to be\n * relatively close to one another to be equal, rather than exactly\n * equal. <p>\n *\n * Floating point numbers are compared for equality by dividing them by\n * one another and comparing the ratio.  By default they must be within\n * 0.0001 (0.01%) to be considered equal; supply this value to the\n * FuzzyFloat constructor, or set the value with the set_rel_diff method.\n * Note that zero is never equal to a non-zero number using this method. <p>\n *\n * Two NaN floats are not considered equal (consistent with the == operator).\n *\/\n","className":"FuzzyFloat","fields":[{"fieldRange":"(line 31,col 3)-(line 31,col 28)","fieldName":"min_ratio","fieldJavadocComment":" Minimum ratio between two floats that will act as equal. ","fieldTokenRange":"double min_ratio = 0.9999;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 31,col 22)-(line 31,col 27)","literalExprId":1,"literalExpr":"0.9999","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[0.9999]","fieldType":"double","fieldJavadoc":"Minimum ratio between two floats that will act as equal.\n","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 33,col 3)-(line 33,col 28)","fieldName":"max_ratio","fieldJavadocComment":" Maximum ratio between two floats that will act as equal. ","fieldTokenRange":"double max_ratio = 1.0001;","fieldTypeResolved":"PrimitiveTypeUsage{name='double'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 33,col 22)-(line 33,col 27)","literalExprId":1,"literalExpr":"1.0001","literalExprClass":"class com.github.javaparser.ast.expr.DoubleLiteralExpr"}],"fieldInitializer":"Optional[1.0001]","fieldType":"double","fieldJavadoc":"Maximum ratio between two floats that will act as equal.\n","fieldTypeResolvedDescribed":"double"},{"fieldRange":"(line 40,col 3)-(line 40,col 22)","fieldName":"off","fieldJavadocComment":"\n   * True if ratio test turned off.\n   * This occurs exactly if the class is instantiated with the relative\n   * difference 0.\n   ","fieldTokenRange":"boolean off = false;","fieldTypeResolved":"PrimitiveTypeUsage{name='boolean'}","fieldAccessSpecifier":"NONE","literalExprs":[{"literalExprRange":"(line 40,col 17)-(line 40,col 21)","literalExprId":1,"literalExpr":"false","literalExprClass":"class com.github.javaparser.ast.expr.BooleanLiteralExpr"}],"fieldInitializer":"Optional[false]","fieldType":"boolean","fieldJavadoc":"True if ratio test turned off.\nThis occurs exactly if the class is instantiated with the relative\ndifference 0.\n","fieldTypeResolvedDescribed":"boolean"}]}],"sourceFileId":50,"packageName":"plume"}]